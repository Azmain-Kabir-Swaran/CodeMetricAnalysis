{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Globber.java",
  "functionName": "doGlob",
  "functionId": "doGlob",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java",
  "functionStartLine": 208,
  "functionEndLine": 396,
  "numCommitsSeen": 26,
  "timeTaken": 3787,
  "changeHistory": [
    "1921e94292f0820985a0cfbf8922a2a1a67fe921",
    "646874c326139457b79cf8cfa547b3c91a78c7b4",
    "b8832fcf1e2ae1e43d5e4523016731af40ab58d7",
    "68e588cbee660d55dba518892d064bee3795a002",
    "7a167311918300b1f00868a83d2f71a1ca88e918",
    "53fed66d918e31a9c3d8bf0d4e6d3861c9b058b3",
    "464470e715c95fc3b832e93800d551fdb44333f1",
    "efc1048ffe10695666cc70be83c2b51cab8cdf0a",
    "d1dfa5f923408fea94fe18b7886ead4573560e6a",
    "b7a6c5ebb48275b3512bdbf201e0e8873b6d77b6",
    "95f9a515aac3c19e14a39539f490203f5867dcc5"
  ],
  "changeHistoryShort": {
    "1921e94292f0820985a0cfbf8922a2a1a67fe921": "Ybodychange",
    "646874c326139457b79cf8cfa547b3c91a78c7b4": "Ybodychange",
    "b8832fcf1e2ae1e43d5e4523016731af40ab58d7": "Ymultichange(Yrename,Ymodifierchange)",
    "68e588cbee660d55dba518892d064bee3795a002": "Ybodychange",
    "7a167311918300b1f00868a83d2f71a1ca88e918": "Ybodychange",
    "53fed66d918e31a9c3d8bf0d4e6d3861c9b058b3": "Ybodychange",
    "464470e715c95fc3b832e93800d551fdb44333f1": "Ybodychange",
    "efc1048ffe10695666cc70be83c2b51cab8cdf0a": "Ybodychange",
    "d1dfa5f923408fea94fe18b7886ead4573560e6a": "Ybodychange",
    "b7a6c5ebb48275b3512bdbf201e0e8873b6d77b6": "Ybodychange",
    "95f9a515aac3c19e14a39539f490203f5867dcc5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1921e94292f0820985a0cfbf8922a2a1a67fe921": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16458. LocatedFileStatusFetcher.getFileStatuses failing intermittently with S3\n\nContributed by Steve Loughran.\n\nIncludes\n-S3A glob scans don\u0027t bother trying to resolve symlinks\n-stack traces don\u0027t get lost in getFileStatuses() when exceptions are wrapped\n-debug level logging of what is up in Globber\n-Contains HADOOP-13373. Add S3A implementation of FSMainOperationsBaseTest.\n-ITestRestrictedReadAccess tests incomplete read access to files.\n\nThis adds a builder API for constructing globbers which other stores can use\nso that they too can skip symlink resolution when not needed.\n\nChange-Id: I23bcdb2783d6bd77cf168fdc165b1b4b334d91c7\n",
      "commitDate": "01/10/19 10:11 AM",
      "commitName": "1921e94292f0820985a0cfbf8922a2a1a67fe921",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/09/18 5:04 AM",
      "commitNameOld": "646874c326139457b79cf8cfa547b3c91a78c7b4",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 376.21,
      "commitsBetweenForRepo": 2883,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,172 +1,189 @@\n   private FileStatus[] doGlob() throws IOException {\n     // First we get the scheme and authority of the pattern that was passed\n     // in.\n     String scheme \u003d schemeFromPath(pathPattern);\n     String authority \u003d authorityFromPath(pathPattern);\n \n     // Next we strip off everything except the pathname itself, and expand all\n     // globs.  Expansion is a process which turns \"grouping\" clauses,\n     // expressed as brackets, into separate path patterns.\n     String pathPatternString \u003d pathPattern.toUri().getPath();\n     List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n \n+    LOG.debug(\"Filesystem glob {}\", pathPatternString);\n     // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n     // match them to entries in the filesystem.\n     ArrayList\u003cFileStatus\u003e results \u003d \n-        new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n+        new ArrayList\u003c\u003e(flattenedPatterns.size());\n     boolean sawWildcard \u003d false;\n     for (String flatPattern : flattenedPatterns) {\n       // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n       // this prior to flattening because of patterns like {/,a}, where which\n       // path you go down influences how the path must be made absolute.\n       Path absPattern \u003d fixRelativePart(new Path(\n           flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n+      LOG.debug(\"Pattern: {}\", absPattern);\n       // Now we break the flattened, absolute pattern into path components.\n       // For example, /a/*/c would be broken into the list [a, *, c]\n       List\u003cString\u003e components \u003d\n           getPathComponents(absPattern.toUri().getPath());\n       // Starting out at the root of the filesystem, we try to match\n       // filesystem entries against pattern components.\n-      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n+      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003c\u003e(1);\n       // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n       // RPC to the NameNode.  So we create a placeholder FileStatus which has\n       // the correct path, but defaults for the rest of the information.\n       // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n       // replace the placeholder with a real FileStatus obtained from the\n       // NameNode.\n       FileStatus rootPlaceholder;\n       if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n           \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n         // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n         // We will skip matching the drive letter and start from listing the\n         // root of the filesystem on that drive.\n         String driveLetter \u003d components.remove(0);\n         rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n             authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n       } else {\n         rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n             new Path(scheme, authority, Path.SEPARATOR));\n       }\n       candidates.add(rootPlaceholder);\n       \n       for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n           componentIdx++) {\n         ArrayList\u003cFileStatus\u003e newCandidates \u003d\n-            new ArrayList\u003cFileStatus\u003e(candidates.size());\n+            new ArrayList\u003c\u003e(candidates.size());\n         GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n         String component \u003d unescapePathComponent(components.get(componentIdx));\n         if (globFilter.hasPattern()) {\n           sawWildcard \u003d true;\n         }\n+        LOG.debug(\"Component {}, patterned\u003d{}\", component, sawWildcard);\n         if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n           // Optimization: if there are no more candidates left, stop examining \n           // the path components.  We can only do this if we\u0027ve already seen\n           // a wildcard component-- otherwise, we still need to visit all path \n           // components in case one of them is a wildcard.\n           break;\n         }\n         if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n             (!globFilter.hasPattern())) {\n           // Optimization: if this is not the terminal path component, and we \n           // are not matching against a glob, assume that it exists.  If it \n           // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n           // or the terminal path component.\n           for (FileStatus candidate : candidates) {\n             candidate.setPath(new Path(candidate.getPath(), component));\n           }\n           continue;\n         }\n         for (FileStatus candidate : candidates) {\n           if (globFilter.hasPattern()) {\n             FileStatus[] children \u003d listStatus(candidate.getPath());\n             if (children.length \u003d\u003d 1) {\n               // If we get back only one result, this could be either a listing\n               // of a directory with one entry, or it could reflect the fact\n               // that what we listed resolved to a file.\n               //\n               // Unfortunately, we can\u0027t just compare the returned paths to\n               // figure this out.  Consider the case where you have /a/b, where\n               // b is a symlink to \"..\".  In that case, listing /a/b will give\n               // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n               // incorrectly conclude that /a/b was a file and should not match\n               // /a/*/*.  So we use getFileStatus of the path we just listed to\n               // disambiguate.\n-              Path path \u003d candidate.getPath();\n-              FileStatus status \u003d getFileStatus(path);\n-              if (status \u003d\u003d null) {\n-                // null means the file was not found\n-                LOG.warn(\"File/directory {} not found:\"\n-                    + \" it may have been deleted.\"\n-                    + \" If this is an object store, this can be a sign of\"\n-                    + \" eventual consistency problems.\",\n-                    path);\n-                continue;\n-              }\n-              if (!status.isDirectory()) {\n-                continue;\n+              if (resolveSymlinks) {\n+                LOG.debug(\"listStatus found one entry; disambiguating {}\",\n+                    children[0]);\n+                Path path \u003d candidate.getPath();\n+                FileStatus status \u003d getFileStatus(path);\n+                if (status \u003d\u003d null) {\n+                  // null means the file was not found\n+                  LOG.warn(\"File/directory {} not found:\"\n+                      + \" it may have been deleted.\"\n+                      + \" If this is an object store, this can be a sign of\"\n+                      + \" eventual consistency problems.\",\n+                      path);\n+                  continue;\n+                }\n+                if (!status.isDirectory()) {\n+                  LOG.debug(\"Resolved entry is a file; skipping: {}\", status);\n+                  continue;\n+                }\n+              } else {\n+                // there\u0027s no symlinks in this store, so no need to issue\n+                // another call, just see if the result is a directory or a file\n+                if (children[0].getPath().equals(candidate.getPath())) {\n+                  // the listing status is of a file\n+                  continue;\n+                }\n               }\n             }\n             for (FileStatus child : children) {\n               if (componentIdx \u003c components.size() - 1) {\n                 // Don\u0027t try to recurse into non-directories.  See HADOOP-10957.\n                 if (!child.isDirectory()) continue; \n               }\n               // Set the child path based on the parent path.\n               child.setPath(new Path(candidate.getPath(),\n                       child.getPath().getName()));\n               if (globFilter.accept(child.getPath())) {\n                 newCandidates.add(child);\n               }\n             }\n           } else {\n             // When dealing with non-glob components, use getFileStatus \n             // instead of listStatus.  This is an optimization, but it also\n             // is necessary for correctness in HDFS, since there are some\n             // special HDFS directories like .reserved and .snapshot that are\n             // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n             FileStatus childStatus \u003d getFileStatus(\n                 new Path(candidate.getPath(), component));\n             if (childStatus !\u003d null) {\n               newCandidates.add(childStatus);\n             }\n           }\n         }\n         candidates \u003d newCandidates;\n       }\n       for (FileStatus status : candidates) {\n         // Use object equality to see if this status is the root placeholder.\n         // See the explanation for rootPlaceholder above for more information.\n         if (status \u003d\u003d rootPlaceholder) {\n           status \u003d getFileStatus(rootPlaceholder.getPath());\n           if (status \u003d\u003d null) continue;\n         }\n         // HADOOP-3497 semantics: the user-defined filter is applied at the\n         // end, once the full path is built up.\n         if (filter.accept(status.getPath())) {\n           results.add(status);\n         }\n       }\n     }\n     /*\n      * When the input pattern \"looks\" like just a simple filename, and we\n      * can\u0027t find it, we return null rather than an empty array.\n      * This is a special case which the shell relies on.\n      *\n      * To be more precise: if there were no results, AND there were no\n      * groupings (aka brackets), and no wildcards in the input (aka stars),\n      * we return null.\n      */\n     if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n         (flattenedPatterns.size() \u003c\u003d 1)) {\n+      LOG.debug(\"No matches found and there was no wildcard in the path {}\",\n+          pathPattern);\n       return null;\n     }\n     /*\n      * In general, the results list will already be sorted, since listStatus\n      * returns results in sorted order for many Hadoop filesystems.  However,\n      * not all Hadoop filesystems have this property.  So we sort here in order\n      * to get consistent results.  See HADOOP-10798 for details.\n      */\n     FileStatus ret[] \u003d results.toArray(new FileStatus[0]);\n     Arrays.sort(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FileStatus[] doGlob() throws IOException {\n    // First we get the scheme and authority of the pattern that was passed\n    // in.\n    String scheme \u003d schemeFromPath(pathPattern);\n    String authority \u003d authorityFromPath(pathPattern);\n\n    // Next we strip off everything except the pathname itself, and expand all\n    // globs.  Expansion is a process which turns \"grouping\" clauses,\n    // expressed as brackets, into separate path patterns.\n    String pathPatternString \u003d pathPattern.toUri().getPath();\n    List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n\n    LOG.debug(\"Filesystem glob {}\", pathPatternString);\n    // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n    // match them to entries in the filesystem.\n    ArrayList\u003cFileStatus\u003e results \u003d \n        new ArrayList\u003c\u003e(flattenedPatterns.size());\n    boolean sawWildcard \u003d false;\n    for (String flatPattern : flattenedPatterns) {\n      // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n      // this prior to flattening because of patterns like {/,a}, where which\n      // path you go down influences how the path must be made absolute.\n      Path absPattern \u003d fixRelativePart(new Path(\n          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n      LOG.debug(\"Pattern: {}\", absPattern);\n      // Now we break the flattened, absolute pattern into path components.\n      // For example, /a/*/c would be broken into the list [a, *, c]\n      List\u003cString\u003e components \u003d\n          getPathComponents(absPattern.toUri().getPath());\n      // Starting out at the root of the filesystem, we try to match\n      // filesystem entries against pattern components.\n      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003c\u003e(1);\n      // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n      // the correct path, but defaults for the rest of the information.\n      // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n      // replace the placeholder with a real FileStatus obtained from the\n      // NameNode.\n      FileStatus rootPlaceholder;\n      if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n          \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n        // We will skip matching the drive letter and start from listing the\n        // root of the filesystem on that drive.\n        String driveLetter \u003d components.remove(0);\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n      } else {\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n            new Path(scheme, authority, Path.SEPARATOR));\n      }\n      candidates.add(rootPlaceholder);\n      \n      for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n          componentIdx++) {\n        ArrayList\u003cFileStatus\u003e newCandidates \u003d\n            new ArrayList\u003c\u003e(candidates.size());\n        GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n        String component \u003d unescapePathComponent(components.get(componentIdx));\n        if (globFilter.hasPattern()) {\n          sawWildcard \u003d true;\n        }\n        LOG.debug(\"Component {}, patterned\u003d{}\", component, sawWildcard);\n        if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n          // Optimization: if there are no more candidates left, stop examining \n          // the path components.  We can only do this if we\u0027ve already seen\n          // a wildcard component-- otherwise, we still need to visit all path \n          // components in case one of them is a wildcard.\n          break;\n        }\n        if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n            (!globFilter.hasPattern())) {\n          // Optimization: if this is not the terminal path component, and we \n          // are not matching against a glob, assume that it exists.  If it \n          // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n          // or the terminal path component.\n          for (FileStatus candidate : candidates) {\n            candidate.setPath(new Path(candidate.getPath(), component));\n          }\n          continue;\n        }\n        for (FileStatus candidate : candidates) {\n          if (globFilter.hasPattern()) {\n            FileStatus[] children \u003d listStatus(candidate.getPath());\n            if (children.length \u003d\u003d 1) {\n              // If we get back only one result, this could be either a listing\n              // of a directory with one entry, or it could reflect the fact\n              // that what we listed resolved to a file.\n              //\n              // Unfortunately, we can\u0027t just compare the returned paths to\n              // figure this out.  Consider the case where you have /a/b, where\n              // b is a symlink to \"..\".  In that case, listing /a/b will give\n              // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n              // incorrectly conclude that /a/b was a file and should not match\n              // /a/*/*.  So we use getFileStatus of the path we just listed to\n              // disambiguate.\n              if (resolveSymlinks) {\n                LOG.debug(\"listStatus found one entry; disambiguating {}\",\n                    children[0]);\n                Path path \u003d candidate.getPath();\n                FileStatus status \u003d getFileStatus(path);\n                if (status \u003d\u003d null) {\n                  // null means the file was not found\n                  LOG.warn(\"File/directory {} not found:\"\n                      + \" it may have been deleted.\"\n                      + \" If this is an object store, this can be a sign of\"\n                      + \" eventual consistency problems.\",\n                      path);\n                  continue;\n                }\n                if (!status.isDirectory()) {\n                  LOG.debug(\"Resolved entry is a file; skipping: {}\", status);\n                  continue;\n                }\n              } else {\n                // there\u0027s no symlinks in this store, so no need to issue\n                // another call, just see if the result is a directory or a file\n                if (children[0].getPath().equals(candidate.getPath())) {\n                  // the listing status is of a file\n                  continue;\n                }\n              }\n            }\n            for (FileStatus child : children) {\n              if (componentIdx \u003c components.size() - 1) {\n                // Don\u0027t try to recurse into non-directories.  See HADOOP-10957.\n                if (!child.isDirectory()) continue; \n              }\n              // Set the child path based on the parent path.\n              child.setPath(new Path(candidate.getPath(),\n                      child.getPath().getName()));\n              if (globFilter.accept(child.getPath())) {\n                newCandidates.add(child);\n              }\n            }\n          } else {\n            // When dealing with non-glob components, use getFileStatus \n            // instead of listStatus.  This is an optimization, but it also\n            // is necessary for correctness in HDFS, since there are some\n            // special HDFS directories like .reserved and .snapshot that are\n            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n            FileStatus childStatus \u003d getFileStatus(\n                new Path(candidate.getPath(), component));\n            if (childStatus !\u003d null) {\n              newCandidates.add(childStatus);\n            }\n          }\n        }\n        candidates \u003d newCandidates;\n      }\n      for (FileStatus status : candidates) {\n        // Use object equality to see if this status is the root placeholder.\n        // See the explanation for rootPlaceholder above for more information.\n        if (status \u003d\u003d rootPlaceholder) {\n          status \u003d getFileStatus(rootPlaceholder.getPath());\n          if (status \u003d\u003d null) continue;\n        }\n        // HADOOP-3497 semantics: the user-defined filter is applied at the\n        // end, once the full path is built up.\n        if (filter.accept(status.getPath())) {\n          results.add(status);\n        }\n      }\n    }\n    /*\n     * When the input pattern \"looks\" like just a simple filename, and we\n     * can\u0027t find it, we return null rather than an empty array.\n     * This is a special case which the shell relies on.\n     *\n     * To be more precise: if there were no results, AND there were no\n     * groupings (aka brackets), and no wildcards in the input (aka stars),\n     * we return null.\n     */\n    if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n        (flattenedPatterns.size() \u003c\u003d 1)) {\n      LOG.debug(\"No matches found and there was no wildcard in the path {}\",\n          pathPattern);\n      return null;\n    }\n    /*\n     * In general, the results list will already be sorted, since listStatus\n     * returns results in sorted order for many Hadoop filesystems.  However,\n     * not all Hadoop filesystems have this property.  So we sort here in order\n     * to get consistent results.  See HADOOP-10798 for details.\n     */\n    FileStatus ret[] \u003d results.toArray(new FileStatus[0]);\n    Arrays.sort(ret);\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java",
      "extendedDetails": {}
    },
    "646874c326139457b79cf8cfa547b3c91a78c7b4": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15748. S3 listing inconsistency can raise NPE in globber.\nContributed by Steve Loughran.\n",
      "commitDate": "20/09/18 5:04 AM",
      "commitName": "646874c326139457b79cf8cfa547b3c91a78c7b4",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "17/07/17 9:32 PM",
      "commitNameOld": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 429.31,
      "commitsBetweenForRepo": 3834,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,161 +1,172 @@\n   private FileStatus[] doGlob() throws IOException {\n     // First we get the scheme and authority of the pattern that was passed\n     // in.\n     String scheme \u003d schemeFromPath(pathPattern);\n     String authority \u003d authorityFromPath(pathPattern);\n \n     // Next we strip off everything except the pathname itself, and expand all\n     // globs.  Expansion is a process which turns \"grouping\" clauses,\n     // expressed as brackets, into separate path patterns.\n     String pathPatternString \u003d pathPattern.toUri().getPath();\n     List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n \n     // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n     // match them to entries in the filesystem.\n     ArrayList\u003cFileStatus\u003e results \u003d \n         new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n     boolean sawWildcard \u003d false;\n     for (String flatPattern : flattenedPatterns) {\n       // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n       // this prior to flattening because of patterns like {/,a}, where which\n       // path you go down influences how the path must be made absolute.\n       Path absPattern \u003d fixRelativePart(new Path(\n           flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n       // Now we break the flattened, absolute pattern into path components.\n       // For example, /a/*/c would be broken into the list [a, *, c]\n       List\u003cString\u003e components \u003d\n           getPathComponents(absPattern.toUri().getPath());\n       // Starting out at the root of the filesystem, we try to match\n       // filesystem entries against pattern components.\n       ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n       // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n       // RPC to the NameNode.  So we create a placeholder FileStatus which has\n       // the correct path, but defaults for the rest of the information.\n       // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n       // replace the placeholder with a real FileStatus obtained from the\n       // NameNode.\n       FileStatus rootPlaceholder;\n       if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n           \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n         // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n         // We will skip matching the drive letter and start from listing the\n         // root of the filesystem on that drive.\n         String driveLetter \u003d components.remove(0);\n         rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n             authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n       } else {\n         rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n             new Path(scheme, authority, Path.SEPARATOR));\n       }\n       candidates.add(rootPlaceholder);\n       \n       for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n           componentIdx++) {\n         ArrayList\u003cFileStatus\u003e newCandidates \u003d\n             new ArrayList\u003cFileStatus\u003e(candidates.size());\n         GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n         String component \u003d unescapePathComponent(components.get(componentIdx));\n         if (globFilter.hasPattern()) {\n           sawWildcard \u003d true;\n         }\n         if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n           // Optimization: if there are no more candidates left, stop examining \n           // the path components.  We can only do this if we\u0027ve already seen\n           // a wildcard component-- otherwise, we still need to visit all path \n           // components in case one of them is a wildcard.\n           break;\n         }\n         if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n             (!globFilter.hasPattern())) {\n           // Optimization: if this is not the terminal path component, and we \n           // are not matching against a glob, assume that it exists.  If it \n           // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n           // or the terminal path component.\n           for (FileStatus candidate : candidates) {\n             candidate.setPath(new Path(candidate.getPath(), component));\n           }\n           continue;\n         }\n         for (FileStatus candidate : candidates) {\n           if (globFilter.hasPattern()) {\n             FileStatus[] children \u003d listStatus(candidate.getPath());\n             if (children.length \u003d\u003d 1) {\n               // If we get back only one result, this could be either a listing\n               // of a directory with one entry, or it could reflect the fact\n               // that what we listed resolved to a file.\n               //\n               // Unfortunately, we can\u0027t just compare the returned paths to\n               // figure this out.  Consider the case where you have /a/b, where\n               // b is a symlink to \"..\".  In that case, listing /a/b will give\n               // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n               // incorrectly conclude that /a/b was a file and should not match\n               // /a/*/*.  So we use getFileStatus of the path we just listed to\n               // disambiguate.\n-              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n+              Path path \u003d candidate.getPath();\n+              FileStatus status \u003d getFileStatus(path);\n+              if (status \u003d\u003d null) {\n+                // null means the file was not found\n+                LOG.warn(\"File/directory {} not found:\"\n+                    + \" it may have been deleted.\"\n+                    + \" If this is an object store, this can be a sign of\"\n+                    + \" eventual consistency problems.\",\n+                    path);\n+                continue;\n+              }\n+              if (!status.isDirectory()) {\n                 continue;\n               }\n             }\n             for (FileStatus child : children) {\n               if (componentIdx \u003c components.size() - 1) {\n                 // Don\u0027t try to recurse into non-directories.  See HADOOP-10957.\n                 if (!child.isDirectory()) continue; \n               }\n               // Set the child path based on the parent path.\n               child.setPath(new Path(candidate.getPath(),\n                       child.getPath().getName()));\n               if (globFilter.accept(child.getPath())) {\n                 newCandidates.add(child);\n               }\n             }\n           } else {\n             // When dealing with non-glob components, use getFileStatus \n             // instead of listStatus.  This is an optimization, but it also\n             // is necessary for correctness in HDFS, since there are some\n             // special HDFS directories like .reserved and .snapshot that are\n             // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n             FileStatus childStatus \u003d getFileStatus(\n                 new Path(candidate.getPath(), component));\n             if (childStatus !\u003d null) {\n               newCandidates.add(childStatus);\n             }\n           }\n         }\n         candidates \u003d newCandidates;\n       }\n       for (FileStatus status : candidates) {\n         // Use object equality to see if this status is the root placeholder.\n         // See the explanation for rootPlaceholder above for more information.\n         if (status \u003d\u003d rootPlaceholder) {\n           status \u003d getFileStatus(rootPlaceholder.getPath());\n           if (status \u003d\u003d null) continue;\n         }\n         // HADOOP-3497 semantics: the user-defined filter is applied at the\n         // end, once the full path is built up.\n         if (filter.accept(status.getPath())) {\n           results.add(status);\n         }\n       }\n     }\n     /*\n      * When the input pattern \"looks\" like just a simple filename, and we\n      * can\u0027t find it, we return null rather than an empty array.\n      * This is a special case which the shell relies on.\n      *\n      * To be more precise: if there were no results, AND there were no\n      * groupings (aka brackets), and no wildcards in the input (aka stars),\n      * we return null.\n      */\n     if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n         (flattenedPatterns.size() \u003c\u003d 1)) {\n       return null;\n     }\n     /*\n      * In general, the results list will already be sorted, since listStatus\n      * returns results in sorted order for many Hadoop filesystems.  However,\n      * not all Hadoop filesystems have this property.  So we sort here in order\n      * to get consistent results.  See HADOOP-10798 for details.\n      */\n     FileStatus ret[] \u003d results.toArray(new FileStatus[0]);\n     Arrays.sort(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FileStatus[] doGlob() throws IOException {\n    // First we get the scheme and authority of the pattern that was passed\n    // in.\n    String scheme \u003d schemeFromPath(pathPattern);\n    String authority \u003d authorityFromPath(pathPattern);\n\n    // Next we strip off everything except the pathname itself, and expand all\n    // globs.  Expansion is a process which turns \"grouping\" clauses,\n    // expressed as brackets, into separate path patterns.\n    String pathPatternString \u003d pathPattern.toUri().getPath();\n    List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n\n    // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n    // match them to entries in the filesystem.\n    ArrayList\u003cFileStatus\u003e results \u003d \n        new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n    boolean sawWildcard \u003d false;\n    for (String flatPattern : flattenedPatterns) {\n      // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n      // this prior to flattening because of patterns like {/,a}, where which\n      // path you go down influences how the path must be made absolute.\n      Path absPattern \u003d fixRelativePart(new Path(\n          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n      // Now we break the flattened, absolute pattern into path components.\n      // For example, /a/*/c would be broken into the list [a, *, c]\n      List\u003cString\u003e components \u003d\n          getPathComponents(absPattern.toUri().getPath());\n      // Starting out at the root of the filesystem, we try to match\n      // filesystem entries against pattern components.\n      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n      // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n      // the correct path, but defaults for the rest of the information.\n      // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n      // replace the placeholder with a real FileStatus obtained from the\n      // NameNode.\n      FileStatus rootPlaceholder;\n      if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n          \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n        // We will skip matching the drive letter and start from listing the\n        // root of the filesystem on that drive.\n        String driveLetter \u003d components.remove(0);\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n      } else {\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n            new Path(scheme, authority, Path.SEPARATOR));\n      }\n      candidates.add(rootPlaceholder);\n      \n      for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n          componentIdx++) {\n        ArrayList\u003cFileStatus\u003e newCandidates \u003d\n            new ArrayList\u003cFileStatus\u003e(candidates.size());\n        GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n        String component \u003d unescapePathComponent(components.get(componentIdx));\n        if (globFilter.hasPattern()) {\n          sawWildcard \u003d true;\n        }\n        if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n          // Optimization: if there are no more candidates left, stop examining \n          // the path components.  We can only do this if we\u0027ve already seen\n          // a wildcard component-- otherwise, we still need to visit all path \n          // components in case one of them is a wildcard.\n          break;\n        }\n        if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n            (!globFilter.hasPattern())) {\n          // Optimization: if this is not the terminal path component, and we \n          // are not matching against a glob, assume that it exists.  If it \n          // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n          // or the terminal path component.\n          for (FileStatus candidate : candidates) {\n            candidate.setPath(new Path(candidate.getPath(), component));\n          }\n          continue;\n        }\n        for (FileStatus candidate : candidates) {\n          if (globFilter.hasPattern()) {\n            FileStatus[] children \u003d listStatus(candidate.getPath());\n            if (children.length \u003d\u003d 1) {\n              // If we get back only one result, this could be either a listing\n              // of a directory with one entry, or it could reflect the fact\n              // that what we listed resolved to a file.\n              //\n              // Unfortunately, we can\u0027t just compare the returned paths to\n              // figure this out.  Consider the case where you have /a/b, where\n              // b is a symlink to \"..\".  In that case, listing /a/b will give\n              // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n              // incorrectly conclude that /a/b was a file and should not match\n              // /a/*/*.  So we use getFileStatus of the path we just listed to\n              // disambiguate.\n              Path path \u003d candidate.getPath();\n              FileStatus status \u003d getFileStatus(path);\n              if (status \u003d\u003d null) {\n                // null means the file was not found\n                LOG.warn(\"File/directory {} not found:\"\n                    + \" it may have been deleted.\"\n                    + \" If this is an object store, this can be a sign of\"\n                    + \" eventual consistency problems.\",\n                    path);\n                continue;\n              }\n              if (!status.isDirectory()) {\n                continue;\n              }\n            }\n            for (FileStatus child : children) {\n              if (componentIdx \u003c components.size() - 1) {\n                // Don\u0027t try to recurse into non-directories.  See HADOOP-10957.\n                if (!child.isDirectory()) continue; \n              }\n              // Set the child path based on the parent path.\n              child.setPath(new Path(candidate.getPath(),\n                      child.getPath().getName()));\n              if (globFilter.accept(child.getPath())) {\n                newCandidates.add(child);\n              }\n            }\n          } else {\n            // When dealing with non-glob components, use getFileStatus \n            // instead of listStatus.  This is an optimization, but it also\n            // is necessary for correctness in HDFS, since there are some\n            // special HDFS directories like .reserved and .snapshot that are\n            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n            FileStatus childStatus \u003d getFileStatus(\n                new Path(candidate.getPath(), component));\n            if (childStatus !\u003d null) {\n              newCandidates.add(childStatus);\n            }\n          }\n        }\n        candidates \u003d newCandidates;\n      }\n      for (FileStatus status : candidates) {\n        // Use object equality to see if this status is the root placeholder.\n        // See the explanation for rootPlaceholder above for more information.\n        if (status \u003d\u003d rootPlaceholder) {\n          status \u003d getFileStatus(rootPlaceholder.getPath());\n          if (status \u003d\u003d null) continue;\n        }\n        // HADOOP-3497 semantics: the user-defined filter is applied at the\n        // end, once the full path is built up.\n        if (filter.accept(status.getPath())) {\n          results.add(status);\n        }\n      }\n    }\n    /*\n     * When the input pattern \"looks\" like just a simple filename, and we\n     * can\u0027t find it, we return null rather than an empty array.\n     * This is a special case which the shell relies on.\n     *\n     * To be more precise: if there were no results, AND there were no\n     * groupings (aka brackets), and no wildcards in the input (aka stars),\n     * we return null.\n     */\n    if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n        (flattenedPatterns.size() \u003c\u003d 1)) {\n      return null;\n    }\n    /*\n     * In general, the results list will already be sorted, since listStatus\n     * returns results in sorted order for many Hadoop filesystems.  However,\n     * not all Hadoop filesystems have this property.  So we sort here in order\n     * to get consistent results.  See HADOOP-10798 for details.\n     */\n    FileStatus ret[] \u003d results.toArray(new FileStatus[0]);\n    Arrays.sort(ret);\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java",
      "extendedDetails": {}
    },
    "b8832fcf1e2ae1e43d5e4523016731af40ab58d7": {
      "type": "Ymultichange(Yrename,Ymodifierchange)",
      "commitMessage": "HADOOP-12201. Add tracing to FileSystem#createFileSystem and Globber#glob (cmccabe)\n",
      "commitDate": "08/07/15 8:07 PM",
      "commitName": "b8832fcf1e2ae1e43d5e4523016731af40ab58d7",
      "commitAuthor": "Colin Patrick Mccabe",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HADOOP-12201. Add tracing to FileSystem#createFileSystem and Globber#glob (cmccabe)\n",
          "commitDate": "08/07/15 8:07 PM",
          "commitName": "b8832fcf1e2ae1e43d5e4523016731af40ab58d7",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "30/06/15 4:40 PM",
          "commitNameOld": "68e588cbee660d55dba518892d064bee3795a002",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 8.14,
          "commitsBetweenForRepo": 50,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,161 +1,161 @@\n-  public FileStatus[] glob() throws IOException {\n+  private FileStatus[] doGlob() throws IOException {\n     // First we get the scheme and authority of the pattern that was passed\n     // in.\n     String scheme \u003d schemeFromPath(pathPattern);\n     String authority \u003d authorityFromPath(pathPattern);\n \n     // Next we strip off everything except the pathname itself, and expand all\n     // globs.  Expansion is a process which turns \"grouping\" clauses,\n     // expressed as brackets, into separate path patterns.\n     String pathPatternString \u003d pathPattern.toUri().getPath();\n     List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n \n     // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n     // match them to entries in the filesystem.\n     ArrayList\u003cFileStatus\u003e results \u003d \n         new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n     boolean sawWildcard \u003d false;\n     for (String flatPattern : flattenedPatterns) {\n       // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n       // this prior to flattening because of patterns like {/,a}, where which\n       // path you go down influences how the path must be made absolute.\n       Path absPattern \u003d fixRelativePart(new Path(\n           flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n       // Now we break the flattened, absolute pattern into path components.\n       // For example, /a/*/c would be broken into the list [a, *, c]\n       List\u003cString\u003e components \u003d\n           getPathComponents(absPattern.toUri().getPath());\n       // Starting out at the root of the filesystem, we try to match\n       // filesystem entries against pattern components.\n       ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n       // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n       // RPC to the NameNode.  So we create a placeholder FileStatus which has\n       // the correct path, but defaults for the rest of the information.\n       // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n       // replace the placeholder with a real FileStatus obtained from the\n       // NameNode.\n       FileStatus rootPlaceholder;\n       if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n           \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n         // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n         // We will skip matching the drive letter and start from listing the\n         // root of the filesystem on that drive.\n         String driveLetter \u003d components.remove(0);\n         rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n             authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n       } else {\n         rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n             new Path(scheme, authority, Path.SEPARATOR));\n       }\n       candidates.add(rootPlaceholder);\n       \n       for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n           componentIdx++) {\n         ArrayList\u003cFileStatus\u003e newCandidates \u003d\n             new ArrayList\u003cFileStatus\u003e(candidates.size());\n         GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n         String component \u003d unescapePathComponent(components.get(componentIdx));\n         if (globFilter.hasPattern()) {\n           sawWildcard \u003d true;\n         }\n         if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n           // Optimization: if there are no more candidates left, stop examining \n           // the path components.  We can only do this if we\u0027ve already seen\n           // a wildcard component-- otherwise, we still need to visit all path \n           // components in case one of them is a wildcard.\n           break;\n         }\n         if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n             (!globFilter.hasPattern())) {\n           // Optimization: if this is not the terminal path component, and we \n           // are not matching against a glob, assume that it exists.  If it \n           // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n           // or the terminal path component.\n           for (FileStatus candidate : candidates) {\n             candidate.setPath(new Path(candidate.getPath(), component));\n           }\n           continue;\n         }\n         for (FileStatus candidate : candidates) {\n           if (globFilter.hasPattern()) {\n             FileStatus[] children \u003d listStatus(candidate.getPath());\n             if (children.length \u003d\u003d 1) {\n               // If we get back only one result, this could be either a listing\n               // of a directory with one entry, or it could reflect the fact\n               // that what we listed resolved to a file.\n               //\n               // Unfortunately, we can\u0027t just compare the returned paths to\n               // figure this out.  Consider the case where you have /a/b, where\n               // b is a symlink to \"..\".  In that case, listing /a/b will give\n               // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n               // incorrectly conclude that /a/b was a file and should not match\n               // /a/*/*.  So we use getFileStatus of the path we just listed to\n               // disambiguate.\n               if (!getFileStatus(candidate.getPath()).isDirectory()) {\n                 continue;\n               }\n             }\n             for (FileStatus child : children) {\n               if (componentIdx \u003c components.size() - 1) {\n                 // Don\u0027t try to recurse into non-directories.  See HADOOP-10957.\n                 if (!child.isDirectory()) continue; \n               }\n               // Set the child path based on the parent path.\n               child.setPath(new Path(candidate.getPath(),\n                       child.getPath().getName()));\n               if (globFilter.accept(child.getPath())) {\n                 newCandidates.add(child);\n               }\n             }\n           } else {\n             // When dealing with non-glob components, use getFileStatus \n             // instead of listStatus.  This is an optimization, but it also\n             // is necessary for correctness in HDFS, since there are some\n             // special HDFS directories like .reserved and .snapshot that are\n             // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n             FileStatus childStatus \u003d getFileStatus(\n                 new Path(candidate.getPath(), component));\n             if (childStatus !\u003d null) {\n               newCandidates.add(childStatus);\n             }\n           }\n         }\n         candidates \u003d newCandidates;\n       }\n       for (FileStatus status : candidates) {\n         // Use object equality to see if this status is the root placeholder.\n         // See the explanation for rootPlaceholder above for more information.\n         if (status \u003d\u003d rootPlaceholder) {\n           status \u003d getFileStatus(rootPlaceholder.getPath());\n           if (status \u003d\u003d null) continue;\n         }\n         // HADOOP-3497 semantics: the user-defined filter is applied at the\n         // end, once the full path is built up.\n         if (filter.accept(status.getPath())) {\n           results.add(status);\n         }\n       }\n     }\n     /*\n      * When the input pattern \"looks\" like just a simple filename, and we\n      * can\u0027t find it, we return null rather than an empty array.\n      * This is a special case which the shell relies on.\n      *\n      * To be more precise: if there were no results, AND there were no\n      * groupings (aka brackets), and no wildcards in the input (aka stars),\n      * we return null.\n      */\n     if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n         (flattenedPatterns.size() \u003c\u003d 1)) {\n       return null;\n     }\n     /*\n      * In general, the results list will already be sorted, since listStatus\n      * returns results in sorted order for many Hadoop filesystems.  However,\n      * not all Hadoop filesystems have this property.  So we sort here in order\n      * to get consistent results.  See HADOOP-10798 for details.\n      */\n     FileStatus ret[] \u003d results.toArray(new FileStatus[0]);\n     Arrays.sort(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private FileStatus[] doGlob() throws IOException {\n    // First we get the scheme and authority of the pattern that was passed\n    // in.\n    String scheme \u003d schemeFromPath(pathPattern);\n    String authority \u003d authorityFromPath(pathPattern);\n\n    // Next we strip off everything except the pathname itself, and expand all\n    // globs.  Expansion is a process which turns \"grouping\" clauses,\n    // expressed as brackets, into separate path patterns.\n    String pathPatternString \u003d pathPattern.toUri().getPath();\n    List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n\n    // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n    // match them to entries in the filesystem.\n    ArrayList\u003cFileStatus\u003e results \u003d \n        new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n    boolean sawWildcard \u003d false;\n    for (String flatPattern : flattenedPatterns) {\n      // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n      // this prior to flattening because of patterns like {/,a}, where which\n      // path you go down influences how the path must be made absolute.\n      Path absPattern \u003d fixRelativePart(new Path(\n          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n      // Now we break the flattened, absolute pattern into path components.\n      // For example, /a/*/c would be broken into the list [a, *, c]\n      List\u003cString\u003e components \u003d\n          getPathComponents(absPattern.toUri().getPath());\n      // Starting out at the root of the filesystem, we try to match\n      // filesystem entries against pattern components.\n      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n      // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n      // the correct path, but defaults for the rest of the information.\n      // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n      // replace the placeholder with a real FileStatus obtained from the\n      // NameNode.\n      FileStatus rootPlaceholder;\n      if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n          \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n        // We will skip matching the drive letter and start from listing the\n        // root of the filesystem on that drive.\n        String driveLetter \u003d components.remove(0);\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n      } else {\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n            new Path(scheme, authority, Path.SEPARATOR));\n      }\n      candidates.add(rootPlaceholder);\n      \n      for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n          componentIdx++) {\n        ArrayList\u003cFileStatus\u003e newCandidates \u003d\n            new ArrayList\u003cFileStatus\u003e(candidates.size());\n        GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n        String component \u003d unescapePathComponent(components.get(componentIdx));\n        if (globFilter.hasPattern()) {\n          sawWildcard \u003d true;\n        }\n        if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n          // Optimization: if there are no more candidates left, stop examining \n          // the path components.  We can only do this if we\u0027ve already seen\n          // a wildcard component-- otherwise, we still need to visit all path \n          // components in case one of them is a wildcard.\n          break;\n        }\n        if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n            (!globFilter.hasPattern())) {\n          // Optimization: if this is not the terminal path component, and we \n          // are not matching against a glob, assume that it exists.  If it \n          // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n          // or the terminal path component.\n          for (FileStatus candidate : candidates) {\n            candidate.setPath(new Path(candidate.getPath(), component));\n          }\n          continue;\n        }\n        for (FileStatus candidate : candidates) {\n          if (globFilter.hasPattern()) {\n            FileStatus[] children \u003d listStatus(candidate.getPath());\n            if (children.length \u003d\u003d 1) {\n              // If we get back only one result, this could be either a listing\n              // of a directory with one entry, or it could reflect the fact\n              // that what we listed resolved to a file.\n              //\n              // Unfortunately, we can\u0027t just compare the returned paths to\n              // figure this out.  Consider the case where you have /a/b, where\n              // b is a symlink to \"..\".  In that case, listing /a/b will give\n              // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n              // incorrectly conclude that /a/b was a file and should not match\n              // /a/*/*.  So we use getFileStatus of the path we just listed to\n              // disambiguate.\n              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n                continue;\n              }\n            }\n            for (FileStatus child : children) {\n              if (componentIdx \u003c components.size() - 1) {\n                // Don\u0027t try to recurse into non-directories.  See HADOOP-10957.\n                if (!child.isDirectory()) continue; \n              }\n              // Set the child path based on the parent path.\n              child.setPath(new Path(candidate.getPath(),\n                      child.getPath().getName()));\n              if (globFilter.accept(child.getPath())) {\n                newCandidates.add(child);\n              }\n            }\n          } else {\n            // When dealing with non-glob components, use getFileStatus \n            // instead of listStatus.  This is an optimization, but it also\n            // is necessary for correctness in HDFS, since there are some\n            // special HDFS directories like .reserved and .snapshot that are\n            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n            FileStatus childStatus \u003d getFileStatus(\n                new Path(candidate.getPath(), component));\n            if (childStatus !\u003d null) {\n              newCandidates.add(childStatus);\n            }\n          }\n        }\n        candidates \u003d newCandidates;\n      }\n      for (FileStatus status : candidates) {\n        // Use object equality to see if this status is the root placeholder.\n        // See the explanation for rootPlaceholder above for more information.\n        if (status \u003d\u003d rootPlaceholder) {\n          status \u003d getFileStatus(rootPlaceholder.getPath());\n          if (status \u003d\u003d null) continue;\n        }\n        // HADOOP-3497 semantics: the user-defined filter is applied at the\n        // end, once the full path is built up.\n        if (filter.accept(status.getPath())) {\n          results.add(status);\n        }\n      }\n    }\n    /*\n     * When the input pattern \"looks\" like just a simple filename, and we\n     * can\u0027t find it, we return null rather than an empty array.\n     * This is a special case which the shell relies on.\n     *\n     * To be more precise: if there were no results, AND there were no\n     * groupings (aka brackets), and no wildcards in the input (aka stars),\n     * we return null.\n     */\n    if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n        (flattenedPatterns.size() \u003c\u003d 1)) {\n      return null;\n    }\n    /*\n     * In general, the results list will already be sorted, since listStatus\n     * returns results in sorted order for many Hadoop filesystems.  However,\n     * not all Hadoop filesystems have this property.  So we sort here in order\n     * to get consistent results.  See HADOOP-10798 for details.\n     */\n    FileStatus ret[] \u003d results.toArray(new FileStatus[0]);\n    Arrays.sort(ret);\n    return ret;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java",
          "extendedDetails": {
            "oldValue": "glob",
            "newValue": "doGlob"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HADOOP-12201. Add tracing to FileSystem#createFileSystem and Globber#glob (cmccabe)\n",
          "commitDate": "08/07/15 8:07 PM",
          "commitName": "b8832fcf1e2ae1e43d5e4523016731af40ab58d7",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "30/06/15 4:40 PM",
          "commitNameOld": "68e588cbee660d55dba518892d064bee3795a002",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 8.14,
          "commitsBetweenForRepo": 50,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,161 +1,161 @@\n-  public FileStatus[] glob() throws IOException {\n+  private FileStatus[] doGlob() throws IOException {\n     // First we get the scheme and authority of the pattern that was passed\n     // in.\n     String scheme \u003d schemeFromPath(pathPattern);\n     String authority \u003d authorityFromPath(pathPattern);\n \n     // Next we strip off everything except the pathname itself, and expand all\n     // globs.  Expansion is a process which turns \"grouping\" clauses,\n     // expressed as brackets, into separate path patterns.\n     String pathPatternString \u003d pathPattern.toUri().getPath();\n     List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n \n     // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n     // match them to entries in the filesystem.\n     ArrayList\u003cFileStatus\u003e results \u003d \n         new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n     boolean sawWildcard \u003d false;\n     for (String flatPattern : flattenedPatterns) {\n       // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n       // this prior to flattening because of patterns like {/,a}, where which\n       // path you go down influences how the path must be made absolute.\n       Path absPattern \u003d fixRelativePart(new Path(\n           flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n       // Now we break the flattened, absolute pattern into path components.\n       // For example, /a/*/c would be broken into the list [a, *, c]\n       List\u003cString\u003e components \u003d\n           getPathComponents(absPattern.toUri().getPath());\n       // Starting out at the root of the filesystem, we try to match\n       // filesystem entries against pattern components.\n       ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n       // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n       // RPC to the NameNode.  So we create a placeholder FileStatus which has\n       // the correct path, but defaults for the rest of the information.\n       // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n       // replace the placeholder with a real FileStatus obtained from the\n       // NameNode.\n       FileStatus rootPlaceholder;\n       if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n           \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n         // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n         // We will skip matching the drive letter and start from listing the\n         // root of the filesystem on that drive.\n         String driveLetter \u003d components.remove(0);\n         rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n             authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n       } else {\n         rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n             new Path(scheme, authority, Path.SEPARATOR));\n       }\n       candidates.add(rootPlaceholder);\n       \n       for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n           componentIdx++) {\n         ArrayList\u003cFileStatus\u003e newCandidates \u003d\n             new ArrayList\u003cFileStatus\u003e(candidates.size());\n         GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n         String component \u003d unescapePathComponent(components.get(componentIdx));\n         if (globFilter.hasPattern()) {\n           sawWildcard \u003d true;\n         }\n         if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n           // Optimization: if there are no more candidates left, stop examining \n           // the path components.  We can only do this if we\u0027ve already seen\n           // a wildcard component-- otherwise, we still need to visit all path \n           // components in case one of them is a wildcard.\n           break;\n         }\n         if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n             (!globFilter.hasPattern())) {\n           // Optimization: if this is not the terminal path component, and we \n           // are not matching against a glob, assume that it exists.  If it \n           // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n           // or the terminal path component.\n           for (FileStatus candidate : candidates) {\n             candidate.setPath(new Path(candidate.getPath(), component));\n           }\n           continue;\n         }\n         for (FileStatus candidate : candidates) {\n           if (globFilter.hasPattern()) {\n             FileStatus[] children \u003d listStatus(candidate.getPath());\n             if (children.length \u003d\u003d 1) {\n               // If we get back only one result, this could be either a listing\n               // of a directory with one entry, or it could reflect the fact\n               // that what we listed resolved to a file.\n               //\n               // Unfortunately, we can\u0027t just compare the returned paths to\n               // figure this out.  Consider the case where you have /a/b, where\n               // b is a symlink to \"..\".  In that case, listing /a/b will give\n               // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n               // incorrectly conclude that /a/b was a file and should not match\n               // /a/*/*.  So we use getFileStatus of the path we just listed to\n               // disambiguate.\n               if (!getFileStatus(candidate.getPath()).isDirectory()) {\n                 continue;\n               }\n             }\n             for (FileStatus child : children) {\n               if (componentIdx \u003c components.size() - 1) {\n                 // Don\u0027t try to recurse into non-directories.  See HADOOP-10957.\n                 if (!child.isDirectory()) continue; \n               }\n               // Set the child path based on the parent path.\n               child.setPath(new Path(candidate.getPath(),\n                       child.getPath().getName()));\n               if (globFilter.accept(child.getPath())) {\n                 newCandidates.add(child);\n               }\n             }\n           } else {\n             // When dealing with non-glob components, use getFileStatus \n             // instead of listStatus.  This is an optimization, but it also\n             // is necessary for correctness in HDFS, since there are some\n             // special HDFS directories like .reserved and .snapshot that are\n             // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n             FileStatus childStatus \u003d getFileStatus(\n                 new Path(candidate.getPath(), component));\n             if (childStatus !\u003d null) {\n               newCandidates.add(childStatus);\n             }\n           }\n         }\n         candidates \u003d newCandidates;\n       }\n       for (FileStatus status : candidates) {\n         // Use object equality to see if this status is the root placeholder.\n         // See the explanation for rootPlaceholder above for more information.\n         if (status \u003d\u003d rootPlaceholder) {\n           status \u003d getFileStatus(rootPlaceholder.getPath());\n           if (status \u003d\u003d null) continue;\n         }\n         // HADOOP-3497 semantics: the user-defined filter is applied at the\n         // end, once the full path is built up.\n         if (filter.accept(status.getPath())) {\n           results.add(status);\n         }\n       }\n     }\n     /*\n      * When the input pattern \"looks\" like just a simple filename, and we\n      * can\u0027t find it, we return null rather than an empty array.\n      * This is a special case which the shell relies on.\n      *\n      * To be more precise: if there were no results, AND there were no\n      * groupings (aka brackets), and no wildcards in the input (aka stars),\n      * we return null.\n      */\n     if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n         (flattenedPatterns.size() \u003c\u003d 1)) {\n       return null;\n     }\n     /*\n      * In general, the results list will already be sorted, since listStatus\n      * returns results in sorted order for many Hadoop filesystems.  However,\n      * not all Hadoop filesystems have this property.  So we sort here in order\n      * to get consistent results.  See HADOOP-10798 for details.\n      */\n     FileStatus ret[] \u003d results.toArray(new FileStatus[0]);\n     Arrays.sort(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private FileStatus[] doGlob() throws IOException {\n    // First we get the scheme and authority of the pattern that was passed\n    // in.\n    String scheme \u003d schemeFromPath(pathPattern);\n    String authority \u003d authorityFromPath(pathPattern);\n\n    // Next we strip off everything except the pathname itself, and expand all\n    // globs.  Expansion is a process which turns \"grouping\" clauses,\n    // expressed as brackets, into separate path patterns.\n    String pathPatternString \u003d pathPattern.toUri().getPath();\n    List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n\n    // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n    // match them to entries in the filesystem.\n    ArrayList\u003cFileStatus\u003e results \u003d \n        new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n    boolean sawWildcard \u003d false;\n    for (String flatPattern : flattenedPatterns) {\n      // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n      // this prior to flattening because of patterns like {/,a}, where which\n      // path you go down influences how the path must be made absolute.\n      Path absPattern \u003d fixRelativePart(new Path(\n          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n      // Now we break the flattened, absolute pattern into path components.\n      // For example, /a/*/c would be broken into the list [a, *, c]\n      List\u003cString\u003e components \u003d\n          getPathComponents(absPattern.toUri().getPath());\n      // Starting out at the root of the filesystem, we try to match\n      // filesystem entries against pattern components.\n      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n      // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n      // the correct path, but defaults for the rest of the information.\n      // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n      // replace the placeholder with a real FileStatus obtained from the\n      // NameNode.\n      FileStatus rootPlaceholder;\n      if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n          \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n        // We will skip matching the drive letter and start from listing the\n        // root of the filesystem on that drive.\n        String driveLetter \u003d components.remove(0);\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n      } else {\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n            new Path(scheme, authority, Path.SEPARATOR));\n      }\n      candidates.add(rootPlaceholder);\n      \n      for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n          componentIdx++) {\n        ArrayList\u003cFileStatus\u003e newCandidates \u003d\n            new ArrayList\u003cFileStatus\u003e(candidates.size());\n        GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n        String component \u003d unescapePathComponent(components.get(componentIdx));\n        if (globFilter.hasPattern()) {\n          sawWildcard \u003d true;\n        }\n        if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n          // Optimization: if there are no more candidates left, stop examining \n          // the path components.  We can only do this if we\u0027ve already seen\n          // a wildcard component-- otherwise, we still need to visit all path \n          // components in case one of them is a wildcard.\n          break;\n        }\n        if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n            (!globFilter.hasPattern())) {\n          // Optimization: if this is not the terminal path component, and we \n          // are not matching against a glob, assume that it exists.  If it \n          // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n          // or the terminal path component.\n          for (FileStatus candidate : candidates) {\n            candidate.setPath(new Path(candidate.getPath(), component));\n          }\n          continue;\n        }\n        for (FileStatus candidate : candidates) {\n          if (globFilter.hasPattern()) {\n            FileStatus[] children \u003d listStatus(candidate.getPath());\n            if (children.length \u003d\u003d 1) {\n              // If we get back only one result, this could be either a listing\n              // of a directory with one entry, or it could reflect the fact\n              // that what we listed resolved to a file.\n              //\n              // Unfortunately, we can\u0027t just compare the returned paths to\n              // figure this out.  Consider the case where you have /a/b, where\n              // b is a symlink to \"..\".  In that case, listing /a/b will give\n              // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n              // incorrectly conclude that /a/b was a file and should not match\n              // /a/*/*.  So we use getFileStatus of the path we just listed to\n              // disambiguate.\n              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n                continue;\n              }\n            }\n            for (FileStatus child : children) {\n              if (componentIdx \u003c components.size() - 1) {\n                // Don\u0027t try to recurse into non-directories.  See HADOOP-10957.\n                if (!child.isDirectory()) continue; \n              }\n              // Set the child path based on the parent path.\n              child.setPath(new Path(candidate.getPath(),\n                      child.getPath().getName()));\n              if (globFilter.accept(child.getPath())) {\n                newCandidates.add(child);\n              }\n            }\n          } else {\n            // When dealing with non-glob components, use getFileStatus \n            // instead of listStatus.  This is an optimization, but it also\n            // is necessary for correctness in HDFS, since there are some\n            // special HDFS directories like .reserved and .snapshot that are\n            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n            FileStatus childStatus \u003d getFileStatus(\n                new Path(candidate.getPath(), component));\n            if (childStatus !\u003d null) {\n              newCandidates.add(childStatus);\n            }\n          }\n        }\n        candidates \u003d newCandidates;\n      }\n      for (FileStatus status : candidates) {\n        // Use object equality to see if this status is the root placeholder.\n        // See the explanation for rootPlaceholder above for more information.\n        if (status \u003d\u003d rootPlaceholder) {\n          status \u003d getFileStatus(rootPlaceholder.getPath());\n          if (status \u003d\u003d null) continue;\n        }\n        // HADOOP-3497 semantics: the user-defined filter is applied at the\n        // end, once the full path is built up.\n        if (filter.accept(status.getPath())) {\n          results.add(status);\n        }\n      }\n    }\n    /*\n     * When the input pattern \"looks\" like just a simple filename, and we\n     * can\u0027t find it, we return null rather than an empty array.\n     * This is a special case which the shell relies on.\n     *\n     * To be more precise: if there were no results, AND there were no\n     * groupings (aka brackets), and no wildcards in the input (aka stars),\n     * we return null.\n     */\n    if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n        (flattenedPatterns.size() \u003c\u003d 1)) {\n      return null;\n    }\n    /*\n     * In general, the results list will already be sorted, since listStatus\n     * returns results in sorted order for many Hadoop filesystems.  However,\n     * not all Hadoop filesystems have this property.  So we sort here in order\n     * to get consistent results.  See HADOOP-10798 for details.\n     */\n    FileStatus ret[] \u003d results.toArray(new FileStatus[0]);\n    Arrays.sort(ret);\n    return ret;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[private]"
          }
        }
      ]
    },
    "68e588cbee660d55dba518892d064bee3795a002": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10798. globStatus() should always return a sorted list of files (cmccabe)\n",
      "commitDate": "30/06/15 4:40 PM",
      "commitName": "68e588cbee660d55dba518892d064bee3795a002",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "27/08/14 7:47 PM",
      "commitNameOld": "7a167311918300b1f00868a83d2f71a1ca88e918",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 306.87,
      "commitsBetweenForRepo": 2666,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,153 +1,161 @@\n   public FileStatus[] glob() throws IOException {\n     // First we get the scheme and authority of the pattern that was passed\n     // in.\n     String scheme \u003d schemeFromPath(pathPattern);\n     String authority \u003d authorityFromPath(pathPattern);\n \n     // Next we strip off everything except the pathname itself, and expand all\n     // globs.  Expansion is a process which turns \"grouping\" clauses,\n     // expressed as brackets, into separate path patterns.\n     String pathPatternString \u003d pathPattern.toUri().getPath();\n     List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n \n     // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n     // match them to entries in the filesystem.\n     ArrayList\u003cFileStatus\u003e results \u003d \n         new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n     boolean sawWildcard \u003d false;\n     for (String flatPattern : flattenedPatterns) {\n       // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n       // this prior to flattening because of patterns like {/,a}, where which\n       // path you go down influences how the path must be made absolute.\n       Path absPattern \u003d fixRelativePart(new Path(\n           flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n       // Now we break the flattened, absolute pattern into path components.\n       // For example, /a/*/c would be broken into the list [a, *, c]\n       List\u003cString\u003e components \u003d\n           getPathComponents(absPattern.toUri().getPath());\n       // Starting out at the root of the filesystem, we try to match\n       // filesystem entries against pattern components.\n       ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n       // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n       // RPC to the NameNode.  So we create a placeholder FileStatus which has\n       // the correct path, but defaults for the rest of the information.\n       // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n       // replace the placeholder with a real FileStatus obtained from the\n       // NameNode.\n       FileStatus rootPlaceholder;\n       if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n           \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n         // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n         // We will skip matching the drive letter and start from listing the\n         // root of the filesystem on that drive.\n         String driveLetter \u003d components.remove(0);\n         rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n             authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n       } else {\n         rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n             new Path(scheme, authority, Path.SEPARATOR));\n       }\n       candidates.add(rootPlaceholder);\n       \n       for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n           componentIdx++) {\n         ArrayList\u003cFileStatus\u003e newCandidates \u003d\n             new ArrayList\u003cFileStatus\u003e(candidates.size());\n         GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n         String component \u003d unescapePathComponent(components.get(componentIdx));\n         if (globFilter.hasPattern()) {\n           sawWildcard \u003d true;\n         }\n         if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n           // Optimization: if there are no more candidates left, stop examining \n           // the path components.  We can only do this if we\u0027ve already seen\n           // a wildcard component-- otherwise, we still need to visit all path \n           // components in case one of them is a wildcard.\n           break;\n         }\n         if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n             (!globFilter.hasPattern())) {\n           // Optimization: if this is not the terminal path component, and we \n           // are not matching against a glob, assume that it exists.  If it \n           // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n           // or the terminal path component.\n           for (FileStatus candidate : candidates) {\n             candidate.setPath(new Path(candidate.getPath(), component));\n           }\n           continue;\n         }\n         for (FileStatus candidate : candidates) {\n           if (globFilter.hasPattern()) {\n             FileStatus[] children \u003d listStatus(candidate.getPath());\n             if (children.length \u003d\u003d 1) {\n               // If we get back only one result, this could be either a listing\n               // of a directory with one entry, or it could reflect the fact\n               // that what we listed resolved to a file.\n               //\n               // Unfortunately, we can\u0027t just compare the returned paths to\n               // figure this out.  Consider the case where you have /a/b, where\n               // b is a symlink to \"..\".  In that case, listing /a/b will give\n               // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n               // incorrectly conclude that /a/b was a file and should not match\n               // /a/*/*.  So we use getFileStatus of the path we just listed to\n               // disambiguate.\n               if (!getFileStatus(candidate.getPath()).isDirectory()) {\n                 continue;\n               }\n             }\n             for (FileStatus child : children) {\n               if (componentIdx \u003c components.size() - 1) {\n                 // Don\u0027t try to recurse into non-directories.  See HADOOP-10957.\n                 if (!child.isDirectory()) continue; \n               }\n               // Set the child path based on the parent path.\n               child.setPath(new Path(candidate.getPath(),\n                       child.getPath().getName()));\n               if (globFilter.accept(child.getPath())) {\n                 newCandidates.add(child);\n               }\n             }\n           } else {\n             // When dealing with non-glob components, use getFileStatus \n             // instead of listStatus.  This is an optimization, but it also\n             // is necessary for correctness in HDFS, since there are some\n             // special HDFS directories like .reserved and .snapshot that are\n             // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n             FileStatus childStatus \u003d getFileStatus(\n                 new Path(candidate.getPath(), component));\n             if (childStatus !\u003d null) {\n               newCandidates.add(childStatus);\n             }\n           }\n         }\n         candidates \u003d newCandidates;\n       }\n       for (FileStatus status : candidates) {\n         // Use object equality to see if this status is the root placeholder.\n         // See the explanation for rootPlaceholder above for more information.\n         if (status \u003d\u003d rootPlaceholder) {\n           status \u003d getFileStatus(rootPlaceholder.getPath());\n           if (status \u003d\u003d null) continue;\n         }\n         // HADOOP-3497 semantics: the user-defined filter is applied at the\n         // end, once the full path is built up.\n         if (filter.accept(status.getPath())) {\n           results.add(status);\n         }\n       }\n     }\n     /*\n      * When the input pattern \"looks\" like just a simple filename, and we\n      * can\u0027t find it, we return null rather than an empty array.\n      * This is a special case which the shell relies on.\n      *\n      * To be more precise: if there were no results, AND there were no\n      * groupings (aka brackets), and no wildcards in the input (aka stars),\n      * we return null.\n      */\n     if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n         (flattenedPatterns.size() \u003c\u003d 1)) {\n       return null;\n     }\n-    return results.toArray(new FileStatus[0]);\n+    /*\n+     * In general, the results list will already be sorted, since listStatus\n+     * returns results in sorted order for many Hadoop filesystems.  However,\n+     * not all Hadoop filesystems have this property.  So we sort here in order\n+     * to get consistent results.  See HADOOP-10798 for details.\n+     */\n+    FileStatus ret[] \u003d results.toArray(new FileStatus[0]);\n+    Arrays.sort(ret);\n+    return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] glob() throws IOException {\n    // First we get the scheme and authority of the pattern that was passed\n    // in.\n    String scheme \u003d schemeFromPath(pathPattern);\n    String authority \u003d authorityFromPath(pathPattern);\n\n    // Next we strip off everything except the pathname itself, and expand all\n    // globs.  Expansion is a process which turns \"grouping\" clauses,\n    // expressed as brackets, into separate path patterns.\n    String pathPatternString \u003d pathPattern.toUri().getPath();\n    List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n\n    // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n    // match them to entries in the filesystem.\n    ArrayList\u003cFileStatus\u003e results \u003d \n        new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n    boolean sawWildcard \u003d false;\n    for (String flatPattern : flattenedPatterns) {\n      // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n      // this prior to flattening because of patterns like {/,a}, where which\n      // path you go down influences how the path must be made absolute.\n      Path absPattern \u003d fixRelativePart(new Path(\n          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n      // Now we break the flattened, absolute pattern into path components.\n      // For example, /a/*/c would be broken into the list [a, *, c]\n      List\u003cString\u003e components \u003d\n          getPathComponents(absPattern.toUri().getPath());\n      // Starting out at the root of the filesystem, we try to match\n      // filesystem entries against pattern components.\n      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n      // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n      // the correct path, but defaults for the rest of the information.\n      // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n      // replace the placeholder with a real FileStatus obtained from the\n      // NameNode.\n      FileStatus rootPlaceholder;\n      if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n          \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n        // We will skip matching the drive letter and start from listing the\n        // root of the filesystem on that drive.\n        String driveLetter \u003d components.remove(0);\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n      } else {\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n            new Path(scheme, authority, Path.SEPARATOR));\n      }\n      candidates.add(rootPlaceholder);\n      \n      for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n          componentIdx++) {\n        ArrayList\u003cFileStatus\u003e newCandidates \u003d\n            new ArrayList\u003cFileStatus\u003e(candidates.size());\n        GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n        String component \u003d unescapePathComponent(components.get(componentIdx));\n        if (globFilter.hasPattern()) {\n          sawWildcard \u003d true;\n        }\n        if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n          // Optimization: if there are no more candidates left, stop examining \n          // the path components.  We can only do this if we\u0027ve already seen\n          // a wildcard component-- otherwise, we still need to visit all path \n          // components in case one of them is a wildcard.\n          break;\n        }\n        if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n            (!globFilter.hasPattern())) {\n          // Optimization: if this is not the terminal path component, and we \n          // are not matching against a glob, assume that it exists.  If it \n          // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n          // or the terminal path component.\n          for (FileStatus candidate : candidates) {\n            candidate.setPath(new Path(candidate.getPath(), component));\n          }\n          continue;\n        }\n        for (FileStatus candidate : candidates) {\n          if (globFilter.hasPattern()) {\n            FileStatus[] children \u003d listStatus(candidate.getPath());\n            if (children.length \u003d\u003d 1) {\n              // If we get back only one result, this could be either a listing\n              // of a directory with one entry, or it could reflect the fact\n              // that what we listed resolved to a file.\n              //\n              // Unfortunately, we can\u0027t just compare the returned paths to\n              // figure this out.  Consider the case where you have /a/b, where\n              // b is a symlink to \"..\".  In that case, listing /a/b will give\n              // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n              // incorrectly conclude that /a/b was a file and should not match\n              // /a/*/*.  So we use getFileStatus of the path we just listed to\n              // disambiguate.\n              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n                continue;\n              }\n            }\n            for (FileStatus child : children) {\n              if (componentIdx \u003c components.size() - 1) {\n                // Don\u0027t try to recurse into non-directories.  See HADOOP-10957.\n                if (!child.isDirectory()) continue; \n              }\n              // Set the child path based on the parent path.\n              child.setPath(new Path(candidate.getPath(),\n                      child.getPath().getName()));\n              if (globFilter.accept(child.getPath())) {\n                newCandidates.add(child);\n              }\n            }\n          } else {\n            // When dealing with non-glob components, use getFileStatus \n            // instead of listStatus.  This is an optimization, but it also\n            // is necessary for correctness in HDFS, since there are some\n            // special HDFS directories like .reserved and .snapshot that are\n            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n            FileStatus childStatus \u003d getFileStatus(\n                new Path(candidate.getPath(), component));\n            if (childStatus !\u003d null) {\n              newCandidates.add(childStatus);\n            }\n          }\n        }\n        candidates \u003d newCandidates;\n      }\n      for (FileStatus status : candidates) {\n        // Use object equality to see if this status is the root placeholder.\n        // See the explanation for rootPlaceholder above for more information.\n        if (status \u003d\u003d rootPlaceholder) {\n          status \u003d getFileStatus(rootPlaceholder.getPath());\n          if (status \u003d\u003d null) continue;\n        }\n        // HADOOP-3497 semantics: the user-defined filter is applied at the\n        // end, once the full path is built up.\n        if (filter.accept(status.getPath())) {\n          results.add(status);\n        }\n      }\n    }\n    /*\n     * When the input pattern \"looks\" like just a simple filename, and we\n     * can\u0027t find it, we return null rather than an empty array.\n     * This is a special case which the shell relies on.\n     *\n     * To be more precise: if there were no results, AND there were no\n     * groupings (aka brackets), and no wildcards in the input (aka stars),\n     * we return null.\n     */\n    if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n        (flattenedPatterns.size() \u003c\u003d 1)) {\n      return null;\n    }\n    /*\n     * In general, the results list will already be sorted, since listStatus\n     * returns results in sorted order for many Hadoop filesystems.  However,\n     * not all Hadoop filesystems have this property.  So we sort here in order\n     * to get consistent results.  See HADOOP-10798 for details.\n     */\n    FileStatus ret[] \u003d results.toArray(new FileStatus[0]);\n    Arrays.sort(ret);\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java",
      "extendedDetails": {}
    },
    "7a167311918300b1f00868a83d2f71a1ca88e918": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10957. The globber will sometimes erroneously return a permission denied exception when there is a non-terminal wildcard.\n",
      "commitDate": "27/08/14 7:47 PM",
      "commitName": "7a167311918300b1f00868a83d2f71a1ca88e918",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "11/02/14 6:12 PM",
      "commitNameOld": "53fed66d918e31a9c3d8bf0d4e6d3861c9b058b3",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 197.02,
      "commitsBetweenForRepo": 1459,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,153 @@\n   public FileStatus[] glob() throws IOException {\n     // First we get the scheme and authority of the pattern that was passed\n     // in.\n     String scheme \u003d schemeFromPath(pathPattern);\n     String authority \u003d authorityFromPath(pathPattern);\n \n     // Next we strip off everything except the pathname itself, and expand all\n     // globs.  Expansion is a process which turns \"grouping\" clauses,\n     // expressed as brackets, into separate path patterns.\n     String pathPatternString \u003d pathPattern.toUri().getPath();\n     List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n \n     // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n     // match them to entries in the filesystem.\n     ArrayList\u003cFileStatus\u003e results \u003d \n         new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n     boolean sawWildcard \u003d false;\n     for (String flatPattern : flattenedPatterns) {\n       // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n       // this prior to flattening because of patterns like {/,a}, where which\n       // path you go down influences how the path must be made absolute.\n       Path absPattern \u003d fixRelativePart(new Path(\n           flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n       // Now we break the flattened, absolute pattern into path components.\n       // For example, /a/*/c would be broken into the list [a, *, c]\n       List\u003cString\u003e components \u003d\n           getPathComponents(absPattern.toUri().getPath());\n       // Starting out at the root of the filesystem, we try to match\n       // filesystem entries against pattern components.\n       ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n       // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n       // RPC to the NameNode.  So we create a placeholder FileStatus which has\n       // the correct path, but defaults for the rest of the information.\n       // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n       // replace the placeholder with a real FileStatus obtained from the\n       // NameNode.\n       FileStatus rootPlaceholder;\n       if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n           \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n         // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n         // We will skip matching the drive letter and start from listing the\n         // root of the filesystem on that drive.\n         String driveLetter \u003d components.remove(0);\n         rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n             authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n       } else {\n         rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n             new Path(scheme, authority, Path.SEPARATOR));\n       }\n       candidates.add(rootPlaceholder);\n       \n       for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n           componentIdx++) {\n         ArrayList\u003cFileStatus\u003e newCandidates \u003d\n             new ArrayList\u003cFileStatus\u003e(candidates.size());\n         GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n         String component \u003d unescapePathComponent(components.get(componentIdx));\n         if (globFilter.hasPattern()) {\n           sawWildcard \u003d true;\n         }\n         if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n           // Optimization: if there are no more candidates left, stop examining \n           // the path components.  We can only do this if we\u0027ve already seen\n           // a wildcard component-- otherwise, we still need to visit all path \n           // components in case one of them is a wildcard.\n           break;\n         }\n         if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n             (!globFilter.hasPattern())) {\n           // Optimization: if this is not the terminal path component, and we \n           // are not matching against a glob, assume that it exists.  If it \n           // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n           // or the terminal path component.\n           for (FileStatus candidate : candidates) {\n             candidate.setPath(new Path(candidate.getPath(), component));\n           }\n           continue;\n         }\n         for (FileStatus candidate : candidates) {\n           if (globFilter.hasPattern()) {\n             FileStatus[] children \u003d listStatus(candidate.getPath());\n             if (children.length \u003d\u003d 1) {\n               // If we get back only one result, this could be either a listing\n               // of a directory with one entry, or it could reflect the fact\n               // that what we listed resolved to a file.\n               //\n               // Unfortunately, we can\u0027t just compare the returned paths to\n               // figure this out.  Consider the case where you have /a/b, where\n               // b is a symlink to \"..\".  In that case, listing /a/b will give\n               // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n               // incorrectly conclude that /a/b was a file and should not match\n               // /a/*/*.  So we use getFileStatus of the path we just listed to\n               // disambiguate.\n               if (!getFileStatus(candidate.getPath()).isDirectory()) {\n                 continue;\n               }\n             }\n             for (FileStatus child : children) {\n+              if (componentIdx \u003c components.size() - 1) {\n+                // Don\u0027t try to recurse into non-directories.  See HADOOP-10957.\n+                if (!child.isDirectory()) continue; \n+              }\n               // Set the child path based on the parent path.\n               child.setPath(new Path(candidate.getPath(),\n                       child.getPath().getName()));\n               if (globFilter.accept(child.getPath())) {\n                 newCandidates.add(child);\n               }\n             }\n           } else {\n             // When dealing with non-glob components, use getFileStatus \n             // instead of listStatus.  This is an optimization, but it also\n             // is necessary for correctness in HDFS, since there are some\n             // special HDFS directories like .reserved and .snapshot that are\n             // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n             FileStatus childStatus \u003d getFileStatus(\n                 new Path(candidate.getPath(), component));\n             if (childStatus !\u003d null) {\n               newCandidates.add(childStatus);\n-             }\n-           }\n+            }\n+          }\n         }\n         candidates \u003d newCandidates;\n       }\n       for (FileStatus status : candidates) {\n         // Use object equality to see if this status is the root placeholder.\n         // See the explanation for rootPlaceholder above for more information.\n         if (status \u003d\u003d rootPlaceholder) {\n           status \u003d getFileStatus(rootPlaceholder.getPath());\n           if (status \u003d\u003d null) continue;\n         }\n         // HADOOP-3497 semantics: the user-defined filter is applied at the\n         // end, once the full path is built up.\n         if (filter.accept(status.getPath())) {\n           results.add(status);\n         }\n       }\n     }\n     /*\n      * When the input pattern \"looks\" like just a simple filename, and we\n      * can\u0027t find it, we return null rather than an empty array.\n      * This is a special case which the shell relies on.\n      *\n      * To be more precise: if there were no results, AND there were no\n      * groupings (aka brackets), and no wildcards in the input (aka stars),\n      * we return null.\n      */\n     if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n         (flattenedPatterns.size() \u003c\u003d 1)) {\n       return null;\n     }\n     return results.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] glob() throws IOException {\n    // First we get the scheme and authority of the pattern that was passed\n    // in.\n    String scheme \u003d schemeFromPath(pathPattern);\n    String authority \u003d authorityFromPath(pathPattern);\n\n    // Next we strip off everything except the pathname itself, and expand all\n    // globs.  Expansion is a process which turns \"grouping\" clauses,\n    // expressed as brackets, into separate path patterns.\n    String pathPatternString \u003d pathPattern.toUri().getPath();\n    List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n\n    // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n    // match them to entries in the filesystem.\n    ArrayList\u003cFileStatus\u003e results \u003d \n        new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n    boolean sawWildcard \u003d false;\n    for (String flatPattern : flattenedPatterns) {\n      // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n      // this prior to flattening because of patterns like {/,a}, where which\n      // path you go down influences how the path must be made absolute.\n      Path absPattern \u003d fixRelativePart(new Path(\n          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n      // Now we break the flattened, absolute pattern into path components.\n      // For example, /a/*/c would be broken into the list [a, *, c]\n      List\u003cString\u003e components \u003d\n          getPathComponents(absPattern.toUri().getPath());\n      // Starting out at the root of the filesystem, we try to match\n      // filesystem entries against pattern components.\n      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n      // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n      // the correct path, but defaults for the rest of the information.\n      // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n      // replace the placeholder with a real FileStatus obtained from the\n      // NameNode.\n      FileStatus rootPlaceholder;\n      if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n          \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n        // We will skip matching the drive letter and start from listing the\n        // root of the filesystem on that drive.\n        String driveLetter \u003d components.remove(0);\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n      } else {\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n            new Path(scheme, authority, Path.SEPARATOR));\n      }\n      candidates.add(rootPlaceholder);\n      \n      for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n          componentIdx++) {\n        ArrayList\u003cFileStatus\u003e newCandidates \u003d\n            new ArrayList\u003cFileStatus\u003e(candidates.size());\n        GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n        String component \u003d unescapePathComponent(components.get(componentIdx));\n        if (globFilter.hasPattern()) {\n          sawWildcard \u003d true;\n        }\n        if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n          // Optimization: if there are no more candidates left, stop examining \n          // the path components.  We can only do this if we\u0027ve already seen\n          // a wildcard component-- otherwise, we still need to visit all path \n          // components in case one of them is a wildcard.\n          break;\n        }\n        if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n            (!globFilter.hasPattern())) {\n          // Optimization: if this is not the terminal path component, and we \n          // are not matching against a glob, assume that it exists.  If it \n          // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n          // or the terminal path component.\n          for (FileStatus candidate : candidates) {\n            candidate.setPath(new Path(candidate.getPath(), component));\n          }\n          continue;\n        }\n        for (FileStatus candidate : candidates) {\n          if (globFilter.hasPattern()) {\n            FileStatus[] children \u003d listStatus(candidate.getPath());\n            if (children.length \u003d\u003d 1) {\n              // If we get back only one result, this could be either a listing\n              // of a directory with one entry, or it could reflect the fact\n              // that what we listed resolved to a file.\n              //\n              // Unfortunately, we can\u0027t just compare the returned paths to\n              // figure this out.  Consider the case where you have /a/b, where\n              // b is a symlink to \"..\".  In that case, listing /a/b will give\n              // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n              // incorrectly conclude that /a/b was a file and should not match\n              // /a/*/*.  So we use getFileStatus of the path we just listed to\n              // disambiguate.\n              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n                continue;\n              }\n            }\n            for (FileStatus child : children) {\n              if (componentIdx \u003c components.size() - 1) {\n                // Don\u0027t try to recurse into non-directories.  See HADOOP-10957.\n                if (!child.isDirectory()) continue; \n              }\n              // Set the child path based on the parent path.\n              child.setPath(new Path(candidate.getPath(),\n                      child.getPath().getName()));\n              if (globFilter.accept(child.getPath())) {\n                newCandidates.add(child);\n              }\n            }\n          } else {\n            // When dealing with non-glob components, use getFileStatus \n            // instead of listStatus.  This is an optimization, but it also\n            // is necessary for correctness in HDFS, since there are some\n            // special HDFS directories like .reserved and .snapshot that are\n            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n            FileStatus childStatus \u003d getFileStatus(\n                new Path(candidate.getPath(), component));\n            if (childStatus !\u003d null) {\n              newCandidates.add(childStatus);\n            }\n          }\n        }\n        candidates \u003d newCandidates;\n      }\n      for (FileStatus status : candidates) {\n        // Use object equality to see if this status is the root placeholder.\n        // See the explanation for rootPlaceholder above for more information.\n        if (status \u003d\u003d rootPlaceholder) {\n          status \u003d getFileStatus(rootPlaceholder.getPath());\n          if (status \u003d\u003d null) continue;\n        }\n        // HADOOP-3497 semantics: the user-defined filter is applied at the\n        // end, once the full path is built up.\n        if (filter.accept(status.getPath())) {\n          results.add(status);\n        }\n      }\n    }\n    /*\n     * When the input pattern \"looks\" like just a simple filename, and we\n     * can\u0027t find it, we return null rather than an empty array.\n     * This is a special case which the shell relies on.\n     *\n     * To be more precise: if there were no results, AND there were no\n     * groupings (aka brackets), and no wildcards in the input (aka stars),\n     * we return null.\n     */\n    if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n        (flattenedPatterns.size() \u003c\u003d 1)) {\n      return null;\n    }\n    return results.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java",
      "extendedDetails": {}
    },
    "53fed66d918e31a9c3d8bf0d4e6d3861c9b058b3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10338. Cannot get the FileStatus of the root inode from the new Globber (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567497 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/02/14 6:12 PM",
      "commitName": "53fed66d918e31a9c3d8bf0d4e6d3861c9b058b3",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "25/09/13 1:51 PM",
      "commitNameOld": "464470e715c95fc3b832e93800d551fdb44333f1",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 139.22,
      "commitsBetweenForRepo": 861,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,149 @@\n   public FileStatus[] glob() throws IOException {\n     // First we get the scheme and authority of the pattern that was passed\n     // in.\n     String scheme \u003d schemeFromPath(pathPattern);\n     String authority \u003d authorityFromPath(pathPattern);\n \n     // Next we strip off everything except the pathname itself, and expand all\n     // globs.  Expansion is a process which turns \"grouping\" clauses,\n     // expressed as brackets, into separate path patterns.\n     String pathPatternString \u003d pathPattern.toUri().getPath();\n     List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n \n     // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n     // match them to entries in the filesystem.\n     ArrayList\u003cFileStatus\u003e results \u003d \n         new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n     boolean sawWildcard \u003d false;\n     for (String flatPattern : flattenedPatterns) {\n       // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n       // this prior to flattening because of patterns like {/,a}, where which\n       // path you go down influences how the path must be made absolute.\n       Path absPattern \u003d fixRelativePart(new Path(\n           flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n       // Now we break the flattened, absolute pattern into path components.\n       // For example, /a/*/c would be broken into the list [a, *, c]\n       List\u003cString\u003e components \u003d\n           getPathComponents(absPattern.toUri().getPath());\n       // Starting out at the root of the filesystem, we try to match\n       // filesystem entries against pattern components.\n       ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n+      // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n+      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n+      // the correct path, but defaults for the rest of the information.\n+      // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n+      // replace the placeholder with a real FileStatus obtained from the\n+      // NameNode.\n+      FileStatus rootPlaceholder;\n       if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n           \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n         // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n         // We will skip matching the drive letter and start from listing the\n         // root of the filesystem on that drive.\n         String driveLetter \u003d components.remove(0);\n-        candidates.add(new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n-            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR)));\n+        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n+            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n       } else {\n-        candidates.add(new FileStatus(0, true, 0, 0, 0,\n-            new Path(scheme, authority, Path.SEPARATOR)));\n+        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n+            new Path(scheme, authority, Path.SEPARATOR));\n       }\n+      candidates.add(rootPlaceholder);\n       \n       for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n           componentIdx++) {\n         ArrayList\u003cFileStatus\u003e newCandidates \u003d\n             new ArrayList\u003cFileStatus\u003e(candidates.size());\n         GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n         String component \u003d unescapePathComponent(components.get(componentIdx));\n         if (globFilter.hasPattern()) {\n           sawWildcard \u003d true;\n         }\n         if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n           // Optimization: if there are no more candidates left, stop examining \n           // the path components.  We can only do this if we\u0027ve already seen\n           // a wildcard component-- otherwise, we still need to visit all path \n           // components in case one of them is a wildcard.\n           break;\n         }\n         if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n             (!globFilter.hasPattern())) {\n           // Optimization: if this is not the terminal path component, and we \n           // are not matching against a glob, assume that it exists.  If it \n           // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n           // or the terminal path component.\n           for (FileStatus candidate : candidates) {\n             candidate.setPath(new Path(candidate.getPath(), component));\n           }\n           continue;\n         }\n         for (FileStatus candidate : candidates) {\n           if (globFilter.hasPattern()) {\n             FileStatus[] children \u003d listStatus(candidate.getPath());\n             if (children.length \u003d\u003d 1) {\n               // If we get back only one result, this could be either a listing\n               // of a directory with one entry, or it could reflect the fact\n               // that what we listed resolved to a file.\n               //\n               // Unfortunately, we can\u0027t just compare the returned paths to\n               // figure this out.  Consider the case where you have /a/b, where\n               // b is a symlink to \"..\".  In that case, listing /a/b will give\n               // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n               // incorrectly conclude that /a/b was a file and should not match\n               // /a/*/*.  So we use getFileStatus of the path we just listed to\n               // disambiguate.\n               if (!getFileStatus(candidate.getPath()).isDirectory()) {\n                 continue;\n               }\n             }\n             for (FileStatus child : children) {\n               // Set the child path based on the parent path.\n               child.setPath(new Path(candidate.getPath(),\n                       child.getPath().getName()));\n               if (globFilter.accept(child.getPath())) {\n                 newCandidates.add(child);\n               }\n             }\n           } else {\n             // When dealing with non-glob components, use getFileStatus \n             // instead of listStatus.  This is an optimization, but it also\n             // is necessary for correctness in HDFS, since there are some\n             // special HDFS directories like .reserved and .snapshot that are\n             // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n             FileStatus childStatus \u003d getFileStatus(\n                 new Path(candidate.getPath(), component));\n             if (childStatus !\u003d null) {\n               newCandidates.add(childStatus);\n              }\n            }\n         }\n         candidates \u003d newCandidates;\n       }\n       for (FileStatus status : candidates) {\n+        // Use object equality to see if this status is the root placeholder.\n+        // See the explanation for rootPlaceholder above for more information.\n+        if (status \u003d\u003d rootPlaceholder) {\n+          status \u003d getFileStatus(rootPlaceholder.getPath());\n+          if (status \u003d\u003d null) continue;\n+        }\n         // HADOOP-3497 semantics: the user-defined filter is applied at the\n         // end, once the full path is built up.\n         if (filter.accept(status.getPath())) {\n           results.add(status);\n         }\n       }\n     }\n     /*\n      * When the input pattern \"looks\" like just a simple filename, and we\n      * can\u0027t find it, we return null rather than an empty array.\n      * This is a special case which the shell relies on.\n      *\n      * To be more precise: if there were no results, AND there were no\n      * groupings (aka brackets), and no wildcards in the input (aka stars),\n      * we return null.\n      */\n     if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n         (flattenedPatterns.size() \u003c\u003d 1)) {\n       return null;\n     }\n     return results.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] glob() throws IOException {\n    // First we get the scheme and authority of the pattern that was passed\n    // in.\n    String scheme \u003d schemeFromPath(pathPattern);\n    String authority \u003d authorityFromPath(pathPattern);\n\n    // Next we strip off everything except the pathname itself, and expand all\n    // globs.  Expansion is a process which turns \"grouping\" clauses,\n    // expressed as brackets, into separate path patterns.\n    String pathPatternString \u003d pathPattern.toUri().getPath();\n    List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n\n    // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n    // match them to entries in the filesystem.\n    ArrayList\u003cFileStatus\u003e results \u003d \n        new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n    boolean sawWildcard \u003d false;\n    for (String flatPattern : flattenedPatterns) {\n      // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n      // this prior to flattening because of patterns like {/,a}, where which\n      // path you go down influences how the path must be made absolute.\n      Path absPattern \u003d fixRelativePart(new Path(\n          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n      // Now we break the flattened, absolute pattern into path components.\n      // For example, /a/*/c would be broken into the list [a, *, c]\n      List\u003cString\u003e components \u003d\n          getPathComponents(absPattern.toUri().getPath());\n      // Starting out at the root of the filesystem, we try to match\n      // filesystem entries against pattern components.\n      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n      // To get the \"real\" FileStatus of root, we\u0027d have to do an expensive\n      // RPC to the NameNode.  So we create a placeholder FileStatus which has\n      // the correct path, but defaults for the rest of the information.\n      // Later, if it turns out we actually want the FileStatus of root, we\u0027ll\n      // replace the placeholder with a real FileStatus obtained from the\n      // NameNode.\n      FileStatus rootPlaceholder;\n      if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n          \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n        // We will skip matching the drive letter and start from listing the\n        // root of the filesystem on that drive.\n        String driveLetter \u003d components.remove(0);\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR));\n      } else {\n        rootPlaceholder \u003d new FileStatus(0, true, 0, 0, 0,\n            new Path(scheme, authority, Path.SEPARATOR));\n      }\n      candidates.add(rootPlaceholder);\n      \n      for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n          componentIdx++) {\n        ArrayList\u003cFileStatus\u003e newCandidates \u003d\n            new ArrayList\u003cFileStatus\u003e(candidates.size());\n        GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n        String component \u003d unescapePathComponent(components.get(componentIdx));\n        if (globFilter.hasPattern()) {\n          sawWildcard \u003d true;\n        }\n        if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n          // Optimization: if there are no more candidates left, stop examining \n          // the path components.  We can only do this if we\u0027ve already seen\n          // a wildcard component-- otherwise, we still need to visit all path \n          // components in case one of them is a wildcard.\n          break;\n        }\n        if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n            (!globFilter.hasPattern())) {\n          // Optimization: if this is not the terminal path component, and we \n          // are not matching against a glob, assume that it exists.  If it \n          // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n          // or the terminal path component.\n          for (FileStatus candidate : candidates) {\n            candidate.setPath(new Path(candidate.getPath(), component));\n          }\n          continue;\n        }\n        for (FileStatus candidate : candidates) {\n          if (globFilter.hasPattern()) {\n            FileStatus[] children \u003d listStatus(candidate.getPath());\n            if (children.length \u003d\u003d 1) {\n              // If we get back only one result, this could be either a listing\n              // of a directory with one entry, or it could reflect the fact\n              // that what we listed resolved to a file.\n              //\n              // Unfortunately, we can\u0027t just compare the returned paths to\n              // figure this out.  Consider the case where you have /a/b, where\n              // b is a symlink to \"..\".  In that case, listing /a/b will give\n              // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n              // incorrectly conclude that /a/b was a file and should not match\n              // /a/*/*.  So we use getFileStatus of the path we just listed to\n              // disambiguate.\n              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n                continue;\n              }\n            }\n            for (FileStatus child : children) {\n              // Set the child path based on the parent path.\n              child.setPath(new Path(candidate.getPath(),\n                      child.getPath().getName()));\n              if (globFilter.accept(child.getPath())) {\n                newCandidates.add(child);\n              }\n            }\n          } else {\n            // When dealing with non-glob components, use getFileStatus \n            // instead of listStatus.  This is an optimization, but it also\n            // is necessary for correctness in HDFS, since there are some\n            // special HDFS directories like .reserved and .snapshot that are\n            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n            FileStatus childStatus \u003d getFileStatus(\n                new Path(candidate.getPath(), component));\n            if (childStatus !\u003d null) {\n              newCandidates.add(childStatus);\n             }\n           }\n        }\n        candidates \u003d newCandidates;\n      }\n      for (FileStatus status : candidates) {\n        // Use object equality to see if this status is the root placeholder.\n        // See the explanation for rootPlaceholder above for more information.\n        if (status \u003d\u003d rootPlaceholder) {\n          status \u003d getFileStatus(rootPlaceholder.getPath());\n          if (status \u003d\u003d null) continue;\n        }\n        // HADOOP-3497 semantics: the user-defined filter is applied at the\n        // end, once the full path is built up.\n        if (filter.accept(status.getPath())) {\n          results.add(status);\n        }\n      }\n    }\n    /*\n     * When the input pattern \"looks\" like just a simple filename, and we\n     * can\u0027t find it, we return null rather than an empty array.\n     * This is a special case which the shell relies on.\n     *\n     * To be more precise: if there were no results, AND there were no\n     * groupings (aka brackets), and no wildcards in the input (aka stars),\n     * we return null.\n     */\n    if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n        (flattenedPatterns.size() \u003c\u003d 1)) {\n      return null;\n    }\n    return results.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java",
      "extendedDetails": {}
    },
    "464470e715c95fc3b832e93800d551fdb44333f1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9981. globStatus should minimize its listStatus and getFileStatus calls.  (Contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1526297 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/09/13 1:51 PM",
      "commitName": "464470e715c95fc3b832e93800d551fdb44333f1",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "18/09/13 7:09 PM",
      "commitNameOld": "1c4f4a38ca958dbb8be911b7b7d6bf57722b7514",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 6.78,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,135 @@\n   public FileStatus[] glob() throws IOException {\n     // First we get the scheme and authority of the pattern that was passed\n     // in.\n     String scheme \u003d schemeFromPath(pathPattern);\n     String authority \u003d authorityFromPath(pathPattern);\n \n     // Next we strip off everything except the pathname itself, and expand all\n     // globs.  Expansion is a process which turns \"grouping\" clauses,\n     // expressed as brackets, into separate path patterns.\n     String pathPatternString \u003d pathPattern.toUri().getPath();\n     List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n \n     // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n     // match them to entries in the filesystem.\n     ArrayList\u003cFileStatus\u003e results \u003d \n         new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n     boolean sawWildcard \u003d false;\n     for (String flatPattern : flattenedPatterns) {\n       // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n       // this prior to flattening because of patterns like {/,a}, where which\n       // path you go down influences how the path must be made absolute.\n       Path absPattern \u003d fixRelativePart(new Path(\n           flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n       // Now we break the flattened, absolute pattern into path components.\n       // For example, /a/*/c would be broken into the list [a, *, c]\n       List\u003cString\u003e components \u003d\n           getPathComponents(absPattern.toUri().getPath());\n       // Starting out at the root of the filesystem, we try to match\n       // filesystem entries against pattern components.\n       ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n       if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n           \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n         // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n         // We will skip matching the drive letter and start from listing the\n         // root of the filesystem on that drive.\n         String driveLetter \u003d components.remove(0);\n         candidates.add(new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n             authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR)));\n       } else {\n         candidates.add(new FileStatus(0, true, 0, 0, 0,\n             new Path(scheme, authority, Path.SEPARATOR)));\n       }\n       \n-      for (String component : components) {\n+      for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n+          componentIdx++) {\n         ArrayList\u003cFileStatus\u003e newCandidates \u003d\n             new ArrayList\u003cFileStatus\u003e(candidates.size());\n-        GlobFilter globFilter \u003d new GlobFilter(component);\n+        GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n+        String component \u003d unescapePathComponent(components.get(componentIdx));\n         if (globFilter.hasPattern()) {\n           sawWildcard \u003d true;\n         }\n         if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n+          // Optimization: if there are no more candidates left, stop examining \n+          // the path components.  We can only do this if we\u0027ve already seen\n+          // a wildcard component-- otherwise, we still need to visit all path \n+          // components in case one of them is a wildcard.\n           break;\n         }\n+        if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n+            (!globFilter.hasPattern())) {\n+          // Optimization: if this is not the terminal path component, and we \n+          // are not matching against a glob, assume that it exists.  If it \n+          // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n+          // or the terminal path component.\n+          for (FileStatus candidate : candidates) {\n+            candidate.setPath(new Path(candidate.getPath(), component));\n+          }\n+          continue;\n+        }\n         for (FileStatus candidate : candidates) {\n-          FileStatus resolvedCandidate \u003d candidate;\n-          if (candidate.isSymlink()) {\n-            // We have to resolve symlinks, because otherwise we don\u0027t know\n-            // whether they are directories.\n-            resolvedCandidate \u003d getFileStatus(candidate.getPath());\n-          }\n-          if (resolvedCandidate \u003d\u003d null ||\n-              resolvedCandidate.isDirectory() \u003d\u003d false) {\n-            continue;\n-          }\n-          FileStatus[] children \u003d listStatus(candidate.getPath());\n-          for (FileStatus child : children) {\n-            // Set the child path based on the parent path.\n-            // This keeps the symlinks in our path.\n-            child.setPath(new Path(candidate.getPath(),\n-                    child.getPath().getName()));\n-            if (globFilter.accept(child.getPath())) {\n-              newCandidates.add(child);\n+          if (globFilter.hasPattern()) {\n+            FileStatus[] children \u003d listStatus(candidate.getPath());\n+            if (children.length \u003d\u003d 1) {\n+              // If we get back only one result, this could be either a listing\n+              // of a directory with one entry, or it could reflect the fact\n+              // that what we listed resolved to a file.\n+              //\n+              // Unfortunately, we can\u0027t just compare the returned paths to\n+              // figure this out.  Consider the case where you have /a/b, where\n+              // b is a symlink to \"..\".  In that case, listing /a/b will give\n+              // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n+              // incorrectly conclude that /a/b was a file and should not match\n+              // /a/*/*.  So we use getFileStatus of the path we just listed to\n+              // disambiguate.\n+              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n+                continue;\n+              }\n             }\n-          }\n+            for (FileStatus child : children) {\n+              // Set the child path based on the parent path.\n+              child.setPath(new Path(candidate.getPath(),\n+                      child.getPath().getName()));\n+              if (globFilter.accept(child.getPath())) {\n+                newCandidates.add(child);\n+              }\n+            }\n+          } else {\n+            // When dealing with non-glob components, use getFileStatus \n+            // instead of listStatus.  This is an optimization, but it also\n+            // is necessary for correctness in HDFS, since there are some\n+            // special HDFS directories like .reserved and .snapshot that are\n+            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n+            FileStatus childStatus \u003d getFileStatus(\n+                new Path(candidate.getPath(), component));\n+            if (childStatus !\u003d null) {\n+              newCandidates.add(childStatus);\n+             }\n+           }\n         }\n         candidates \u003d newCandidates;\n       }\n       for (FileStatus status : candidates) {\n         // HADOOP-3497 semantics: the user-defined filter is applied at the\n         // end, once the full path is built up.\n         if (filter.accept(status.getPath())) {\n           results.add(status);\n         }\n       }\n     }\n     /*\n      * When the input pattern \"looks\" like just a simple filename, and we\n      * can\u0027t find it, we return null rather than an empty array.\n      * This is a special case which the shell relies on.\n      *\n      * To be more precise: if there were no results, AND there were no\n      * groupings (aka brackets), and no wildcards in the input (aka stars),\n      * we return null.\n      */\n     if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n         (flattenedPatterns.size() \u003c\u003d 1)) {\n       return null;\n     }\n     return results.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] glob() throws IOException {\n    // First we get the scheme and authority of the pattern that was passed\n    // in.\n    String scheme \u003d schemeFromPath(pathPattern);\n    String authority \u003d authorityFromPath(pathPattern);\n\n    // Next we strip off everything except the pathname itself, and expand all\n    // globs.  Expansion is a process which turns \"grouping\" clauses,\n    // expressed as brackets, into separate path patterns.\n    String pathPatternString \u003d pathPattern.toUri().getPath();\n    List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n\n    // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n    // match them to entries in the filesystem.\n    ArrayList\u003cFileStatus\u003e results \u003d \n        new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n    boolean sawWildcard \u003d false;\n    for (String flatPattern : flattenedPatterns) {\n      // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n      // this prior to flattening because of patterns like {/,a}, where which\n      // path you go down influences how the path must be made absolute.\n      Path absPattern \u003d fixRelativePart(new Path(\n          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n      // Now we break the flattened, absolute pattern into path components.\n      // For example, /a/*/c would be broken into the list [a, *, c]\n      List\u003cString\u003e components \u003d\n          getPathComponents(absPattern.toUri().getPath());\n      // Starting out at the root of the filesystem, we try to match\n      // filesystem entries against pattern components.\n      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n      if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n          \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n        // We will skip matching the drive letter and start from listing the\n        // root of the filesystem on that drive.\n        String driveLetter \u003d components.remove(0);\n        candidates.add(new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR)));\n      } else {\n        candidates.add(new FileStatus(0, true, 0, 0, 0,\n            new Path(scheme, authority, Path.SEPARATOR)));\n      }\n      \n      for (int componentIdx \u003d 0; componentIdx \u003c components.size();\n          componentIdx++) {\n        ArrayList\u003cFileStatus\u003e newCandidates \u003d\n            new ArrayList\u003cFileStatus\u003e(candidates.size());\n        GlobFilter globFilter \u003d new GlobFilter(components.get(componentIdx));\n        String component \u003d unescapePathComponent(components.get(componentIdx));\n        if (globFilter.hasPattern()) {\n          sawWildcard \u003d true;\n        }\n        if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n          // Optimization: if there are no more candidates left, stop examining \n          // the path components.  We can only do this if we\u0027ve already seen\n          // a wildcard component-- otherwise, we still need to visit all path \n          // components in case one of them is a wildcard.\n          break;\n        }\n        if ((componentIdx \u003c components.size() - 1) \u0026\u0026\n            (!globFilter.hasPattern())) {\n          // Optimization: if this is not the terminal path component, and we \n          // are not matching against a glob, assume that it exists.  If it \n          // doesn\u0027t exist, we\u0027ll find out later when resolving a later glob\n          // or the terminal path component.\n          for (FileStatus candidate : candidates) {\n            candidate.setPath(new Path(candidate.getPath(), component));\n          }\n          continue;\n        }\n        for (FileStatus candidate : candidates) {\n          if (globFilter.hasPattern()) {\n            FileStatus[] children \u003d listStatus(candidate.getPath());\n            if (children.length \u003d\u003d 1) {\n              // If we get back only one result, this could be either a listing\n              // of a directory with one entry, or it could reflect the fact\n              // that what we listed resolved to a file.\n              //\n              // Unfortunately, we can\u0027t just compare the returned paths to\n              // figure this out.  Consider the case where you have /a/b, where\n              // b is a symlink to \"..\".  In that case, listing /a/b will give\n              // back \"/a/b\" again.  If we just went by returned pathname, we\u0027d\n              // incorrectly conclude that /a/b was a file and should not match\n              // /a/*/*.  So we use getFileStatus of the path we just listed to\n              // disambiguate.\n              if (!getFileStatus(candidate.getPath()).isDirectory()) {\n                continue;\n              }\n            }\n            for (FileStatus child : children) {\n              // Set the child path based on the parent path.\n              child.setPath(new Path(candidate.getPath(),\n                      child.getPath().getName()));\n              if (globFilter.accept(child.getPath())) {\n                newCandidates.add(child);\n              }\n            }\n          } else {\n            // When dealing with non-glob components, use getFileStatus \n            // instead of listStatus.  This is an optimization, but it also\n            // is necessary for correctness in HDFS, since there are some\n            // special HDFS directories like .reserved and .snapshot that are\n            // not visible to listStatus, but which do exist.  (See HADOOP-9877)\n            FileStatus childStatus \u003d getFileStatus(\n                new Path(candidate.getPath(), component));\n            if (childStatus !\u003d null) {\n              newCandidates.add(childStatus);\n             }\n           }\n        }\n        candidates \u003d newCandidates;\n      }\n      for (FileStatus status : candidates) {\n        // HADOOP-3497 semantics: the user-defined filter is applied at the\n        // end, once the full path is built up.\n        if (filter.accept(status.getPath())) {\n          results.add(status);\n        }\n      }\n    }\n    /*\n     * When the input pattern \"looks\" like just a simple filename, and we\n     * can\u0027t find it, we return null rather than an empty array.\n     * This is a special case which the shell relies on.\n     *\n     * To be more precise: if there were no results, AND there were no\n     * groupings (aka brackets), and no wildcards in the input (aka stars),\n     * we return null.\n     */\n    if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n        (flattenedPatterns.size() \u003c\u003d 1)) {\n      return null;\n    }\n    return results.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java",
      "extendedDetails": {}
    },
    "efc1048ffe10695666cc70be83c2b51cab8cdf0a": {
      "type": "Ybodychange",
      "commitMessage": "Revert HADOOP-9877 because of breakage reported in HADOOP-9912\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1520713 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/13 3:57 PM",
      "commitName": "efc1048ffe10695666cc70be83c2b51cab8cdf0a",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "22/08/13 2:13 PM",
      "commitNameOld": "d1dfa5f923408fea94fe18b7886ead4573560e6a",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 15.07,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,100 @@\n   public FileStatus[] glob() throws IOException {\n     // First we get the scheme and authority of the pattern that was passed\n     // in.\n     String scheme \u003d schemeFromPath(pathPattern);\n     String authority \u003d authorityFromPath(pathPattern);\n \n     // Next we strip off everything except the pathname itself, and expand all\n     // globs.  Expansion is a process which turns \"grouping\" clauses,\n     // expressed as brackets, into separate path patterns.\n     String pathPatternString \u003d pathPattern.toUri().getPath();\n     List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n \n     // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n     // match them to entries in the filesystem.\n     ArrayList\u003cFileStatus\u003e results \u003d \n         new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n     boolean sawWildcard \u003d false;\n     for (String flatPattern : flattenedPatterns) {\n       // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n       // this prior to flattening because of patterns like {/,a}, where which\n       // path you go down influences how the path must be made absolute.\n       Path absPattern \u003d fixRelativePart(new Path(\n           flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n       // Now we break the flattened, absolute pattern into path components.\n       // For example, /a/*/c would be broken into the list [a, *, c]\n       List\u003cString\u003e components \u003d\n           getPathComponents(absPattern.toUri().getPath());\n       // Starting out at the root of the filesystem, we try to match\n       // filesystem entries against pattern components.\n       ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n       if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n           \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n         // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n         // We will skip matching the drive letter and start from listing the\n         // root of the filesystem on that drive.\n         String driveLetter \u003d components.remove(0);\n         candidates.add(new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n             authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR)));\n       } else {\n         candidates.add(new FileStatus(0, true, 0, 0, 0,\n             new Path(scheme, authority, Path.SEPARATOR)));\n       }\n       \n       for (String component : components) {\n         ArrayList\u003cFileStatus\u003e newCandidates \u003d\n             new ArrayList\u003cFileStatus\u003e(candidates.size());\n         GlobFilter globFilter \u003d new GlobFilter(component);\n         if (globFilter.hasPattern()) {\n           sawWildcard \u003d true;\n         }\n         if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n           break;\n         }\n         for (FileStatus candidate : candidates) {\n           FileStatus resolvedCandidate \u003d candidate;\n           if (candidate.isSymlink()) {\n             // We have to resolve symlinks, because otherwise we don\u0027t know\n             // whether they are directories.\n             resolvedCandidate \u003d getFileStatus(candidate.getPath());\n           }\n           if (resolvedCandidate \u003d\u003d null ||\n               resolvedCandidate.isDirectory() \u003d\u003d false) {\n             continue;\n           }\n-          // For components without pattern, we get its FileStatus directly\n-          // using getFileLinkStatus for two reasons:\n-          // 1. It should be faster to only get FileStatus needed rather than\n-          //    get all children.\n-          // 2. Some special filesystem directories (e.g. HDFS snapshot\n-          //    directories) are not returned by listStatus, but do exist if\n-          //    checked explicitly via getFileLinkStatus.\n-          if (globFilter.hasPattern()) {\n-            FileStatus[] children \u003d listStatus(candidate.getPath());\n-            for (FileStatus child : children) {\n-              // Set the child path based on the parent path.\n-              // This keeps the symlinks in our path.\n-              child.setPath(new Path(candidate.getPath(),\n-                      child.getPath().getName()));\n-              if (globFilter.accept(child.getPath())) {\n-                newCandidates.add(child);\n-              }\n-            }\n-          } else {\n-            Path p \u003d new Path(candidate.getPath(), unquotePathComponent(component));\n-            FileStatus s \u003d getFileLinkStatus(p);\n-            if (s !\u003d null) {\n-              s.setPath(p);\n-              newCandidates.add(s);\n+          FileStatus[] children \u003d listStatus(candidate.getPath());\n+          for (FileStatus child : children) {\n+            // Set the child path based on the parent path.\n+            // This keeps the symlinks in our path.\n+            child.setPath(new Path(candidate.getPath(),\n+                    child.getPath().getName()));\n+            if (globFilter.accept(child.getPath())) {\n+              newCandidates.add(child);\n             }\n           }\n         }\n         candidates \u003d newCandidates;\n       }\n       for (FileStatus status : candidates) {\n         // HADOOP-3497 semantics: the user-defined filter is applied at the\n         // end, once the full path is built up.\n         if (filter.accept(status.getPath())) {\n           results.add(status);\n         }\n       }\n     }\n     /*\n      * When the input pattern \"looks\" like just a simple filename, and we\n      * can\u0027t find it, we return null rather than an empty array.\n      * This is a special case which the shell relies on.\n      *\n      * To be more precise: if there were no results, AND there were no\n      * groupings (aka brackets), and no wildcards in the input (aka stars),\n      * we return null.\n      */\n     if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n         (flattenedPatterns.size() \u003c\u003d 1)) {\n       return null;\n     }\n     return results.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] glob() throws IOException {\n    // First we get the scheme and authority of the pattern that was passed\n    // in.\n    String scheme \u003d schemeFromPath(pathPattern);\n    String authority \u003d authorityFromPath(pathPattern);\n\n    // Next we strip off everything except the pathname itself, and expand all\n    // globs.  Expansion is a process which turns \"grouping\" clauses,\n    // expressed as brackets, into separate path patterns.\n    String pathPatternString \u003d pathPattern.toUri().getPath();\n    List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n\n    // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n    // match them to entries in the filesystem.\n    ArrayList\u003cFileStatus\u003e results \u003d \n        new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n    boolean sawWildcard \u003d false;\n    for (String flatPattern : flattenedPatterns) {\n      // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n      // this prior to flattening because of patterns like {/,a}, where which\n      // path you go down influences how the path must be made absolute.\n      Path absPattern \u003d fixRelativePart(new Path(\n          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n      // Now we break the flattened, absolute pattern into path components.\n      // For example, /a/*/c would be broken into the list [a, *, c]\n      List\u003cString\u003e components \u003d\n          getPathComponents(absPattern.toUri().getPath());\n      // Starting out at the root of the filesystem, we try to match\n      // filesystem entries against pattern components.\n      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n      if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n          \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n        // We will skip matching the drive letter and start from listing the\n        // root of the filesystem on that drive.\n        String driveLetter \u003d components.remove(0);\n        candidates.add(new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR)));\n      } else {\n        candidates.add(new FileStatus(0, true, 0, 0, 0,\n            new Path(scheme, authority, Path.SEPARATOR)));\n      }\n      \n      for (String component : components) {\n        ArrayList\u003cFileStatus\u003e newCandidates \u003d\n            new ArrayList\u003cFileStatus\u003e(candidates.size());\n        GlobFilter globFilter \u003d new GlobFilter(component);\n        if (globFilter.hasPattern()) {\n          sawWildcard \u003d true;\n        }\n        if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n          break;\n        }\n        for (FileStatus candidate : candidates) {\n          FileStatus resolvedCandidate \u003d candidate;\n          if (candidate.isSymlink()) {\n            // We have to resolve symlinks, because otherwise we don\u0027t know\n            // whether they are directories.\n            resolvedCandidate \u003d getFileStatus(candidate.getPath());\n          }\n          if (resolvedCandidate \u003d\u003d null ||\n              resolvedCandidate.isDirectory() \u003d\u003d false) {\n            continue;\n          }\n          FileStatus[] children \u003d listStatus(candidate.getPath());\n          for (FileStatus child : children) {\n            // Set the child path based on the parent path.\n            // This keeps the symlinks in our path.\n            child.setPath(new Path(candidate.getPath(),\n                    child.getPath().getName()));\n            if (globFilter.accept(child.getPath())) {\n              newCandidates.add(child);\n            }\n          }\n        }\n        candidates \u003d newCandidates;\n      }\n      for (FileStatus status : candidates) {\n        // HADOOP-3497 semantics: the user-defined filter is applied at the\n        // end, once the full path is built up.\n        if (filter.accept(status.getPath())) {\n          results.add(status);\n        }\n      }\n    }\n    /*\n     * When the input pattern \"looks\" like just a simple filename, and we\n     * can\u0027t find it, we return null rather than an empty array.\n     * This is a special case which the shell relies on.\n     *\n     * To be more precise: if there were no results, AND there were no\n     * groupings (aka brackets), and no wildcards in the input (aka stars),\n     * we return null.\n     */\n    if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n        (flattenedPatterns.size() \u003c\u003d 1)) {\n      return null;\n    }\n    return results.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java",
      "extendedDetails": {}
    },
    "d1dfa5f923408fea94fe18b7886ead4573560e6a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9887. globStatus does not correctly handle paths starting with a drive spec on Windows. Contributed by Chuan Liu.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1516608 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/08/13 2:13 PM",
      "commitName": "d1dfa5f923408fea94fe18b7886ead4573560e6a",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "20/08/13 1:19 PM",
      "commitNameOld": "b7a6c5ebb48275b3512bdbf201e0e8873b6d77b6",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 2.04,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,116 @@\n   public FileStatus[] glob() throws IOException {\n     // First we get the scheme and authority of the pattern that was passed\n     // in.\n     String scheme \u003d schemeFromPath(pathPattern);\n     String authority \u003d authorityFromPath(pathPattern);\n \n     // Next we strip off everything except the pathname itself, and expand all\n     // globs.  Expansion is a process which turns \"grouping\" clauses,\n     // expressed as brackets, into separate path patterns.\n     String pathPatternString \u003d pathPattern.toUri().getPath();\n     List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n \n     // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n     // match them to entries in the filesystem.\n     ArrayList\u003cFileStatus\u003e results \u003d \n         new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n     boolean sawWildcard \u003d false;\n     for (String flatPattern : flattenedPatterns) {\n       // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n       // this prior to flattening because of patterns like {/,a}, where which\n       // path you go down influences how the path must be made absolute.\n-      Path absPattern \u003d\n-          fixRelativePart(new Path(flatPattern .isEmpty() ? \".\" : flatPattern ));\n+      Path absPattern \u003d fixRelativePart(new Path(\n+          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n       // Now we break the flattened, absolute pattern into path components.\n       // For example, /a/*/c would be broken into the list [a, *, c]\n       List\u003cString\u003e components \u003d\n           getPathComponents(absPattern.toUri().getPath());\n       // Starting out at the root of the filesystem, we try to match\n       // filesystem entries against pattern components.\n       ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n-      candidates.add(new FileStatus(0, true, 0, 0, 0,\n-          new Path(scheme, authority, \"/\")));\n-\n+      if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n+          \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n+        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n+        // We will skip matching the drive letter and start from listing the\n+        // root of the filesystem on that drive.\n+        String driveLetter \u003d components.remove(0);\n+        candidates.add(new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n+            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR)));\n+      } else {\n+        candidates.add(new FileStatus(0, true, 0, 0, 0,\n+            new Path(scheme, authority, Path.SEPARATOR)));\n+      }\n+      \n       for (String component : components) {\n         ArrayList\u003cFileStatus\u003e newCandidates \u003d\n             new ArrayList\u003cFileStatus\u003e(candidates.size());\n         GlobFilter globFilter \u003d new GlobFilter(component);\n         if (globFilter.hasPattern()) {\n           sawWildcard \u003d true;\n         }\n         if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n           break;\n         }\n         for (FileStatus candidate : candidates) {\n           FileStatus resolvedCandidate \u003d candidate;\n           if (candidate.isSymlink()) {\n             // We have to resolve symlinks, because otherwise we don\u0027t know\n             // whether they are directories.\n             resolvedCandidate \u003d getFileStatus(candidate.getPath());\n           }\n           if (resolvedCandidate \u003d\u003d null ||\n               resolvedCandidate.isDirectory() \u003d\u003d false) {\n             continue;\n           }\n           // For components without pattern, we get its FileStatus directly\n           // using getFileLinkStatus for two reasons:\n           // 1. It should be faster to only get FileStatus needed rather than\n           //    get all children.\n           // 2. Some special filesystem directories (e.g. HDFS snapshot\n           //    directories) are not returned by listStatus, but do exist if\n           //    checked explicitly via getFileLinkStatus.\n           if (globFilter.hasPattern()) {\n             FileStatus[] children \u003d listStatus(candidate.getPath());\n             for (FileStatus child : children) {\n               // Set the child path based on the parent path.\n               // This keeps the symlinks in our path.\n               child.setPath(new Path(candidate.getPath(),\n                       child.getPath().getName()));\n               if (globFilter.accept(child.getPath())) {\n                 newCandidates.add(child);\n               }\n             }\n           } else {\n             Path p \u003d new Path(candidate.getPath(), unquotePathComponent(component));\n             FileStatus s \u003d getFileLinkStatus(p);\n             if (s !\u003d null) {\n               s.setPath(p);\n               newCandidates.add(s);\n             }\n           }\n         }\n         candidates \u003d newCandidates;\n       }\n       for (FileStatus status : candidates) {\n         // HADOOP-3497 semantics: the user-defined filter is applied at the\n         // end, once the full path is built up.\n         if (filter.accept(status.getPath())) {\n           results.add(status);\n         }\n       }\n     }\n     /*\n      * When the input pattern \"looks\" like just a simple filename, and we\n      * can\u0027t find it, we return null rather than an empty array.\n      * This is a special case which the shell relies on.\n      *\n      * To be more precise: if there were no results, AND there were no\n      * groupings (aka brackets), and no wildcards in the input (aka stars),\n      * we return null.\n      */\n     if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n         (flattenedPatterns.size() \u003c\u003d 1)) {\n       return null;\n     }\n     return results.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] glob() throws IOException {\n    // First we get the scheme and authority of the pattern that was passed\n    // in.\n    String scheme \u003d schemeFromPath(pathPattern);\n    String authority \u003d authorityFromPath(pathPattern);\n\n    // Next we strip off everything except the pathname itself, and expand all\n    // globs.  Expansion is a process which turns \"grouping\" clauses,\n    // expressed as brackets, into separate path patterns.\n    String pathPatternString \u003d pathPattern.toUri().getPath();\n    List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n\n    // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n    // match them to entries in the filesystem.\n    ArrayList\u003cFileStatus\u003e results \u003d \n        new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n    boolean sawWildcard \u003d false;\n    for (String flatPattern : flattenedPatterns) {\n      // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n      // this prior to flattening because of patterns like {/,a}, where which\n      // path you go down influences how the path must be made absolute.\n      Path absPattern \u003d fixRelativePart(new Path(\n          flatPattern.isEmpty() ? Path.CUR_DIR : flatPattern));\n      // Now we break the flattened, absolute pattern into path components.\n      // For example, /a/*/c would be broken into the list [a, *, c]\n      List\u003cString\u003e components \u003d\n          getPathComponents(absPattern.toUri().getPath());\n      // Starting out at the root of the filesystem, we try to match\n      // filesystem entries against pattern components.\n      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n      if (Path.WINDOWS \u0026\u0026 !components.isEmpty()\n          \u0026\u0026 Path.isWindowsAbsolutePath(absPattern.toUri().getPath(), true)) {\n        // On Windows the path could begin with a drive letter, e.g. /E:/foo.\n        // We will skip matching the drive letter and start from listing the\n        // root of the filesystem on that drive.\n        String driveLetter \u003d components.remove(0);\n        candidates.add(new FileStatus(0, true, 0, 0, 0, new Path(scheme,\n            authority, Path.SEPARATOR + driveLetter + Path.SEPARATOR)));\n      } else {\n        candidates.add(new FileStatus(0, true, 0, 0, 0,\n            new Path(scheme, authority, Path.SEPARATOR)));\n      }\n      \n      for (String component : components) {\n        ArrayList\u003cFileStatus\u003e newCandidates \u003d\n            new ArrayList\u003cFileStatus\u003e(candidates.size());\n        GlobFilter globFilter \u003d new GlobFilter(component);\n        if (globFilter.hasPattern()) {\n          sawWildcard \u003d true;\n        }\n        if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n          break;\n        }\n        for (FileStatus candidate : candidates) {\n          FileStatus resolvedCandidate \u003d candidate;\n          if (candidate.isSymlink()) {\n            // We have to resolve symlinks, because otherwise we don\u0027t know\n            // whether they are directories.\n            resolvedCandidate \u003d getFileStatus(candidate.getPath());\n          }\n          if (resolvedCandidate \u003d\u003d null ||\n              resolvedCandidate.isDirectory() \u003d\u003d false) {\n            continue;\n          }\n          // For components without pattern, we get its FileStatus directly\n          // using getFileLinkStatus for two reasons:\n          // 1. It should be faster to only get FileStatus needed rather than\n          //    get all children.\n          // 2. Some special filesystem directories (e.g. HDFS snapshot\n          //    directories) are not returned by listStatus, but do exist if\n          //    checked explicitly via getFileLinkStatus.\n          if (globFilter.hasPattern()) {\n            FileStatus[] children \u003d listStatus(candidate.getPath());\n            for (FileStatus child : children) {\n              // Set the child path based on the parent path.\n              // This keeps the symlinks in our path.\n              child.setPath(new Path(candidate.getPath(),\n                      child.getPath().getName()));\n              if (globFilter.accept(child.getPath())) {\n                newCandidates.add(child);\n              }\n            }\n          } else {\n            Path p \u003d new Path(candidate.getPath(), unquotePathComponent(component));\n            FileStatus s \u003d getFileLinkStatus(p);\n            if (s !\u003d null) {\n              s.setPath(p);\n              newCandidates.add(s);\n            }\n          }\n        }\n        candidates \u003d newCandidates;\n      }\n      for (FileStatus status : candidates) {\n        // HADOOP-3497 semantics: the user-defined filter is applied at the\n        // end, once the full path is built up.\n        if (filter.accept(status.getPath())) {\n          results.add(status);\n        }\n      }\n    }\n    /*\n     * When the input pattern \"looks\" like just a simple filename, and we\n     * can\u0027t find it, we return null rather than an empty array.\n     * This is a special case which the shell relies on.\n     *\n     * To be more precise: if there were no results, AND there were no\n     * groupings (aka brackets), and no wildcards in the input (aka stars),\n     * we return null.\n     */\n    if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n        (flattenedPatterns.size() \u003c\u003d 1)) {\n      return null;\n    }\n    return results.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java",
      "extendedDetails": {}
    },
    "b7a6c5ebb48275b3512bdbf201e0e8873b6d77b6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9877. Fix listing of snapshot directories in globStatus. (Binglin Chang via Andrew Wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1515955 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/08/13 1:19 PM",
      "commitName": "b7a6c5ebb48275b3512bdbf201e0e8873b6d77b6",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "15/08/13 4:05 PM",
      "commitNameOld": "8df7e7deecad2b8131d67a1916b1ec4c9f7bc633",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 4.88,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,106 @@\n   public FileStatus[] glob() throws IOException {\n     // First we get the scheme and authority of the pattern that was passed\n     // in.\n     String scheme \u003d schemeFromPath(pathPattern);\n     String authority \u003d authorityFromPath(pathPattern);\n \n     // Next we strip off everything except the pathname itself, and expand all\n     // globs.  Expansion is a process which turns \"grouping\" clauses,\n     // expressed as brackets, into separate path patterns.\n     String pathPatternString \u003d pathPattern.toUri().getPath();\n     List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n \n     // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n     // match them to entries in the filesystem.\n     ArrayList\u003cFileStatus\u003e results \u003d \n         new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n     boolean sawWildcard \u003d false;\n     for (String flatPattern : flattenedPatterns) {\n       // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n       // this prior to flattening because of patterns like {/,a}, where which\n       // path you go down influences how the path must be made absolute.\n       Path absPattern \u003d\n           fixRelativePart(new Path(flatPattern .isEmpty() ? \".\" : flatPattern ));\n       // Now we break the flattened, absolute pattern into path components.\n       // For example, /a/*/c would be broken into the list [a, *, c]\n       List\u003cString\u003e components \u003d\n           getPathComponents(absPattern.toUri().getPath());\n       // Starting out at the root of the filesystem, we try to match\n       // filesystem entries against pattern components.\n       ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n       candidates.add(new FileStatus(0, true, 0, 0, 0,\n           new Path(scheme, authority, \"/\")));\n \n       for (String component : components) {\n         ArrayList\u003cFileStatus\u003e newCandidates \u003d\n             new ArrayList\u003cFileStatus\u003e(candidates.size());\n         GlobFilter globFilter \u003d new GlobFilter(component);\n         if (globFilter.hasPattern()) {\n           sawWildcard \u003d true;\n         }\n         if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n           break;\n         }\n         for (FileStatus candidate : candidates) {\n           FileStatus resolvedCandidate \u003d candidate;\n           if (candidate.isSymlink()) {\n             // We have to resolve symlinks, because otherwise we don\u0027t know\n             // whether they are directories.\n             resolvedCandidate \u003d getFileStatus(candidate.getPath());\n           }\n           if (resolvedCandidate \u003d\u003d null ||\n               resolvedCandidate.isDirectory() \u003d\u003d false) {\n             continue;\n           }\n-          FileStatus[] children \u003d listStatus(candidate.getPath());\n-          for (FileStatus child : children) {\n-            // Set the child path based on the parent path.\n-            // This keeps the symlinks in our path.\n-            child.setPath(new Path(candidate.getPath(),\n-                    child.getPath().getName()));\n-            if (globFilter.accept(child.getPath())) {\n-              newCandidates.add(child);\n+          // For components without pattern, we get its FileStatus directly\n+          // using getFileLinkStatus for two reasons:\n+          // 1. It should be faster to only get FileStatus needed rather than\n+          //    get all children.\n+          // 2. Some special filesystem directories (e.g. HDFS snapshot\n+          //    directories) are not returned by listStatus, but do exist if\n+          //    checked explicitly via getFileLinkStatus.\n+          if (globFilter.hasPattern()) {\n+            FileStatus[] children \u003d listStatus(candidate.getPath());\n+            for (FileStatus child : children) {\n+              // Set the child path based on the parent path.\n+              // This keeps the symlinks in our path.\n+              child.setPath(new Path(candidate.getPath(),\n+                      child.getPath().getName()));\n+              if (globFilter.accept(child.getPath())) {\n+                newCandidates.add(child);\n+              }\n+            }\n+          } else {\n+            Path p \u003d new Path(candidate.getPath(), unquotePathComponent(component));\n+            FileStatus s \u003d getFileLinkStatus(p);\n+            if (s !\u003d null) {\n+              s.setPath(p);\n+              newCandidates.add(s);\n             }\n           }\n         }\n         candidates \u003d newCandidates;\n       }\n       for (FileStatus status : candidates) {\n         // HADOOP-3497 semantics: the user-defined filter is applied at the\n         // end, once the full path is built up.\n         if (filter.accept(status.getPath())) {\n           results.add(status);\n         }\n       }\n     }\n     /*\n      * When the input pattern \"looks\" like just a simple filename, and we\n      * can\u0027t find it, we return null rather than an empty array.\n      * This is a special case which the shell relies on.\n      *\n      * To be more precise: if there were no results, AND there were no\n      * groupings (aka brackets), and no wildcards in the input (aka stars),\n      * we return null.\n      */\n     if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n         (flattenedPatterns.size() \u003c\u003d 1)) {\n       return null;\n     }\n     return results.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] glob() throws IOException {\n    // First we get the scheme and authority of the pattern that was passed\n    // in.\n    String scheme \u003d schemeFromPath(pathPattern);\n    String authority \u003d authorityFromPath(pathPattern);\n\n    // Next we strip off everything except the pathname itself, and expand all\n    // globs.  Expansion is a process which turns \"grouping\" clauses,\n    // expressed as brackets, into separate path patterns.\n    String pathPatternString \u003d pathPattern.toUri().getPath();\n    List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n\n    // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n    // match them to entries in the filesystem.\n    ArrayList\u003cFileStatus\u003e results \u003d \n        new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n    boolean sawWildcard \u003d false;\n    for (String flatPattern : flattenedPatterns) {\n      // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n      // this prior to flattening because of patterns like {/,a}, where which\n      // path you go down influences how the path must be made absolute.\n      Path absPattern \u003d\n          fixRelativePart(new Path(flatPattern .isEmpty() ? \".\" : flatPattern ));\n      // Now we break the flattened, absolute pattern into path components.\n      // For example, /a/*/c would be broken into the list [a, *, c]\n      List\u003cString\u003e components \u003d\n          getPathComponents(absPattern.toUri().getPath());\n      // Starting out at the root of the filesystem, we try to match\n      // filesystem entries against pattern components.\n      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n      candidates.add(new FileStatus(0, true, 0, 0, 0,\n          new Path(scheme, authority, \"/\")));\n\n      for (String component : components) {\n        ArrayList\u003cFileStatus\u003e newCandidates \u003d\n            new ArrayList\u003cFileStatus\u003e(candidates.size());\n        GlobFilter globFilter \u003d new GlobFilter(component);\n        if (globFilter.hasPattern()) {\n          sawWildcard \u003d true;\n        }\n        if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n          break;\n        }\n        for (FileStatus candidate : candidates) {\n          FileStatus resolvedCandidate \u003d candidate;\n          if (candidate.isSymlink()) {\n            // We have to resolve symlinks, because otherwise we don\u0027t know\n            // whether they are directories.\n            resolvedCandidate \u003d getFileStatus(candidate.getPath());\n          }\n          if (resolvedCandidate \u003d\u003d null ||\n              resolvedCandidate.isDirectory() \u003d\u003d false) {\n            continue;\n          }\n          // For components without pattern, we get its FileStatus directly\n          // using getFileLinkStatus for two reasons:\n          // 1. It should be faster to only get FileStatus needed rather than\n          //    get all children.\n          // 2. Some special filesystem directories (e.g. HDFS snapshot\n          //    directories) are not returned by listStatus, but do exist if\n          //    checked explicitly via getFileLinkStatus.\n          if (globFilter.hasPattern()) {\n            FileStatus[] children \u003d listStatus(candidate.getPath());\n            for (FileStatus child : children) {\n              // Set the child path based on the parent path.\n              // This keeps the symlinks in our path.\n              child.setPath(new Path(candidate.getPath(),\n                      child.getPath().getName()));\n              if (globFilter.accept(child.getPath())) {\n                newCandidates.add(child);\n              }\n            }\n          } else {\n            Path p \u003d new Path(candidate.getPath(), unquotePathComponent(component));\n            FileStatus s \u003d getFileLinkStatus(p);\n            if (s !\u003d null) {\n              s.setPath(p);\n              newCandidates.add(s);\n            }\n          }\n        }\n        candidates \u003d newCandidates;\n      }\n      for (FileStatus status : candidates) {\n        // HADOOP-3497 semantics: the user-defined filter is applied at the\n        // end, once the full path is built up.\n        if (filter.accept(status.getPath())) {\n          results.add(status);\n        }\n      }\n    }\n    /*\n     * When the input pattern \"looks\" like just a simple filename, and we\n     * can\u0027t find it, we return null rather than an empty array.\n     * This is a special case which the shell relies on.\n     *\n     * To be more precise: if there were no results, AND there were no\n     * groupings (aka brackets), and no wildcards in the input (aka stars),\n     * we return null.\n     */\n    if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n        (flattenedPatterns.size() \u003c\u003d 1)) {\n      return null;\n    }\n    return results.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java",
      "extendedDetails": {}
    },
    "95f9a515aac3c19e14a39539f490203f5867dcc5": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9817. FileSystem#globStatus and FileContext#globStatus need to work with symlinks. (Colin Patrick McCabe via Andrew Wang)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1510807 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/08/13 4:28 PM",
      "commitName": "95f9a515aac3c19e14a39539f490203f5867dcc5",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,90 @@\n+  public FileStatus[] glob() throws IOException {\n+    // First we get the scheme and authority of the pattern that was passed\n+    // in.\n+    String scheme \u003d schemeFromPath(pathPattern);\n+    String authority \u003d authorityFromPath(pathPattern);\n+\n+    // Next we strip off everything except the pathname itself, and expand all\n+    // globs.  Expansion is a process which turns \"grouping\" clauses,\n+    // expressed as brackets, into separate path patterns.\n+    String pathPatternString \u003d pathPattern.toUri().getPath();\n+    List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n+\n+    // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n+    // match them to entries in the filesystem.\n+    ArrayList\u003cFileStatus\u003e results \u003d \n+        new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n+    boolean sawWildcard \u003d false;\n+    for (String flatPattern : flattenedPatterns) {\n+      // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n+      // this prior to flattening because of patterns like {/,a}, where which\n+      // path you go down influences how the path must be made absolute.\n+      Path absPattern \u003d\n+          fixRelativePart(new Path(flatPattern .isEmpty() ? \".\" : flatPattern ));\n+      // Now we break the flattened, absolute pattern into path components.\n+      // For example, /a/*/c would be broken into the list [a, *, c]\n+      List\u003cString\u003e components \u003d\n+          getPathComponents(absPattern.toUri().getPath());\n+      // Starting out at the root of the filesystem, we try to match\n+      // filesystem entries against pattern components.\n+      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n+      candidates.add(new FileStatus(0, true, 0, 0, 0,\n+          new Path(scheme, authority, \"/\")));\n+\n+      for (String component : components) {\n+        ArrayList\u003cFileStatus\u003e newCandidates \u003d\n+            new ArrayList\u003cFileStatus\u003e(candidates.size());\n+        GlobFilter globFilter \u003d new GlobFilter(component);\n+        if (globFilter.hasPattern()) {\n+          sawWildcard \u003d true;\n+        }\n+        if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n+          break;\n+        }\n+        for (FileStatus candidate : candidates) {\n+          FileStatus resolvedCandidate \u003d candidate;\n+          if (candidate.isSymlink()) {\n+            // We have to resolve symlinks, because otherwise we don\u0027t know\n+            // whether they are directories.\n+            resolvedCandidate \u003d getFileStatus(candidate.getPath());\n+          }\n+          if (resolvedCandidate \u003d\u003d null ||\n+              resolvedCandidate.isDirectory() \u003d\u003d false) {\n+            continue;\n+          }\n+          FileStatus[] children \u003d listStatus(candidate.getPath());\n+          for (FileStatus child : children) {\n+            // Set the child path based on the parent path.\n+            // This keeps the symlinks in our path.\n+            child.setPath(new Path(candidate.getPath(),\n+                    child.getPath().getName()));\n+            if (globFilter.accept(child.getPath())) {\n+              newCandidates.add(child);\n+            }\n+          }\n+        }\n+        candidates \u003d newCandidates;\n+      }\n+      for (FileStatus status : candidates) {\n+        // HADOOP-3497 semantics: the user-defined filter is applied at the\n+        // end, once the full path is built up.\n+        if (filter.accept(status.getPath())) {\n+          results.add(status);\n+        }\n+      }\n+    }\n+    /*\n+     * When the input pattern \"looks\" like just a simple filename, and we\n+     * can\u0027t find it, we return null rather than an empty array.\n+     * This is a special case which the shell relies on.\n+     *\n+     * To be more precise: if there were no results, AND there were no\n+     * groupings (aka brackets), and no wildcards in the input (aka stars),\n+     * we return null.\n+     */\n+    if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n+        (flattenedPatterns.size() \u003c\u003d 1)) {\n+      return null;\n+    }\n+    return results.toArray(new FileStatus[0]);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] glob() throws IOException {\n    // First we get the scheme and authority of the pattern that was passed\n    // in.\n    String scheme \u003d schemeFromPath(pathPattern);\n    String authority \u003d authorityFromPath(pathPattern);\n\n    // Next we strip off everything except the pathname itself, and expand all\n    // globs.  Expansion is a process which turns \"grouping\" clauses,\n    // expressed as brackets, into separate path patterns.\n    String pathPatternString \u003d pathPattern.toUri().getPath();\n    List\u003cString\u003e flattenedPatterns \u003d GlobExpander.expand(pathPatternString);\n\n    // Now loop over all flattened patterns.  In every case, we\u0027ll be trying to\n    // match them to entries in the filesystem.\n    ArrayList\u003cFileStatus\u003e results \u003d \n        new ArrayList\u003cFileStatus\u003e(flattenedPatterns.size());\n    boolean sawWildcard \u003d false;\n    for (String flatPattern : flattenedPatterns) {\n      // Get the absolute path for this flattened pattern.  We couldn\u0027t do \n      // this prior to flattening because of patterns like {/,a}, where which\n      // path you go down influences how the path must be made absolute.\n      Path absPattern \u003d\n          fixRelativePart(new Path(flatPattern .isEmpty() ? \".\" : flatPattern ));\n      // Now we break the flattened, absolute pattern into path components.\n      // For example, /a/*/c would be broken into the list [a, *, c]\n      List\u003cString\u003e components \u003d\n          getPathComponents(absPattern.toUri().getPath());\n      // Starting out at the root of the filesystem, we try to match\n      // filesystem entries against pattern components.\n      ArrayList\u003cFileStatus\u003e candidates \u003d new ArrayList\u003cFileStatus\u003e(1);\n      candidates.add(new FileStatus(0, true, 0, 0, 0,\n          new Path(scheme, authority, \"/\")));\n\n      for (String component : components) {\n        ArrayList\u003cFileStatus\u003e newCandidates \u003d\n            new ArrayList\u003cFileStatus\u003e(candidates.size());\n        GlobFilter globFilter \u003d new GlobFilter(component);\n        if (globFilter.hasPattern()) {\n          sawWildcard \u003d true;\n        }\n        if (candidates.isEmpty() \u0026\u0026 sawWildcard) {\n          break;\n        }\n        for (FileStatus candidate : candidates) {\n          FileStatus resolvedCandidate \u003d candidate;\n          if (candidate.isSymlink()) {\n            // We have to resolve symlinks, because otherwise we don\u0027t know\n            // whether they are directories.\n            resolvedCandidate \u003d getFileStatus(candidate.getPath());\n          }\n          if (resolvedCandidate \u003d\u003d null ||\n              resolvedCandidate.isDirectory() \u003d\u003d false) {\n            continue;\n          }\n          FileStatus[] children \u003d listStatus(candidate.getPath());\n          for (FileStatus child : children) {\n            // Set the child path based on the parent path.\n            // This keeps the symlinks in our path.\n            child.setPath(new Path(candidate.getPath(),\n                    child.getPath().getName()));\n            if (globFilter.accept(child.getPath())) {\n              newCandidates.add(child);\n            }\n          }\n        }\n        candidates \u003d newCandidates;\n      }\n      for (FileStatus status : candidates) {\n        // HADOOP-3497 semantics: the user-defined filter is applied at the\n        // end, once the full path is built up.\n        if (filter.accept(status.getPath())) {\n          results.add(status);\n        }\n      }\n    }\n    /*\n     * When the input pattern \"looks\" like just a simple filename, and we\n     * can\u0027t find it, we return null rather than an empty array.\n     * This is a special case which the shell relies on.\n     *\n     * To be more precise: if there were no results, AND there were no\n     * groupings (aka brackets), and no wildcards in the input (aka stars),\n     * we return null.\n     */\n    if ((!sawWildcard) \u0026\u0026 results.isEmpty() \u0026\u0026\n        (flattenedPatterns.size() \u003c\u003d 1)) {\n      return null;\n    }\n    return results.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/Globber.java"
    }
  }
}