{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Dispatcher.java",
  "functionName": "dispatchBlocks",
  "functionId": "dispatchBlocks",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
  "functionStartLine": 932,
  "functionEndLine": 994,
  "numCommitsSeen": 201,
  "timeTaken": 13561,
  "changeHistory": [
    "b2cc8b6b4a78f31cdd937dc4d1a2255f80c5881e",
    "c966a3837af1c1a1c4a441f491b0d76d5c9e5d78",
    "28eb2aabebd15c15a357d86e23ca407d3c85211c",
    "49a09179e3fadae090126261be0a7fe0aa48798e",
    "f6367c5f44a88cb5eb7edffb015b10b657504a61",
    "58db263e93daf08280e6a586a10cebd6122cf72a",
    "7ecbfd44aa57f5f54c214b7fdedda2500be76f51",
    "b56daff6a186599764b046248565918b894ec116",
    "673280df24f0228bf01777035ceeab8807da8c40",
    "d1dab6cc63abf5d44533ad9b39e32c582327627b",
    "5d5aae0694bc27df5b9fa50819854cd3050a8658",
    "e60673697d5046c29c52bbabdfe80506f99773e4",
    "c3cf331dc91e2beef2afeed11105084843b02858",
    "b8597e6a10b2e8df1bee4e8ce0c8be345f7e007d",
    "1ba58e2e2c7778d7c44ba6cd72ac4aa0f288ded8",
    "be5509c53743a0beddda3f5798e72b919e797bd0",
    "eae2a304624ee6caaa8591999752be2bba2b89e0",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "b2cc8b6b4a78f31cdd937dc4d1a2255f80c5881e": "Ymultichange(Yparameterchange,Ybodychange)",
    "c966a3837af1c1a1c4a441f491b0d76d5c9e5d78": "Ybodychange",
    "28eb2aabebd15c15a357d86e23ca407d3c85211c": "Ymultichange(Yparameterchange,Ybodychange)",
    "49a09179e3fadae090126261be0a7fe0aa48798e": "Ybodychange",
    "f6367c5f44a88cb5eb7edffb015b10b657504a61": "Ybodychange",
    "58db263e93daf08280e6a586a10cebd6122cf72a": "Ybodychange",
    "7ecbfd44aa57f5f54c214b7fdedda2500be76f51": "Ybodychange",
    "b56daff6a186599764b046248565918b894ec116": "Ybodychange",
    "673280df24f0228bf01777035ceeab8807da8c40": "Ybodychange",
    "d1dab6cc63abf5d44533ad9b39e32c582327627b": "Ybodychange",
    "5d5aae0694bc27df5b9fa50819854cd3050a8658": "Ybodychange",
    "e60673697d5046c29c52bbabdfe80506f99773e4": "Ybodychange",
    "c3cf331dc91e2beef2afeed11105084843b02858": "Ymultichange(Ymovefromfile,Ybodychange)",
    "b8597e6a10b2e8df1bee4e8ce0c8be345f7e007d": "Ybodychange",
    "1ba58e2e2c7778d7c44ba6cd72ac4aa0f288ded8": "Ybodychange",
    "be5509c53743a0beddda3f5798e72b919e797bd0": "Ybodychange",
    "eae2a304624ee6caaa8591999752be2bba2b89e0": "Ybodychange",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b2cc8b6b4a78f31cdd937dc4d1a2255f80c5881e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-14973. More strictly enforce Balancer/Mover/SPS throttling of getBlocks RPCs to NameNodes. Contributed by Erik Krogen.\n",
      "commitDate": "15/11/19 10:10 AM",
      "commitName": "b2cc8b6b4a78f31cdd937dc4d1a2255f80c5881e",
      "commitAuthor": "Erik Krogen",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-14973. More strictly enforce Balancer/Mover/SPS throttling of getBlocks RPCs to NameNodes. Contributed by Erik Krogen.\n",
          "commitDate": "15/11/19 10:10 AM",
          "commitName": "b2cc8b6b4a78f31cdd937dc4d1a2255f80c5881e",
          "commitAuthor": "Erik Krogen",
          "commitDateOld": "18/02/19 3:30 PM",
          "commitNameOld": "1de25d134f64d815f9b43606fa426ece5ddbc430",
          "commitAuthorOld": "Inigo Goiri",
          "daysBetweenCommits": 269.78,
          "commitsBetweenForRepo": 1985,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,63 @@\n-    private void dispatchBlocks(long delay) {\n+    private void dispatchBlocks() {\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n       long previousMoveTimestamp \u003d Time.monotonicNow();\n       while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n               + \", scheduledSize\u003d\" + getScheduledSize()\n               + \", srcBlocks#\u003d\" + srcBlocks.size());\n         }\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n           // Reset previous move timestamp\n           previousMoveTimestamp \u003d Time.monotonicNow();\n           executePendingMove(p);\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n-            if(delay \u003e 0) {\n-              if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Sleeping \" + delay + \"  msec.\");\n-              }\n-              Thread.sleep(delay);\n-            }\n             final long received \u003d getBlockList();\n             if (received \u003d\u003d 0) {\n               return;\n             }\n             blocksToReceive -\u003d received;\n             continue;\n-          } catch (InterruptedException ignored) {\n-            // nothing to do\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting reportedBlock list\", e);\n             return;\n-          } finally {\n-            delay \u003d 0L;\n           }\n         } else {\n           // jump out of while-loop after the configured timeout.\n           long noMoveInterval \u003d Time.monotonicNow() - previousMoveTimestamp;\n           if (noMoveInterval \u003e maxNoMoveInterval) {\n             LOG.info(\"Failed to find a pending move for \"  + noMoveInterval\n                 + \" ms.  Skipping \" + this);\n             resetScheduledSize();\n           }\n         }\n \n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n           // Didn\u0027t find a possible move in this iteration of the while loop,\n           // adding a small delay before choosing next move again.\n           Thread.sleep(100);\n         } catch (InterruptedException ignored) {\n         }\n       }\n \n       if (isIterationOver()) {\n         LOG.info(\"The maximum iteration time (\" + maxIterationTime/1000\n             + \" seconds) has been reached. Stopping \" + this);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void dispatchBlocks() {\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      long previousMoveTimestamp \u003d Time.monotonicNow();\n      while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n              + \", scheduledSize\u003d\" + getScheduledSize()\n              + \", srcBlocks#\u003d\" + srcBlocks.size());\n        }\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // Reset previous move timestamp\n          previousMoveTimestamp \u003d Time.monotonicNow();\n          executePendingMove(p);\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            final long received \u003d getBlockList();\n            if (received \u003d\u003d 0) {\n              return;\n            }\n            blocksToReceive -\u003d received;\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting reportedBlock list\", e);\n            return;\n          }\n        } else {\n          // jump out of while-loop after the configured timeout.\n          long noMoveInterval \u003d Time.monotonicNow() - previousMoveTimestamp;\n          if (noMoveInterval \u003e maxNoMoveInterval) {\n            LOG.info(\"Failed to find a pending move for \"  + noMoveInterval\n                + \" ms.  Skipping \" + this);\n            resetScheduledSize();\n          }\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n          // Didn\u0027t find a possible move in this iteration of the while loop,\n          // adding a small delay before choosing next move again.\n          Thread.sleep(100);\n        } catch (InterruptedException ignored) {\n        }\n      }\n\n      if (isIterationOver()) {\n        LOG.info(\"The maximum iteration time (\" + maxIterationTime/1000\n            + \" seconds) has been reached. Stopping \" + this);\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
          "extendedDetails": {
            "oldValue": "[delay-long]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-14973. More strictly enforce Balancer/Mover/SPS throttling of getBlocks RPCs to NameNodes. Contributed by Erik Krogen.\n",
          "commitDate": "15/11/19 10:10 AM",
          "commitName": "b2cc8b6b4a78f31cdd937dc4d1a2255f80c5881e",
          "commitAuthor": "Erik Krogen",
          "commitDateOld": "18/02/19 3:30 PM",
          "commitNameOld": "1de25d134f64d815f9b43606fa426ece5ddbc430",
          "commitAuthorOld": "Inigo Goiri",
          "daysBetweenCommits": 269.78,
          "commitsBetweenForRepo": 1985,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,63 @@\n-    private void dispatchBlocks(long delay) {\n+    private void dispatchBlocks() {\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n       long previousMoveTimestamp \u003d Time.monotonicNow();\n       while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n               + \", scheduledSize\u003d\" + getScheduledSize()\n               + \", srcBlocks#\u003d\" + srcBlocks.size());\n         }\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n           // Reset previous move timestamp\n           previousMoveTimestamp \u003d Time.monotonicNow();\n           executePendingMove(p);\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n-            if(delay \u003e 0) {\n-              if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Sleeping \" + delay + \"  msec.\");\n-              }\n-              Thread.sleep(delay);\n-            }\n             final long received \u003d getBlockList();\n             if (received \u003d\u003d 0) {\n               return;\n             }\n             blocksToReceive -\u003d received;\n             continue;\n-          } catch (InterruptedException ignored) {\n-            // nothing to do\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting reportedBlock list\", e);\n             return;\n-          } finally {\n-            delay \u003d 0L;\n           }\n         } else {\n           // jump out of while-loop after the configured timeout.\n           long noMoveInterval \u003d Time.monotonicNow() - previousMoveTimestamp;\n           if (noMoveInterval \u003e maxNoMoveInterval) {\n             LOG.info(\"Failed to find a pending move for \"  + noMoveInterval\n                 + \" ms.  Skipping \" + this);\n             resetScheduledSize();\n           }\n         }\n \n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n           // Didn\u0027t find a possible move in this iteration of the while loop,\n           // adding a small delay before choosing next move again.\n           Thread.sleep(100);\n         } catch (InterruptedException ignored) {\n         }\n       }\n \n       if (isIterationOver()) {\n         LOG.info(\"The maximum iteration time (\" + maxIterationTime/1000\n             + \" seconds) has been reached. Stopping \" + this);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void dispatchBlocks() {\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      long previousMoveTimestamp \u003d Time.monotonicNow();\n      while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n              + \", scheduledSize\u003d\" + getScheduledSize()\n              + \", srcBlocks#\u003d\" + srcBlocks.size());\n        }\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // Reset previous move timestamp\n          previousMoveTimestamp \u003d Time.monotonicNow();\n          executePendingMove(p);\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            final long received \u003d getBlockList();\n            if (received \u003d\u003d 0) {\n              return;\n            }\n            blocksToReceive -\u003d received;\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting reportedBlock list\", e);\n            return;\n          }\n        } else {\n          // jump out of while-loop after the configured timeout.\n          long noMoveInterval \u003d Time.monotonicNow() - previousMoveTimestamp;\n          if (noMoveInterval \u003e maxNoMoveInterval) {\n            LOG.info(\"Failed to find a pending move for \"  + noMoveInterval\n                + \" ms.  Skipping \" + this);\n            resetScheduledSize();\n          }\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n          // Didn\u0027t find a possible move in this iteration of the while loop,\n          // adding a small delay before choosing next move again.\n          Thread.sleep(100);\n        } catch (InterruptedException ignored) {\n        }\n      }\n\n      if (isIterationOver()) {\n        LOG.info(\"The maximum iteration time (\" + maxIterationTime/1000\n            + \" seconds) has been reached. Stopping \" + this);\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
          "extendedDetails": {}
        }
      ]
    },
    "c966a3837af1c1a1c4a441f491b0d76d5c9e5d78": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13174. hdfs mover -p /path times out after 20 min. Contributed by Istvan Fajth.\n",
      "commitDate": "15/06/18 1:36 PM",
      "commitName": "c966a3837af1c1a1c4a441f491b0d76d5c9e5d78",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "07/03/18 11:27 AM",
      "commitNameOld": "88fba00caa8c8e26f70deb9be5b534e7482620a1",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 100.05,
      "commitsBetweenForRepo": 1371,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n     private void dispatchBlocks(long delay) {\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n       long previousMoveTimestamp \u003d Time.monotonicNow();\n       while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n               + \", scheduledSize\u003d\" + getScheduledSize()\n               + \", srcBlocks#\u003d\" + srcBlocks.size());\n         }\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n           // Reset previous move timestamp\n           previousMoveTimestamp \u003d Time.monotonicNow();\n           executePendingMove(p);\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             if(delay \u003e 0) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Sleeping \" + delay + \"  msec.\");\n               }\n               Thread.sleep(delay);\n             }\n             final long received \u003d getBlockList();\n             if (received \u003d\u003d 0) {\n               return;\n             }\n             blocksToReceive -\u003d received;\n             continue;\n           } catch (InterruptedException ignored) {\n             // nothing to do\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting reportedBlock list\", e);\n             return;\n           } finally {\n             delay \u003d 0L;\n           }\n         } else {\n           // jump out of while-loop after the configured timeout.\n           long noMoveInterval \u003d Time.monotonicNow() - previousMoveTimestamp;\n           if (noMoveInterval \u003e maxNoMoveInterval) {\n             LOG.info(\"Failed to find a pending move for \"  + noMoveInterval\n                 + \" ms.  Skipping \" + this);\n             resetScheduledSize();\n           }\n         }\n \n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n           // Didn\u0027t find a possible move in this iteration of the while loop,\n           // adding a small delay before choosing next move again.\n           Thread.sleep(100);\n         } catch (InterruptedException ignored) {\n         }\n       }\n \n       if (isIterationOver()) {\n-        LOG.info(\"The maximum iteration time (\" + MAX_ITERATION_TIME/1000\n+        LOG.info(\"The maximum iteration time (\" + maxIterationTime/1000\n             + \" seconds) has been reached. Stopping \" + this);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks(long delay) {\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      long previousMoveTimestamp \u003d Time.monotonicNow();\n      while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n              + \", scheduledSize\u003d\" + getScheduledSize()\n              + \", srcBlocks#\u003d\" + srcBlocks.size());\n        }\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // Reset previous move timestamp\n          previousMoveTimestamp \u003d Time.monotonicNow();\n          executePendingMove(p);\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            if(delay \u003e 0) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sleeping \" + delay + \"  msec.\");\n              }\n              Thread.sleep(delay);\n            }\n            final long received \u003d getBlockList();\n            if (received \u003d\u003d 0) {\n              return;\n            }\n            blocksToReceive -\u003d received;\n            continue;\n          } catch (InterruptedException ignored) {\n            // nothing to do\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting reportedBlock list\", e);\n            return;\n          } finally {\n            delay \u003d 0L;\n          }\n        } else {\n          // jump out of while-loop after the configured timeout.\n          long noMoveInterval \u003d Time.monotonicNow() - previousMoveTimestamp;\n          if (noMoveInterval \u003e maxNoMoveInterval) {\n            LOG.info(\"Failed to find a pending move for \"  + noMoveInterval\n                + \" ms.  Skipping \" + this);\n            resetScheduledSize();\n          }\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n          // Didn\u0027t find a possible move in this iteration of the while loop,\n          // adding a small delay before choosing next move again.\n          Thread.sleep(100);\n        } catch (InterruptedException ignored) {\n        }\n      }\n\n      if (isIterationOver()) {\n        LOG.info(\"The maximum iteration time (\" + maxIterationTime/1000\n            + \" seconds) has been reached. Stopping \" + this);\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {}
    },
    "28eb2aabebd15c15a357d86e23ca407d3c85211c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-11384. Balancer disperses getBlocks calls to avoid NameNode\u0027s rpc queue saturation. Contributed by Konstantin V Shvachko.",
      "commitDate": "26/04/17 5:28 PM",
      "commitName": "28eb2aabebd15c15a357d86e23ca407d3c85211c",
      "commitAuthor": "Konstantin V Shvachko",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-11384. Balancer disperses getBlocks calls to avoid NameNode\u0027s rpc queue saturation. Contributed by Konstantin V Shvachko.",
          "commitDate": "26/04/17 5:28 PM",
          "commitName": "28eb2aabebd15c15a357d86e23ca407d3c85211c",
          "commitAuthor": "Konstantin V Shvachko",
          "commitDateOld": "25/04/17 11:57 PM",
          "commitNameOld": "2f73396b5901fd5fe29f6cd76fc1b3134b854b37",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 0.73,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,63 +1,73 @@\n-    private void dispatchBlocks() {\n+    private void dispatchBlocks(long delay) {\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n       long previousMoveTimestamp \u003d Time.monotonicNow();\n       while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n               + \", scheduledSize\u003d\" + getScheduledSize()\n               + \", srcBlocks#\u003d\" + srcBlocks.size());\n         }\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n           // Reset previous move timestamp\n           previousMoveTimestamp \u003d Time.monotonicNow();\n           executePendingMove(p);\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n+            if(delay \u003e 0) {\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Sleeping \" + delay + \"  msec.\");\n+              }\n+              Thread.sleep(delay);\n+            }\n             final long received \u003d getBlockList();\n             if (received \u003d\u003d 0) {\n               return;\n             }\n             blocksToReceive -\u003d received;\n             continue;\n+          } catch (InterruptedException ignored) {\n+            // nothing to do\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting reportedBlock list\", e);\n             return;\n+          } finally {\n+            delay \u003d 0L;\n           }\n         } else {\n           // jump out of while-loop after the configured timeout.\n           long noMoveInterval \u003d Time.monotonicNow() - previousMoveTimestamp;\n           if (noMoveInterval \u003e maxNoMoveInterval) {\n             LOG.info(\"Failed to find a pending move for \"  + noMoveInterval\n                 + \" ms.  Skipping \" + this);\n             resetScheduledSize();\n           }\n         }\n \n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n           // Didn\u0027t find a possible move in this iteration of the while loop,\n           // adding a small delay before choosing next move again.\n           Thread.sleep(100);\n         } catch (InterruptedException ignored) {\n         }\n       }\n \n       if (isIterationOver()) {\n         LOG.info(\"The maximum iteration time (\" + MAX_ITERATION_TIME/1000\n             + \" seconds) has been reached. Stopping \" + this);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void dispatchBlocks(long delay) {\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      long previousMoveTimestamp \u003d Time.monotonicNow();\n      while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n              + \", scheduledSize\u003d\" + getScheduledSize()\n              + \", srcBlocks#\u003d\" + srcBlocks.size());\n        }\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // Reset previous move timestamp\n          previousMoveTimestamp \u003d Time.monotonicNow();\n          executePendingMove(p);\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            if(delay \u003e 0) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sleeping \" + delay + \"  msec.\");\n              }\n              Thread.sleep(delay);\n            }\n            final long received \u003d getBlockList();\n            if (received \u003d\u003d 0) {\n              return;\n            }\n            blocksToReceive -\u003d received;\n            continue;\n          } catch (InterruptedException ignored) {\n            // nothing to do\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting reportedBlock list\", e);\n            return;\n          } finally {\n            delay \u003d 0L;\n          }\n        } else {\n          // jump out of while-loop after the configured timeout.\n          long noMoveInterval \u003d Time.monotonicNow() - previousMoveTimestamp;\n          if (noMoveInterval \u003e maxNoMoveInterval) {\n            LOG.info(\"Failed to find a pending move for \"  + noMoveInterval\n                + \" ms.  Skipping \" + this);\n            resetScheduledSize();\n          }\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n          // Didn\u0027t find a possible move in this iteration of the while loop,\n          // adding a small delay before choosing next move again.\n          Thread.sleep(100);\n        } catch (InterruptedException ignored) {\n        }\n      }\n\n      if (isIterationOver()) {\n        LOG.info(\"The maximum iteration time (\" + MAX_ITERATION_TIME/1000\n            + \" seconds) has been reached. Stopping \" + this);\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[delay-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-11384. Balancer disperses getBlocks calls to avoid NameNode\u0027s rpc queue saturation. Contributed by Konstantin V Shvachko.",
          "commitDate": "26/04/17 5:28 PM",
          "commitName": "28eb2aabebd15c15a357d86e23ca407d3c85211c",
          "commitAuthor": "Konstantin V Shvachko",
          "commitDateOld": "25/04/17 11:57 PM",
          "commitNameOld": "2f73396b5901fd5fe29f6cd76fc1b3134b854b37",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 0.73,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,63 +1,73 @@\n-    private void dispatchBlocks() {\n+    private void dispatchBlocks(long delay) {\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n       long previousMoveTimestamp \u003d Time.monotonicNow();\n       while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n               + \", scheduledSize\u003d\" + getScheduledSize()\n               + \", srcBlocks#\u003d\" + srcBlocks.size());\n         }\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n           // Reset previous move timestamp\n           previousMoveTimestamp \u003d Time.monotonicNow();\n           executePendingMove(p);\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n+            if(delay \u003e 0) {\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Sleeping \" + delay + \"  msec.\");\n+              }\n+              Thread.sleep(delay);\n+            }\n             final long received \u003d getBlockList();\n             if (received \u003d\u003d 0) {\n               return;\n             }\n             blocksToReceive -\u003d received;\n             continue;\n+          } catch (InterruptedException ignored) {\n+            // nothing to do\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting reportedBlock list\", e);\n             return;\n+          } finally {\n+            delay \u003d 0L;\n           }\n         } else {\n           // jump out of while-loop after the configured timeout.\n           long noMoveInterval \u003d Time.monotonicNow() - previousMoveTimestamp;\n           if (noMoveInterval \u003e maxNoMoveInterval) {\n             LOG.info(\"Failed to find a pending move for \"  + noMoveInterval\n                 + \" ms.  Skipping \" + this);\n             resetScheduledSize();\n           }\n         }\n \n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n           // Didn\u0027t find a possible move in this iteration of the while loop,\n           // adding a small delay before choosing next move again.\n           Thread.sleep(100);\n         } catch (InterruptedException ignored) {\n         }\n       }\n \n       if (isIterationOver()) {\n         LOG.info(\"The maximum iteration time (\" + MAX_ITERATION_TIME/1000\n             + \" seconds) has been reached. Stopping \" + this);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void dispatchBlocks(long delay) {\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      long previousMoveTimestamp \u003d Time.monotonicNow();\n      while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n              + \", scheduledSize\u003d\" + getScheduledSize()\n              + \", srcBlocks#\u003d\" + srcBlocks.size());\n        }\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // Reset previous move timestamp\n          previousMoveTimestamp \u003d Time.monotonicNow();\n          executePendingMove(p);\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            if(delay \u003e 0) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sleeping \" + delay + \"  msec.\");\n              }\n              Thread.sleep(delay);\n            }\n            final long received \u003d getBlockList();\n            if (received \u003d\u003d 0) {\n              return;\n            }\n            blocksToReceive -\u003d received;\n            continue;\n          } catch (InterruptedException ignored) {\n            // nothing to do\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting reportedBlock list\", e);\n            return;\n          } finally {\n            delay \u003d 0L;\n          }\n        } else {\n          // jump out of while-loop after the configured timeout.\n          long noMoveInterval \u003d Time.monotonicNow() - previousMoveTimestamp;\n          if (noMoveInterval \u003e maxNoMoveInterval) {\n            LOG.info(\"Failed to find a pending move for \"  + noMoveInterval\n                + \" ms.  Skipping \" + this);\n            resetScheduledSize();\n          }\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n          // Didn\u0027t find a possible move in this iteration of the while loop,\n          // adding a small delay before choosing next move again.\n          Thread.sleep(100);\n        } catch (InterruptedException ignored) {\n        }\n      }\n\n      if (isIterationOver()) {\n        LOG.info(\"The maximum iteration time (\" + MAX_ITERATION_TIME/1000\n            + \" seconds) has been reached. Stopping \" + this);\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
          "extendedDetails": {}
        }
      ]
    },
    "49a09179e3fadae090126261be0a7fe0aa48798e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10966. Enhance Dispatcher logic on deciding when to give up a source DataNode. Contributed by  Mark Wagner and Zhe Zhang.\n",
      "commitDate": "21/11/16 8:13 AM",
      "commitName": "49a09179e3fadae090126261be0a7fe0aa48798e",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "25/10/16 10:19 AM",
      "commitNameOld": "f6367c5f44a88cb5eb7edffb015b10b657504a61",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 26.95,
      "commitsBetweenForRepo": 258,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,63 @@\n     private void dispatchBlocks() {\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n-      int noPendingMoveIteration \u003d 0;\n+      long previousMoveTimestamp \u003d Time.monotonicNow();\n       while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n               + \", scheduledSize\u003d\" + getScheduledSize()\n               + \", srcBlocks#\u003d\" + srcBlocks.size());\n         }\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n-          // Reset no pending move counter\n-          noPendingMoveIteration\u003d0;\n+          // Reset previous move timestamp\n+          previousMoveTimestamp \u003d Time.monotonicNow();\n           executePendingMove(p);\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             final long received \u003d getBlockList();\n             if (received \u003d\u003d 0) {\n               return;\n             }\n             blocksToReceive -\u003d received;\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting reportedBlock list\", e);\n             return;\n           }\n         } else {\n-          // source node cannot find a pending block to move, iteration +1\n-          noPendingMoveIteration++;\n-          // in case no blocks can be moved for source node\u0027s task,\n-          // jump out of while-loop after 5 iterations.\n-          if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n-            LOG.info(\"Failed to find a pending move \"  + noPendingMoveIteration\n-                + \" times.  Skipping \" + this);\n+          // jump out of while-loop after the configured timeout.\n+          long noMoveInterval \u003d Time.monotonicNow() - previousMoveTimestamp;\n+          if (noMoveInterval \u003e maxNoMoveInterval) {\n+            LOG.info(\"Failed to find a pending move for \"  + noMoveInterval\n+                + \" ms.  Skipping \" + this);\n             resetScheduledSize();\n           }\n         }\n \n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n+          // Didn\u0027t find a possible move in this iteration of the while loop,\n+          // adding a small delay before choosing next move again.\n+          Thread.sleep(100);\n         } catch (InterruptedException ignored) {\n         }\n       }\n \n       if (isIterationOver()) {\n         LOG.info(\"The maximum iteration time (\" + MAX_ITERATION_TIME/1000\n             + \" seconds) has been reached. Stopping \" + this);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      long previousMoveTimestamp \u003d Time.monotonicNow();\n      while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n              + \", scheduledSize\u003d\" + getScheduledSize()\n              + \", srcBlocks#\u003d\" + srcBlocks.size());\n        }\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // Reset previous move timestamp\n          previousMoveTimestamp \u003d Time.monotonicNow();\n          executePendingMove(p);\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            final long received \u003d getBlockList();\n            if (received \u003d\u003d 0) {\n              return;\n            }\n            blocksToReceive -\u003d received;\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting reportedBlock list\", e);\n            return;\n          }\n        } else {\n          // jump out of while-loop after the configured timeout.\n          long noMoveInterval \u003d Time.monotonicNow() - previousMoveTimestamp;\n          if (noMoveInterval \u003e maxNoMoveInterval) {\n            LOG.info(\"Failed to find a pending move for \"  + noMoveInterval\n                + \" ms.  Skipping \" + this);\n            resetScheduledSize();\n          }\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n          // Didn\u0027t find a possible move in this iteration of the while loop,\n          // adding a small delay before choosing next move again.\n          Thread.sleep(100);\n        } catch (InterruptedException ignored) {\n        }\n      }\n\n      if (isIterationOver()) {\n        LOG.info(\"The maximum iteration time (\" + MAX_ITERATION_TIME/1000\n            + \" seconds) has been reached. Stopping \" + this);\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {}
    },
    "f6367c5f44a88cb5eb7edffb015b10b657504a61": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11015. Enforce timeout in balancer. Contributed by Kihwal Lee.\n",
      "commitDate": "25/10/16 10:19 AM",
      "commitName": "f6367c5f44a88cb5eb7edffb015b10b657504a61",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "17/10/16 5:45 PM",
      "commitNameOld": "b61fb267b92b2736920b4bd0c673d31e7632ebb9",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 7.69,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,62 @@\n     private void dispatchBlocks() {\n-      final long startTime \u003d Time.monotonicNow();\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n-      boolean isTimeUp \u003d false;\n       int noPendingMoveIteration \u003d 0;\n-      while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n+      while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n               + \", scheduledSize\u003d\" + getScheduledSize()\n               + \", srcBlocks#\u003d\" + srcBlocks.size());\n         }\n-        // check if time is up or not\n-        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n-          LOG.info(\"Time up (max time\u003d\" + MAX_ITERATION_TIME/1000\n-              + \" seconds).  Skipping \" + this);\n-          isTimeUp \u003d true;\n-          continue;\n-        }\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n           // Reset no pending move counter\n           noPendingMoveIteration\u003d0;\n           executePendingMove(p);\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             final long received \u003d getBlockList();\n             if (received \u003d\u003d 0) {\n               return;\n             }\n             blocksToReceive -\u003d received;\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting reportedBlock list\", e);\n             return;\n           }\n         } else {\n           // source node cannot find a pending block to move, iteration +1\n           noPendingMoveIteration++;\n           // in case no blocks can be moved for source node\u0027s task,\n           // jump out of while-loop after 5 iterations.\n           if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n             LOG.info(\"Failed to find a pending move \"  + noPendingMoveIteration\n                 + \" times.  Skipping \" + this);\n             resetScheduledSize();\n           }\n         }\n \n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n+\n+      if (isIterationOver()) {\n+        LOG.info(\"The maximum iteration time (\" + MAX_ITERATION_TIME/1000\n+            + \" seconds) has been reached. Stopping \" + this);\n+      }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      int noPendingMoveIteration \u003d 0;\n      while (getScheduledSize() \u003e 0 \u0026\u0026 !isIterationOver()\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n              + \", scheduledSize\u003d\" + getScheduledSize()\n              + \", srcBlocks#\u003d\" + srcBlocks.size());\n        }\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // Reset no pending move counter\n          noPendingMoveIteration\u003d0;\n          executePendingMove(p);\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            final long received \u003d getBlockList();\n            if (received \u003d\u003d 0) {\n              return;\n            }\n            blocksToReceive -\u003d received;\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting reportedBlock list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pending block to move, iteration +1\n          noPendingMoveIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n            LOG.info(\"Failed to find a pending move \"  + noPendingMoveIteration\n                + \" times.  Skipping \" + this);\n            resetScheduledSize();\n          }\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n\n      if (isIterationOver()) {\n        LOG.info(\"The maximum iteration time (\" + MAX_ITERATION_TIME/1000\n            + \" seconds) has been reached. Stopping \" + this);\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {}
    },
    "58db263e93daf08280e6a586a10cebd6122cf72a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-742. A down DataNode makes Balancer to hang on repeatingly asking NameNode its partial block list. Contributed by Mit Desai.\n",
      "commitDate": "03/08/16 10:14 AM",
      "commitName": "58db263e93daf08280e6a586a10cebd6122cf72a",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/11/15 10:22 AM",
      "commitNameOld": "ec414600ede8e305c584818565b50e055ea5d2b5",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 272.95,
      "commitsBetweenForRepo": 1860,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,66 @@\n     private void dispatchBlocks() {\n       final long startTime \u003d Time.monotonicNow();\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n       boolean isTimeUp \u003d false;\n       int noPendingMoveIteration \u003d 0;\n       while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n               + \", scheduledSize\u003d\" + getScheduledSize()\n               + \", srcBlocks#\u003d\" + srcBlocks.size());\n         }\n+        // check if time is up or not\n+        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n+          LOG.info(\"Time up (max time\u003d\" + MAX_ITERATION_TIME/1000\n+              + \" seconds).  Skipping \" + this);\n+          isTimeUp \u003d true;\n+          continue;\n+        }\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n           // Reset no pending move counter\n           noPendingMoveIteration\u003d0;\n           executePendingMove(p);\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             final long received \u003d getBlockList();\n             if (received \u003d\u003d 0) {\n               return;\n             }\n             blocksToReceive -\u003d received;\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting reportedBlock list\", e);\n             return;\n           }\n         } else {\n           // source node cannot find a pending block to move, iteration +1\n           noPendingMoveIteration++;\n           // in case no blocks can be moved for source node\u0027s task,\n           // jump out of while-loop after 5 iterations.\n           if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n             LOG.info(\"Failed to find a pending move \"  + noPendingMoveIteration\n                 + \" times.  Skipping \" + this);\n             resetScheduledSize();\n           }\n         }\n \n-        // check if time is up or not\n-        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n-          LOG.info(\"Time up (max time\u003d\" + MAX_ITERATION_TIME/1000\n-              + \" seconds).  Skipping \" + this);\n-          isTimeUp \u003d true;\n-          continue;\n-        }\n-\n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      final long startTime \u003d Time.monotonicNow();\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      boolean isTimeUp \u003d false;\n      int noPendingMoveIteration \u003d 0;\n      while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n              + \", scheduledSize\u003d\" + getScheduledSize()\n              + \", srcBlocks#\u003d\" + srcBlocks.size());\n        }\n        // check if time is up or not\n        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n          LOG.info(\"Time up (max time\u003d\" + MAX_ITERATION_TIME/1000\n              + \" seconds).  Skipping \" + this);\n          isTimeUp \u003d true;\n          continue;\n        }\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // Reset no pending move counter\n          noPendingMoveIteration\u003d0;\n          executePendingMove(p);\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            final long received \u003d getBlockList();\n            if (received \u003d\u003d 0) {\n              return;\n            }\n            blocksToReceive -\u003d received;\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting reportedBlock list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pending block to move, iteration +1\n          noPendingMoveIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n            LOG.info(\"Failed to find a pending move \"  + noPendingMoveIteration\n                + \" times.  Skipping \" + this);\n            resetScheduledSize();\n          }\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {}
    },
    "7ecbfd44aa57f5f54c214b7fdedda2500be76f51": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8826. In Balancer, add an option to specify the source node list so that balancer only selects blocks to move from those nodes.\n",
      "commitDate": "18/08/15 7:25 PM",
      "commitName": "7ecbfd44aa57f5f54c214b7fdedda2500be76f51",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "14/08/15 1:03 PM",
      "commitNameOld": "2bc0a4f299fbd8035e29f62ce9cd22e209a62805",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 4.27,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,67 @@\n     private void dispatchBlocks() {\n       final long startTime \u003d Time.monotonicNow();\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n       boolean isTimeUp \u003d false;\n       int noPendingMoveIteration \u003d 0;\n       while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n               + \", scheduledSize\u003d\" + getScheduledSize()\n               + \", srcBlocks#\u003d\" + srcBlocks.size());\n         }\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n           // Reset no pending move counter\n           noPendingMoveIteration\u003d0;\n           executePendingMove(p);\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n-            blocksToReceive -\u003d getBlockList();\n+            final long received \u003d getBlockList();\n+            if (received \u003d\u003d 0) {\n+              return;\n+            }\n+            blocksToReceive -\u003d received;\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting block list\", e);\n             return;\n           }\n         } else {\n           // source node cannot find a pending block to move, iteration +1\n           noPendingMoveIteration++;\n           // in case no blocks can be moved for source node\u0027s task,\n           // jump out of while-loop after 5 iterations.\n           if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n             LOG.info(\"Failed to find a pending move \"  + noPendingMoveIteration\n                 + \" times.  Skipping \" + this);\n             resetScheduledSize();\n           }\n         }\n \n         // check if time is up or not\n         if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n           LOG.info(\"Time up (max time\u003d\" + MAX_ITERATION_TIME/1000\n               + \" seconds).  Skipping \" + this);\n           isTimeUp \u003d true;\n           continue;\n         }\n \n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      final long startTime \u003d Time.monotonicNow();\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      boolean isTimeUp \u003d false;\n      int noPendingMoveIteration \u003d 0;\n      while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n              + \", scheduledSize\u003d\" + getScheduledSize()\n              + \", srcBlocks#\u003d\" + srcBlocks.size());\n        }\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // Reset no pending move counter\n          noPendingMoveIteration\u003d0;\n          executePendingMove(p);\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            final long received \u003d getBlockList();\n            if (received \u003d\u003d 0) {\n              return;\n            }\n            blocksToReceive -\u003d received;\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pending block to move, iteration +1\n          noPendingMoveIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n            LOG.info(\"Failed to find a pending move \"  + noPendingMoveIteration\n                + \" times.  Skipping \" + this);\n            resetScheduledSize();\n          }\n        }\n\n        // check if time is up or not\n        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n          LOG.info(\"Time up (max time\u003d\" + MAX_ITERATION_TIME/1000\n              + \" seconds).  Skipping \" + this);\n          isTimeUp \u003d true;\n          continue;\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {}
    },
    "b56daff6a186599764b046248565918b894ec116": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8818. Changes the global moveExecutor to per datanode executors and changes MAX_SIZE_TO_MOVE to be configurable.\n",
      "commitDate": "10/08/15 4:52 PM",
      "commitName": "b56daff6a186599764b046248565918b894ec116",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "13/07/15 3:12 PM",
      "commitNameOld": "9ef03a4c5bb5573eadc7d04e371c4af2dc6bae37",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 28.07,
      "commitsBetweenForRepo": 150,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,63 @@\n     private void dispatchBlocks() {\n       final long startTime \u003d Time.monotonicNow();\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n       boolean isTimeUp \u003d false;\n       int noPendingMoveIteration \u003d 0;\n       while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n+        if (LOG.isTraceEnabled()) {\n+          LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n+              + \", scheduledSize\u003d\" + getScheduledSize()\n+              + \", srcBlocks#\u003d\" + srcBlocks.size());\n+        }\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n           // Reset no pending move counter\n           noPendingMoveIteration\u003d0;\n           executePendingMove(p);\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             blocksToReceive -\u003d getBlockList();\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting block list\", e);\n             return;\n           }\n         } else {\n           // source node cannot find a pending block to move, iteration +1\n           noPendingMoveIteration++;\n           // in case no blocks can be moved for source node\u0027s task,\n           // jump out of while-loop after 5 iterations.\n           if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n+            LOG.info(\"Failed to find a pending move \"  + noPendingMoveIteration\n+                + \" times.  Skipping \" + this);\n             resetScheduledSize();\n           }\n         }\n \n         // check if time is up or not\n         if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n+          LOG.info(\"Time up (max time\u003d\" + MAX_ITERATION_TIME/1000\n+              + \" seconds).  Skipping \" + this);\n           isTimeUp \u003d true;\n           continue;\n         }\n \n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      final long startTime \u003d Time.monotonicNow();\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      boolean isTimeUp \u003d false;\n      int noPendingMoveIteration \u003d 0;\n      while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(this + \" blocksToReceive\u003d\" + blocksToReceive\n              + \", scheduledSize\u003d\" + getScheduledSize()\n              + \", srcBlocks#\u003d\" + srcBlocks.size());\n        }\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // Reset no pending move counter\n          noPendingMoveIteration\u003d0;\n          executePendingMove(p);\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pending block to move, iteration +1\n          noPendingMoveIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n            LOG.info(\"Failed to find a pending move \"  + noPendingMoveIteration\n                + \" times.  Skipping \" + this);\n            resetScheduledSize();\n          }\n        }\n\n        // check if time is up or not\n        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n          LOG.info(\"Time up (max time\u003d\" + MAX_ITERATION_TIME/1000\n              + \" seconds).  Skipping \" + this);\n          isTimeUp \u003d true;\n          continue;\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {}
    },
    "673280df24f0228bf01777035ceeab8807da8c40": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7621. Erasure Coding: update the Balancer/Mover data migration logic. Contributed by Walter Su.\n",
      "commitDate": "03/06/15 11:51 AM",
      "commitName": "673280df24f0228bf01777035ceeab8807da8c40",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "05/05/15 3:41 PM",
      "commitNameOld": "4da8490b512a33a255ed27309860859388d7c168",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 28.84,
      "commitsBetweenForRepo": 380,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n     private void dispatchBlocks() {\n       final long startTime \u003d Time.monotonicNow();\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n       boolean isTimeUp \u003d false;\n       int noPendingMoveIteration \u003d 0;\n       while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n           // Reset no pending move counter\n           noPendingMoveIteration\u003d0;\n           executePendingMove(p);\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             blocksToReceive -\u003d getBlockList();\n             continue;\n           } catch (IOException e) {\n-            LOG.warn(\"Exception while getting block list\", e);\n+            LOG.warn(\"Exception while getting reportedBlock list\", e);\n             return;\n           }\n         } else {\n           // source node cannot find a pending block to move, iteration +1\n           noPendingMoveIteration++;\n           // in case no blocks can be moved for source node\u0027s task,\n           // jump out of while-loop after 5 iterations.\n           if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n             resetScheduledSize();\n           }\n         }\n \n         // check if time is up or not\n         if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n           isTimeUp \u003d true;\n           continue;\n         }\n \n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      final long startTime \u003d Time.monotonicNow();\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      boolean isTimeUp \u003d false;\n      int noPendingMoveIteration \u003d 0;\n      while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // Reset no pending move counter\n          noPendingMoveIteration\u003d0;\n          executePendingMove(p);\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting reportedBlock list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pending block to move, iteration +1\n          noPendingMoveIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n            resetScheduledSize();\n          }\n        }\n\n        // check if time is up or not\n        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {}
    },
    "d1dab6cc63abf5d44533ad9b39e32c582327627b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6621. Hadoop Balancer prematurely exits iterations. Contributed by Rafal Wodjdyla and Benjamin Bowman.\n",
      "commitDate": "11/09/14 10:32 AM",
      "commitName": "d1dab6cc63abf5d44533ad9b39e32c582327627b",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "13/08/14 11:43 AM",
      "commitNameOld": "195961a7c1da86421761162836766b1de07930fd",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 28.95,
      "commitsBetweenForRepo": 225,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,60 @@\n     private void dispatchBlocks() {\n       final long startTime \u003d Time.monotonicNow();\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n       boolean isTimeUp \u003d false;\n       int noPendingMoveIteration \u003d 0;\n       while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n+          // Reset no pending move counter\n+          noPendingMoveIteration\u003d0;\n           // move the block\n           moveExecutor.execute(new Runnable() {\n             @Override\n             public void run() {\n               p.dispatch();\n             }\n           });\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             blocksToReceive -\u003d getBlockList();\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting block list\", e);\n             return;\n           }\n         } else {\n           // source node cannot find a pending block to move, iteration +1\n           noPendingMoveIteration++;\n           // in case no blocks can be moved for source node\u0027s task,\n           // jump out of while-loop after 5 iterations.\n           if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n             resetScheduledSize();\n           }\n         }\n \n         // check if time is up or not\n         if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n           isTimeUp \u003d true;\n           continue;\n         }\n \n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      final long startTime \u003d Time.monotonicNow();\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      boolean isTimeUp \u003d false;\n      int noPendingMoveIteration \u003d 0;\n      while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // Reset no pending move counter\n          noPendingMoveIteration\u003d0;\n          // move the block\n          moveExecutor.execute(new Runnable() {\n            @Override\n            public void run() {\n              p.dispatch();\n            }\n          });\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pending block to move, iteration +1\n          noPendingMoveIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n            resetScheduledSize();\n          }\n        }\n\n        // check if time is up or not\n        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {}
    },
    "5d5aae0694bc27df5b9fa50819854cd3050a8658": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6801. Archival Storage: Add a new data migration tool. Contributed by Tsz Wo Nicholas Sze.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-6584@1618675 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/14 10:51 AM",
      "commitName": "5d5aae0694bc27df5b9fa50819854cd3050a8658",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "13/08/14 11:43 AM",
      "commitNameOld": "195961a7c1da86421761162836766b1de07930fd",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 4.96,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,52 @@\n     private void dispatchBlocks() {\n       final long startTime \u003d Time.monotonicNow();\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n       boolean isTimeUp \u003d false;\n       int noPendingMoveIteration \u003d 0;\n       while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n-          // move the block\n-          moveExecutor.execute(new Runnable() {\n-            @Override\n-            public void run() {\n-              p.dispatch();\n-            }\n-          });\n+          executePendingMove(p);\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             blocksToReceive -\u003d getBlockList();\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting block list\", e);\n             return;\n           }\n         } else {\n           // source node cannot find a pending block to move, iteration +1\n           noPendingMoveIteration++;\n           // in case no blocks can be moved for source node\u0027s task,\n           // jump out of while-loop after 5 iterations.\n           if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n             resetScheduledSize();\n           }\n         }\n \n         // check if time is up or not\n         if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n           isTimeUp \u003d true;\n           continue;\n         }\n \n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      final long startTime \u003d Time.monotonicNow();\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      boolean isTimeUp \u003d false;\n      int noPendingMoveIteration \u003d 0;\n      while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          executePendingMove(p);\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pending block to move, iteration +1\n          noPendingMoveIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n            resetScheduledSize();\n          }\n        }\n\n        // check if time is up or not\n        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {}
    },
    "e60673697d5046c29c52bbabdfe80506f99773e4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6837. Code cleanup for Balancer and Dispatcher. Contributed by Tsz Wo Nicholas Sze.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617337 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/08/14 11:01 AM",
      "commitName": "e60673697d5046c29c52bbabdfe80506f99773e4",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "08/08/14 2:33 PM",
      "commitNameOld": "c3cf331dc91e2beef2afeed11105084843b02858",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.85,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n     private void dispatchBlocks() {\n       final long startTime \u003d Time.monotonicNow();\n       this.blocksToReceive \u003d 2 * getScheduledSize();\n       boolean isTimeUp \u003d false;\n-      int noPendingBlockIteration \u003d 0;\n+      int noPendingMoveIteration \u003d 0;\n       while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n           \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n         final PendingMove p \u003d chooseNextMove();\n         if (p !\u003d null) {\n           // move the block\n           moveExecutor.execute(new Runnable() {\n             @Override\n             public void run() {\n               p.dispatch();\n             }\n           });\n           continue;\n         }\n \n         // Since we cannot schedule any block to move,\n         // remove any moved blocks from the source block list and\n         removeMovedBlocks(); // filter already moved blocks\n         // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             blocksToReceive -\u003d getBlockList();\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting block list\", e);\n             return;\n           }\n         } else {\n-          // source node cannot find a pendingBlockToMove, iteration +1\n-          noPendingBlockIteration++;\n+          // source node cannot find a pending block to move, iteration +1\n+          noPendingMoveIteration++;\n           // in case no blocks can be moved for source node\u0027s task,\n           // jump out of while-loop after 5 iterations.\n-          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n+          if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n             resetScheduledSize();\n           }\n         }\n \n         // check if time is up or not\n         if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n           isTimeUp \u003d true;\n           continue;\n         }\n \n         // Now we can not schedule any block to move and there are\n         // no new blocks added to the source block list, so we wait.\n         try {\n           synchronized (Dispatcher.this) {\n             Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      final long startTime \u003d Time.monotonicNow();\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      boolean isTimeUp \u003d false;\n      int noPendingMoveIteration \u003d 0;\n      while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // move the block\n          moveExecutor.execute(new Runnable() {\n            @Override\n            public void run() {\n              p.dispatch();\n            }\n          });\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pending block to move, iteration +1\n          noPendingMoveIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingMoveIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n            resetScheduledSize();\n          }\n        }\n\n        // check if time is up or not\n        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
      "extendedDetails": {}
    },
    "c3cf331dc91e2beef2afeed11105084843b02858": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "HDFS-6828. Separate block replica dispatching from Balancer. Contributed by Tsz Wo Nicholas Sze.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616889 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/14 2:33 PM",
      "commitName": "c3cf331dc91e2beef2afeed11105084843b02858",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-6828. Separate block replica dispatching from Balancer. Contributed by Tsz Wo Nicholas Sze.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616889 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/08/14 2:33 PM",
          "commitName": "c3cf331dc91e2beef2afeed11105084843b02858",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "08/08/14 2:22 PM",
          "commitNameOld": "05d1bf4157e6660610f11951845e59899260596e",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,56 +1,58 @@\n     private void dispatchBlocks() {\n-      long startTime \u003d Time.now();\n-      long scheduledSize \u003d getScheduledSize();\n-      this.blocksToReceive \u003d 2*scheduledSize;\n+      final long startTime \u003d Time.monotonicNow();\n+      this.blocksToReceive \u003d 2 * getScheduledSize();\n       boolean isTimeUp \u003d false;\n       int noPendingBlockIteration \u003d 0;\n-      while(!isTimeUp \u0026\u0026 getScheduledSize()\u003e0 \u0026\u0026\n-          (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n-        PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n-        if (pendingBlock !\u003d null) {\n+      while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n+          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n+        final PendingMove p \u003d chooseNextMove();\n+        if (p !\u003d null) {\n           // move the block\n-          pendingBlock.scheduleBlockMove();\n+          moveExecutor.execute(new Runnable() {\n+            @Override\n+            public void run() {\n+              p.dispatch();\n+            }\n+          });\n           continue;\n         }\n-        \n-        /* Since we can not schedule any block to move,\n-         * filter any moved blocks from the source block list and\n-         * check if we should fetch more blocks from the namenode\n-         */\n-        filterMovedBlocks(); // filter already moved blocks\n+\n+        // Since we cannot schedule any block to move,\n+        // remove any moved blocks from the source block list and\n+        removeMovedBlocks(); // filter already moved blocks\n+        // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             blocksToReceive -\u003d getBlockList();\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting block list\", e);\n             return;\n           }\n         } else {\n           // source node cannot find a pendingBlockToMove, iteration +1\n           noPendingBlockIteration++;\n           // in case no blocks can be moved for source node\u0027s task,\n           // jump out of while-loop after 5 iterations.\n-          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_BLOCK_ITERATIONS) {\n+          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n             resetScheduledSize();\n           }\n         }\n-        \n+\n         // check if time is up or not\n-        if (Time.now()-startTime \u003e MAX_ITERATION_TIME) {\n+        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n           isTimeUp \u003d true;\n           continue;\n         }\n-        \n-        /* Now we can not schedule any block to move and there are\n-         * no new blocks added to the source block list, so we wait. \n-         */\n+\n+        // Now we can not schedule any block to move and there are\n+        // no new blocks added to the source block list, so we wait.\n         try {\n-          synchronized(Balancer.this) {\n-            Balancer.this.wait(1000);  // wait for targets/sources to be idle\n+          synchronized (Dispatcher.this) {\n+            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void dispatchBlocks() {\n      final long startTime \u003d Time.monotonicNow();\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      boolean isTimeUp \u003d false;\n      int noPendingBlockIteration \u003d 0;\n      while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // move the block\n          moveExecutor.execute(new Runnable() {\n            @Override\n            public void run() {\n              p.dispatch();\n            }\n          });\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pendingBlockToMove, iteration +1\n          noPendingBlockIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n            resetScheduledSize();\n          }\n        }\n\n        // check if time is up or not\n        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
            "oldMethodName": "dispatchBlocks",
            "newMethodName": "dispatchBlocks"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6828. Separate block replica dispatching from Balancer. Contributed by Tsz Wo Nicholas Sze.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616889 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/08/14 2:33 PM",
          "commitName": "c3cf331dc91e2beef2afeed11105084843b02858",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "08/08/14 2:22 PM",
          "commitNameOld": "05d1bf4157e6660610f11951845e59899260596e",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,56 +1,58 @@\n     private void dispatchBlocks() {\n-      long startTime \u003d Time.now();\n-      long scheduledSize \u003d getScheduledSize();\n-      this.blocksToReceive \u003d 2*scheduledSize;\n+      final long startTime \u003d Time.monotonicNow();\n+      this.blocksToReceive \u003d 2 * getScheduledSize();\n       boolean isTimeUp \u003d false;\n       int noPendingBlockIteration \u003d 0;\n-      while(!isTimeUp \u0026\u0026 getScheduledSize()\u003e0 \u0026\u0026\n-          (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n-        PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n-        if (pendingBlock !\u003d null) {\n+      while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n+          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n+        final PendingMove p \u003d chooseNextMove();\n+        if (p !\u003d null) {\n           // move the block\n-          pendingBlock.scheduleBlockMove();\n+          moveExecutor.execute(new Runnable() {\n+            @Override\n+            public void run() {\n+              p.dispatch();\n+            }\n+          });\n           continue;\n         }\n-        \n-        /* Since we can not schedule any block to move,\n-         * filter any moved blocks from the source block list and\n-         * check if we should fetch more blocks from the namenode\n-         */\n-        filterMovedBlocks(); // filter already moved blocks\n+\n+        // Since we cannot schedule any block to move,\n+        // remove any moved blocks from the source block list and\n+        removeMovedBlocks(); // filter already moved blocks\n+        // check if we should fetch more blocks from the namenode\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             blocksToReceive -\u003d getBlockList();\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting block list\", e);\n             return;\n           }\n         } else {\n           // source node cannot find a pendingBlockToMove, iteration +1\n           noPendingBlockIteration++;\n           // in case no blocks can be moved for source node\u0027s task,\n           // jump out of while-loop after 5 iterations.\n-          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_BLOCK_ITERATIONS) {\n+          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n             resetScheduledSize();\n           }\n         }\n-        \n+\n         // check if time is up or not\n-        if (Time.now()-startTime \u003e MAX_ITERATION_TIME) {\n+        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n           isTimeUp \u003d true;\n           continue;\n         }\n-        \n-        /* Now we can not schedule any block to move and there are\n-         * no new blocks added to the source block list, so we wait. \n-         */\n+\n+        // Now we can not schedule any block to move and there are\n+        // no new blocks added to the source block list, so we wait.\n         try {\n-          synchronized(Balancer.this) {\n-            Balancer.this.wait(1000);  // wait for targets/sources to be idle\n+          synchronized (Dispatcher.this) {\n+            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void dispatchBlocks() {\n      final long startTime \u003d Time.monotonicNow();\n      this.blocksToReceive \u003d 2 * getScheduledSize();\n      boolean isTimeUp \u003d false;\n      int noPendingBlockIteration \u003d 0;\n      while (!isTimeUp \u0026\u0026 getScheduledSize() \u003e 0\n          \u0026\u0026 (!srcBlocks.isEmpty() || blocksToReceive \u003e 0)) {\n        final PendingMove p \u003d chooseNextMove();\n        if (p !\u003d null) {\n          // move the block\n          moveExecutor.execute(new Runnable() {\n            @Override\n            public void run() {\n              p.dispatch();\n            }\n          });\n          continue;\n        }\n\n        // Since we cannot schedule any block to move,\n        // remove any moved blocks from the source block list and\n        removeMovedBlocks(); // filter already moved blocks\n        // check if we should fetch more blocks from the namenode\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pendingBlockToMove, iteration +1\n          noPendingBlockIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_MOVE_ITERATIONS) {\n            resetScheduledSize();\n          }\n        }\n\n        // check if time is up or not\n        if (Time.monotonicNow() - startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n\n        // Now we can not schedule any block to move and there are\n        // no new blocks added to the source block list, so we wait.\n        try {\n          synchronized (Dispatcher.this) {\n            Dispatcher.this.wait(1000); // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Dispatcher.java",
          "extendedDetails": {}
        }
      ]
    },
    "b8597e6a10b2e8df1bee4e8ce0c8be345f7e007d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6685. Balancer should preserve storage type of replicas.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615015 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/07/14 6:05 PM",
      "commitName": "b8597e6a10b2e8df1bee4e8ce0c8be345f7e007d",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "30/07/14 11:02 PM",
      "commitNameOld": "b8b8f3f5e7214d6fcfc30e1b94ff097e52868f4f",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n     private void dispatchBlocks() {\n       long startTime \u003d Time.now();\n       long scheduledSize \u003d getScheduledSize();\n       this.blocksToReceive \u003d 2*scheduledSize;\n       boolean isTimeUp \u003d false;\n       int noPendingBlockIteration \u003d 0;\n       while(!isTimeUp \u0026\u0026 getScheduledSize()\u003e0 \u0026\u0026\n           (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n         PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n         if (pendingBlock !\u003d null) {\n           // move the block\n           pendingBlock.scheduleBlockMove();\n           continue;\n         }\n         \n         /* Since we can not schedule any block to move,\n          * filter any moved blocks from the source block list and\n          * check if we should fetch more blocks from the namenode\n          */\n         filterMovedBlocks(); // filter already moved blocks\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             blocksToReceive -\u003d getBlockList();\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting block list\", e);\n             return;\n           }\n         } else {\n           // source node cannot find a pendingBlockToMove, iteration +1\n           noPendingBlockIteration++;\n           // in case no blocks can be moved for source node\u0027s task,\n           // jump out of while-loop after 5 iterations.\n           if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_BLOCK_ITERATIONS) {\n-            setScheduledSize(0);\n+            resetScheduledSize();\n           }\n         }\n         \n         // check if time is up or not\n         if (Time.now()-startTime \u003e MAX_ITERATION_TIME) {\n           isTimeUp \u003d true;\n           continue;\n         }\n         \n         /* Now we can not schedule any block to move and there are\n          * no new blocks added to the source block list, so we wait. \n          */\n         try {\n           synchronized(Balancer.this) {\n             Balancer.this.wait(1000);  // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      long startTime \u003d Time.now();\n      long scheduledSize \u003d getScheduledSize();\n      this.blocksToReceive \u003d 2*scheduledSize;\n      boolean isTimeUp \u003d false;\n      int noPendingBlockIteration \u003d 0;\n      while(!isTimeUp \u0026\u0026 getScheduledSize()\u003e0 \u0026\u0026\n          (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n        PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n        if (pendingBlock !\u003d null) {\n          // move the block\n          pendingBlock.scheduleBlockMove();\n          continue;\n        }\n        \n        /* Since we can not schedule any block to move,\n         * filter any moved blocks from the source block list and\n         * check if we should fetch more blocks from the namenode\n         */\n        filterMovedBlocks(); // filter already moved blocks\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pendingBlockToMove, iteration +1\n          noPendingBlockIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_BLOCK_ITERATIONS) {\n            resetScheduledSize();\n          }\n        }\n        \n        // check if time is up or not\n        if (Time.now()-startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n        \n        /* Now we can not schedule any block to move and there are\n         * no new blocks added to the source block list, so we wait. \n         */\n        try {\n          synchronized(Balancer.this) {\n            Balancer.this.wait(1000);  // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "1ba58e2e2c7778d7c44ba6cd72ac4aa0f288ded8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4376. Fix race conditions in Balancer.  Contributed by Junping Du\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1532932 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/10/13 4:06 PM",
      "commitName": "1ba58e2e2c7778d7c44ba6cd72ac4aa0f288ded8",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "16/07/13 7:04 AM",
      "commitNameOld": "2d6049f1d683529c9e6372f33ee9b91fcfdbd3bd",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 92.38,
      "commitsBetweenForRepo": 584,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,56 @@\n     private void dispatchBlocks() {\n       long startTime \u003d Time.now();\n+      long scheduledSize \u003d getScheduledSize();\n       this.blocksToReceive \u003d 2*scheduledSize;\n       boolean isTimeUp \u003d false;\n       int noPendingBlockIteration \u003d 0;\n-      while(!isTimeUp \u0026\u0026 scheduledSize\u003e0 \u0026\u0026\n+      while(!isTimeUp \u0026\u0026 getScheduledSize()\u003e0 \u0026\u0026\n           (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n         PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n         if (pendingBlock !\u003d null) {\n           // move the block\n           pendingBlock.scheduleBlockMove();\n           continue;\n         }\n         \n         /* Since we can not schedule any block to move,\n          * filter any moved blocks from the source block list and\n          * check if we should fetch more blocks from the namenode\n          */\n         filterMovedBlocks(); // filter already moved blocks\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             blocksToReceive -\u003d getBlockList();\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting block list\", e);\n             return;\n           }\n         } else {\n           // source node cannot find a pendingBlockToMove, iteration +1\n           noPendingBlockIteration++;\n           // in case no blocks can be moved for source node\u0027s task,\n           // jump out of while-loop after 5 iterations.\n           if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_BLOCK_ITERATIONS) {\n-            scheduledSize \u003d 0;\n+            setScheduledSize(0);\n           }\n         }\n         \n         // check if time is up or not\n         if (Time.now()-startTime \u003e MAX_ITERATION_TIME) {\n           isTimeUp \u003d true;\n           continue;\n         }\n         \n         /* Now we can not schedule any block to move and there are\n          * no new blocks added to the source block list, so we wait. \n          */\n         try {\n           synchronized(Balancer.this) {\n             Balancer.this.wait(1000);  // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      long startTime \u003d Time.now();\n      long scheduledSize \u003d getScheduledSize();\n      this.blocksToReceive \u003d 2*scheduledSize;\n      boolean isTimeUp \u003d false;\n      int noPendingBlockIteration \u003d 0;\n      while(!isTimeUp \u0026\u0026 getScheduledSize()\u003e0 \u0026\u0026\n          (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n        PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n        if (pendingBlock !\u003d null) {\n          // move the block\n          pendingBlock.scheduleBlockMove();\n          continue;\n        }\n        \n        /* Since we can not schedule any block to move,\n         * filter any moved blocks from the source block list and\n         * check if we should fetch more blocks from the namenode\n         */\n        filterMovedBlocks(); // filter already moved blocks\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pendingBlockToMove, iteration +1\n          noPendingBlockIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_BLOCK_ITERATIONS) {\n            setScheduledSize(0);\n          }\n        }\n        \n        // check if time is up or not\n        if (Time.now()-startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n        \n        /* Now we can not schedule any block to move and there are\n         * no new blocks added to the source block list, so we wait. \n         */\n        try {\n          synchronized(Balancer.this) {\n            Balancer.this.wait(1000);  // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "be5509c53743a0beddda3f5798e72b919e797bd0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4382. Fix typo MAX_NOT_CHANGED_INTERATIONS. Contributed by Ted Yu.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1431726 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/13 3:20 PM",
      "commitName": "be5509c53743a0beddda3f5798e72b919e797bd0",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "09/01/13 1:20 PM",
      "commitNameOld": "3cd17b614e9436d06cd9b4ccc5f9cf59fbe1cf21",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n     private void dispatchBlocks() {\n       long startTime \u003d Time.now();\n       this.blocksToReceive \u003d 2*scheduledSize;\n       boolean isTimeUp \u003d false;\n       int noPendingBlockIteration \u003d 0;\n       while(!isTimeUp \u0026\u0026 scheduledSize\u003e0 \u0026\u0026\n           (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n         PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n         if (pendingBlock !\u003d null) {\n           // move the block\n           pendingBlock.scheduleBlockMove();\n           continue;\n         }\n         \n         /* Since we can not schedule any block to move,\n          * filter any moved blocks from the source block list and\n          * check if we should fetch more blocks from the namenode\n          */\n         filterMovedBlocks(); // filter already moved blocks\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             blocksToReceive -\u003d getBlockList();\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting block list\", e);\n             return;\n           }\n         } else {\n           // source node cannot find a pendingBlockToMove, iteration +1\n           noPendingBlockIteration++;\n           // in case no blocks can be moved for source node\u0027s task,\n           // jump out of while-loop after 5 iterations.\n-          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_BLOCK_INTERATIONS) {\n+          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_BLOCK_ITERATIONS) {\n             scheduledSize \u003d 0;\n           }\n         }\n         \n         // check if time is up or not\n         if (Time.now()-startTime \u003e MAX_ITERATION_TIME) {\n           isTimeUp \u003d true;\n           continue;\n         }\n         \n         /* Now we can not schedule any block to move and there are\n          * no new blocks added to the source block list, so we wait. \n          */\n         try {\n           synchronized(Balancer.this) {\n             Balancer.this.wait(1000);  // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      long startTime \u003d Time.now();\n      this.blocksToReceive \u003d 2*scheduledSize;\n      boolean isTimeUp \u003d false;\n      int noPendingBlockIteration \u003d 0;\n      while(!isTimeUp \u0026\u0026 scheduledSize\u003e0 \u0026\u0026\n          (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n        PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n        if (pendingBlock !\u003d null) {\n          // move the block\n          pendingBlock.scheduleBlockMove();\n          continue;\n        }\n        \n        /* Since we can not schedule any block to move,\n         * filter any moved blocks from the source block list and\n         * check if we should fetch more blocks from the namenode\n         */\n        filterMovedBlocks(); // filter already moved blocks\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pendingBlockToMove, iteration +1\n          noPendingBlockIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_BLOCK_ITERATIONS) {\n            scheduledSize \u003d 0;\n          }\n        }\n        \n        // check if time is up or not\n        if (Time.now()-startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n        \n        /* Now we can not schedule any block to move and there are\n         * no new blocks added to the source block list, so we wait. \n         */\n        try {\n          synchronized(Balancer.this) {\n            Balancer.this.wait(1000);  // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "eae2a304624ee6caaa8591999752be2bba2b89e0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4261. Fix bugs in Balaner causing infinite loop and TestBalancerWithNodeGroup timeing out.  Contributed by Junping Du\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430917 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/13 7:55 AM",
      "commitName": "eae2a304624ee6caaa8591999752be2bba2b89e0",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "08/01/13 1:05 PM",
      "commitNameOld": "5cdb7e5ce7f0c3129749be8f29e2f11c0e0f2269",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.78,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,55 @@\n     private void dispatchBlocks() {\n       long startTime \u003d Time.now();\n       this.blocksToReceive \u003d 2*scheduledSize;\n       boolean isTimeUp \u003d false;\n+      int noPendingBlockIteration \u003d 0;\n       while(!isTimeUp \u0026\u0026 scheduledSize\u003e0 \u0026\u0026\n           (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n         PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n         if (pendingBlock !\u003d null) {\n           // move the block\n           pendingBlock.scheduleBlockMove();\n           continue;\n         }\n         \n         /* Since we can not schedule any block to move,\n          * filter any moved blocks from the source block list and\n          * check if we should fetch more blocks from the namenode\n          */\n         filterMovedBlocks(); // filter already moved blocks\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             blocksToReceive -\u003d getBlockList();\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting block list\", e);\n             return;\n           }\n-        } \n+        } else {\n+          // source node cannot find a pendingBlockToMove, iteration +1\n+          noPendingBlockIteration++;\n+          // in case no blocks can be moved for source node\u0027s task,\n+          // jump out of while-loop after 5 iterations.\n+          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_BLOCK_INTERATIONS) {\n+            scheduledSize \u003d 0;\n+          }\n+        }\n         \n         // check if time is up or not\n         if (Time.now()-startTime \u003e MAX_ITERATION_TIME) {\n           isTimeUp \u003d true;\n           continue;\n         }\n         \n         /* Now we can not schedule any block to move and there are\n          * no new blocks added to the source block list, so we wait. \n          */\n         try {\n           synchronized(Balancer.this) {\n             Balancer.this.wait(1000);  // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      long startTime \u003d Time.now();\n      this.blocksToReceive \u003d 2*scheduledSize;\n      boolean isTimeUp \u003d false;\n      int noPendingBlockIteration \u003d 0;\n      while(!isTimeUp \u0026\u0026 scheduledSize\u003e0 \u0026\u0026\n          (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n        PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n        if (pendingBlock !\u003d null) {\n          // move the block\n          pendingBlock.scheduleBlockMove();\n          continue;\n        }\n        \n        /* Since we can not schedule any block to move,\n         * filter any moved blocks from the source block list and\n         * check if we should fetch more blocks from the namenode\n         */\n        filterMovedBlocks(); // filter already moved blocks\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } else {\n          // source node cannot find a pendingBlockToMove, iteration +1\n          noPendingBlockIteration++;\n          // in case no blocks can be moved for source node\u0027s task,\n          // jump out of while-loop after 5 iterations.\n          if (noPendingBlockIteration \u003e\u003d MAX_NO_PENDING_BLOCK_INTERATIONS) {\n            scheduledSize \u003d 0;\n          }\n        }\n        \n        // check if time is up or not\n        if (Time.now()-startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n        \n        /* Now we can not schedule any block to move and there are\n         * no new blocks added to the source block list, so we wait. \n         */\n        try {\n          synchronized(Balancer.this) {\n            Balancer.this.wait(1000);  // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3641. Move server Util time methods to common and use now instead of System#currentTimeMillis. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1360858 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 12:01 PM",
      "commitName": "4a5ba3b7bd2360fd9605863630b477d362874e1e",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "08/07/12 11:39 AM",
      "commitNameOld": "07295260b10cd2376660a673ceb9d8ce0570b528",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 4.02,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n     private void dispatchBlocks() {\n-      long startTime \u003d Util.now();\n+      long startTime \u003d Time.now();\n       this.blocksToReceive \u003d 2*scheduledSize;\n       boolean isTimeUp \u003d false;\n       while(!isTimeUp \u0026\u0026 scheduledSize\u003e0 \u0026\u0026\n           (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n         PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n         if (pendingBlock !\u003d null) {\n           // move the block\n           pendingBlock.scheduleBlockMove();\n           continue;\n         }\n         \n         /* Since we can not schedule any block to move,\n          * filter any moved blocks from the source block list and\n          * check if we should fetch more blocks from the namenode\n          */\n         filterMovedBlocks(); // filter already moved blocks\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             blocksToReceive -\u003d getBlockList();\n             continue;\n           } catch (IOException e) {\n             LOG.warn(\"Exception while getting block list\", e);\n             return;\n           }\n         } \n         \n         // check if time is up or not\n-        if (Util.now()-startTime \u003e MAX_ITERATION_TIME) {\n+        if (Time.now()-startTime \u003e MAX_ITERATION_TIME) {\n           isTimeUp \u003d true;\n           continue;\n         }\n         \n         /* Now we can not schedule any block to move and there are\n          * no new blocks added to the source block list, so we wait. \n          */\n         try {\n           synchronized(Balancer.this) {\n             Balancer.this.wait(1000);  // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      long startTime \u003d Time.now();\n      this.blocksToReceive \u003d 2*scheduledSize;\n      boolean isTimeUp \u003d false;\n      while(!isTimeUp \u0026\u0026 scheduledSize\u003e0 \u0026\u0026\n          (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n        PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n        if (pendingBlock !\u003d null) {\n          // move the block\n          pendingBlock.scheduleBlockMove();\n          continue;\n        }\n        \n        /* Since we can not schedule any block to move,\n         * filter any moved blocks from the source block list and\n         * check if we should fetch more blocks from the namenode\n         */\n        filterMovedBlocks(); // filter already moved blocks\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } \n        \n        // check if time is up or not\n        if (Time.now()-startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n        \n        /* Now we can not schedule any block to move and there are\n         * no new blocks added to the source block list, so we wait. \n         */\n        try {\n          synchronized(Balancer.this) {\n            Balancer.this.wait(1000);  // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void dispatchBlocks() {\n      long startTime \u003d Util.now();\n      this.blocksToReceive \u003d 2*scheduledSize;\n      boolean isTimeUp \u003d false;\n      while(!isTimeUp \u0026\u0026 scheduledSize\u003e0 \u0026\u0026\n          (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n        PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n        if (pendingBlock !\u003d null) {\n          // move the block\n          pendingBlock.scheduleBlockMove();\n          continue;\n        }\n        \n        /* Since we can not schedule any block to move,\n         * filter any moved blocks from the source block list and\n         * check if we should fetch more blocks from the namenode\n         */\n        filterMovedBlocks(); // filter already moved blocks\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } \n        \n        // check if time is up or not\n        if (Util.now()-startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n        \n        /* Now we can not schedule any block to move and there are\n         * no new blocks added to the source block list, so we wait. \n         */\n        try {\n          synchronized(Balancer.this) {\n            Balancer.this.wait(1000);  // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void dispatchBlocks() {\n      long startTime \u003d Util.now();\n      this.blocksToReceive \u003d 2*scheduledSize;\n      boolean isTimeUp \u003d false;\n      while(!isTimeUp \u0026\u0026 scheduledSize\u003e0 \u0026\u0026\n          (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n        PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n        if (pendingBlock !\u003d null) {\n          // move the block\n          pendingBlock.scheduleBlockMove();\n          continue;\n        }\n        \n        /* Since we can not schedule any block to move,\n         * filter any moved blocks from the source block list and\n         * check if we should fetch more blocks from the namenode\n         */\n        filterMovedBlocks(); // filter already moved blocks\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } \n        \n        // check if time is up or not\n        if (Util.now()-startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n        \n        /* Now we can not schedule any block to move and there are\n         * no new blocks added to the source block list, so we wait. \n         */\n        try {\n          synchronized(Balancer.this) {\n            Balancer.this.wait(1000);  // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java"
      }
    },
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1977. Stop using StringUtils.stringifyException(). Contributed by Bharath Mundlapudi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1145834 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/11 6:11 PM",
      "commitName": "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "28/06/11 6:31 PM",
      "commitNameOld": "09b6f98de431628c80bc8a6faf0070eeaf72ff2a",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 13.99,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n     private void dispatchBlocks() {\n       long startTime \u003d Util.now();\n       this.blocksToReceive \u003d 2*scheduledSize;\n       boolean isTimeUp \u003d false;\n       while(!isTimeUp \u0026\u0026 scheduledSize\u003e0 \u0026\u0026\n           (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n         PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n         if (pendingBlock !\u003d null) {\n           // move the block\n           pendingBlock.scheduleBlockMove();\n           continue;\n         }\n         \n         /* Since we can not schedule any block to move,\n          * filter any moved blocks from the source block list and\n          * check if we should fetch more blocks from the namenode\n          */\n         filterMovedBlocks(); // filter already moved blocks\n         if (shouldFetchMoreBlocks()) {\n           // fetch new blocks\n           try {\n             blocksToReceive -\u003d getBlockList();\n             continue;\n           } catch (IOException e) {\n-            LOG.warn(StringUtils.stringifyException(e));\n+            LOG.warn(\"Exception while getting block list\", e);\n             return;\n           }\n         } \n         \n         // check if time is up or not\n         if (Util.now()-startTime \u003e MAX_ITERATION_TIME) {\n           isTimeUp \u003d true;\n           continue;\n         }\n         \n         /* Now we can not schedule any block to move and there are\n          * no new blocks added to the source block list, so we wait. \n          */\n         try {\n           synchronized(Balancer.this) {\n             Balancer.this.wait(1000);  // wait for targets/sources to be idle\n           }\n         } catch (InterruptedException ignored) {\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      long startTime \u003d Util.now();\n      this.blocksToReceive \u003d 2*scheduledSize;\n      boolean isTimeUp \u003d false;\n      while(!isTimeUp \u0026\u0026 scheduledSize\u003e0 \u0026\u0026\n          (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n        PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n        if (pendingBlock !\u003d null) {\n          // move the block\n          pendingBlock.scheduleBlockMove();\n          continue;\n        }\n        \n        /* Since we can not schedule any block to move,\n         * filter any moved blocks from the source block list and\n         * check if we should fetch more blocks from the namenode\n         */\n        filterMovedBlocks(); // filter already moved blocks\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(\"Exception while getting block list\", e);\n            return;\n          }\n        } \n        \n        // check if time is up or not\n        if (Util.now()-startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n        \n        /* Now we can not schedule any block to move and there are\n         * no new blocks added to the source block list, so we wait. \n         */\n        try {\n          synchronized(Balancer.this) {\n            Balancer.this.wait(1000);  // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,46 @@\n+    private void dispatchBlocks() {\n+      long startTime \u003d Util.now();\n+      this.blocksToReceive \u003d 2*scheduledSize;\n+      boolean isTimeUp \u003d false;\n+      while(!isTimeUp \u0026\u0026 scheduledSize\u003e0 \u0026\u0026\n+          (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n+        PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n+        if (pendingBlock !\u003d null) {\n+          // move the block\n+          pendingBlock.scheduleBlockMove();\n+          continue;\n+        }\n+        \n+        /* Since we can not schedule any block to move,\n+         * filter any moved blocks from the source block list and\n+         * check if we should fetch more blocks from the namenode\n+         */\n+        filterMovedBlocks(); // filter already moved blocks\n+        if (shouldFetchMoreBlocks()) {\n+          // fetch new blocks\n+          try {\n+            blocksToReceive -\u003d getBlockList();\n+            continue;\n+          } catch (IOException e) {\n+            LOG.warn(StringUtils.stringifyException(e));\n+            return;\n+          }\n+        } \n+        \n+        // check if time is up or not\n+        if (Util.now()-startTime \u003e MAX_ITERATION_TIME) {\n+          isTimeUp \u003d true;\n+          continue;\n+        }\n+        \n+        /* Now we can not schedule any block to move and there are\n+         * no new blocks added to the source block list, so we wait. \n+         */\n+        try {\n+          synchronized(Balancer.this) {\n+            Balancer.this.wait(1000);  // wait for targets/sources to be idle\n+          }\n+        } catch (InterruptedException ignored) {\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void dispatchBlocks() {\n      long startTime \u003d Util.now();\n      this.blocksToReceive \u003d 2*scheduledSize;\n      boolean isTimeUp \u003d false;\n      while(!isTimeUp \u0026\u0026 scheduledSize\u003e0 \u0026\u0026\n          (!srcBlockList.isEmpty() || blocksToReceive\u003e0)) {\n        PendingBlockMove pendingBlock \u003d chooseNextBlockToMove();\n        if (pendingBlock !\u003d null) {\n          // move the block\n          pendingBlock.scheduleBlockMove();\n          continue;\n        }\n        \n        /* Since we can not schedule any block to move,\n         * filter any moved blocks from the source block list and\n         * check if we should fetch more blocks from the namenode\n         */\n        filterMovedBlocks(); // filter already moved blocks\n        if (shouldFetchMoreBlocks()) {\n          // fetch new blocks\n          try {\n            blocksToReceive -\u003d getBlockList();\n            continue;\n          } catch (IOException e) {\n            LOG.warn(StringUtils.stringifyException(e));\n            return;\n          }\n        } \n        \n        // check if time is up or not\n        if (Util.now()-startTime \u003e MAX_ITERATION_TIME) {\n          isTimeUp \u003d true;\n          continue;\n        }\n        \n        /* Now we can not schedule any block to move and there are\n         * no new blocks added to the source block list, so we wait. \n         */\n        try {\n          synchronized(Balancer.this) {\n            Balancer.this.wait(1000);  // wait for targets/sources to be idle\n          }\n        } catch (InterruptedException ignored) {\n        }\n      }\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/balancer/Balancer.java"
    }
  }
}