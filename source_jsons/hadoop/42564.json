{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NodesListManager.java",
  "functionName": "handle",
  "functionId": "handle___event-NodesListManagerEvent",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java",
  "functionStartLine": 523,
  "functionEndLine": 550,
  "numCommitsSeen": 38,
  "timeTaken": 3804,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "b46ca7e73b8bac3fdbff0b13afe009308078acf2",
    "223ce323bb81463ec5c5ac7316738370d4a47366",
    "bcc85e3bab78bcacd430eac23141774465b96ef9",
    "32e490b6c035487e99df30ce80366446fe09bd6c",
    "990dcae7174f781483d1688319674e9cb4ccb960",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "606114d6029758f2be130960b8fc3102457406ba"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "b46ca7e73b8bac3fdbff0b13afe009308078acf2": "Ybodychange",
    "223ce323bb81463ec5c5ac7316738370d4a47366": "Ybodychange",
    "bcc85e3bab78bcacd430eac23141774465b96ef9": "Ybodychange",
    "32e490b6c035487e99df30ce80366446fe09bd6c": "Ybodychange",
    "990dcae7174f781483d1688319674e9cb4ccb960": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "606114d6029758f2be130960b8fc3102457406ba": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 10.76,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n   public void handle(NodesListManagerEvent event) {\n     RMNode eventNode \u003d event.getNode();\n     switch (event.getType()) {\n     case NODE_UNUSABLE:\n-      LOG.debug(eventNode + \" reported unusable\");\n+      LOG.debug(\"{} reported unusable\", eventNode);\n       sendRMAppNodeUpdateEventToNonFinalizedApps(eventNode,\n           RMAppNodeUpdateType.NODE_UNUSABLE);\n       break;\n     case NODE_USABLE:\n-      LOG.debug(eventNode + \" reported usable\");\n+      LOG.debug(\"{} reported usable\", eventNode);\n       sendRMAppNodeUpdateEventToNonFinalizedApps(eventNode,\n           RMAppNodeUpdateType.NODE_USABLE);\n       break;\n     case NODE_DECOMMISSIONING:\n-      LOG.debug(eventNode + \" reported decommissioning\");\n+      LOG.debug(\"{} reported decommissioning\", eventNode);\n       sendRMAppNodeUpdateEventToNonFinalizedApps(\n           eventNode, RMAppNodeUpdateType.NODE_DECOMMISSIONING);\n       break;\n \n     default:\n       LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n     }\n     // remove the cache of normalized hostname if enabled\n     if (resolver instanceof CachedResolver) {\n       ((CachedResolver)resolver).removeFromCache(\n           eventNode.getNodeID().getHost());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(NodesListManagerEvent event) {\n    RMNode eventNode \u003d event.getNode();\n    switch (event.getType()) {\n    case NODE_UNUSABLE:\n      LOG.debug(\"{} reported unusable\", eventNode);\n      sendRMAppNodeUpdateEventToNonFinalizedApps(eventNode,\n          RMAppNodeUpdateType.NODE_UNUSABLE);\n      break;\n    case NODE_USABLE:\n      LOG.debug(\"{} reported usable\", eventNode);\n      sendRMAppNodeUpdateEventToNonFinalizedApps(eventNode,\n          RMAppNodeUpdateType.NODE_USABLE);\n      break;\n    case NODE_DECOMMISSIONING:\n      LOG.debug(\"{} reported decommissioning\", eventNode);\n      sendRMAppNodeUpdateEventToNonFinalizedApps(\n          eventNode, RMAppNodeUpdateType.NODE_DECOMMISSIONING);\n      break;\n\n    default:\n      LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n    }\n    // remove the cache of normalized hostname if enabled\n    if (resolver instanceof CachedResolver) {\n      ((CachedResolver)resolver).removeFromCache(\n          eventNode.getNodeID().getHost());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java",
      "extendedDetails": {}
    },
    "b46ca7e73b8bac3fdbff0b13afe009308078acf2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6483. Add nodes transitioning to DECOMMISSIONING state to the list of updated nodes returned to the AM. (Juan Rodriguez Hortala via asuresh)\n",
      "commitDate": "22/11/17 7:18 PM",
      "commitName": "b46ca7e73b8bac3fdbff0b13afe009308078acf2",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "16/05/17 7:57 PM",
      "commitNameOld": "d87a63a9019d74a1c338c724e050952843a153e5",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 190.01,
      "commitsBetweenForRepo": 1400,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,28 @@\n   public void handle(NodesListManagerEvent event) {\n     RMNode eventNode \u003d event.getNode();\n     switch (event.getType()) {\n     case NODE_UNUSABLE:\n       LOG.debug(eventNode + \" reported unusable\");\n-      for(RMApp app: rmContext.getRMApps().values()) {\n-        if (!app.isAppFinalStateStored()) {\n-          this.rmContext\n-              .getDispatcher()\n-              .getEventHandler()\n-              .handle(\n-                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n-                      RMAppNodeUpdateType.NODE_UNUSABLE));\n-        }\n-      }\n+      sendRMAppNodeUpdateEventToNonFinalizedApps(eventNode,\n+          RMAppNodeUpdateType.NODE_UNUSABLE);\n       break;\n     case NODE_USABLE:\n       LOG.debug(eventNode + \" reported usable\");\n-      for (RMApp app : rmContext.getRMApps().values()) {\n-        if (!app.isAppFinalStateStored()) {\n-          this.rmContext\n-              .getDispatcher()\n-              .getEventHandler()\n-              .handle(\n-                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n-                      RMAppNodeUpdateType.NODE_USABLE));\n-        }\n-      }\n+      sendRMAppNodeUpdateEventToNonFinalizedApps(eventNode,\n+          RMAppNodeUpdateType.NODE_USABLE);\n       break;\n+    case NODE_DECOMMISSIONING:\n+      LOG.debug(eventNode + \" reported decommissioning\");\n+      sendRMAppNodeUpdateEventToNonFinalizedApps(\n+          eventNode, RMAppNodeUpdateType.NODE_DECOMMISSIONING);\n+      break;\n+\n     default:\n       LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n     }\n     // remove the cache of normalized hostname if enabled\n     if (resolver instanceof CachedResolver) {\n       ((CachedResolver)resolver).removeFromCache(\n           eventNode.getNodeID().getHost());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(NodesListManagerEvent event) {\n    RMNode eventNode \u003d event.getNode();\n    switch (event.getType()) {\n    case NODE_UNUSABLE:\n      LOG.debug(eventNode + \" reported unusable\");\n      sendRMAppNodeUpdateEventToNonFinalizedApps(eventNode,\n          RMAppNodeUpdateType.NODE_UNUSABLE);\n      break;\n    case NODE_USABLE:\n      LOG.debug(eventNode + \" reported usable\");\n      sendRMAppNodeUpdateEventToNonFinalizedApps(eventNode,\n          RMAppNodeUpdateType.NODE_USABLE);\n      break;\n    case NODE_DECOMMISSIONING:\n      LOG.debug(eventNode + \" reported decommissioning\");\n      sendRMAppNodeUpdateEventToNonFinalizedApps(\n          eventNode, RMAppNodeUpdateType.NODE_DECOMMISSIONING);\n      break;\n\n    default:\n      LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n    }\n    // remove the cache of normalized hostname if enabled\n    if (resolver instanceof CachedResolver) {\n      ((CachedResolver)resolver).removeFromCache(\n          eventNode.getNodeID().getHost());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java",
      "extendedDetails": {}
    },
    "223ce323bb81463ec5c5ac7316738370d4a47366": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1382. Remove unusableRMNodesConcurrentSet (never used) in NodeListManager to get rid of memory leak. Contributed by Rohith Sharma K S.\n",
      "commitDate": "30/12/15 7:52 AM",
      "commitName": "223ce323bb81463ec5c5ac7316738370d4a47366",
      "commitAuthor": "Junping Du",
      "commitDateOld": "18/09/15 10:04 AM",
      "commitNameOld": "9bc913a35c46e65d373c3ae3f01a377e16e8d0ca",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 102.95,
      "commitsBetweenForRepo": 724,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,38 @@\n   public void handle(NodesListManagerEvent event) {\n     RMNode eventNode \u003d event.getNode();\n     switch (event.getType()) {\n     case NODE_UNUSABLE:\n       LOG.debug(eventNode + \" reported unusable\");\n-      unusableRMNodesConcurrentSet.add(eventNode);\n       for(RMApp app: rmContext.getRMApps().values()) {\n         if (!app.isAppFinalStateStored()) {\n           this.rmContext\n               .getDispatcher()\n               .getEventHandler()\n               .handle(\n                   new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                       RMAppNodeUpdateType.NODE_UNUSABLE));\n         }\n       }\n       break;\n     case NODE_USABLE:\n-      if (unusableRMNodesConcurrentSet.contains(eventNode)) {\n-        LOG.debug(eventNode + \" reported usable\");\n-        unusableRMNodesConcurrentSet.remove(eventNode);\n-      }\n+      LOG.debug(eventNode + \" reported usable\");\n       for (RMApp app : rmContext.getRMApps().values()) {\n         if (!app.isAppFinalStateStored()) {\n           this.rmContext\n               .getDispatcher()\n               .getEventHandler()\n               .handle(\n                   new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                       RMAppNodeUpdateType.NODE_USABLE));\n         }\n       }\n       break;\n     default:\n       LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n     }\n     // remove the cache of normalized hostname if enabled\n     if (resolver instanceof CachedResolver) {\n       ((CachedResolver)resolver).removeFromCache(\n           eventNode.getNodeID().getHost());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(NodesListManagerEvent event) {\n    RMNode eventNode \u003d event.getNode();\n    switch (event.getType()) {\n    case NODE_UNUSABLE:\n      LOG.debug(eventNode + \" reported unusable\");\n      for(RMApp app: rmContext.getRMApps().values()) {\n        if (!app.isAppFinalStateStored()) {\n          this.rmContext\n              .getDispatcher()\n              .getEventHandler()\n              .handle(\n                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                      RMAppNodeUpdateType.NODE_UNUSABLE));\n        }\n      }\n      break;\n    case NODE_USABLE:\n      LOG.debug(eventNode + \" reported usable\");\n      for (RMApp app : rmContext.getRMApps().values()) {\n        if (!app.isAppFinalStateStored()) {\n          this.rmContext\n              .getDispatcher()\n              .getEventHandler()\n              .handle(\n                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                      RMAppNodeUpdateType.NODE_USABLE));\n        }\n      }\n      break;\n    default:\n      LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n    }\n    // remove the cache of normalized hostname if enabled\n    if (resolver instanceof CachedResolver) {\n      ((CachedResolver)resolver).removeFromCache(\n          eventNode.getNodeID().getHost());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java",
      "extendedDetails": {}
    },
    "bcc85e3bab78bcacd430eac23141774465b96ef9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4024. YARN RM should avoid unnecessary resolving IP when NMs doing heartbeat. (Hong Zhiguo via wangda)\n",
      "commitDate": "04/09/15 3:13 PM",
      "commitName": "bcc85e3bab78bcacd430eac23141774465b96ef9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "31/07/15 10:37 AM",
      "commitNameOld": "32e490b6c035487e99df30ce80366446fe09bd6c",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 35.19,
      "commitsBetweenForRepo": 191,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,42 @@\n   public void handle(NodesListManagerEvent event) {\n     RMNode eventNode \u003d event.getNode();\n     switch (event.getType()) {\n     case NODE_UNUSABLE:\n       LOG.debug(eventNode + \" reported unusable\");\n       unusableRMNodesConcurrentSet.add(eventNode);\n       for(RMApp app: rmContext.getRMApps().values()) {\n         if (!app.isAppFinalStateStored()) {\n           this.rmContext\n               .getDispatcher()\n               .getEventHandler()\n               .handle(\n                   new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                       RMAppNodeUpdateType.NODE_UNUSABLE));\n         }\n       }\n       break;\n     case NODE_USABLE:\n       if (unusableRMNodesConcurrentSet.contains(eventNode)) {\n         LOG.debug(eventNode + \" reported usable\");\n         unusableRMNodesConcurrentSet.remove(eventNode);\n       }\n       for (RMApp app : rmContext.getRMApps().values()) {\n         if (!app.isAppFinalStateStored()) {\n           this.rmContext\n               .getDispatcher()\n               .getEventHandler()\n               .handle(\n                   new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                       RMAppNodeUpdateType.NODE_USABLE));\n         }\n       }\n       break;\n     default:\n       LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n     }\n+    // remove the cache of normalized hostname if enabled\n+    if (resolver instanceof CachedResolver) {\n+      ((CachedResolver)resolver).removeFromCache(\n+          eventNode.getNodeID().getHost());\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(NodesListManagerEvent event) {\n    RMNode eventNode \u003d event.getNode();\n    switch (event.getType()) {\n    case NODE_UNUSABLE:\n      LOG.debug(eventNode + \" reported unusable\");\n      unusableRMNodesConcurrentSet.add(eventNode);\n      for(RMApp app: rmContext.getRMApps().values()) {\n        if (!app.isAppFinalStateStored()) {\n          this.rmContext\n              .getDispatcher()\n              .getEventHandler()\n              .handle(\n                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                      RMAppNodeUpdateType.NODE_UNUSABLE));\n        }\n      }\n      break;\n    case NODE_USABLE:\n      if (unusableRMNodesConcurrentSet.contains(eventNode)) {\n        LOG.debug(eventNode + \" reported usable\");\n        unusableRMNodesConcurrentSet.remove(eventNode);\n      }\n      for (RMApp app : rmContext.getRMApps().values()) {\n        if (!app.isAppFinalStateStored()) {\n          this.rmContext\n              .getDispatcher()\n              .getEventHandler()\n              .handle(\n                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                      RMAppNodeUpdateType.NODE_USABLE));\n        }\n      }\n      break;\n    default:\n      LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n    }\n    // remove the cache of normalized hostname if enabled\n    if (resolver instanceof CachedResolver) {\n      ((CachedResolver)resolver).removeFromCache(\n          eventNode.getNodeID().getHost());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java",
      "extendedDetails": {}
    },
    "32e490b6c035487e99df30ce80366446fe09bd6c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3990. AsyncDispatcher may overloaded with RMAppNodeUpdateEvent when Node is connected/disconnected. Contributed by Bibin A Chundatt\n",
      "commitDate": "31/07/15 10:37 AM",
      "commitName": "32e490b6c035487e99df30ce80366446fe09bd6c",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "22/04/15 10:07 AM",
      "commitNameOld": "fad9d7e85b1ba0934ab592daa9d3c9550b2bb501",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 100.02,
      "commitsBetweenForRepo": 809,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,37 @@\n   public void handle(NodesListManagerEvent event) {\n     RMNode eventNode \u003d event.getNode();\n     switch (event.getType()) {\n     case NODE_UNUSABLE:\n       LOG.debug(eventNode + \" reported unusable\");\n       unusableRMNodesConcurrentSet.add(eventNode);\n       for(RMApp app: rmContext.getRMApps().values()) {\n-        this.rmContext\n-            .getDispatcher()\n-            .getEventHandler()\n-            .handle(\n-                new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n-                    RMAppNodeUpdateType.NODE_UNUSABLE));\n+        if (!app.isAppFinalStateStored()) {\n+          this.rmContext\n+              .getDispatcher()\n+              .getEventHandler()\n+              .handle(\n+                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n+                      RMAppNodeUpdateType.NODE_UNUSABLE));\n+        }\n       }\n       break;\n     case NODE_USABLE:\n       if (unusableRMNodesConcurrentSet.contains(eventNode)) {\n         LOG.debug(eventNode + \" reported usable\");\n         unusableRMNodesConcurrentSet.remove(eventNode);\n       }\n       for (RMApp app : rmContext.getRMApps().values()) {\n-        this.rmContext\n-            .getDispatcher()\n-            .getEventHandler()\n-            .handle(\n-                new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n-                    RMAppNodeUpdateType.NODE_USABLE));\n+        if (!app.isAppFinalStateStored()) {\n+          this.rmContext\n+              .getDispatcher()\n+              .getEventHandler()\n+              .handle(\n+                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n+                      RMAppNodeUpdateType.NODE_USABLE));\n+        }\n       }\n       break;\n     default:\n       LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(NodesListManagerEvent event) {\n    RMNode eventNode \u003d event.getNode();\n    switch (event.getType()) {\n    case NODE_UNUSABLE:\n      LOG.debug(eventNode + \" reported unusable\");\n      unusableRMNodesConcurrentSet.add(eventNode);\n      for(RMApp app: rmContext.getRMApps().values()) {\n        if (!app.isAppFinalStateStored()) {\n          this.rmContext\n              .getDispatcher()\n              .getEventHandler()\n              .handle(\n                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                      RMAppNodeUpdateType.NODE_UNUSABLE));\n        }\n      }\n      break;\n    case NODE_USABLE:\n      if (unusableRMNodesConcurrentSet.contains(eventNode)) {\n        LOG.debug(eventNode + \" reported usable\");\n        unusableRMNodesConcurrentSet.remove(eventNode);\n      }\n      for (RMApp app : rmContext.getRMApps().values()) {\n        if (!app.isAppFinalStateStored()) {\n          this.rmContext\n              .getDispatcher()\n              .getEventHandler()\n              .handle(\n                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                      RMAppNodeUpdateType.NODE_USABLE));\n        }\n      }\n      break;\n    default:\n      LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java",
      "extendedDetails": {}
    },
    "990dcae7174f781483d1688319674e9cb4ccb960": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1343. NodeManagers additions/restarts are not reported as node updates in AllocateResponse responses to AMs. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1537368 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/10/13 7:54 PM",
      "commitName": "990dcae7174f781483d1688319674e9cb4ccb960",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "16/06/13 11:39 PM",
      "commitNameOld": "b9efe6bd4a1277b4067ecde715a7713a85968886",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 135.84,
      "commitsBetweenForRepo": 849,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,33 @@\n   public void handle(NodesListManagerEvent event) {\n     RMNode eventNode \u003d event.getNode();\n     switch (event.getType()) {\n     case NODE_UNUSABLE:\n       LOG.debug(eventNode + \" reported unusable\");\n       unusableRMNodesConcurrentSet.add(eventNode);\n       for(RMApp app: rmContext.getRMApps().values()) {\n         this.rmContext\n             .getDispatcher()\n             .getEventHandler()\n             .handle(\n                 new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                     RMAppNodeUpdateType.NODE_UNUSABLE));\n       }\n       break;\n     case NODE_USABLE:\n       if (unusableRMNodesConcurrentSet.contains(eventNode)) {\n         LOG.debug(eventNode + \" reported usable\");\n         unusableRMNodesConcurrentSet.remove(eventNode);\n-        for (RMApp app : rmContext.getRMApps().values()) {\n-          this.rmContext\n-              .getDispatcher()\n-              .getEventHandler()\n-              .handle(\n-                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n-                      RMAppNodeUpdateType.NODE_USABLE));\n-        }\n-      } else {\n-        LOG.warn(eventNode\n-            + \" reported usable without first reporting unusable\");\n+      }\n+      for (RMApp app : rmContext.getRMApps().values()) {\n+        this.rmContext\n+            .getDispatcher()\n+            .getEventHandler()\n+            .handle(\n+                new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n+                    RMAppNodeUpdateType.NODE_USABLE));\n       }\n       break;\n     default:\n       LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(NodesListManagerEvent event) {\n    RMNode eventNode \u003d event.getNode();\n    switch (event.getType()) {\n    case NODE_UNUSABLE:\n      LOG.debug(eventNode + \" reported unusable\");\n      unusableRMNodesConcurrentSet.add(eventNode);\n      for(RMApp app: rmContext.getRMApps().values()) {\n        this.rmContext\n            .getDispatcher()\n            .getEventHandler()\n            .handle(\n                new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                    RMAppNodeUpdateType.NODE_UNUSABLE));\n      }\n      break;\n    case NODE_USABLE:\n      if (unusableRMNodesConcurrentSet.contains(eventNode)) {\n        LOG.debug(eventNode + \" reported usable\");\n        unusableRMNodesConcurrentSet.remove(eventNode);\n      }\n      for (RMApp app : rmContext.getRMApps().values()) {\n        this.rmContext\n            .getDispatcher()\n            .getEventHandler()\n            .handle(\n                new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                    RMAppNodeUpdateType.NODE_USABLE));\n      }\n      break;\n    default:\n      LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void handle(NodesListManagerEvent event) {\n    RMNode eventNode \u003d event.getNode();\n    switch (event.getType()) {\n    case NODE_UNUSABLE:\n      LOG.debug(eventNode + \" reported unusable\");\n      unusableRMNodesConcurrentSet.add(eventNode);\n      for(RMApp app: rmContext.getRMApps().values()) {\n        this.rmContext\n            .getDispatcher()\n            .getEventHandler()\n            .handle(\n                new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                    RMAppNodeUpdateType.NODE_UNUSABLE));\n      }\n      break;\n    case NODE_USABLE:\n      if (unusableRMNodesConcurrentSet.contains(eventNode)) {\n        LOG.debug(eventNode + \" reported usable\");\n        unusableRMNodesConcurrentSet.remove(eventNode);\n        for (RMApp app : rmContext.getRMApps().values()) {\n          this.rmContext\n              .getDispatcher()\n              .getEventHandler()\n              .handle(\n                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                      RMAppNodeUpdateType.NODE_USABLE));\n        }\n      } else {\n        LOG.warn(eventNode\n            + \" reported usable without first reporting unusable\");\n      }\n      break;\n    default:\n      LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java"
      }
    },
    "606114d6029758f2be130960b8fc3102457406ba": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3533. Add a channel between RM and AM to get information on nodes. Contributed by Bikas Saha. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1305230 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/12 10:45 PM",
      "commitName": "606114d6029758f2be130960b8fc3102457406ba",
      "commitAuthor": "Arun Murthy",
      "diff": "@@ -0,0 +1,36 @@\n+  public void handle(NodesListManagerEvent event) {\n+    RMNode eventNode \u003d event.getNode();\n+    switch (event.getType()) {\n+    case NODE_UNUSABLE:\n+      LOG.debug(eventNode + \" reported unusable\");\n+      unusableRMNodesConcurrentSet.add(eventNode);\n+      for(RMApp app: rmContext.getRMApps().values()) {\n+        this.rmContext\n+            .getDispatcher()\n+            .getEventHandler()\n+            .handle(\n+                new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n+                    RMAppNodeUpdateType.NODE_UNUSABLE));\n+      }\n+      break;\n+    case NODE_USABLE:\n+      if (unusableRMNodesConcurrentSet.contains(eventNode)) {\n+        LOG.debug(eventNode + \" reported usable\");\n+        unusableRMNodesConcurrentSet.remove(eventNode);\n+        for (RMApp app : rmContext.getRMApps().values()) {\n+          this.rmContext\n+              .getDispatcher()\n+              .getEventHandler()\n+              .handle(\n+                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n+                      RMAppNodeUpdateType.NODE_USABLE));\n+        }\n+      } else {\n+        LOG.warn(eventNode\n+            + \" reported usable without first reporting unusable\");\n+      }\n+      break;\n+    default:\n+      LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(NodesListManagerEvent event) {\n    RMNode eventNode \u003d event.getNode();\n    switch (event.getType()) {\n    case NODE_UNUSABLE:\n      LOG.debug(eventNode + \" reported unusable\");\n      unusableRMNodesConcurrentSet.add(eventNode);\n      for(RMApp app: rmContext.getRMApps().values()) {\n        this.rmContext\n            .getDispatcher()\n            .getEventHandler()\n            .handle(\n                new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                    RMAppNodeUpdateType.NODE_UNUSABLE));\n      }\n      break;\n    case NODE_USABLE:\n      if (unusableRMNodesConcurrentSet.contains(eventNode)) {\n        LOG.debug(eventNode + \" reported usable\");\n        unusableRMNodesConcurrentSet.remove(eventNode);\n        for (RMApp app : rmContext.getRMApps().values()) {\n          this.rmContext\n              .getDispatcher()\n              .getEventHandler()\n              .handle(\n                  new RMAppNodeUpdateEvent(app.getApplicationId(), eventNode,\n                      RMAppNodeUpdateType.NODE_USABLE));\n        }\n      } else {\n        LOG.warn(eventNode\n            + \" reported usable without first reporting unusable\");\n      }\n      break;\n    default:\n      LOG.error(\"Ignoring invalid eventtype \" + event.getType());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java"
    }
  }
}