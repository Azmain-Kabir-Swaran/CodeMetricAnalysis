{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ViewFileSystemOverloadScheme.java",
  "functionName": "fsGetter",
  "functionId": "fsGetter",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFileSystemOverloadScheme.java",
  "functionStartLine": 133,
  "functionEndLine": 135,
  "numCommitsSeen": 2,
  "timeTaken": 1339,
  "changeHistory": [
    "ac4a2e11d98827c7926a34cda27aa7bcfd3f36c1",
    "9c8236d04dfc3d4cefe7a00b63625f60ee232cfe"
  ],
  "changeHistoryShort": {
    "ac4a2e11d98827c7926a34cda27aa7bcfd3f36c1": "Ybodychange",
    "9c8236d04dfc3d4cefe7a00b63625f60ee232cfe": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ac4a2e11d98827c7926a34cda27aa7bcfd3f36c1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15306. Make mount-table to read from central place ( Let\u0027s say from HDFS). Contributed by Uma Maheswara Rao G.\n\n",
      "commitDate": "14/05/20 5:29 PM",
      "commitName": "ac4a2e11d98827c7926a34cda27aa7bcfd3f36c1",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "04/05/20 5:55 PM",
      "commitNameOld": "9c8236d04dfc3d4cefe7a00b63625f60ee232cfe",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 9.98,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,3 @@\n   protected FsGetter fsGetter() {\n-\n-    return new FsGetter() {\n-      @Override\n-      public FileSystem getNewInstance(URI uri, Configuration conf)\n-          throws IOException {\n-        if (uri.getScheme().equals(getScheme())) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\n-                \"The file system initialized uri scheme is matching with the \"\n-                    + \"given target uri scheme. The target uri is: \" + uri);\n-          }\n-          /*\n-           * Avoid looping when target fs scheme is matching to overloaded\n-           * scheme.\n-           */\n-          return createFileSystem(uri, conf);\n-        } else {\n-          return FileSystem.newInstance(uri, conf);\n-        }\n-      }\n-\n-      /**\n-       * When ViewFileSystemOverloadScheme scheme and target uri scheme are\n-       * matching, it will not take advantage of FileSystem cache as it will\n-       * create instance directly. For caching needs please set\n-       * \"fs.viewfs.enable.inner.cache\" to true.\n-       */\n-      @Override\n-      public FileSystem get(URI uri, Configuration conf) throws IOException {\n-        if (uri.getScheme().equals(getScheme())) {\n-          // Avoid looping when target fs scheme is matching to overloaded\n-          // scheme.\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\n-                \"The file system initialized uri scheme is matching with the \"\n-                    + \"given target uri scheme. So, the target file system \"\n-                    + \"instances will not be cached. To cache fs instances, \"\n-                    + \"please set fs.viewfs.enable.inner.cache to true. \"\n-                    + \"The target uri is: \" + uri);\n-          }\n-          return createFileSystem(uri, conf);\n-        } else {\n-          return FileSystem.get(uri, conf);\n-        }\n-      }\n-\n-      private FileSystem createFileSystem(URI uri, Configuration conf)\n-          throws IOException {\n-        final String fsImplConf \u003d String.format(\n-            FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,\n-            uri.getScheme());\n-        Class\u003c?\u003e clazz \u003d conf.getClass(fsImplConf, null);\n-        if (clazz \u003d\u003d null) {\n-          throw new UnsupportedFileSystemException(\n-              String.format(\"%s\u003dnull: %s: %s\", fsImplConf,\n-                  \"No overload scheme fs configured\", uri.getScheme()));\n-        }\n-        FileSystem fs \u003d (FileSystem) newInstance(clazz, uri, conf);\n-        fs.initialize(uri, conf);\n-        return fs;\n-      }\n-\n-      private \u003cT\u003e T newInstance(Class\u003cT\u003e theClass, URI uri,\n-          Configuration conf) {\n-        T result;\n-        try {\n-          Constructor\u003cT\u003e meth \u003d theClass.getConstructor();\n-          meth.setAccessible(true);\n-          result \u003d meth.newInstance();\n-        } catch (InvocationTargetException e) {\n-          Throwable cause \u003d e.getCause();\n-          if (cause instanceof RuntimeException) {\n-            throw (RuntimeException) cause;\n-          } else {\n-            throw new RuntimeException(cause);\n-          }\n-        } catch (Exception e) {\n-          throw new RuntimeException(e);\n-        }\n-        return result;\n-      }\n-    };\n+    return new ChildFsGetter(getScheme());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected FsGetter fsGetter() {\n    return new ChildFsGetter(getScheme());\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFileSystemOverloadScheme.java",
      "extendedDetails": {}
    },
    "9c8236d04dfc3d4cefe7a00b63625f60ee232cfe": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-15305. Extend ViewFS and provide ViewFileSystemOverloadScheme implementation with scheme configurable. Contributed by Uma Maheswara Rao G.\n\n",
      "commitDate": "04/05/20 5:55 PM",
      "commitName": "9c8236d04dfc3d4cefe7a00b63625f60ee232cfe",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,84 @@\n+  protected FsGetter fsGetter() {\n+\n+    return new FsGetter() {\n+      @Override\n+      public FileSystem getNewInstance(URI uri, Configuration conf)\n+          throws IOException {\n+        if (uri.getScheme().equals(getScheme())) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\n+                \"The file system initialized uri scheme is matching with the \"\n+                    + \"given target uri scheme. The target uri is: \" + uri);\n+          }\n+          /*\n+           * Avoid looping when target fs scheme is matching to overloaded\n+           * scheme.\n+           */\n+          return createFileSystem(uri, conf);\n+        } else {\n+          return FileSystem.newInstance(uri, conf);\n+        }\n+      }\n+\n+      /**\n+       * When ViewFileSystemOverloadScheme scheme and target uri scheme are\n+       * matching, it will not take advantage of FileSystem cache as it will\n+       * create instance directly. For caching needs please set\n+       * \"fs.viewfs.enable.inner.cache\" to true.\n+       */\n+      @Override\n+      public FileSystem get(URI uri, Configuration conf) throws IOException {\n+        if (uri.getScheme().equals(getScheme())) {\n+          // Avoid looping when target fs scheme is matching to overloaded\n+          // scheme.\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\n+                \"The file system initialized uri scheme is matching with the \"\n+                    + \"given target uri scheme. So, the target file system \"\n+                    + \"instances will not be cached. To cache fs instances, \"\n+                    + \"please set fs.viewfs.enable.inner.cache to true. \"\n+                    + \"The target uri is: \" + uri);\n+          }\n+          return createFileSystem(uri, conf);\n+        } else {\n+          return FileSystem.get(uri, conf);\n+        }\n+      }\n+\n+      private FileSystem createFileSystem(URI uri, Configuration conf)\n+          throws IOException {\n+        final String fsImplConf \u003d String.format(\n+            FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,\n+            uri.getScheme());\n+        Class\u003c?\u003e clazz \u003d conf.getClass(fsImplConf, null);\n+        if (clazz \u003d\u003d null) {\n+          throw new UnsupportedFileSystemException(\n+              String.format(\"%s\u003dnull: %s: %s\", fsImplConf,\n+                  \"No overload scheme fs configured\", uri.getScheme()));\n+        }\n+        FileSystem fs \u003d (FileSystem) newInstance(clazz, uri, conf);\n+        fs.initialize(uri, conf);\n+        return fs;\n+      }\n+\n+      private \u003cT\u003e T newInstance(Class\u003cT\u003e theClass, URI uri,\n+          Configuration conf) {\n+        T result;\n+        try {\n+          Constructor\u003cT\u003e meth \u003d theClass.getConstructor();\n+          meth.setAccessible(true);\n+          result \u003d meth.newInstance();\n+        } catch (InvocationTargetException e) {\n+          Throwable cause \u003d e.getCause();\n+          if (cause instanceof RuntimeException) {\n+            throw (RuntimeException) cause;\n+          } else {\n+            throw new RuntimeException(cause);\n+          }\n+        } catch (Exception e) {\n+          throw new RuntimeException(e);\n+        }\n+        return result;\n+      }\n+    };\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected FsGetter fsGetter() {\n\n    return new FsGetter() {\n      @Override\n      public FileSystem getNewInstance(URI uri, Configuration conf)\n          throws IOException {\n        if (uri.getScheme().equals(getScheme())) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\n                \"The file system initialized uri scheme is matching with the \"\n                    + \"given target uri scheme. The target uri is: \" + uri);\n          }\n          /*\n           * Avoid looping when target fs scheme is matching to overloaded\n           * scheme.\n           */\n          return createFileSystem(uri, conf);\n        } else {\n          return FileSystem.newInstance(uri, conf);\n        }\n      }\n\n      /**\n       * When ViewFileSystemOverloadScheme scheme and target uri scheme are\n       * matching, it will not take advantage of FileSystem cache as it will\n       * create instance directly. For caching needs please set\n       * \"fs.viewfs.enable.inner.cache\" to true.\n       */\n      @Override\n      public FileSystem get(URI uri, Configuration conf) throws IOException {\n        if (uri.getScheme().equals(getScheme())) {\n          // Avoid looping when target fs scheme is matching to overloaded\n          // scheme.\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\n                \"The file system initialized uri scheme is matching with the \"\n                    + \"given target uri scheme. So, the target file system \"\n                    + \"instances will not be cached. To cache fs instances, \"\n                    + \"please set fs.viewfs.enable.inner.cache to true. \"\n                    + \"The target uri is: \" + uri);\n          }\n          return createFileSystem(uri, conf);\n        } else {\n          return FileSystem.get(uri, conf);\n        }\n      }\n\n      private FileSystem createFileSystem(URI uri, Configuration conf)\n          throws IOException {\n        final String fsImplConf \u003d String.format(\n            FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,\n            uri.getScheme());\n        Class\u003c?\u003e clazz \u003d conf.getClass(fsImplConf, null);\n        if (clazz \u003d\u003d null) {\n          throw new UnsupportedFileSystemException(\n              String.format(\"%s\u003dnull: %s: %s\", fsImplConf,\n                  \"No overload scheme fs configured\", uri.getScheme()));\n        }\n        FileSystem fs \u003d (FileSystem) newInstance(clazz, uri, conf);\n        fs.initialize(uri, conf);\n        return fs;\n      }\n\n      private \u003cT\u003e T newInstance(Class\u003cT\u003e theClass, URI uri,\n          Configuration conf) {\n        T result;\n        try {\n          Constructor\u003cT\u003e meth \u003d theClass.getConstructor();\n          meth.setAccessible(true);\n          result \u003d meth.newInstance();\n        } catch (InvocationTargetException e) {\n          Throwable cause \u003d e.getCause();\n          if (cause instanceof RuntimeException) {\n            throw (RuntimeException) cause;\n          } else {\n            throw new RuntimeException(cause);\n          }\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n        return result;\n      }\n    };\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFileSystemOverloadScheme.java"
    }
  }
}