{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativePmemMappableBlockLoader.java",
  "functionName": "verifyChecksumAndMapBlock",
  "functionId": "verifyChecksumAndMapBlock___region-POSIX.PmemMappedRegion__length-long__metaIn-FileInputStream__blockChannel-FileChannel__blockFileName-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/NativePmemMappableBlockLoader.java",
  "functionStartLine": 125,
  "functionEndLine": 187,
  "numCommitsSeen": 3,
  "timeTaken": 992,
  "changeHistory": [
    "d1aad444907e1fc5314e8e64529e57c51ed7561c"
  ],
  "changeHistoryShort": {
    "d1aad444907e1fc5314e8e64529e57c51ed7561c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d1aad444907e1fc5314e8e64529e57c51ed7561c": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-14356. Implement HDFS cache on SCM with native PMDK libs. Contributed by Feilong He.\n",
      "commitDate": "05/06/19 6:33 AM",
      "commitName": "d1aad444907e1fc5314e8e64529e57c51ed7561c",
      "commitAuthor": "Sammi Chen",
      "diff": "@@ -0,0 +1,63 @@\n+  private void verifyChecksumAndMapBlock(POSIX.PmemMappedRegion region,\n+      long length, FileInputStream metaIn, FileChannel blockChannel,\n+      String blockFileName) throws IOException {\n+    // Verify the checksum from the block\u0027s meta file\n+    // Get the DataChecksum from the meta file header\n+    BlockMetadataHeader header \u003d\n+        BlockMetadataHeader.readHeader(new DataInputStream(\n+            new BufferedInputStream(metaIn, BlockMetadataHeader\n+                .getHeaderSize())));\n+    FileChannel metaChannel \u003d null;\n+    try {\n+      metaChannel \u003d metaIn.getChannel();\n+      if (metaChannel \u003d\u003d null) {\n+        throw new IOException(\"Cannot get FileChannel\" +\n+            \" from Block InputStream meta file.\");\n+      }\n+      DataChecksum checksum \u003d header.getChecksum();\n+      final int bytesPerChecksum \u003d checksum.getBytesPerChecksum();\n+      final int checksumSize \u003d checksum.getChecksumSize();\n+      final int numChunks \u003d (8 * 1024 * 1024) / bytesPerChecksum;\n+      ByteBuffer blockBuf \u003d ByteBuffer.allocate(numChunks * bytesPerChecksum);\n+      ByteBuffer checksumBuf \u003d ByteBuffer.allocate(numChunks * checksumSize);\n+      // Verify the checksum\n+      int bytesVerified \u003d 0;\n+      long mappedAddress \u003d -1L;\n+      if (region !\u003d null) {\n+        mappedAddress \u003d region.getAddress();\n+      }\n+      while (bytesVerified \u003c length) {\n+        Preconditions.checkState(bytesVerified % bytesPerChecksum \u003d\u003d 0,\n+            \"Unexpected partial chunk before EOF.\");\n+        assert bytesVerified % bytesPerChecksum \u003d\u003d 0;\n+        int bytesRead \u003d fillBuffer(blockChannel, blockBuf);\n+        if (bytesRead \u003d\u003d -1) {\n+          throw new IOException(\n+              \"Checksum verification failed for the block \" + blockFileName +\n+                  \": premature EOF\");\n+        }\n+        blockBuf.flip();\n+        // Number of read chunks, including partial chunk at end\n+        int chunks \u003d (bytesRead + bytesPerChecksum - 1) / bytesPerChecksum;\n+        checksumBuf.limit(chunks * checksumSize);\n+        fillBuffer(metaChannel, checksumBuf);\n+        checksumBuf.flip();\n+        checksum.verifyChunkedSums(blockBuf, checksumBuf, blockFileName,\n+            bytesVerified);\n+        // Success\n+        bytesVerified +\u003d bytesRead;\n+        // Copy data to persistent file\n+        POSIX.Pmem.memCopy(blockBuf.array(), mappedAddress,\n+            region.isPmem(), bytesRead);\n+        mappedAddress +\u003d bytesRead;\n+        // Clear buffer\n+        blockBuf.clear();\n+        checksumBuf.clear();\n+      }\n+      if (region !\u003d null) {\n+        POSIX.Pmem.memSync(region);\n+      }\n+    } finally {\n+      IOUtils.closeQuietly(metaChannel);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void verifyChecksumAndMapBlock(POSIX.PmemMappedRegion region,\n      long length, FileInputStream metaIn, FileChannel blockChannel,\n      String blockFileName) throws IOException {\n    // Verify the checksum from the block\u0027s meta file\n    // Get the DataChecksum from the meta file header\n    BlockMetadataHeader header \u003d\n        BlockMetadataHeader.readHeader(new DataInputStream(\n            new BufferedInputStream(metaIn, BlockMetadataHeader\n                .getHeaderSize())));\n    FileChannel metaChannel \u003d null;\n    try {\n      metaChannel \u003d metaIn.getChannel();\n      if (metaChannel \u003d\u003d null) {\n        throw new IOException(\"Cannot get FileChannel\" +\n            \" from Block InputStream meta file.\");\n      }\n      DataChecksum checksum \u003d header.getChecksum();\n      final int bytesPerChecksum \u003d checksum.getBytesPerChecksum();\n      final int checksumSize \u003d checksum.getChecksumSize();\n      final int numChunks \u003d (8 * 1024 * 1024) / bytesPerChecksum;\n      ByteBuffer blockBuf \u003d ByteBuffer.allocate(numChunks * bytesPerChecksum);\n      ByteBuffer checksumBuf \u003d ByteBuffer.allocate(numChunks * checksumSize);\n      // Verify the checksum\n      int bytesVerified \u003d 0;\n      long mappedAddress \u003d -1L;\n      if (region !\u003d null) {\n        mappedAddress \u003d region.getAddress();\n      }\n      while (bytesVerified \u003c length) {\n        Preconditions.checkState(bytesVerified % bytesPerChecksum \u003d\u003d 0,\n            \"Unexpected partial chunk before EOF.\");\n        assert bytesVerified % bytesPerChecksum \u003d\u003d 0;\n        int bytesRead \u003d fillBuffer(blockChannel, blockBuf);\n        if (bytesRead \u003d\u003d -1) {\n          throw new IOException(\n              \"Checksum verification failed for the block \" + blockFileName +\n                  \": premature EOF\");\n        }\n        blockBuf.flip();\n        // Number of read chunks, including partial chunk at end\n        int chunks \u003d (bytesRead + bytesPerChecksum - 1) / bytesPerChecksum;\n        checksumBuf.limit(chunks * checksumSize);\n        fillBuffer(metaChannel, checksumBuf);\n        checksumBuf.flip();\n        checksum.verifyChunkedSums(blockBuf, checksumBuf, blockFileName,\n            bytesVerified);\n        // Success\n        bytesVerified +\u003d bytesRead;\n        // Copy data to persistent file\n        POSIX.Pmem.memCopy(blockBuf.array(), mappedAddress,\n            region.isPmem(), bytesRead);\n        mappedAddress +\u003d bytesRead;\n        // Clear buffer\n        blockBuf.clear();\n        checksumBuf.clear();\n      }\n      if (region !\u003d null) {\n        POSIX.Pmem.memSync(region);\n      }\n    } finally {\n      IOUtils.closeQuietly(metaChannel);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/NativePmemMappableBlockLoader.java"
    }
  }
}