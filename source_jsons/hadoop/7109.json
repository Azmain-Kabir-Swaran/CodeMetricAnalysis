{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StoragePolicySatisfier.java",
  "functionName": "buildStripedBlockMovingInfos",
  "functionId": "buildStripedBlockMovingInfos___blockInfo-LocatedBlock__sourceNode-DatanodeInfo__sourceStorageType-StorageType__targetNode-DatanodeInfo__targetStorageType-StorageType__blkMovingInfos-List__BlockMovingInfo____ecPolicy-ErasureCodingPolicy",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
  "functionStartLine": 705,
  "functionEndLine": 735,
  "numCommitsSeen": 75,
  "timeTaken": 5145,
  "changeHistory": [
    "05d4daf6ba3e5bd40f46e8003ee12fc7c613453d",
    "78420719eb1f138c6f10558befb7bc8ebcc28a54",
    "00eceed233d6e80d5c7137bf5b5286746ec4d5fb",
    "81ed364b632189c6eebd6426b6abc52c790570ea"
  ],
  "changeHistoryShort": {
    "05d4daf6ba3e5bd40f46e8003ee12fc7c613453d": "Ymultichange(Yparameterchange,Ybodychange)",
    "78420719eb1f138c6f10558befb7bc8ebcc28a54": "Yfilerename",
    "00eceed233d6e80d5c7137bf5b5286746ec4d5fb": "Ymultichange(Yparameterchange,Ybodychange)",
    "81ed364b632189c6eebd6426b6abc52c790570ea": "Yintroduced"
  },
  "changeHistoryDetails": {
    "05d4daf6ba3e5bd40f46e8003ee12fc7c613453d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-12982 : [SPS]: Reduce the locking and cleanup the Namesystem access. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "05d4daf6ba3e5bd40f46e8003ee12fc7c613453d",
      "commitAuthor": "Surendra Singh Lilhore",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-12982 : [SPS]: Reduce the locking and cleanup the Namesystem access. Contributed by Rakesh R.\n",
          "commitDate": "12/08/18 3:06 AM",
          "commitName": "05d4daf6ba3e5bd40f46e8003ee12fc7c613453d",
          "commitAuthor": "Surendra Singh Lilhore",
          "commitDateOld": "12/08/18 3:06 AM",
          "commitNameOld": "78420719eb1f138c6f10558befb7bc8ebcc28a54",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,31 @@\n-  private void buildStripedBlockMovingInfos(BlockInfo blockInfo,\n+  private void buildStripedBlockMovingInfos(LocatedBlock blockInfo,\n       DatanodeInfo sourceNode, StorageType sourceStorageType,\n       DatanodeInfo targetNode, StorageType targetStorageType,\n-      List\u003cBlockMovingInfo\u003e blkMovingInfos) {\n+      List\u003cBlockMovingInfo\u003e blkMovingInfos, ErasureCodingPolicy ecPolicy) {\n     // For a striped block, it needs to construct internal block at the given\n     // index of a block group. Here it is iterating over all the block indices\n     // and construct internal blocks which can be then considered for block\n     // movement.\n-    BlockInfoStriped sBlockInfo \u003d (BlockInfoStriped) blockInfo;\n-    for (StorageAndBlockIndex si : sBlockInfo.getStorageAndIndexInfos()) {\n-      if (si.getBlockIndex() \u003e\u003d 0) {\n-        DatanodeDescriptor dn \u003d si.getStorage().getDatanodeDescriptor();\n-        if (sourceNode.equals(dn)) {\n+    LocatedStripedBlock sBlockInfo \u003d (LocatedStripedBlock) blockInfo;\n+    byte[] indices \u003d sBlockInfo.getBlockIndices();\n+    DatanodeInfo[] locations \u003d sBlockInfo.getLocations();\n+    for (int i \u003d 0; i \u003c indices.length; i++) {\n+      byte blkIndex \u003d indices[i];\n+      if (blkIndex \u003e\u003d 0) {\n+        // pick block movement only for the given source node.\n+        if (sourceNode.equals(locations[i])) {\n           // construct internal block\n-          long blockId \u003d blockInfo.getBlockId() + si.getBlockIndex();\n+          ExtendedBlock extBlock \u003d sBlockInfo.getBlock();\n           long numBytes \u003d StripedBlockUtil.getInternalBlockLength(\n-              sBlockInfo.getNumBytes(), sBlockInfo.getCellSize(),\n-              sBlockInfo.getDataBlockNum(), si.getBlockIndex());\n-          Block blk \u003d new Block(blockId, numBytes,\n-              blockInfo.getGenerationStamp());\n+              extBlock.getNumBytes(), ecPolicy, blkIndex);\n+          Block blk \u003d new Block(ExtendedBlock.getLocalBlock(extBlock));\n+          long blkId \u003d blk.getBlockId() + blkIndex;\n+          blk.setBlockId(blkId);\n+          blk.setNumBytes(numBytes);\n           BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blk, sourceNode,\n               targetNode, sourceStorageType, targetStorageType);\n           blkMovingInfos.add(blkMovingInfo);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void buildStripedBlockMovingInfos(LocatedBlock blockInfo,\n      DatanodeInfo sourceNode, StorageType sourceStorageType,\n      DatanodeInfo targetNode, StorageType targetStorageType,\n      List\u003cBlockMovingInfo\u003e blkMovingInfos, ErasureCodingPolicy ecPolicy) {\n    // For a striped block, it needs to construct internal block at the given\n    // index of a block group. Here it is iterating over all the block indices\n    // and construct internal blocks which can be then considered for block\n    // movement.\n    LocatedStripedBlock sBlockInfo \u003d (LocatedStripedBlock) blockInfo;\n    byte[] indices \u003d sBlockInfo.getBlockIndices();\n    DatanodeInfo[] locations \u003d sBlockInfo.getLocations();\n    for (int i \u003d 0; i \u003c indices.length; i++) {\n      byte blkIndex \u003d indices[i];\n      if (blkIndex \u003e\u003d 0) {\n        // pick block movement only for the given source node.\n        if (sourceNode.equals(locations[i])) {\n          // construct internal block\n          ExtendedBlock extBlock \u003d sBlockInfo.getBlock();\n          long numBytes \u003d StripedBlockUtil.getInternalBlockLength(\n              extBlock.getNumBytes(), ecPolicy, blkIndex);\n          Block blk \u003d new Block(ExtendedBlock.getLocalBlock(extBlock));\n          long blkId \u003d blk.getBlockId() + blkIndex;\n          blk.setBlockId(blkId);\n          blk.setNumBytes(numBytes);\n          BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blk, sourceNode,\n              targetNode, sourceStorageType, targetStorageType);\n          blkMovingInfos.add(blkMovingInfo);\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
          "extendedDetails": {
            "oldValue": "[blockInfo-BlockInfo, sourceNode-DatanodeInfo, sourceStorageType-StorageType, targetNode-DatanodeInfo, targetStorageType-StorageType, blkMovingInfos-List\u003cBlockMovingInfo\u003e]",
            "newValue": "[blockInfo-LocatedBlock, sourceNode-DatanodeInfo, sourceStorageType-StorageType, targetNode-DatanodeInfo, targetStorageType-StorageType, blkMovingInfos-List\u003cBlockMovingInfo\u003e, ecPolicy-ErasureCodingPolicy]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-12982 : [SPS]: Reduce the locking and cleanup the Namesystem access. Contributed by Rakesh R.\n",
          "commitDate": "12/08/18 3:06 AM",
          "commitName": "05d4daf6ba3e5bd40f46e8003ee12fc7c613453d",
          "commitAuthor": "Surendra Singh Lilhore",
          "commitDateOld": "12/08/18 3:06 AM",
          "commitNameOld": "78420719eb1f138c6f10558befb7bc8ebcc28a54",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,31 @@\n-  private void buildStripedBlockMovingInfos(BlockInfo blockInfo,\n+  private void buildStripedBlockMovingInfos(LocatedBlock blockInfo,\n       DatanodeInfo sourceNode, StorageType sourceStorageType,\n       DatanodeInfo targetNode, StorageType targetStorageType,\n-      List\u003cBlockMovingInfo\u003e blkMovingInfos) {\n+      List\u003cBlockMovingInfo\u003e blkMovingInfos, ErasureCodingPolicy ecPolicy) {\n     // For a striped block, it needs to construct internal block at the given\n     // index of a block group. Here it is iterating over all the block indices\n     // and construct internal blocks which can be then considered for block\n     // movement.\n-    BlockInfoStriped sBlockInfo \u003d (BlockInfoStriped) blockInfo;\n-    for (StorageAndBlockIndex si : sBlockInfo.getStorageAndIndexInfos()) {\n-      if (si.getBlockIndex() \u003e\u003d 0) {\n-        DatanodeDescriptor dn \u003d si.getStorage().getDatanodeDescriptor();\n-        if (sourceNode.equals(dn)) {\n+    LocatedStripedBlock sBlockInfo \u003d (LocatedStripedBlock) blockInfo;\n+    byte[] indices \u003d sBlockInfo.getBlockIndices();\n+    DatanodeInfo[] locations \u003d sBlockInfo.getLocations();\n+    for (int i \u003d 0; i \u003c indices.length; i++) {\n+      byte blkIndex \u003d indices[i];\n+      if (blkIndex \u003e\u003d 0) {\n+        // pick block movement only for the given source node.\n+        if (sourceNode.equals(locations[i])) {\n           // construct internal block\n-          long blockId \u003d blockInfo.getBlockId() + si.getBlockIndex();\n+          ExtendedBlock extBlock \u003d sBlockInfo.getBlock();\n           long numBytes \u003d StripedBlockUtil.getInternalBlockLength(\n-              sBlockInfo.getNumBytes(), sBlockInfo.getCellSize(),\n-              sBlockInfo.getDataBlockNum(), si.getBlockIndex());\n-          Block blk \u003d new Block(blockId, numBytes,\n-              blockInfo.getGenerationStamp());\n+              extBlock.getNumBytes(), ecPolicy, blkIndex);\n+          Block blk \u003d new Block(ExtendedBlock.getLocalBlock(extBlock));\n+          long blkId \u003d blk.getBlockId() + blkIndex;\n+          blk.setBlockId(blkId);\n+          blk.setNumBytes(numBytes);\n           BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blk, sourceNode,\n               targetNode, sourceStorageType, targetStorageType);\n           blkMovingInfos.add(blkMovingInfo);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void buildStripedBlockMovingInfos(LocatedBlock blockInfo,\n      DatanodeInfo sourceNode, StorageType sourceStorageType,\n      DatanodeInfo targetNode, StorageType targetStorageType,\n      List\u003cBlockMovingInfo\u003e blkMovingInfos, ErasureCodingPolicy ecPolicy) {\n    // For a striped block, it needs to construct internal block at the given\n    // index of a block group. Here it is iterating over all the block indices\n    // and construct internal blocks which can be then considered for block\n    // movement.\n    LocatedStripedBlock sBlockInfo \u003d (LocatedStripedBlock) blockInfo;\n    byte[] indices \u003d sBlockInfo.getBlockIndices();\n    DatanodeInfo[] locations \u003d sBlockInfo.getLocations();\n    for (int i \u003d 0; i \u003c indices.length; i++) {\n      byte blkIndex \u003d indices[i];\n      if (blkIndex \u003e\u003d 0) {\n        // pick block movement only for the given source node.\n        if (sourceNode.equals(locations[i])) {\n          // construct internal block\n          ExtendedBlock extBlock \u003d sBlockInfo.getBlock();\n          long numBytes \u003d StripedBlockUtil.getInternalBlockLength(\n              extBlock.getNumBytes(), ecPolicy, blkIndex);\n          Block blk \u003d new Block(ExtendedBlock.getLocalBlock(extBlock));\n          long blkId \u003d blk.getBlockId() + blkIndex;\n          blk.setBlockId(blkId);\n          blk.setNumBytes(numBytes);\n          BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blk, sourceNode,\n              targetNode, sourceStorageType, targetStorageType);\n          blkMovingInfos.add(blkMovingInfo);\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
          "extendedDetails": {}
        }
      ]
    },
    "78420719eb1f138c6f10558befb7bc8ebcc28a54": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-12955: [SPS]: Move SPS classes to a separate package. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "78420719eb1f138c6f10558befb7bc8ebcc28a54",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "c561cb316e365ef674784cd6cf0b12c0fbc271a3",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void buildStripedBlockMovingInfos(BlockInfo blockInfo,\n      DatanodeInfo sourceNode, StorageType sourceStorageType,\n      DatanodeInfo targetNode, StorageType targetStorageType,\n      List\u003cBlockMovingInfo\u003e blkMovingInfos) {\n    // For a striped block, it needs to construct internal block at the given\n    // index of a block group. Here it is iterating over all the block indices\n    // and construct internal blocks which can be then considered for block\n    // movement.\n    BlockInfoStriped sBlockInfo \u003d (BlockInfoStriped) blockInfo;\n    for (StorageAndBlockIndex si : sBlockInfo.getStorageAndIndexInfos()) {\n      if (si.getBlockIndex() \u003e\u003d 0) {\n        DatanodeDescriptor dn \u003d si.getStorage().getDatanodeDescriptor();\n        if (sourceNode.equals(dn)) {\n          // construct internal block\n          long blockId \u003d blockInfo.getBlockId() + si.getBlockIndex();\n          long numBytes \u003d StripedBlockUtil.getInternalBlockLength(\n              sBlockInfo.getNumBytes(), sBlockInfo.getCellSize(),\n              sBlockInfo.getDataBlockNum(), si.getBlockIndex());\n          Block blk \u003d new Block(blockId, numBytes,\n              blockInfo.getGenerationStamp());\n          BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blk, sourceNode,\n              targetNode, sourceStorageType, targetStorageType);\n          blkMovingInfos.add(blkMovingInfo);\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java"
      }
    },
    "00eceed233d6e80d5c7137bf5b5286746ec4d5fb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-12570: [SPS]: Refactor Co-ordinator datanode logic to track the block storage movements. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "00eceed233d6e80d5c7137bf5b5286746ec4d5fb",
      "commitAuthor": "Uma Maheswara Rao G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-12570: [SPS]: Refactor Co-ordinator datanode logic to track the block storage movements. Contributed by Rakesh R.\n",
          "commitDate": "12/08/18 3:06 AM",
          "commitName": "00eceed233d6e80d5c7137bf5b5286746ec4d5fb",
          "commitAuthor": "Uma Maheswara Rao G",
          "commitDateOld": "12/08/18 3:06 AM",
          "commitNameOld": "bfd3f8bd8a9ae2186ec3e4addc71f912ec7b8923",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,27 @@\n   private void buildStripedBlockMovingInfos(BlockInfo blockInfo,\n-      List\u003cDatanodeInfo\u003e sourceNodes, List\u003cStorageType\u003e sourceStorageTypes,\n-      List\u003cDatanodeInfo\u003e targetNodes, List\u003cStorageType\u003e targetStorageTypes,\n+      DatanodeInfo sourceNode, StorageType sourceStorageType,\n+      DatanodeInfo targetNode, StorageType targetStorageType,\n       List\u003cBlockMovingInfo\u003e blkMovingInfos) {\n     // For a striped block, it needs to construct internal block at the given\n     // index of a block group. Here it is iterating over all the block indices\n     // and construct internal blocks which can be then considered for block\n     // movement.\n     BlockInfoStriped sBlockInfo \u003d (BlockInfoStriped) blockInfo;\n     for (StorageAndBlockIndex si : sBlockInfo.getStorageAndIndexInfos()) {\n       if (si.getBlockIndex() \u003e\u003d 0) {\n         DatanodeDescriptor dn \u003d si.getStorage().getDatanodeDescriptor();\n-        DatanodeInfo[] srcNode \u003d new DatanodeInfo[1];\n-        StorageType[] srcStorageType \u003d new StorageType[1];\n-        DatanodeInfo[] targetNode \u003d new DatanodeInfo[1];\n-        StorageType[] targetStorageType \u003d new StorageType[1];\n-        for (int i \u003d 0; i \u003c sourceNodes.size(); i++) {\n-          DatanodeInfo node \u003d sourceNodes.get(i);\n-          if (node.equals(dn)) {\n-            srcNode[0] \u003d node;\n-            srcStorageType[0] \u003d sourceStorageTypes.get(i);\n-            targetNode[0] \u003d targetNodes.get(i);\n-            targetStorageType[0] \u003d targetStorageTypes.get(i);\n-\n-            // construct internal block\n-            long blockId \u003d blockInfo.getBlockId() + si.getBlockIndex();\n-            long numBytes \u003d StripedBlockUtil.getInternalBlockLength(\n-                sBlockInfo.getNumBytes(), sBlockInfo.getCellSize(),\n-                sBlockInfo.getDataBlockNum(), si.getBlockIndex());\n-            Block blk \u003d new Block(blockId, numBytes,\n-                blockInfo.getGenerationStamp());\n-            BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blk, srcNode,\n-                targetNode, srcStorageType, targetStorageType);\n-            blkMovingInfos.add(blkMovingInfo);\n-            break; // found matching source-target nodes\n-          }\n+        if (sourceNode.equals(dn)) {\n+          // construct internal block\n+          long blockId \u003d blockInfo.getBlockId() + si.getBlockIndex();\n+          long numBytes \u003d StripedBlockUtil.getInternalBlockLength(\n+              sBlockInfo.getNumBytes(), sBlockInfo.getCellSize(),\n+              sBlockInfo.getDataBlockNum(), si.getBlockIndex());\n+          Block blk \u003d new Block(blockId, numBytes,\n+              blockInfo.getGenerationStamp());\n+          BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blk, sourceNode,\n+              targetNode, sourceStorageType, targetStorageType);\n+          blkMovingInfos.add(blkMovingInfo);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void buildStripedBlockMovingInfos(BlockInfo blockInfo,\n      DatanodeInfo sourceNode, StorageType sourceStorageType,\n      DatanodeInfo targetNode, StorageType targetStorageType,\n      List\u003cBlockMovingInfo\u003e blkMovingInfos) {\n    // For a striped block, it needs to construct internal block at the given\n    // index of a block group. Here it is iterating over all the block indices\n    // and construct internal blocks which can be then considered for block\n    // movement.\n    BlockInfoStriped sBlockInfo \u003d (BlockInfoStriped) blockInfo;\n    for (StorageAndBlockIndex si : sBlockInfo.getStorageAndIndexInfos()) {\n      if (si.getBlockIndex() \u003e\u003d 0) {\n        DatanodeDescriptor dn \u003d si.getStorage().getDatanodeDescriptor();\n        if (sourceNode.equals(dn)) {\n          // construct internal block\n          long blockId \u003d blockInfo.getBlockId() + si.getBlockIndex();\n          long numBytes \u003d StripedBlockUtil.getInternalBlockLength(\n              sBlockInfo.getNumBytes(), sBlockInfo.getCellSize(),\n              sBlockInfo.getDataBlockNum(), si.getBlockIndex());\n          Block blk \u003d new Block(blockId, numBytes,\n              blockInfo.getGenerationStamp());\n          BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blk, sourceNode,\n              targetNode, sourceStorageType, targetStorageType);\n          blkMovingInfos.add(blkMovingInfo);\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java",
          "extendedDetails": {
            "oldValue": "[blockInfo-BlockInfo, sourceNodes-List\u003cDatanodeInfo\u003e, sourceStorageTypes-List\u003cStorageType\u003e, targetNodes-List\u003cDatanodeInfo\u003e, targetStorageTypes-List\u003cStorageType\u003e, blkMovingInfos-List\u003cBlockMovingInfo\u003e]",
            "newValue": "[blockInfo-BlockInfo, sourceNode-DatanodeInfo, sourceStorageType-StorageType, targetNode-DatanodeInfo, targetStorageType-StorageType, blkMovingInfos-List\u003cBlockMovingInfo\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-12570: [SPS]: Refactor Co-ordinator datanode logic to track the block storage movements. Contributed by Rakesh R.\n",
          "commitDate": "12/08/18 3:06 AM",
          "commitName": "00eceed233d6e80d5c7137bf5b5286746ec4d5fb",
          "commitAuthor": "Uma Maheswara Rao G",
          "commitDateOld": "12/08/18 3:06 AM",
          "commitNameOld": "bfd3f8bd8a9ae2186ec3e4addc71f912ec7b8923",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,27 @@\n   private void buildStripedBlockMovingInfos(BlockInfo blockInfo,\n-      List\u003cDatanodeInfo\u003e sourceNodes, List\u003cStorageType\u003e sourceStorageTypes,\n-      List\u003cDatanodeInfo\u003e targetNodes, List\u003cStorageType\u003e targetStorageTypes,\n+      DatanodeInfo sourceNode, StorageType sourceStorageType,\n+      DatanodeInfo targetNode, StorageType targetStorageType,\n       List\u003cBlockMovingInfo\u003e blkMovingInfos) {\n     // For a striped block, it needs to construct internal block at the given\n     // index of a block group. Here it is iterating over all the block indices\n     // and construct internal blocks which can be then considered for block\n     // movement.\n     BlockInfoStriped sBlockInfo \u003d (BlockInfoStriped) blockInfo;\n     for (StorageAndBlockIndex si : sBlockInfo.getStorageAndIndexInfos()) {\n       if (si.getBlockIndex() \u003e\u003d 0) {\n         DatanodeDescriptor dn \u003d si.getStorage().getDatanodeDescriptor();\n-        DatanodeInfo[] srcNode \u003d new DatanodeInfo[1];\n-        StorageType[] srcStorageType \u003d new StorageType[1];\n-        DatanodeInfo[] targetNode \u003d new DatanodeInfo[1];\n-        StorageType[] targetStorageType \u003d new StorageType[1];\n-        for (int i \u003d 0; i \u003c sourceNodes.size(); i++) {\n-          DatanodeInfo node \u003d sourceNodes.get(i);\n-          if (node.equals(dn)) {\n-            srcNode[0] \u003d node;\n-            srcStorageType[0] \u003d sourceStorageTypes.get(i);\n-            targetNode[0] \u003d targetNodes.get(i);\n-            targetStorageType[0] \u003d targetStorageTypes.get(i);\n-\n-            // construct internal block\n-            long blockId \u003d blockInfo.getBlockId() + si.getBlockIndex();\n-            long numBytes \u003d StripedBlockUtil.getInternalBlockLength(\n-                sBlockInfo.getNumBytes(), sBlockInfo.getCellSize(),\n-                sBlockInfo.getDataBlockNum(), si.getBlockIndex());\n-            Block blk \u003d new Block(blockId, numBytes,\n-                blockInfo.getGenerationStamp());\n-            BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blk, srcNode,\n-                targetNode, srcStorageType, targetStorageType);\n-            blkMovingInfos.add(blkMovingInfo);\n-            break; // found matching source-target nodes\n-          }\n+        if (sourceNode.equals(dn)) {\n+          // construct internal block\n+          long blockId \u003d blockInfo.getBlockId() + si.getBlockIndex();\n+          long numBytes \u003d StripedBlockUtil.getInternalBlockLength(\n+              sBlockInfo.getNumBytes(), sBlockInfo.getCellSize(),\n+              sBlockInfo.getDataBlockNum(), si.getBlockIndex());\n+          Block blk \u003d new Block(blockId, numBytes,\n+              blockInfo.getGenerationStamp());\n+          BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blk, sourceNode,\n+              targetNode, sourceStorageType, targetStorageType);\n+          blkMovingInfos.add(blkMovingInfo);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void buildStripedBlockMovingInfos(BlockInfo blockInfo,\n      DatanodeInfo sourceNode, StorageType sourceStorageType,\n      DatanodeInfo targetNode, StorageType targetStorageType,\n      List\u003cBlockMovingInfo\u003e blkMovingInfos) {\n    // For a striped block, it needs to construct internal block at the given\n    // index of a block group. Here it is iterating over all the block indices\n    // and construct internal blocks which can be then considered for block\n    // movement.\n    BlockInfoStriped sBlockInfo \u003d (BlockInfoStriped) blockInfo;\n    for (StorageAndBlockIndex si : sBlockInfo.getStorageAndIndexInfos()) {\n      if (si.getBlockIndex() \u003e\u003d 0) {\n        DatanodeDescriptor dn \u003d si.getStorage().getDatanodeDescriptor();\n        if (sourceNode.equals(dn)) {\n          // construct internal block\n          long blockId \u003d blockInfo.getBlockId() + si.getBlockIndex();\n          long numBytes \u003d StripedBlockUtil.getInternalBlockLength(\n              sBlockInfo.getNumBytes(), sBlockInfo.getCellSize(),\n              sBlockInfo.getDataBlockNum(), si.getBlockIndex());\n          Block blk \u003d new Block(blockId, numBytes,\n              blockInfo.getGenerationStamp());\n          BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blk, sourceNode,\n              targetNode, sourceStorageType, targetStorageType);\n          blkMovingInfos.add(blkMovingInfo);\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java",
          "extendedDetails": {}
        }
      ]
    },
    "81ed364b632189c6eebd6426b6abc52c790570ea": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-11193 : [SPS]: Erasure coded files should be considered for satisfying storage policy. Contributed by Rakesh R\n",
      "commitDate": "12/08/18 3:05 AM",
      "commitName": "81ed364b632189c6eebd6426b6abc52c790570ea",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,40 @@\n+  private void buildStripedBlockMovingInfos(BlockInfo blockInfo,\n+      List\u003cDatanodeInfo\u003e sourceNodes, List\u003cStorageType\u003e sourceStorageTypes,\n+      List\u003cDatanodeInfo\u003e targetNodes, List\u003cStorageType\u003e targetStorageTypes,\n+      List\u003cBlockMovingInfo\u003e blkMovingInfos) {\n+    // For a striped block, it needs to construct internal block at the given\n+    // index of a block group. Here it is iterating over all the block indices\n+    // and construct internal blocks which can be then considered for block\n+    // movement.\n+    BlockInfoStriped sBlockInfo \u003d (BlockInfoStriped) blockInfo;\n+    for (StorageAndBlockIndex si : sBlockInfo.getStorageAndIndexInfos()) {\n+      if (si.getBlockIndex() \u003e\u003d 0) {\n+        DatanodeDescriptor dn \u003d si.getStorage().getDatanodeDescriptor();\n+        DatanodeInfo[] srcNode \u003d new DatanodeInfo[1];\n+        StorageType[] srcStorageType \u003d new StorageType[1];\n+        DatanodeInfo[] targetNode \u003d new DatanodeInfo[1];\n+        StorageType[] targetStorageType \u003d new StorageType[1];\n+        for (int i \u003d 0; i \u003c sourceNodes.size(); i++) {\n+          DatanodeInfo node \u003d sourceNodes.get(i);\n+          if (node.equals(dn)) {\n+            srcNode[0] \u003d node;\n+            srcStorageType[0] \u003d sourceStorageTypes.get(i);\n+            targetNode[0] \u003d targetNodes.get(i);\n+            targetStorageType[0] \u003d targetStorageTypes.get(i);\n+\n+            // construct internal block\n+            long blockId \u003d blockInfo.getBlockId() + si.getBlockIndex();\n+            long numBytes \u003d StripedBlockUtil.getInternalBlockLength(\n+                sBlockInfo.getNumBytes(), sBlockInfo.getCellSize(),\n+                sBlockInfo.getDataBlockNum(), si.getBlockIndex());\n+            Block blk \u003d new Block(blockId, numBytes,\n+                blockInfo.getGenerationStamp());\n+            BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blk, srcNode,\n+                targetNode, srcStorageType, targetStorageType);\n+            blkMovingInfos.add(blkMovingInfo);\n+            break; // found matching source-target nodes\n+          }\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void buildStripedBlockMovingInfos(BlockInfo blockInfo,\n      List\u003cDatanodeInfo\u003e sourceNodes, List\u003cStorageType\u003e sourceStorageTypes,\n      List\u003cDatanodeInfo\u003e targetNodes, List\u003cStorageType\u003e targetStorageTypes,\n      List\u003cBlockMovingInfo\u003e blkMovingInfos) {\n    // For a striped block, it needs to construct internal block at the given\n    // index of a block group. Here it is iterating over all the block indices\n    // and construct internal blocks which can be then considered for block\n    // movement.\n    BlockInfoStriped sBlockInfo \u003d (BlockInfoStriped) blockInfo;\n    for (StorageAndBlockIndex si : sBlockInfo.getStorageAndIndexInfos()) {\n      if (si.getBlockIndex() \u003e\u003d 0) {\n        DatanodeDescriptor dn \u003d si.getStorage().getDatanodeDescriptor();\n        DatanodeInfo[] srcNode \u003d new DatanodeInfo[1];\n        StorageType[] srcStorageType \u003d new StorageType[1];\n        DatanodeInfo[] targetNode \u003d new DatanodeInfo[1];\n        StorageType[] targetStorageType \u003d new StorageType[1];\n        for (int i \u003d 0; i \u003c sourceNodes.size(); i++) {\n          DatanodeInfo node \u003d sourceNodes.get(i);\n          if (node.equals(dn)) {\n            srcNode[0] \u003d node;\n            srcStorageType[0] \u003d sourceStorageTypes.get(i);\n            targetNode[0] \u003d targetNodes.get(i);\n            targetStorageType[0] \u003d targetStorageTypes.get(i);\n\n            // construct internal block\n            long blockId \u003d blockInfo.getBlockId() + si.getBlockIndex();\n            long numBytes \u003d StripedBlockUtil.getInternalBlockLength(\n                sBlockInfo.getNumBytes(), sBlockInfo.getCellSize(),\n                sBlockInfo.getDataBlockNum(), si.getBlockIndex());\n            Block blk \u003d new Block(blockId, numBytes,\n                blockInfo.getGenerationStamp());\n            BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blk, srcNode,\n                targetNode, srcStorageType, targetStorageType);\n            blkMovingInfos.add(blkMovingInfo);\n            break; // found matching source-target nodes\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java"
    }
  }
}