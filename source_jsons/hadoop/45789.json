{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TFileAggregatedLogsBlock.java",
  "functionName": "render",
  "functionId": "render___html-Block",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/tfile/TFileAggregatedLogsBlock.java",
  "functionStartLine": 64,
  "functionEndLine": 171,
  "numCommitsSeen": 4,
  "timeTaken": 1985,
  "changeHistory": [
    "460ba7fb14114f44e14a660f533f32c54e504478",
    "631b5c2db733b0733a779e843b8035f68d0fcdf3",
    "91cc070d67533ebb3325b982eba2135e0d175a82"
  ],
  "changeHistoryShort": {
    "460ba7fb14114f44e14a660f533f32c54e504478": "Ybodychange",
    "631b5c2db733b0733a779e843b8035f68d0fcdf3": "Ybodychange",
    "91cc070d67533ebb3325b982eba2135e0d175a82": "Yintroduced"
  },
  "changeHistoryDetails": {
    "460ba7fb14114f44e14a660f533f32c54e504478": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9558.  Fixed LogAggregation test cases.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "23/05/19 3:38 PM",
      "commitName": "460ba7fb14114f44e14a660f533f32c54e504478",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "13/08/18 1:50 PM",
      "commitNameOld": "74411ce0ce7336c0f7bb5793939fdd64a5dcdef6",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 283.08,
      "commitsBetweenForRepo": 2119,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,108 @@\n   protected void render(Block html) {\n \n     BlockParameters params \u003d verifyAndParseParameters(html);\n     if (params \u003d\u003d null) {\n       return;\n     }\n \n     RemoteIterator\u003cFileStatus\u003e nodeFiles;\n     try {\n       nodeFiles \u003d LogAggregationUtils\n           .getRemoteNodeFileDir(conf, params.getAppId(),\n-              params.getAppOwner());\n+          params.getAppOwner(), remoteRootLogDir, remoteRootLogDirSuffix);\n     } catch (RuntimeException e) {\n       throw e;\n     } catch (Exception ex) {\n       html.h1(\"No logs available for container \"\n           + params.getContainerId().toString());\n       return;\n     }\n \n     NodeId nodeId \u003d params.getNodeId();\n     String logEntity \u003d params.getLogEntity();\n     ApplicationId appId \u003d params.getAppId();\n     ContainerId containerId \u003d params.getContainerId();\n     long start \u003d params.getStartIndex();\n     long end \u003d params.getEndIndex();\n     long startTime \u003d params.getStartTime();\n     long endTime \u003d params.getEndTime();\n \n     boolean foundLog \u003d false;\n     String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n     try {\n       while (nodeFiles.hasNext()) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         try {\n           FileStatus thisNodeFile \u003d nodeFiles.next();\n           if (thisNodeFile.getPath().getName().equals(\n               params.getAppId() + \".har\")) {\n             Path p \u003d new Path(\"har:///\"\n                 + thisNodeFile.getPath().toUri().getRawPath());\n             nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n             continue;\n           }\n           if (!thisNodeFile.getPath().getName()\n               .contains(LogAggregationUtils.getNodeString(nodeId))\n               || thisNodeFile.getPath().getName()\n                   .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n             continue;\n           }\n           long logUploadedTime \u003d thisNodeFile.getModificationTime();\n           if (logUploadedTime \u003c startTime || logUploadedTime \u003e endTime) {\n             continue;\n           }\n           reader \u003d new AggregatedLogFormat.LogReader(\n               conf, thisNodeFile.getPath());\n \n           String owner \u003d null;\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n           try {\n             owner \u003d reader.getApplicationOwner();\n             appAcls \u003d reader.getApplicationAcls();\n           } catch (IOException e) {\n             LOG.error(\"Error getting logs for \" + logEntity, e);\n             continue;\n           }\n           String remoteUser \u003d request().getRemoteUser();\n \n           if (!checkAcls(conf, appId, owner, appAcls, remoteUser)) {\n             html.h1().__(\"User [\" + remoteUser\n                 + \"] is not authorized to view the logs for \" + logEntity\n                 + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n                 .__();\n             LOG.error(\"User [\" + remoteUser\n                 + \"] is not authorized to view the logs for \" + logEntity);\n             continue;\n           }\n \n           AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n               .getContainerLogsReader(containerId);\n           if (logReader \u003d\u003d null) {\n             continue;\n           }\n \n           foundLog \u003d readContainerLogs(html, logReader, start, end,\n               desiredLogType, logUploadedTime, startTime, endTime);\n         } catch (IOException ex) {\n           LOG.error(\"Error getting logs for \" + logEntity, ex);\n           continue;\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n         }\n       }\n       if (!foundLog) {\n         if (desiredLogType.isEmpty()) {\n           html.h1(\"No logs available for container \"\n               + containerId.toString());\n         } else {\n           html.h1(\"Unable to locate \u0027\" + desiredLogType\n               + \"\u0027 log for container \" + containerId.toString());\n         }\n       }\n     } catch (IOException e) {\n       html.h1().__(\"Error getting logs for \" + logEntity).__();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n\n    BlockParameters params \u003d verifyAndParseParameters(html);\n    if (params \u003d\u003d null) {\n      return;\n    }\n\n    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n    try {\n      nodeFiles \u003d LogAggregationUtils\n          .getRemoteNodeFileDir(conf, params.getAppId(),\n          params.getAppOwner(), remoteRootLogDir, remoteRootLogDirSuffix);\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception ex) {\n      html.h1(\"No logs available for container \"\n          + params.getContainerId().toString());\n      return;\n    }\n\n    NodeId nodeId \u003d params.getNodeId();\n    String logEntity \u003d params.getLogEntity();\n    ApplicationId appId \u003d params.getAppId();\n    ContainerId containerId \u003d params.getContainerId();\n    long start \u003d params.getStartIndex();\n    long end \u003d params.getEndIndex();\n    long startTime \u003d params.getStartTime();\n    long endTime \u003d params.getEndTime();\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      while (nodeFiles.hasNext()) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        try {\n          FileStatus thisNodeFile \u003d nodeFiles.next();\n          if (thisNodeFile.getPath().getName().equals(\n              params.getAppId() + \".har\")) {\n            Path p \u003d new Path(\"har:///\"\n                + thisNodeFile.getPath().toUri().getRawPath());\n            nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n            continue;\n          }\n          if (!thisNodeFile.getPath().getName()\n              .contains(LogAggregationUtils.getNodeString(nodeId))\n              || thisNodeFile.getPath().getName()\n                  .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n            continue;\n          }\n          long logUploadedTime \u003d thisNodeFile.getModificationTime();\n          if (logUploadedTime \u003c startTime || logUploadedTime \u003e endTime) {\n            continue;\n          }\n          reader \u003d new AggregatedLogFormat.LogReader(\n              conf, thisNodeFile.getPath());\n\n          String owner \u003d null;\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n          try {\n            owner \u003d reader.getApplicationOwner();\n            appAcls \u003d reader.getApplicationAcls();\n          } catch (IOException e) {\n            LOG.error(\"Error getting logs for \" + logEntity, e);\n            continue;\n          }\n          String remoteUser \u003d request().getRemoteUser();\n\n          if (!checkAcls(conf, appId, owner, appAcls, remoteUser)) {\n            html.h1().__(\"User [\" + remoteUser\n                + \"] is not authorized to view the logs for \" + logEntity\n                + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n                .__();\n            LOG.error(\"User [\" + remoteUser\n                + \"] is not authorized to view the logs for \" + logEntity);\n            continue;\n          }\n\n          AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n              .getContainerLogsReader(containerId);\n          if (logReader \u003d\u003d null) {\n            continue;\n          }\n\n          foundLog \u003d readContainerLogs(html, logReader, start, end,\n              desiredLogType, logUploadedTime, startTime, endTime);\n        } catch (IOException ex) {\n          LOG.error(\"Error getting logs for \" + logEntity, ex);\n          continue;\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \"\n              + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (IOException e) {\n      html.h1().__(\"Error getting logs for \" + logEntity).__();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/tfile/TFileAggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "631b5c2db733b0733a779e843b8035f68d0fcdf3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5418. When partial log aggregation is enabled, display the list of aggregated files on the container log page. (Xuan Gong via wangda)\n\nChange-Id: I1befb0bbaeb89fb315bafe3e2f3379663f8cf1ec\n",
      "commitDate": "15/12/17 3:38 PM",
      "commitName": "631b5c2db733b0733a779e843b8035f68d0fcdf3",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "31/08/17 4:41 PM",
      "commitNameOld": "91cc070d67533ebb3325b982eba2135e0d175a82",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 106.0,
      "commitsBetweenForRepo": 857,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,108 @@\n   protected void render(Block html) {\n \n     BlockParameters params \u003d verifyAndParseParameters(html);\n     if (params \u003d\u003d null) {\n       return;\n     }\n \n     RemoteIterator\u003cFileStatus\u003e nodeFiles;\n     try {\n       nodeFiles \u003d LogAggregationUtils\n           .getRemoteNodeFileDir(conf, params.getAppId(),\n               params.getAppOwner());\n     } catch (RuntimeException e) {\n       throw e;\n     } catch (Exception ex) {\n       html.h1(\"No logs available for container \"\n           + params.getContainerId().toString());\n       return;\n     }\n \n     NodeId nodeId \u003d params.getNodeId();\n     String logEntity \u003d params.getLogEntity();\n     ApplicationId appId \u003d params.getAppId();\n     ContainerId containerId \u003d params.getContainerId();\n     long start \u003d params.getStartIndex();\n     long end \u003d params.getEndIndex();\n+    long startTime \u003d params.getStartTime();\n+    long endTime \u003d params.getEndTime();\n \n     boolean foundLog \u003d false;\n     String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n     try {\n       while (nodeFiles.hasNext()) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         try {\n           FileStatus thisNodeFile \u003d nodeFiles.next();\n           if (thisNodeFile.getPath().getName().equals(\n               params.getAppId() + \".har\")) {\n             Path p \u003d new Path(\"har:///\"\n                 + thisNodeFile.getPath().toUri().getRawPath());\n             nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n             continue;\n           }\n           if (!thisNodeFile.getPath().getName()\n               .contains(LogAggregationUtils.getNodeString(nodeId))\n               || thisNodeFile.getPath().getName()\n                   .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n             continue;\n           }\n           long logUploadedTime \u003d thisNodeFile.getModificationTime();\n+          if (logUploadedTime \u003c startTime || logUploadedTime \u003e endTime) {\n+            continue;\n+          }\n           reader \u003d new AggregatedLogFormat.LogReader(\n               conf, thisNodeFile.getPath());\n \n           String owner \u003d null;\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n           try {\n             owner \u003d reader.getApplicationOwner();\n             appAcls \u003d reader.getApplicationAcls();\n           } catch (IOException e) {\n             LOG.error(\"Error getting logs for \" + logEntity, e);\n             continue;\n           }\n           String remoteUser \u003d request().getRemoteUser();\n \n           if (!checkAcls(conf, appId, owner, appAcls, remoteUser)) {\n             html.h1().__(\"User [\" + remoteUser\n                 + \"] is not authorized to view the logs for \" + logEntity\n                 + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n                 .__();\n             LOG.error(\"User [\" + remoteUser\n                 + \"] is not authorized to view the logs for \" + logEntity);\n             continue;\n           }\n \n           AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n               .getContainerLogsReader(containerId);\n           if (logReader \u003d\u003d null) {\n             continue;\n           }\n \n           foundLog \u003d readContainerLogs(html, logReader, start, end,\n-              desiredLogType, logUploadedTime);\n+              desiredLogType, logUploadedTime, startTime, endTime);\n         } catch (IOException ex) {\n           LOG.error(\"Error getting logs for \" + logEntity, ex);\n           continue;\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n         }\n       }\n       if (!foundLog) {\n         if (desiredLogType.isEmpty()) {\n           html.h1(\"No logs available for container \"\n               + containerId.toString());\n         } else {\n           html.h1(\"Unable to locate \u0027\" + desiredLogType\n               + \"\u0027 log for container \" + containerId.toString());\n         }\n       }\n     } catch (IOException e) {\n       html.h1().__(\"Error getting logs for \" + logEntity).__();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n\n    BlockParameters params \u003d verifyAndParseParameters(html);\n    if (params \u003d\u003d null) {\n      return;\n    }\n\n    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n    try {\n      nodeFiles \u003d LogAggregationUtils\n          .getRemoteNodeFileDir(conf, params.getAppId(),\n              params.getAppOwner());\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception ex) {\n      html.h1(\"No logs available for container \"\n          + params.getContainerId().toString());\n      return;\n    }\n\n    NodeId nodeId \u003d params.getNodeId();\n    String logEntity \u003d params.getLogEntity();\n    ApplicationId appId \u003d params.getAppId();\n    ContainerId containerId \u003d params.getContainerId();\n    long start \u003d params.getStartIndex();\n    long end \u003d params.getEndIndex();\n    long startTime \u003d params.getStartTime();\n    long endTime \u003d params.getEndTime();\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      while (nodeFiles.hasNext()) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        try {\n          FileStatus thisNodeFile \u003d nodeFiles.next();\n          if (thisNodeFile.getPath().getName().equals(\n              params.getAppId() + \".har\")) {\n            Path p \u003d new Path(\"har:///\"\n                + thisNodeFile.getPath().toUri().getRawPath());\n            nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n            continue;\n          }\n          if (!thisNodeFile.getPath().getName()\n              .contains(LogAggregationUtils.getNodeString(nodeId))\n              || thisNodeFile.getPath().getName()\n                  .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n            continue;\n          }\n          long logUploadedTime \u003d thisNodeFile.getModificationTime();\n          if (logUploadedTime \u003c startTime || logUploadedTime \u003e endTime) {\n            continue;\n          }\n          reader \u003d new AggregatedLogFormat.LogReader(\n              conf, thisNodeFile.getPath());\n\n          String owner \u003d null;\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n          try {\n            owner \u003d reader.getApplicationOwner();\n            appAcls \u003d reader.getApplicationAcls();\n          } catch (IOException e) {\n            LOG.error(\"Error getting logs for \" + logEntity, e);\n            continue;\n          }\n          String remoteUser \u003d request().getRemoteUser();\n\n          if (!checkAcls(conf, appId, owner, appAcls, remoteUser)) {\n            html.h1().__(\"User [\" + remoteUser\n                + \"] is not authorized to view the logs for \" + logEntity\n                + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n                .__();\n            LOG.error(\"User [\" + remoteUser\n                + \"] is not authorized to view the logs for \" + logEntity);\n            continue;\n          }\n\n          AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n              .getContainerLogsReader(containerId);\n          if (logReader \u003d\u003d null) {\n            continue;\n          }\n\n          foundLog \u003d readContainerLogs(html, logReader, start, end,\n              desiredLogType, logUploadedTime, startTime, endTime);\n        } catch (IOException ex) {\n          LOG.error(\"Error getting logs for \" + logEntity, ex);\n          continue;\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \"\n              + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (IOException e) {\n      html.h1().__(\"Error getting logs for \" + logEntity).__();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/tfile/TFileAggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "91cc070d67533ebb3325b982eba2135e0d175a82": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6877. Create an abstract log reader for extendability. Contributed by Xuan Gong.\n",
      "commitDate": "31/08/17 4:41 PM",
      "commitName": "91cc070d67533ebb3325b982eba2135e0d175a82",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,103 @@\n+  protected void render(Block html) {\n+\n+    BlockParameters params \u003d verifyAndParseParameters(html);\n+    if (params \u003d\u003d null) {\n+      return;\n+    }\n+\n+    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n+    try {\n+      nodeFiles \u003d LogAggregationUtils\n+          .getRemoteNodeFileDir(conf, params.getAppId(),\n+              params.getAppOwner());\n+    } catch (RuntimeException e) {\n+      throw e;\n+    } catch (Exception ex) {\n+      html.h1(\"No logs available for container \"\n+          + params.getContainerId().toString());\n+      return;\n+    }\n+\n+    NodeId nodeId \u003d params.getNodeId();\n+    String logEntity \u003d params.getLogEntity();\n+    ApplicationId appId \u003d params.getAppId();\n+    ContainerId containerId \u003d params.getContainerId();\n+    long start \u003d params.getStartIndex();\n+    long end \u003d params.getEndIndex();\n+\n+    boolean foundLog \u003d false;\n+    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n+    try {\n+      while (nodeFiles.hasNext()) {\n+        AggregatedLogFormat.LogReader reader \u003d null;\n+        try {\n+          FileStatus thisNodeFile \u003d nodeFiles.next();\n+          if (thisNodeFile.getPath().getName().equals(\n+              params.getAppId() + \".har\")) {\n+            Path p \u003d new Path(\"har:///\"\n+                + thisNodeFile.getPath().toUri().getRawPath());\n+            nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n+            continue;\n+          }\n+          if (!thisNodeFile.getPath().getName()\n+              .contains(LogAggregationUtils.getNodeString(nodeId))\n+              || thisNodeFile.getPath().getName()\n+                  .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n+            continue;\n+          }\n+          long logUploadedTime \u003d thisNodeFile.getModificationTime();\n+          reader \u003d new AggregatedLogFormat.LogReader(\n+              conf, thisNodeFile.getPath());\n+\n+          String owner \u003d null;\n+          Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n+          try {\n+            owner \u003d reader.getApplicationOwner();\n+            appAcls \u003d reader.getApplicationAcls();\n+          } catch (IOException e) {\n+            LOG.error(\"Error getting logs for \" + logEntity, e);\n+            continue;\n+          }\n+          String remoteUser \u003d request().getRemoteUser();\n+\n+          if (!checkAcls(conf, appId, owner, appAcls, remoteUser)) {\n+            html.h1().__(\"User [\" + remoteUser\n+                + \"] is not authorized to view the logs for \" + logEntity\n+                + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n+                .__();\n+            LOG.error(\"User [\" + remoteUser\n+                + \"] is not authorized to view the logs for \" + logEntity);\n+            continue;\n+          }\n+\n+          AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n+              .getContainerLogsReader(containerId);\n+          if (logReader \u003d\u003d null) {\n+            continue;\n+          }\n+\n+          foundLog \u003d readContainerLogs(html, logReader, start, end,\n+              desiredLogType, logUploadedTime);\n+        } catch (IOException ex) {\n+          LOG.error(\"Error getting logs for \" + logEntity, ex);\n+          continue;\n+        } finally {\n+          if (reader !\u003d null) {\n+            reader.close();\n+          }\n+        }\n+      }\n+      if (!foundLog) {\n+        if (desiredLogType.isEmpty()) {\n+          html.h1(\"No logs available for container \"\n+              + containerId.toString());\n+        } else {\n+          html.h1(\"Unable to locate \u0027\" + desiredLogType\n+              + \"\u0027 log for container \" + containerId.toString());\n+        }\n+      }\n+    } catch (IOException e) {\n+      html.h1().__(\"Error getting logs for \" + logEntity).__();\n+      LOG.error(\"Error getting logs for \" + logEntity, e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n\n    BlockParameters params \u003d verifyAndParseParameters(html);\n    if (params \u003d\u003d null) {\n      return;\n    }\n\n    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n    try {\n      nodeFiles \u003d LogAggregationUtils\n          .getRemoteNodeFileDir(conf, params.getAppId(),\n              params.getAppOwner());\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception ex) {\n      html.h1(\"No logs available for container \"\n          + params.getContainerId().toString());\n      return;\n    }\n\n    NodeId nodeId \u003d params.getNodeId();\n    String logEntity \u003d params.getLogEntity();\n    ApplicationId appId \u003d params.getAppId();\n    ContainerId containerId \u003d params.getContainerId();\n    long start \u003d params.getStartIndex();\n    long end \u003d params.getEndIndex();\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      while (nodeFiles.hasNext()) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        try {\n          FileStatus thisNodeFile \u003d nodeFiles.next();\n          if (thisNodeFile.getPath().getName().equals(\n              params.getAppId() + \".har\")) {\n            Path p \u003d new Path(\"har:///\"\n                + thisNodeFile.getPath().toUri().getRawPath());\n            nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n            continue;\n          }\n          if (!thisNodeFile.getPath().getName()\n              .contains(LogAggregationUtils.getNodeString(nodeId))\n              || thisNodeFile.getPath().getName()\n                  .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n            continue;\n          }\n          long logUploadedTime \u003d thisNodeFile.getModificationTime();\n          reader \u003d new AggregatedLogFormat.LogReader(\n              conf, thisNodeFile.getPath());\n\n          String owner \u003d null;\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n          try {\n            owner \u003d reader.getApplicationOwner();\n            appAcls \u003d reader.getApplicationAcls();\n          } catch (IOException e) {\n            LOG.error(\"Error getting logs for \" + logEntity, e);\n            continue;\n          }\n          String remoteUser \u003d request().getRemoteUser();\n\n          if (!checkAcls(conf, appId, owner, appAcls, remoteUser)) {\n            html.h1().__(\"User [\" + remoteUser\n                + \"] is not authorized to view the logs for \" + logEntity\n                + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")\n                .__();\n            LOG.error(\"User [\" + remoteUser\n                + \"] is not authorized to view the logs for \" + logEntity);\n            continue;\n          }\n\n          AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n              .getContainerLogsReader(containerId);\n          if (logReader \u003d\u003d null) {\n            continue;\n          }\n\n          foundLog \u003d readContainerLogs(html, logReader, start, end,\n              desiredLogType, logUploadedTime);\n        } catch (IOException ex) {\n          LOG.error(\"Error getting logs for \" + logEntity, ex);\n          continue;\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \"\n              + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (IOException e) {\n      html.h1().__(\"Error getting logs for \" + logEntity).__();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/tfile/TFileAggregatedLogsBlock.java"
    }
  }
}