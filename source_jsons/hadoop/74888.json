{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DelegationTokenAuthenticationFilter.java",
  "functionName": "doFilter",
  "functionId": "doFilter___filterChain-FilterChain__request-HttpServletRequest__response-HttpServletResponse",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationFilter.java",
  "functionStartLine": 245,
  "functionEndLine": 309,
  "numCommitsSeen": 15,
  "timeTaken": 1484,
  "changeHistory": [
    "4070caad70db49b50554088d29ac2fbc7ba62a0a",
    "424a00daa069bf2049014fd46ad152ec5fc77ac8",
    "70b218748badf079c859c3af2b468a0b7b49c333",
    "6d7a6766bd55b355e44dbdcc4dfa22b050b1a509"
  ],
  "changeHistoryShort": {
    "4070caad70db49b50554088d29ac2fbc7ba62a0a": "Ybodychange",
    "424a00daa069bf2049014fd46ad152ec5fc77ac8": "Ybodychange",
    "70b218748badf079c859c3af2b468a0b7b49c333": "Ybodychange",
    "6d7a6766bd55b355e44dbdcc4dfa22b050b1a509": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4070caad70db49b50554088d29ac2fbc7ba62a0a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13526. Add detailed logging in KMS for the authentication failure of proxy user. Contributed by Suraj Acharya.\n",
      "commitDate": "22/08/16 6:09 PM",
      "commitName": "4070caad70db49b50554088d29ac2fbc7ba62a0a",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "19/05/16 6:48 AM",
      "commitNameOld": "22ff9e68d1d9f27d62455c15fb1242538551aca9",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 95.47,
      "commitsBetweenForRepo": 762,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,65 @@\n   protected void doFilter(FilterChain filterChain, HttpServletRequest request,\n       HttpServletResponse response) throws IOException, ServletException {\n     boolean requestCompleted \u003d false;\n     UserGroupInformation ugi \u003d null;\n     AuthenticationToken authToken \u003d (AuthenticationToken)\n         request.getUserPrincipal();\n     if (authToken !\u003d null \u0026\u0026 authToken !\u003d AuthenticationToken.ANONYMOUS) {\n       // if the request was authenticated because of a delegation token,\n       // then we ignore proxyuser (this is the same as the RPC behavior).\n       ugi \u003d (UserGroupInformation) request.getAttribute(\n           DelegationTokenAuthenticationHandler.DELEGATION_TOKEN_UGI_ATTRIBUTE);\n       if (ugi \u003d\u003d null) {\n         String realUser \u003d request.getUserPrincipal().getName();\n         ugi \u003d UserGroupInformation.createRemoteUser(realUser,\n             handlerAuthMethod);\n         String doAsUser \u003d getDoAs(request);\n         if (doAsUser !\u003d null) {\n           ugi \u003d UserGroupInformation.createProxyUser(doAsUser, ugi);\n           try {\n             ProxyUsers.authorize(ugi, request.getRemoteAddr());\n           } catch (AuthorizationException ex) {\n             HttpExceptionUtils.createServletExceptionResponse(response,\n                 HttpServletResponse.SC_FORBIDDEN, ex);\n             requestCompleted \u003d true;\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Authentication exception: \" + ex.getMessage(), ex);\n+            } else {\n+              LOG.warn(\"Authentication exception: \" + ex.getMessage());\n+            }\n           }\n         }\n       }\n       UGI_TL.set(ugi);\n     }\n     if (!requestCompleted) {\n       final UserGroupInformation ugiF \u003d ugi;\n       try {\n         request \u003d new HttpServletRequestWrapper(request) {\n \n           @Override\n           public String getAuthType() {\n             return (ugiF !\u003d null) ? handlerAuthMethod.toString() : null;\n           }\n \n           @Override\n           public String getRemoteUser() {\n             return (ugiF !\u003d null) ? ugiF.getShortUserName() : null;\n           }\n \n           @Override\n           public Principal getUserPrincipal() {\n             return (ugiF !\u003d null) ? new Principal() {\n               @Override\n               public String getName() {\n                 return ugiF.getUserName();\n               }\n             } : null;\n           }\n         };\n         super.doFilter(filterChain, request, response);\n       } finally {\n         UGI_TL.remove();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doFilter(FilterChain filterChain, HttpServletRequest request,\n      HttpServletResponse response) throws IOException, ServletException {\n    boolean requestCompleted \u003d false;\n    UserGroupInformation ugi \u003d null;\n    AuthenticationToken authToken \u003d (AuthenticationToken)\n        request.getUserPrincipal();\n    if (authToken !\u003d null \u0026\u0026 authToken !\u003d AuthenticationToken.ANONYMOUS) {\n      // if the request was authenticated because of a delegation token,\n      // then we ignore proxyuser (this is the same as the RPC behavior).\n      ugi \u003d (UserGroupInformation) request.getAttribute(\n          DelegationTokenAuthenticationHandler.DELEGATION_TOKEN_UGI_ATTRIBUTE);\n      if (ugi \u003d\u003d null) {\n        String realUser \u003d request.getUserPrincipal().getName();\n        ugi \u003d UserGroupInformation.createRemoteUser(realUser,\n            handlerAuthMethod);\n        String doAsUser \u003d getDoAs(request);\n        if (doAsUser !\u003d null) {\n          ugi \u003d UserGroupInformation.createProxyUser(doAsUser, ugi);\n          try {\n            ProxyUsers.authorize(ugi, request.getRemoteAddr());\n          } catch (AuthorizationException ex) {\n            HttpExceptionUtils.createServletExceptionResponse(response,\n                HttpServletResponse.SC_FORBIDDEN, ex);\n            requestCompleted \u003d true;\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Authentication exception: \" + ex.getMessage(), ex);\n            } else {\n              LOG.warn(\"Authentication exception: \" + ex.getMessage());\n            }\n          }\n        }\n      }\n      UGI_TL.set(ugi);\n    }\n    if (!requestCompleted) {\n      final UserGroupInformation ugiF \u003d ugi;\n      try {\n        request \u003d new HttpServletRequestWrapper(request) {\n\n          @Override\n          public String getAuthType() {\n            return (ugiF !\u003d null) ? handlerAuthMethod.toString() : null;\n          }\n\n          @Override\n          public String getRemoteUser() {\n            return (ugiF !\u003d null) ? ugiF.getShortUserName() : null;\n          }\n\n          @Override\n          public Principal getUserPrincipal() {\n            return (ugiF !\u003d null) ? new Principal() {\n              @Override\n              public String getName() {\n                return ugiF.getUserName();\n              }\n            } : null;\n          }\n        };\n        super.doFilter(filterChain, request, response);\n      } finally {\n        UGI_TL.remove();\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationFilter.java",
      "extendedDetails": {}
    },
    "424a00daa069bf2049014fd46ad152ec5fc77ac8": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11704. DelegationTokenAuthenticationFilter must pass ipaddress instead of hostname to ProxyUsers#authorize (Anubhav Dhoot via asuresh)\n",
      "commitDate": "21/04/15 11:31 AM",
      "commitName": "424a00daa069bf2049014fd46ad152ec5fc77ac8",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "05/11/14 5:47 PM",
      "commitNameOld": "8a261e68e4177b47be01ceae7310ea56aeb7ca38",
      "commitAuthorOld": "Aaron T. Myers",
      "daysBetweenCommits": 166.7,
      "commitsBetweenForRepo": 1298,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   protected void doFilter(FilterChain filterChain, HttpServletRequest request,\n       HttpServletResponse response) throws IOException, ServletException {\n     boolean requestCompleted \u003d false;\n     UserGroupInformation ugi \u003d null;\n     AuthenticationToken authToken \u003d (AuthenticationToken)\n         request.getUserPrincipal();\n     if (authToken !\u003d null \u0026\u0026 authToken !\u003d AuthenticationToken.ANONYMOUS) {\n       // if the request was authenticated because of a delegation token,\n       // then we ignore proxyuser (this is the same as the RPC behavior).\n       ugi \u003d (UserGroupInformation) request.getAttribute(\n           DelegationTokenAuthenticationHandler.DELEGATION_TOKEN_UGI_ATTRIBUTE);\n       if (ugi \u003d\u003d null) {\n         String realUser \u003d request.getUserPrincipal().getName();\n         ugi \u003d UserGroupInformation.createRemoteUser(realUser,\n             handlerAuthMethod);\n         String doAsUser \u003d getDoAs(request);\n         if (doAsUser !\u003d null) {\n           ugi \u003d UserGroupInformation.createProxyUser(doAsUser, ugi);\n           try {\n-            ProxyUsers.authorize(ugi, request.getRemoteHost());\n+            ProxyUsers.authorize(ugi, request.getRemoteAddr());\n           } catch (AuthorizationException ex) {\n             HttpExceptionUtils.createServletExceptionResponse(response,\n                 HttpServletResponse.SC_FORBIDDEN, ex);\n             requestCompleted \u003d true;\n           }\n         }\n       }\n       UGI_TL.set(ugi);\n     }\n     if (!requestCompleted) {\n       final UserGroupInformation ugiF \u003d ugi;\n       try {\n         request \u003d new HttpServletRequestWrapper(request) {\n \n           @Override\n           public String getAuthType() {\n             return (ugiF !\u003d null) ? handlerAuthMethod.toString() : null;\n           }\n \n           @Override\n           public String getRemoteUser() {\n             return (ugiF !\u003d null) ? ugiF.getShortUserName() : null;\n           }\n \n           @Override\n           public Principal getUserPrincipal() {\n             return (ugiF !\u003d null) ? new Principal() {\n               @Override\n               public String getName() {\n                 return ugiF.getUserName();\n               }\n             } : null;\n           }\n         };\n         super.doFilter(filterChain, request, response);\n       } finally {\n         UGI_TL.remove();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doFilter(FilterChain filterChain, HttpServletRequest request,\n      HttpServletResponse response) throws IOException, ServletException {\n    boolean requestCompleted \u003d false;\n    UserGroupInformation ugi \u003d null;\n    AuthenticationToken authToken \u003d (AuthenticationToken)\n        request.getUserPrincipal();\n    if (authToken !\u003d null \u0026\u0026 authToken !\u003d AuthenticationToken.ANONYMOUS) {\n      // if the request was authenticated because of a delegation token,\n      // then we ignore proxyuser (this is the same as the RPC behavior).\n      ugi \u003d (UserGroupInformation) request.getAttribute(\n          DelegationTokenAuthenticationHandler.DELEGATION_TOKEN_UGI_ATTRIBUTE);\n      if (ugi \u003d\u003d null) {\n        String realUser \u003d request.getUserPrincipal().getName();\n        ugi \u003d UserGroupInformation.createRemoteUser(realUser,\n            handlerAuthMethod);\n        String doAsUser \u003d getDoAs(request);\n        if (doAsUser !\u003d null) {\n          ugi \u003d UserGroupInformation.createProxyUser(doAsUser, ugi);\n          try {\n            ProxyUsers.authorize(ugi, request.getRemoteAddr());\n          } catch (AuthorizationException ex) {\n            HttpExceptionUtils.createServletExceptionResponse(response,\n                HttpServletResponse.SC_FORBIDDEN, ex);\n            requestCompleted \u003d true;\n          }\n        }\n      }\n      UGI_TL.set(ugi);\n    }\n    if (!requestCompleted) {\n      final UserGroupInformation ugiF \u003d ugi;\n      try {\n        request \u003d new HttpServletRequestWrapper(request) {\n\n          @Override\n          public String getAuthType() {\n            return (ugiF !\u003d null) ? handlerAuthMethod.toString() : null;\n          }\n\n          @Override\n          public String getRemoteUser() {\n            return (ugiF !\u003d null) ? ugiF.getShortUserName() : null;\n          }\n\n          @Override\n          public Principal getUserPrincipal() {\n            return (ugiF !\u003d null) ? new Principal() {\n              @Override\n              public String getName() {\n                return ugiF.getUserName();\n              }\n            } : null;\n          }\n        };\n        super.doFilter(filterChain, request, response);\n      } finally {\n        UGI_TL.remove();\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationFilter.java",
      "extendedDetails": {}
    },
    "70b218748badf079c859c3af2b468a0b7b49c333": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11015. Http server/client utils to propagate and recreate Exceptions from server to client. (tucu)\n",
      "commitDate": "04/09/14 9:11 AM",
      "commitName": "70b218748badf079c859c3af2b468a0b7b49c333",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "11/08/14 5:10 PM",
      "commitNameOld": "6d7a6766bd55b355e44dbdcc4dfa22b050b1a509",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 23.67,
      "commitsBetweenForRepo": 179,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,60 @@\n   protected void doFilter(FilterChain filterChain, HttpServletRequest request,\n       HttpServletResponse response) throws IOException, ServletException {\n     boolean requestCompleted \u003d false;\n     UserGroupInformation ugi \u003d null;\n     AuthenticationToken authToken \u003d (AuthenticationToken)\n         request.getUserPrincipal();\n     if (authToken !\u003d null \u0026\u0026 authToken !\u003d AuthenticationToken.ANONYMOUS) {\n       // if the request was authenticated because of a delegation token,\n       // then we ignore proxyuser (this is the same as the RPC behavior).\n       ugi \u003d (UserGroupInformation) request.getAttribute(\n           DelegationTokenAuthenticationHandler.DELEGATION_TOKEN_UGI_ATTRIBUTE);\n       if (ugi \u003d\u003d null) {\n         String realUser \u003d request.getUserPrincipal().getName();\n         ugi \u003d UserGroupInformation.createRemoteUser(realUser,\n             handlerAuthMethod);\n         String doAsUser \u003d getDoAs(request);\n         if (doAsUser !\u003d null) {\n           ugi \u003d UserGroupInformation.createProxyUser(doAsUser, ugi);\n           try {\n             ProxyUsers.authorize(ugi, request.getRemoteHost());\n           } catch (AuthorizationException ex) {\n-            String msg \u003d String.format(\n-                \"User \u0027%s\u0027 from host \u0027%s\u0027 not allowed to impersonate user \u0027%s\u0027\",\n-                realUser, request.getRemoteHost(), doAsUser);\n-            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n-            response.setContentType(APPLICATION_JSON_MIME);\n-            Map\u003cString, String\u003e json \u003d new HashMap\u003cString, String\u003e();\n-            json.put(ERROR_EXCEPTION_JSON,\n-                AuthorizationException.class.getName());\n-            json.put(ERROR_MESSAGE_JSON, msg);\n-            Writer writer \u003d response.getWriter();\n-            ObjectMapper jsonMapper \u003d new ObjectMapper();\n-            jsonMapper.writeValue(writer, json);\n+            HttpExceptionUtils.createServletExceptionResponse(response,\n+                HttpServletResponse.SC_FORBIDDEN, ex);\n             requestCompleted \u003d true;\n           }\n         }\n       }\n       UGI_TL.set(ugi);\n     }\n     if (!requestCompleted) {\n       final UserGroupInformation ugiF \u003d ugi;\n       try {\n         request \u003d new HttpServletRequestWrapper(request) {\n \n           @Override\n           public String getAuthType() {\n             return (ugiF !\u003d null) ? handlerAuthMethod.toString() : null;\n           }\n \n           @Override\n           public String getRemoteUser() {\n             return (ugiF !\u003d null) ? ugiF.getShortUserName() : null;\n           }\n \n           @Override\n           public Principal getUserPrincipal() {\n             return (ugiF !\u003d null) ? new Principal() {\n               @Override\n               public String getName() {\n                 return ugiF.getUserName();\n               }\n             } : null;\n           }\n         };\n         super.doFilter(filterChain, request, response);\n       } finally {\n         UGI_TL.remove();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doFilter(FilterChain filterChain, HttpServletRequest request,\n      HttpServletResponse response) throws IOException, ServletException {\n    boolean requestCompleted \u003d false;\n    UserGroupInformation ugi \u003d null;\n    AuthenticationToken authToken \u003d (AuthenticationToken)\n        request.getUserPrincipal();\n    if (authToken !\u003d null \u0026\u0026 authToken !\u003d AuthenticationToken.ANONYMOUS) {\n      // if the request was authenticated because of a delegation token,\n      // then we ignore proxyuser (this is the same as the RPC behavior).\n      ugi \u003d (UserGroupInformation) request.getAttribute(\n          DelegationTokenAuthenticationHandler.DELEGATION_TOKEN_UGI_ATTRIBUTE);\n      if (ugi \u003d\u003d null) {\n        String realUser \u003d request.getUserPrincipal().getName();\n        ugi \u003d UserGroupInformation.createRemoteUser(realUser,\n            handlerAuthMethod);\n        String doAsUser \u003d getDoAs(request);\n        if (doAsUser !\u003d null) {\n          ugi \u003d UserGroupInformation.createProxyUser(doAsUser, ugi);\n          try {\n            ProxyUsers.authorize(ugi, request.getRemoteHost());\n          } catch (AuthorizationException ex) {\n            HttpExceptionUtils.createServletExceptionResponse(response,\n                HttpServletResponse.SC_FORBIDDEN, ex);\n            requestCompleted \u003d true;\n          }\n        }\n      }\n      UGI_TL.set(ugi);\n    }\n    if (!requestCompleted) {\n      final UserGroupInformation ugiF \u003d ugi;\n      try {\n        request \u003d new HttpServletRequestWrapper(request) {\n\n          @Override\n          public String getAuthType() {\n            return (ugiF !\u003d null) ? handlerAuthMethod.toString() : null;\n          }\n\n          @Override\n          public String getRemoteUser() {\n            return (ugiF !\u003d null) ? ugiF.getShortUserName() : null;\n          }\n\n          @Override\n          public Principal getUserPrincipal() {\n            return (ugiF !\u003d null) ? new Principal() {\n              @Override\n              public String getName() {\n                return ugiF.getUserName();\n              }\n            } : null;\n          }\n        };\n        super.doFilter(filterChain, request, response);\n      } finally {\n        UGI_TL.remove();\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationFilter.java",
      "extendedDetails": {}
    },
    "6d7a6766bd55b355e44dbdcc4dfa22b050b1a509": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10835. Implement HTTP proxyuser support in HTTP authentication client/server libraries. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617384 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/08/14 5:10 PM",
      "commitName": "6d7a6766bd55b355e44dbdcc4dfa22b050b1a509",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,70 @@\n+  protected void doFilter(FilterChain filterChain, HttpServletRequest request,\n+      HttpServletResponse response) throws IOException, ServletException {\n+    boolean requestCompleted \u003d false;\n+    UserGroupInformation ugi \u003d null;\n+    AuthenticationToken authToken \u003d (AuthenticationToken)\n+        request.getUserPrincipal();\n+    if (authToken !\u003d null \u0026\u0026 authToken !\u003d AuthenticationToken.ANONYMOUS) {\n+      // if the request was authenticated because of a delegation token,\n+      // then we ignore proxyuser (this is the same as the RPC behavior).\n+      ugi \u003d (UserGroupInformation) request.getAttribute(\n+          DelegationTokenAuthenticationHandler.DELEGATION_TOKEN_UGI_ATTRIBUTE);\n+      if (ugi \u003d\u003d null) {\n+        String realUser \u003d request.getUserPrincipal().getName();\n+        ugi \u003d UserGroupInformation.createRemoteUser(realUser,\n+            handlerAuthMethod);\n+        String doAsUser \u003d getDoAs(request);\n+        if (doAsUser !\u003d null) {\n+          ugi \u003d UserGroupInformation.createProxyUser(doAsUser, ugi);\n+          try {\n+            ProxyUsers.authorize(ugi, request.getRemoteHost());\n+          } catch (AuthorizationException ex) {\n+            String msg \u003d String.format(\n+                \"User \u0027%s\u0027 from host \u0027%s\u0027 not allowed to impersonate user \u0027%s\u0027\",\n+                realUser, request.getRemoteHost(), doAsUser);\n+            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n+            response.setContentType(APPLICATION_JSON_MIME);\n+            Map\u003cString, String\u003e json \u003d new HashMap\u003cString, String\u003e();\n+            json.put(ERROR_EXCEPTION_JSON,\n+                AuthorizationException.class.getName());\n+            json.put(ERROR_MESSAGE_JSON, msg);\n+            Writer writer \u003d response.getWriter();\n+            ObjectMapper jsonMapper \u003d new ObjectMapper();\n+            jsonMapper.writeValue(writer, json);\n+            requestCompleted \u003d true;\n+          }\n+        }\n+      }\n+      UGI_TL.set(ugi);\n+    }\n+    if (!requestCompleted) {\n+      final UserGroupInformation ugiF \u003d ugi;\n+      try {\n+        request \u003d new HttpServletRequestWrapper(request) {\n+\n+          @Override\n+          public String getAuthType() {\n+            return (ugiF !\u003d null) ? handlerAuthMethod.toString() : null;\n+          }\n+\n+          @Override\n+          public String getRemoteUser() {\n+            return (ugiF !\u003d null) ? ugiF.getShortUserName() : null;\n+          }\n+\n+          @Override\n+          public Principal getUserPrincipal() {\n+            return (ugiF !\u003d null) ? new Principal() {\n+              @Override\n+              public String getName() {\n+                return ugiF.getUserName();\n+              }\n+            } : null;\n+          }\n+        };\n+        super.doFilter(filterChain, request, response);\n+      } finally {\n+        UGI_TL.remove();\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doFilter(FilterChain filterChain, HttpServletRequest request,\n      HttpServletResponse response) throws IOException, ServletException {\n    boolean requestCompleted \u003d false;\n    UserGroupInformation ugi \u003d null;\n    AuthenticationToken authToken \u003d (AuthenticationToken)\n        request.getUserPrincipal();\n    if (authToken !\u003d null \u0026\u0026 authToken !\u003d AuthenticationToken.ANONYMOUS) {\n      // if the request was authenticated because of a delegation token,\n      // then we ignore proxyuser (this is the same as the RPC behavior).\n      ugi \u003d (UserGroupInformation) request.getAttribute(\n          DelegationTokenAuthenticationHandler.DELEGATION_TOKEN_UGI_ATTRIBUTE);\n      if (ugi \u003d\u003d null) {\n        String realUser \u003d request.getUserPrincipal().getName();\n        ugi \u003d UserGroupInformation.createRemoteUser(realUser,\n            handlerAuthMethod);\n        String doAsUser \u003d getDoAs(request);\n        if (doAsUser !\u003d null) {\n          ugi \u003d UserGroupInformation.createProxyUser(doAsUser, ugi);\n          try {\n            ProxyUsers.authorize(ugi, request.getRemoteHost());\n          } catch (AuthorizationException ex) {\n            String msg \u003d String.format(\n                \"User \u0027%s\u0027 from host \u0027%s\u0027 not allowed to impersonate user \u0027%s\u0027\",\n                realUser, request.getRemoteHost(), doAsUser);\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            response.setContentType(APPLICATION_JSON_MIME);\n            Map\u003cString, String\u003e json \u003d new HashMap\u003cString, String\u003e();\n            json.put(ERROR_EXCEPTION_JSON,\n                AuthorizationException.class.getName());\n            json.put(ERROR_MESSAGE_JSON, msg);\n            Writer writer \u003d response.getWriter();\n            ObjectMapper jsonMapper \u003d new ObjectMapper();\n            jsonMapper.writeValue(writer, json);\n            requestCompleted \u003d true;\n          }\n        }\n      }\n      UGI_TL.set(ugi);\n    }\n    if (!requestCompleted) {\n      final UserGroupInformation ugiF \u003d ugi;\n      try {\n        request \u003d new HttpServletRequestWrapper(request) {\n\n          @Override\n          public String getAuthType() {\n            return (ugiF !\u003d null) ? handlerAuthMethod.toString() : null;\n          }\n\n          @Override\n          public String getRemoteUser() {\n            return (ugiF !\u003d null) ? ugiF.getShortUserName() : null;\n          }\n\n          @Override\n          public Principal getUserPrincipal() {\n            return (ugiF !\u003d null) ? new Principal() {\n              @Override\n              public String getName() {\n                return ugiF.getUserName();\n              }\n            } : null;\n          }\n        };\n        super.doFilter(filterChain, request, response);\n      } finally {\n        UGI_TL.remove();\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/token/delegation/web/DelegationTokenAuthenticationFilter.java"
    }
  }
}