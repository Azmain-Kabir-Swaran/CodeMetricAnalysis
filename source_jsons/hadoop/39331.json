{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacityScheduler.java",
  "functionName": "checkAndGetApplicationPriority",
  "functionId": "checkAndGetApplicationPriority___priorityRequestedByApp-Priority__user-UserGroupInformation__queuePath-String__applicationId-ApplicationId",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
  "functionStartLine": 2654,
  "functionEndLine": 2708,
  "numCommitsSeen": 616,
  "timeTaken": 9778,
  "changeHistory": [
    "410c605aec308a2ccd903f60aade3aaeefcaa610",
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "2d0e24eb01cec6f4554671b54729717510711c63",
    "287d3d6804a869723ae36605a3c2d2b3eae3941e",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
    "b469ac531af1bdda01a04ae0b8d39218ca292163",
    "c39ca541f498712133890961598bbff50d89d68b"
  ],
  "changeHistoryShort": {
    "410c605aec308a2ccd903f60aade3aaeefcaa610": "Ybodychange",
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ymultichange(Yparameterchange,Ybodychange)",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "2d0e24eb01cec6f4554671b54729717510711c63": "Ybodychange",
    "287d3d6804a869723ae36605a3c2d2b3eae3941e": "Ymultichange(Yparameterchange,Ybodychange)",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": "Ybodychange",
    "b469ac531af1bdda01a04ae0b8d39218ca292163": "Ybodychange",
    "c39ca541f498712133890961598bbff50d89d68b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "410c605aec308a2ccd903f60aade3aaeefcaa610": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10247. Application priority queue ACLs are not respected. Contributed by Sunil G\n",
      "commitDate": "29/04/20 6:53 AM",
      "commitName": "410c605aec308a2ccd903f60aade3aaeefcaa610",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "25/03/20 4:20 AM",
      "commitNameOld": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 35.11,
      "commitsBetweenForRepo": 115,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n   public Priority checkAndGetApplicationPriority(\n           Priority priorityRequestedByApp, UserGroupInformation user,\n           String queuePath, ApplicationId applicationId) throws YarnException {\n     readLock.lock();\n     try {\n       Priority appPriority \u003d priorityRequestedByApp;\n \n       // Verify the scenario where priority is null from submissionContext.\n       if (null \u003d\u003d appPriority) {\n         // Verify whether submitted user has any default priority set. If so,\n         // user\u0027s default priority will get precedence over queue default.\n         // for updateApplicationPriority call flow, this check is done in\n         // CientRMService itself.\n         appPriority \u003d this.appPriorityACLManager.getDefaultPriority(\n             normalizeQueueName(queuePath),\n             user);\n \n         // Get the default priority for the Queue. If Queue is non-existent,\n         // then\n         // use default priority. Do it only if user doesn\u0027t have any default.\n         if (null \u003d\u003d appPriority) {\n           appPriority \u003d this.queueManager.getDefaultPriorityForQueue(\n               normalizeQueueName(queuePath));\n         }\n \n         LOG.info(\n             \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n                 + \"hence considering default queue/cluster priority: \"\n                 + appPriority.getPriority());\n       }\n \n       // Verify whether submitted priority is lesser than max priority\n       // in the cluster. If it is out of found, defining a max cap.\n       if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n           .getPriority()) {\n         appPriority \u003d Priority\n             .newInstance(getMaxClusterLevelAppPriority().getPriority());\n       }\n \n       // Lets check for ACLs here.\n-      if (!appPriorityACLManager.checkAccess(user, queuePath, appPriority)) {\n+      if (!appPriorityACLManager.checkAccess(user, normalizeQueueName(queuePath), appPriority)) {\n         throw new YarnException(new AccessControlException(\n-            \"User \" + user + \" does not have permission to submit/update \"\n-                + applicationId + \" for \" + appPriority));\n+                \"User \" + user + \" does not have permission to submit/update \"\n+                        + applicationId + \" for \" + appPriority));\n       }\n \n       LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n           + \"\u0027 is acceptable in queue : \" + queuePath + \" for application: \"\n           + applicationId);\n \n       return appPriority;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Priority checkAndGetApplicationPriority(\n          Priority priorityRequestedByApp, UserGroupInformation user,\n          String queuePath, ApplicationId applicationId) throws YarnException {\n    readLock.lock();\n    try {\n      Priority appPriority \u003d priorityRequestedByApp;\n\n      // Verify the scenario where priority is null from submissionContext.\n      if (null \u003d\u003d appPriority) {\n        // Verify whether submitted user has any default priority set. If so,\n        // user\u0027s default priority will get precedence over queue default.\n        // for updateApplicationPriority call flow, this check is done in\n        // CientRMService itself.\n        appPriority \u003d this.appPriorityACLManager.getDefaultPriority(\n            normalizeQueueName(queuePath),\n            user);\n\n        // Get the default priority for the Queue. If Queue is non-existent,\n        // then\n        // use default priority. Do it only if user doesn\u0027t have any default.\n        if (null \u003d\u003d appPriority) {\n          appPriority \u003d this.queueManager.getDefaultPriorityForQueue(\n              normalizeQueueName(queuePath));\n        }\n\n        LOG.info(\n            \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n                + \"hence considering default queue/cluster priority: \"\n                + appPriority.getPriority());\n      }\n\n      // Verify whether submitted priority is lesser than max priority\n      // in the cluster. If it is out of found, defining a max cap.\n      if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n          .getPriority()) {\n        appPriority \u003d Priority\n            .newInstance(getMaxClusterLevelAppPriority().getPriority());\n      }\n\n      // Lets check for ACLs here.\n      if (!appPriorityACLManager.checkAccess(user, normalizeQueueName(queuePath), appPriority)) {\n        throw new YarnException(new AccessControlException(\n                \"User \" + user + \" does not have permission to submit/update \"\n                        + applicationId + \" for \" + appPriority));\n      }\n\n      LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n          + \"\u0027 is acceptable in queue : \" + queuePath + \" for application: \"\n          + applicationId);\n\n      return appPriority;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
          "commitDate": "25/03/20 4:20 AM",
          "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
          "commitAuthor": "Sunil G",
          "commitDateOld": "19/03/20 12:25 AM",
          "commitNameOld": "f2d3ac2a3f27a849e00f529c5c2df6ef0bd82911",
          "commitAuthorOld": "Prabhu Joseph",
          "daysBetweenCommits": 6.16,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,55 @@\n   public Priority checkAndGetApplicationPriority(\n-      Priority priorityRequestedByApp, UserGroupInformation user,\n-      String queueName, ApplicationId applicationId) throws YarnException {\n+          Priority priorityRequestedByApp, UserGroupInformation user,\n+          String queuePath, ApplicationId applicationId) throws YarnException {\n     readLock.lock();\n     try {\n       Priority appPriority \u003d priorityRequestedByApp;\n \n       // Verify the scenario where priority is null from submissionContext.\n       if (null \u003d\u003d appPriority) {\n         // Verify whether submitted user has any default priority set. If so,\n         // user\u0027s default priority will get precedence over queue default.\n         // for updateApplicationPriority call flow, this check is done in\n         // CientRMService itself.\n-        appPriority \u003d this.appPriorityACLManager.getDefaultPriority(queueName,\n+        appPriority \u003d this.appPriorityACLManager.getDefaultPriority(\n+            normalizeQueueName(queuePath),\n             user);\n \n         // Get the default priority for the Queue. If Queue is non-existent,\n         // then\n         // use default priority. Do it only if user doesn\u0027t have any default.\n         if (null \u003d\u003d appPriority) {\n-          appPriority \u003d this.queueManager.getDefaultPriorityForQueue(queueName);\n+          appPriority \u003d this.queueManager.getDefaultPriorityForQueue(\n+              normalizeQueueName(queuePath));\n         }\n \n         LOG.info(\n             \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n                 + \"hence considering default queue/cluster priority: \"\n                 + appPriority.getPriority());\n       }\n \n       // Verify whether submitted priority is lesser than max priority\n       // in the cluster. If it is out of found, defining a max cap.\n       if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n           .getPriority()) {\n         appPriority \u003d Priority\n             .newInstance(getMaxClusterLevelAppPriority().getPriority());\n       }\n \n       // Lets check for ACLs here.\n-      if (!appPriorityACLManager.checkAccess(user, queueName, appPriority)) {\n+      if (!appPriorityACLManager.checkAccess(user, queuePath, appPriority)) {\n         throw new YarnException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit/update \"\n                 + applicationId + \" for \" + appPriority));\n       }\n \n       LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n-          + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n+          + \"\u0027 is acceptable in queue : \" + queuePath + \" for application: \"\n           + applicationId);\n \n       return appPriority;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Priority checkAndGetApplicationPriority(\n          Priority priorityRequestedByApp, UserGroupInformation user,\n          String queuePath, ApplicationId applicationId) throws YarnException {\n    readLock.lock();\n    try {\n      Priority appPriority \u003d priorityRequestedByApp;\n\n      // Verify the scenario where priority is null from submissionContext.\n      if (null \u003d\u003d appPriority) {\n        // Verify whether submitted user has any default priority set. If so,\n        // user\u0027s default priority will get precedence over queue default.\n        // for updateApplicationPriority call flow, this check is done in\n        // CientRMService itself.\n        appPriority \u003d this.appPriorityACLManager.getDefaultPriority(\n            normalizeQueueName(queuePath),\n            user);\n\n        // Get the default priority for the Queue. If Queue is non-existent,\n        // then\n        // use default priority. Do it only if user doesn\u0027t have any default.\n        if (null \u003d\u003d appPriority) {\n          appPriority \u003d this.queueManager.getDefaultPriorityForQueue(\n              normalizeQueueName(queuePath));\n        }\n\n        LOG.info(\n            \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n                + \"hence considering default queue/cluster priority: \"\n                + appPriority.getPriority());\n      }\n\n      // Verify whether submitted priority is lesser than max priority\n      // in the cluster. If it is out of found, defining a max cap.\n      if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n          .getPriority()) {\n        appPriority \u003d Priority\n            .newInstance(getMaxClusterLevelAppPriority().getPriority());\n      }\n\n      // Lets check for ACLs here.\n      if (!appPriorityACLManager.checkAccess(user, queuePath, appPriority)) {\n        throw new YarnException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit/update \"\n                + applicationId + \" for \" + appPriority));\n      }\n\n      LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n          + \"\u0027 is acceptable in queue : \" + queuePath + \" for application: \"\n          + applicationId);\n\n      return appPriority;\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[priorityRequestedByApp-Priority, user-UserGroupInformation, queueName-String, applicationId-ApplicationId]",
            "newValue": "[priorityRequestedByApp-Priority, user-UserGroupInformation, queuePath-String, applicationId-ApplicationId]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
          "commitDate": "25/03/20 4:20 AM",
          "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
          "commitAuthor": "Sunil G",
          "commitDateOld": "19/03/20 12:25 AM",
          "commitNameOld": "f2d3ac2a3f27a849e00f529c5c2df6ef0bd82911",
          "commitAuthorOld": "Prabhu Joseph",
          "daysBetweenCommits": 6.16,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,55 @@\n   public Priority checkAndGetApplicationPriority(\n-      Priority priorityRequestedByApp, UserGroupInformation user,\n-      String queueName, ApplicationId applicationId) throws YarnException {\n+          Priority priorityRequestedByApp, UserGroupInformation user,\n+          String queuePath, ApplicationId applicationId) throws YarnException {\n     readLock.lock();\n     try {\n       Priority appPriority \u003d priorityRequestedByApp;\n \n       // Verify the scenario where priority is null from submissionContext.\n       if (null \u003d\u003d appPriority) {\n         // Verify whether submitted user has any default priority set. If so,\n         // user\u0027s default priority will get precedence over queue default.\n         // for updateApplicationPriority call flow, this check is done in\n         // CientRMService itself.\n-        appPriority \u003d this.appPriorityACLManager.getDefaultPriority(queueName,\n+        appPriority \u003d this.appPriorityACLManager.getDefaultPriority(\n+            normalizeQueueName(queuePath),\n             user);\n \n         // Get the default priority for the Queue. If Queue is non-existent,\n         // then\n         // use default priority. Do it only if user doesn\u0027t have any default.\n         if (null \u003d\u003d appPriority) {\n-          appPriority \u003d this.queueManager.getDefaultPriorityForQueue(queueName);\n+          appPriority \u003d this.queueManager.getDefaultPriorityForQueue(\n+              normalizeQueueName(queuePath));\n         }\n \n         LOG.info(\n             \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n                 + \"hence considering default queue/cluster priority: \"\n                 + appPriority.getPriority());\n       }\n \n       // Verify whether submitted priority is lesser than max priority\n       // in the cluster. If it is out of found, defining a max cap.\n       if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n           .getPriority()) {\n         appPriority \u003d Priority\n             .newInstance(getMaxClusterLevelAppPriority().getPriority());\n       }\n \n       // Lets check for ACLs here.\n-      if (!appPriorityACLManager.checkAccess(user, queueName, appPriority)) {\n+      if (!appPriorityACLManager.checkAccess(user, queuePath, appPriority)) {\n         throw new YarnException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit/update \"\n                 + applicationId + \" for \" + appPriority));\n       }\n \n       LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n-          + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n+          + \"\u0027 is acceptable in queue : \" + queuePath + \" for application: \"\n           + applicationId);\n \n       return appPriority;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Priority checkAndGetApplicationPriority(\n          Priority priorityRequestedByApp, UserGroupInformation user,\n          String queuePath, ApplicationId applicationId) throws YarnException {\n    readLock.lock();\n    try {\n      Priority appPriority \u003d priorityRequestedByApp;\n\n      // Verify the scenario where priority is null from submissionContext.\n      if (null \u003d\u003d appPriority) {\n        // Verify whether submitted user has any default priority set. If so,\n        // user\u0027s default priority will get precedence over queue default.\n        // for updateApplicationPriority call flow, this check is done in\n        // CientRMService itself.\n        appPriority \u003d this.appPriorityACLManager.getDefaultPriority(\n            normalizeQueueName(queuePath),\n            user);\n\n        // Get the default priority for the Queue. If Queue is non-existent,\n        // then\n        // use default priority. Do it only if user doesn\u0027t have any default.\n        if (null \u003d\u003d appPriority) {\n          appPriority \u003d this.queueManager.getDefaultPriorityForQueue(\n              normalizeQueueName(queuePath));\n        }\n\n        LOG.info(\n            \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n                + \"hence considering default queue/cluster priority: \"\n                + appPriority.getPriority());\n      }\n\n      // Verify whether submitted priority is lesser than max priority\n      // in the cluster. If it is out of found, defining a max cap.\n      if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n          .getPriority()) {\n        appPriority \u003d Priority\n            .newInstance(getMaxClusterLevelAppPriority().getPriority());\n      }\n\n      // Lets check for ACLs here.\n      if (!appPriorityACLManager.checkAccess(user, queuePath, appPriority)) {\n        throw new YarnException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit/update \"\n                + applicationId + \" for \" + appPriority));\n      }\n\n      LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n          + \"\u0027 is acceptable in queue : \" + queuePath + \" for application: \"\n          + applicationId);\n\n      return appPriority;\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   public Priority checkAndGetApplicationPriority(\n       Priority priorityRequestedByApp, UserGroupInformation user,\n       String queueName, ApplicationId applicationId) throws YarnException {\n+    readLock.lock();\n     try {\n-      readLock.lock();\n       Priority appPriority \u003d priorityRequestedByApp;\n \n       // Verify the scenario where priority is null from submissionContext.\n       if (null \u003d\u003d appPriority) {\n         // Verify whether submitted user has any default priority set. If so,\n         // user\u0027s default priority will get precedence over queue default.\n         // for updateApplicationPriority call flow, this check is done in\n         // CientRMService itself.\n         appPriority \u003d this.appPriorityACLManager.getDefaultPriority(queueName,\n             user);\n \n         // Get the default priority for the Queue. If Queue is non-existent,\n         // then\n         // use default priority. Do it only if user doesn\u0027t have any default.\n         if (null \u003d\u003d appPriority) {\n           appPriority \u003d this.queueManager.getDefaultPriorityForQueue(queueName);\n         }\n \n         LOG.info(\n             \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n                 + \"hence considering default queue/cluster priority: \"\n                 + appPriority.getPriority());\n       }\n \n       // Verify whether submitted priority is lesser than max priority\n       // in the cluster. If it is out of found, defining a max cap.\n       if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n           .getPriority()) {\n         appPriority \u003d Priority\n             .newInstance(getMaxClusterLevelAppPriority().getPriority());\n       }\n \n       // Lets check for ACLs here.\n       if (!appPriorityACLManager.checkAccess(user, queueName, appPriority)) {\n         throw new YarnException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit/update \"\n                 + applicationId + \" for \" + appPriority));\n       }\n \n       LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n           + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n           + applicationId);\n \n       return appPriority;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Priority checkAndGetApplicationPriority(\n      Priority priorityRequestedByApp, UserGroupInformation user,\n      String queueName, ApplicationId applicationId) throws YarnException {\n    readLock.lock();\n    try {\n      Priority appPriority \u003d priorityRequestedByApp;\n\n      // Verify the scenario where priority is null from submissionContext.\n      if (null \u003d\u003d appPriority) {\n        // Verify whether submitted user has any default priority set. If so,\n        // user\u0027s default priority will get precedence over queue default.\n        // for updateApplicationPriority call flow, this check is done in\n        // CientRMService itself.\n        appPriority \u003d this.appPriorityACLManager.getDefaultPriority(queueName,\n            user);\n\n        // Get the default priority for the Queue. If Queue is non-existent,\n        // then\n        // use default priority. Do it only if user doesn\u0027t have any default.\n        if (null \u003d\u003d appPriority) {\n          appPriority \u003d this.queueManager.getDefaultPriorityForQueue(queueName);\n        }\n\n        LOG.info(\n            \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n                + \"hence considering default queue/cluster priority: \"\n                + appPriority.getPriority());\n      }\n\n      // Verify whether submitted priority is lesser than max priority\n      // in the cluster. If it is out of found, defining a max cap.\n      if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n          .getPriority()) {\n        appPriority \u003d Priority\n            .newInstance(getMaxClusterLevelAppPriority().getPriority());\n      }\n\n      // Lets check for ACLs here.\n      if (!appPriorityACLManager.checkAccess(user, queueName, appPriority)) {\n        throw new YarnException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit/update \"\n                + applicationId + \" for \" + appPriority));\n      }\n\n      LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n          + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n          + applicationId);\n\n      return appPriority;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "2d0e24eb01cec6f4554671b54729717510711c63": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6328. Fix a spelling mistake in CapacityScheduler. Contributed by Jin Yibo. This closes #202\n",
      "commitDate": "15/03/17 2:18 AM",
      "commitName": "2d0e24eb01cec6f4554671b54729717510711c63",
      "commitAuthor": "Sunil G",
      "commitDateOld": "07/03/17 10:34 PM",
      "commitNameOld": "1eb81867032b016a59662043cbae50daa52dafa9",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 7.11,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   public Priority checkAndGetApplicationPriority(\n       Priority priorityRequestedByApp, UserGroupInformation user,\n       String queueName, ApplicationId applicationId) throws YarnException {\n     try {\n       readLock.lock();\n       Priority appPriority \u003d priorityRequestedByApp;\n \n       // Verify the scenario where priority is null from submissionContext.\n       if (null \u003d\u003d appPriority) {\n         // Verify whether submitted user has any default priority set. If so,\n         // user\u0027s default priority will get precedence over queue default.\n         // for updateApplicationPriority call flow, this check is done in\n         // CientRMService itself.\n         appPriority \u003d this.appPriorityACLManager.getDefaultPriority(queueName,\n             user);\n \n         // Get the default priority for the Queue. If Queue is non-existent,\n         // then\n-        // use default priority. Do it only if user doesnt have any default.\n+        // use default priority. Do it only if user doesn\u0027t have any default.\n         if (null \u003d\u003d appPriority) {\n           appPriority \u003d this.queueManager.getDefaultPriorityForQueue(queueName);\n         }\n \n         LOG.info(\n             \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n                 + \"hence considering default queue/cluster priority: \"\n                 + appPriority.getPriority());\n       }\n \n       // Verify whether submitted priority is lesser than max priority\n       // in the cluster. If it is out of found, defining a max cap.\n       if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n           .getPriority()) {\n         appPriority \u003d Priority\n             .newInstance(getMaxClusterLevelAppPriority().getPriority());\n       }\n \n       // Lets check for ACLs here.\n       if (!appPriorityACLManager.checkAccess(user, queueName, appPriority)) {\n         throw new YarnException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit/update \"\n                 + applicationId + \" for \" + appPriority));\n       }\n \n       LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n           + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n           + applicationId);\n \n       return appPriority;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Priority checkAndGetApplicationPriority(\n      Priority priorityRequestedByApp, UserGroupInformation user,\n      String queueName, ApplicationId applicationId) throws YarnException {\n    try {\n      readLock.lock();\n      Priority appPriority \u003d priorityRequestedByApp;\n\n      // Verify the scenario where priority is null from submissionContext.\n      if (null \u003d\u003d appPriority) {\n        // Verify whether submitted user has any default priority set. If so,\n        // user\u0027s default priority will get precedence over queue default.\n        // for updateApplicationPriority call flow, this check is done in\n        // CientRMService itself.\n        appPriority \u003d this.appPriorityACLManager.getDefaultPriority(queueName,\n            user);\n\n        // Get the default priority for the Queue. If Queue is non-existent,\n        // then\n        // use default priority. Do it only if user doesn\u0027t have any default.\n        if (null \u003d\u003d appPriority) {\n          appPriority \u003d this.queueManager.getDefaultPriorityForQueue(queueName);\n        }\n\n        LOG.info(\n            \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n                + \"hence considering default queue/cluster priority: \"\n                + appPriority.getPriority());\n      }\n\n      // Verify whether submitted priority is lesser than max priority\n      // in the cluster. If it is out of found, defining a max cap.\n      if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n          .getPriority()) {\n        appPriority \u003d Priority\n            .newInstance(getMaxClusterLevelAppPriority().getPriority());\n      }\n\n      // Lets check for ACLs here.\n      if (!appPriorityACLManager.checkAccess(user, queueName, appPriority)) {\n        throw new YarnException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit/update \"\n                + applicationId + \" for \" + appPriority));\n      }\n\n      LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n          + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n          + applicationId);\n\n      return appPriority;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "287d3d6804a869723ae36605a3c2d2b3eae3941e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3955. Support for application priority ACLs in queues of CapacityScheduler. (Sunil G via wangda)\n",
      "commitDate": "09/01/17 8:40 AM",
      "commitName": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3955. Support for application priority ACLs in queues of CapacityScheduler. (Sunil G via wangda)\n",
          "commitDate": "09/01/17 8:40 AM",
          "commitName": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "05/01/17 10:31 AM",
          "commitNameOld": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.92,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,53 @@\n-  public Priority checkAndGetApplicationPriority(Priority priorityFromContext,\n-      String user, String queueName, ApplicationId applicationId)\n-      throws YarnException {\n-    Priority appPriority \u003d null;\n+  public Priority checkAndGetApplicationPriority(\n+      Priority priorityRequestedByApp, UserGroupInformation user,\n+      String queueName, ApplicationId applicationId) throws YarnException {\n+    try {\n+      readLock.lock();\n+      Priority appPriority \u003d priorityRequestedByApp;\n \n-    // ToDo: Verify against priority ACLs\n+      // Verify the scenario where priority is null from submissionContext.\n+      if (null \u003d\u003d appPriority) {\n+        // Verify whether submitted user has any default priority set. If so,\n+        // user\u0027s default priority will get precedence over queue default.\n+        // for updateApplicationPriority call flow, this check is done in\n+        // CientRMService itself.\n+        appPriority \u003d this.appPriorityACLManager.getDefaultPriority(queueName,\n+            user);\n \n-    // Verify the scenario where priority is null from submissionContext.\n-    if (null \u003d\u003d priorityFromContext) {\n-      // Get the default priority for the Queue. If Queue is non-existent, then\n-      // use default priority\n-      priorityFromContext \u003d this.queueManager.getDefaultPriorityForQueue(\n-          queueName);\n+        // Get the default priority for the Queue. If Queue is non-existent,\n+        // then\n+        // use default priority. Do it only if user doesnt have any default.\n+        if (null \u003d\u003d appPriority) {\n+          appPriority \u003d this.queueManager.getDefaultPriorityForQueue(queueName);\n+        }\n \n-      LOG.info(\"Application \u0027\" + applicationId\n-          + \"\u0027 is submitted without priority \"\n-          + \"hence considering default queue/cluster priority: \"\n-          + priorityFromContext.getPriority());\n+        LOG.info(\n+            \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n+                + \"hence considering default queue/cluster priority: \"\n+                + appPriority.getPriority());\n+      }\n+\n+      // Verify whether submitted priority is lesser than max priority\n+      // in the cluster. If it is out of found, defining a max cap.\n+      if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n+          .getPriority()) {\n+        appPriority \u003d Priority\n+            .newInstance(getMaxClusterLevelAppPriority().getPriority());\n+      }\n+\n+      // Lets check for ACLs here.\n+      if (!appPriorityACLManager.checkAccess(user, queueName, appPriority)) {\n+        throw new YarnException(new AccessControlException(\n+            \"User \" + user + \" does not have permission to submit/update \"\n+                + applicationId + \" for \" + appPriority));\n+      }\n+\n+      LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n+          + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n+          + applicationId);\n+\n+      return appPriority;\n+    } finally {\n+      readLock.unlock();\n     }\n-\n-    // Verify whether submitted priority is lesser than max priority\n-    // in the cluster. If it is out of found, defining a max cap.\n-    if (priorityFromContext.compareTo(getMaxClusterLevelAppPriority()) \u003c 0) {\n-      priorityFromContext \u003d Priority\n-          .newInstance(getMaxClusterLevelAppPriority().getPriority());\n-    }\n-\n-    appPriority \u003d priorityFromContext;\n-\n-    LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n-        + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n-        + applicationId + \" for the user: \" + user);\n-\n-    return appPriority;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Priority checkAndGetApplicationPriority(\n      Priority priorityRequestedByApp, UserGroupInformation user,\n      String queueName, ApplicationId applicationId) throws YarnException {\n    try {\n      readLock.lock();\n      Priority appPriority \u003d priorityRequestedByApp;\n\n      // Verify the scenario where priority is null from submissionContext.\n      if (null \u003d\u003d appPriority) {\n        // Verify whether submitted user has any default priority set. If so,\n        // user\u0027s default priority will get precedence over queue default.\n        // for updateApplicationPriority call flow, this check is done in\n        // CientRMService itself.\n        appPriority \u003d this.appPriorityACLManager.getDefaultPriority(queueName,\n            user);\n\n        // Get the default priority for the Queue. If Queue is non-existent,\n        // then\n        // use default priority. Do it only if user doesnt have any default.\n        if (null \u003d\u003d appPriority) {\n          appPriority \u003d this.queueManager.getDefaultPriorityForQueue(queueName);\n        }\n\n        LOG.info(\n            \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n                + \"hence considering default queue/cluster priority: \"\n                + appPriority.getPriority());\n      }\n\n      // Verify whether submitted priority is lesser than max priority\n      // in the cluster. If it is out of found, defining a max cap.\n      if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n          .getPriority()) {\n        appPriority \u003d Priority\n            .newInstance(getMaxClusterLevelAppPriority().getPriority());\n      }\n\n      // Lets check for ACLs here.\n      if (!appPriorityACLManager.checkAccess(user, queueName, appPriority)) {\n        throw new YarnException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit/update \"\n                + applicationId + \" for \" + appPriority));\n      }\n\n      LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n          + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n          + applicationId);\n\n      return appPriority;\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[priorityFromContext-Priority, user-String, queueName-String, applicationId-ApplicationId]",
            "newValue": "[priorityRequestedByApp-Priority, user-UserGroupInformation, queueName-String, applicationId-ApplicationId]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3955. Support for application priority ACLs in queues of CapacityScheduler. (Sunil G via wangda)\n",
          "commitDate": "09/01/17 8:40 AM",
          "commitName": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "05/01/17 10:31 AM",
          "commitNameOld": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.92,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,53 @@\n-  public Priority checkAndGetApplicationPriority(Priority priorityFromContext,\n-      String user, String queueName, ApplicationId applicationId)\n-      throws YarnException {\n-    Priority appPriority \u003d null;\n+  public Priority checkAndGetApplicationPriority(\n+      Priority priorityRequestedByApp, UserGroupInformation user,\n+      String queueName, ApplicationId applicationId) throws YarnException {\n+    try {\n+      readLock.lock();\n+      Priority appPriority \u003d priorityRequestedByApp;\n \n-    // ToDo: Verify against priority ACLs\n+      // Verify the scenario where priority is null from submissionContext.\n+      if (null \u003d\u003d appPriority) {\n+        // Verify whether submitted user has any default priority set. If so,\n+        // user\u0027s default priority will get precedence over queue default.\n+        // for updateApplicationPriority call flow, this check is done in\n+        // CientRMService itself.\n+        appPriority \u003d this.appPriorityACLManager.getDefaultPriority(queueName,\n+            user);\n \n-    // Verify the scenario where priority is null from submissionContext.\n-    if (null \u003d\u003d priorityFromContext) {\n-      // Get the default priority for the Queue. If Queue is non-existent, then\n-      // use default priority\n-      priorityFromContext \u003d this.queueManager.getDefaultPriorityForQueue(\n-          queueName);\n+        // Get the default priority for the Queue. If Queue is non-existent,\n+        // then\n+        // use default priority. Do it only if user doesnt have any default.\n+        if (null \u003d\u003d appPriority) {\n+          appPriority \u003d this.queueManager.getDefaultPriorityForQueue(queueName);\n+        }\n \n-      LOG.info(\"Application \u0027\" + applicationId\n-          + \"\u0027 is submitted without priority \"\n-          + \"hence considering default queue/cluster priority: \"\n-          + priorityFromContext.getPriority());\n+        LOG.info(\n+            \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n+                + \"hence considering default queue/cluster priority: \"\n+                + appPriority.getPriority());\n+      }\n+\n+      // Verify whether submitted priority is lesser than max priority\n+      // in the cluster. If it is out of found, defining a max cap.\n+      if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n+          .getPriority()) {\n+        appPriority \u003d Priority\n+            .newInstance(getMaxClusterLevelAppPriority().getPriority());\n+      }\n+\n+      // Lets check for ACLs here.\n+      if (!appPriorityACLManager.checkAccess(user, queueName, appPriority)) {\n+        throw new YarnException(new AccessControlException(\n+            \"User \" + user + \" does not have permission to submit/update \"\n+                + applicationId + \" for \" + appPriority));\n+      }\n+\n+      LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n+          + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n+          + applicationId);\n+\n+      return appPriority;\n+    } finally {\n+      readLock.unlock();\n     }\n-\n-    // Verify whether submitted priority is lesser than max priority\n-    // in the cluster. If it is out of found, defining a max cap.\n-    if (priorityFromContext.compareTo(getMaxClusterLevelAppPriority()) \u003c 0) {\n-      priorityFromContext \u003d Priority\n-          .newInstance(getMaxClusterLevelAppPriority().getPriority());\n-    }\n-\n-    appPriority \u003d priorityFromContext;\n-\n-    LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n-        + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n-        + applicationId + \" for the user: \" + user);\n-\n-    return appPriority;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Priority checkAndGetApplicationPriority(\n      Priority priorityRequestedByApp, UserGroupInformation user,\n      String queueName, ApplicationId applicationId) throws YarnException {\n    try {\n      readLock.lock();\n      Priority appPriority \u003d priorityRequestedByApp;\n\n      // Verify the scenario where priority is null from submissionContext.\n      if (null \u003d\u003d appPriority) {\n        // Verify whether submitted user has any default priority set. If so,\n        // user\u0027s default priority will get precedence over queue default.\n        // for updateApplicationPriority call flow, this check is done in\n        // CientRMService itself.\n        appPriority \u003d this.appPriorityACLManager.getDefaultPriority(queueName,\n            user);\n\n        // Get the default priority for the Queue. If Queue is non-existent,\n        // then\n        // use default priority. Do it only if user doesnt have any default.\n        if (null \u003d\u003d appPriority) {\n          appPriority \u003d this.queueManager.getDefaultPriorityForQueue(queueName);\n        }\n\n        LOG.info(\n            \"Application \u0027\" + applicationId + \"\u0027 is submitted without priority \"\n                + \"hence considering default queue/cluster priority: \"\n                + appPriority.getPriority());\n      }\n\n      // Verify whether submitted priority is lesser than max priority\n      // in the cluster. If it is out of found, defining a max cap.\n      if (appPriority.getPriority() \u003e getMaxClusterLevelAppPriority()\n          .getPriority()) {\n        appPriority \u003d Priority\n            .newInstance(getMaxClusterLevelAppPriority().getPriority());\n      }\n\n      // Lets check for ACLs here.\n      if (!appPriorityACLManager.checkAccess(user, queueName, appPriority)) {\n        throw new YarnException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit/update \"\n                + applicationId + \" for \" + appPriority));\n      }\n\n      LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n          + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n          + applicationId);\n\n      return appPriority;\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5761. Separate QueueManager from Scheduler. (Xuan Gong via gtcarrera9)\n",
      "commitDate": "30/11/16 1:38 PM",
      "commitName": "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
      "commitAuthor": "Li Lu",
      "commitDateOld": "29/11/16 9:40 AM",
      "commitNameOld": "25f9872be63423ada6a18481eaad2888e731fdac",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,35 @@\n   public Priority checkAndGetApplicationPriority(Priority priorityFromContext,\n       String user, String queueName, ApplicationId applicationId)\n       throws YarnException {\n     Priority appPriority \u003d null;\n \n     // ToDo: Verify against priority ACLs\n \n     // Verify the scenario where priority is null from submissionContext.\n     if (null \u003d\u003d priorityFromContext) {\n       // Get the default priority for the Queue. If Queue is non-existent, then\n       // use default priority\n-      priorityFromContext \u003d getDefaultPriorityForQueue(queueName);\n+      priorityFromContext \u003d this.queueManager.getDefaultPriorityForQueue(\n+          queueName);\n \n       LOG.info(\"Application \u0027\" + applicationId\n           + \"\u0027 is submitted without priority \"\n           + \"hence considering default queue/cluster priority: \"\n           + priorityFromContext.getPriority());\n     }\n \n     // Verify whether submitted priority is lesser than max priority\n     // in the cluster. If it is out of found, defining a max cap.\n     if (priorityFromContext.compareTo(getMaxClusterLevelAppPriority()) \u003c 0) {\n       priorityFromContext \u003d Priority\n           .newInstance(getMaxClusterLevelAppPriority().getPriority());\n     }\n \n     appPriority \u003d priorityFromContext;\n \n     LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n         + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n         + applicationId + \" for the user: \" + user);\n \n     return appPriority;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Priority checkAndGetApplicationPriority(Priority priorityFromContext,\n      String user, String queueName, ApplicationId applicationId)\n      throws YarnException {\n    Priority appPriority \u003d null;\n\n    // ToDo: Verify against priority ACLs\n\n    // Verify the scenario where priority is null from submissionContext.\n    if (null \u003d\u003d priorityFromContext) {\n      // Get the default priority for the Queue. If Queue is non-existent, then\n      // use default priority\n      priorityFromContext \u003d this.queueManager.getDefaultPriorityForQueue(\n          queueName);\n\n      LOG.info(\"Application \u0027\" + applicationId\n          + \"\u0027 is submitted without priority \"\n          + \"hence considering default queue/cluster priority: \"\n          + priorityFromContext.getPriority());\n    }\n\n    // Verify whether submitted priority is lesser than max priority\n    // in the cluster. If it is out of found, defining a max cap.\n    if (priorityFromContext.compareTo(getMaxClusterLevelAppPriority()) \u003c 0) {\n      priorityFromContext \u003d Priority\n          .newInstance(getMaxClusterLevelAppPriority().getPriority());\n    }\n\n    appPriority \u003d priorityFromContext;\n\n    LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n        + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n        + applicationId + \" for the user: \" + user);\n\n    return appPriority;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "b469ac531af1bdda01a04ae0b8d39218ca292163": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3970. Add REST api support for Application Priority. Contributed by Naganarasimha G R.\n",
      "commitDate": "03/09/15 4:10 AM",
      "commitName": "b469ac531af1bdda01a04ae0b8d39218ca292163",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "01/09/15 1:49 AM",
      "commitNameOld": "bf669b6d9f8ba165e30b8823218d625a49958925",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 2.1,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   public Priority checkAndGetApplicationPriority(Priority priorityFromContext,\n       String user, String queueName, ApplicationId applicationId)\n       throws YarnException {\n     Priority appPriority \u003d null;\n \n     // ToDo: Verify against priority ACLs\n \n     // Verify the scenario where priority is null from submissionContext.\n     if (null \u003d\u003d priorityFromContext) {\n       // Get the default priority for the Queue. If Queue is non-existent, then\n       // use default priority\n       priorityFromContext \u003d getDefaultPriorityForQueue(queueName);\n \n       LOG.info(\"Application \u0027\" + applicationId\n           + \"\u0027 is submitted without priority \"\n-          + \"hence considering default queue/cluster priority:\"\n+          + \"hence considering default queue/cluster priority: \"\n           + priorityFromContext.getPriority());\n     }\n \n     // Verify whether submitted priority is lesser than max priority\n     // in the cluster. If it is out of found, defining a max cap.\n     if (priorityFromContext.compareTo(getMaxClusterLevelAppPriority()) \u003c 0) {\n       priorityFromContext \u003d Priority\n           .newInstance(getMaxClusterLevelAppPriority().getPriority());\n     }\n \n     appPriority \u003d priorityFromContext;\n \n     LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n-        + \"\u0027 is acceptable in queue :\" + queueName + \"for application:\"\n-        + applicationId + \"for the user: \" + user);\n+        + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n+        + applicationId + \" for the user: \" + user);\n \n     return appPriority;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Priority checkAndGetApplicationPriority(Priority priorityFromContext,\n      String user, String queueName, ApplicationId applicationId)\n      throws YarnException {\n    Priority appPriority \u003d null;\n\n    // ToDo: Verify against priority ACLs\n\n    // Verify the scenario where priority is null from submissionContext.\n    if (null \u003d\u003d priorityFromContext) {\n      // Get the default priority for the Queue. If Queue is non-existent, then\n      // use default priority\n      priorityFromContext \u003d getDefaultPriorityForQueue(queueName);\n\n      LOG.info(\"Application \u0027\" + applicationId\n          + \"\u0027 is submitted without priority \"\n          + \"hence considering default queue/cluster priority: \"\n          + priorityFromContext.getPriority());\n    }\n\n    // Verify whether submitted priority is lesser than max priority\n    // in the cluster. If it is out of found, defining a max cap.\n    if (priorityFromContext.compareTo(getMaxClusterLevelAppPriority()) \u003c 0) {\n      priorityFromContext \u003d Priority\n          .newInstance(getMaxClusterLevelAppPriority().getPriority());\n    }\n\n    appPriority \u003d priorityFromContext;\n\n    LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n        + \"\u0027 is acceptable in queue : \" + queueName + \" for application: \"\n        + applicationId + \" for the user: \" + user);\n\n    return appPriority;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "c39ca541f498712133890961598bbff50d89d68b": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2003. Support for Application priority : Changes in RM and Capacity Scheduler. (Sunil G via wangda)\n",
      "commitDate": "21/07/15 9:57 AM",
      "commitName": "c39ca541f498712133890961598bbff50d89d68b",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,34 @@\n+  public Priority checkAndGetApplicationPriority(Priority priorityFromContext,\n+      String user, String queueName, ApplicationId applicationId)\n+      throws YarnException {\n+    Priority appPriority \u003d null;\n+\n+    // ToDo: Verify against priority ACLs\n+\n+    // Verify the scenario where priority is null from submissionContext.\n+    if (null \u003d\u003d priorityFromContext) {\n+      // Get the default priority for the Queue. If Queue is non-existent, then\n+      // use default priority\n+      priorityFromContext \u003d getDefaultPriorityForQueue(queueName);\n+\n+      LOG.info(\"Application \u0027\" + applicationId\n+          + \"\u0027 is submitted without priority \"\n+          + \"hence considering default queue/cluster priority:\"\n+          + priorityFromContext.getPriority());\n+    }\n+\n+    // Verify whether submitted priority is lesser than max priority\n+    // in the cluster. If it is out of found, defining a max cap.\n+    if (priorityFromContext.compareTo(getMaxClusterLevelAppPriority()) \u003c 0) {\n+      priorityFromContext \u003d Priority\n+          .newInstance(getMaxClusterLevelAppPriority().getPriority());\n+    }\n+\n+    appPriority \u003d priorityFromContext;\n+\n+    LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n+        + \"\u0027 is acceptable in queue :\" + queueName + \"for application:\"\n+        + applicationId + \"for the user: \" + user);\n+\n+    return appPriority;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Priority checkAndGetApplicationPriority(Priority priorityFromContext,\n      String user, String queueName, ApplicationId applicationId)\n      throws YarnException {\n    Priority appPriority \u003d null;\n\n    // ToDo: Verify against priority ACLs\n\n    // Verify the scenario where priority is null from submissionContext.\n    if (null \u003d\u003d priorityFromContext) {\n      // Get the default priority for the Queue. If Queue is non-existent, then\n      // use default priority\n      priorityFromContext \u003d getDefaultPriorityForQueue(queueName);\n\n      LOG.info(\"Application \u0027\" + applicationId\n          + \"\u0027 is submitted without priority \"\n          + \"hence considering default queue/cluster priority:\"\n          + priorityFromContext.getPriority());\n    }\n\n    // Verify whether submitted priority is lesser than max priority\n    // in the cluster. If it is out of found, defining a max cap.\n    if (priorityFromContext.compareTo(getMaxClusterLevelAppPriority()) \u003c 0) {\n      priorityFromContext \u003d Priority\n          .newInstance(getMaxClusterLevelAppPriority().getPriority());\n    }\n\n    appPriority \u003d priorityFromContext;\n\n    LOG.info(\"Priority \u0027\" + appPriority.getPriority()\n        + \"\u0027 is acceptable in queue :\" + queueName + \"for application:\"\n        + applicationId + \"for the user: \" + user);\n\n    return appPriority;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
    }
  }
}