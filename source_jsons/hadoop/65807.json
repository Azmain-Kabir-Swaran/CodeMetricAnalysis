{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DynamoDBMetadataStore.java",
  "functionName": "listChildren",
  "functionId": "listChildren___path-Path(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
  "functionStartLine": 810,
  "functionEndLine": 839,
  "numCommitsSeen": 44,
  "timeTaken": 6240,
  "changeHistory": [
    "56dee667707926f3796c7757be1a133a362f05c9",
    "ea25f4de236611d388e14a710ebe5d6872c421b6",
    "7b219778e05a50e33cca75d727e62783322b7f80",
    "cfb01869038065defe50ab53d4d1eda4e6cdee33",
    "085f10e75dea5446861253cf63aced337536481c",
    "7ba1cfdea7f5daf799adc4f0ed2e45f55841a058",
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
    "d7232857d8d1e10cdac171acdc931187e45fd6be",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
    "621b43e254afaff708cd6fc4698b29628f6abc33"
  ],
  "changeHistoryShort": {
    "56dee667707926f3796c7757be1a133a362f05c9": "Ybodychange",
    "ea25f4de236611d388e14a710ebe5d6872c421b6": "Ybodychange",
    "7b219778e05a50e33cca75d727e62783322b7f80": "Ybodychange",
    "cfb01869038065defe50ab53d4d1eda4e6cdee33": "Ybodychange",
    "085f10e75dea5446861253cf63aced337536481c": "Ybodychange",
    "7ba1cfdea7f5daf799adc4f0ed2e45f55841a058": "Ybodychange",
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3": "Ybodychange",
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899": "Ybodychange",
    "d7232857d8d1e10cdac171acdc931187e45fd6be": "Ybodychange",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Ymultichange(Ybodychange,Yparametermetachange)",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Yintroduced"
  },
  "changeHistoryDetails": {
    "56dee667707926f3796c7757be1a133a362f05c9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16823. Large DeleteObject requests are their own Thundering Herd.\n\nContributed by Steve Loughran.\n\nDuring S3A rename() and delete() calls, the list of objects delete is\nbuilt up into batches of a thousand and then POSTed in a single large\nDeleteObjects request.\n\nBut as the IO capacity allowed on an S3 partition may only be 3500 writes\nper second *and* each entry in that POST counts as a single write, then\none of those posts alone can trigger throttling on an already loaded\nS3 directory tree. Which can trigger backoff and retry, with the same\nthousand entry post, and so recreate the exact same problem.\n\nFixes\n\n* Page size for delete object requests is set in\n  fs.s3a.bulk.delete.page.size; the default is 250.\n* The property fs.s3a.experimental.aws.s3.throttling (default\u003dtrue)\n  can be set to false to disable throttle retry logic in the AWS\n  client SDK -it is all handled in the S3A client. This\n  gives more visibility in to when operations are being throttled\n* Bulk delete throttling events are logged to the log\n  org.apache.hadoop.fs.s3a.throttled log at INFO; if this appears\n  often then choose a smaller page size.\n* The metric \"store_io_throttled\" adds the entire count of delete\n  requests when a single DeleteObjects request is throttled.\n* A new quantile, \"store_io_throttle_rate\" can track throttling\n  load over time.\n* DynamoDB metastore throttle resilience issues have also been\n  identified and fixed. Note: the fs.s3a.experimental.aws.s3.throttling\n  flag does not apply to DDB IO precisely because there may still be\n  lurking issues there and it safest to rely on the DynamoDB client\n  SDK.\n\nChange-Id: I00f85cdd94fc008864d060533f6bd4870263fd84\n",
      "commitDate": "13/02/20 11:09 AM",
      "commitName": "56dee667707926f3796c7757be1a133a362f05c9",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "25/01/20 10:35 AM",
      "commitNameOld": "7f40e6688a5716fca53e1090d8347a43064d6d43",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 19.02,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,30 @@\n   public DirListingMetadata listChildren(final Path path) throws IOException {\n     checkPath(path);\n     LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n \n+    final QuerySpec spec \u003d new QuerySpec()\n+        .withHashKey(pathToParentKeyAttribute(path))\n+        .withConsistentRead(true); // strictly consistent read\n+    final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n     // find the children in the table\n-    return readOp.retry(\n+    final ItemCollection\u003cQueryOutcome\u003e items \u003d scanOp.retry(\n         \"listChildren\",\n         path.toString(),\n         true,\n-        () -\u003e {\n-          final QuerySpec spec \u003d new QuerySpec()\n-              .withHashKey(pathToParentKeyAttribute(path))\n-              .withConsistentRead(true); // strictly consistent read\n-          final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n+        () -\u003e table.query(spec));\n+    // now wrap the result with retry logic\n+    try {\n+      for (Item item : wrapWithRetries(items)) {\n+        metas.add(itemToPathMetadata(item, username));\n+      }\n+    } catch (WrappedIOException e) {\n+      // failure in the iterators; unwrap.\n+      throw e.getCause();\n+    }\n \n-          final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n-          for (Item item : items) {\n-            DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n-            metas.add(meta);\n-          }\n-\n-          // Minor race condition here - if the path is deleted between\n-          // getting the list of items and the directory metadata we might\n-          // get a null in DDBPathMetadata.\n-          DDBPathMetadata dirPathMeta \u003d get(path);\n-\n-          final DirListingMetadata dirListing \u003d\n-              getDirListingMetadataFromDirMetaAndList(path, metas,\n-                  dirPathMeta);\n-          return dirListing;\n-        });\n+    // Minor race condition here - if the path is deleted between\n+    // getting the list of items and the directory metadata we might\n+    // get a null in DDBPathMetadata.\n+    return getDirListingMetadataFromDirMetaAndList(path, metas,\n+        get(path));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DirListingMetadata listChildren(final Path path) throws IOException {\n    checkPath(path);\n    LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n\n    final QuerySpec spec \u003d new QuerySpec()\n        .withHashKey(pathToParentKeyAttribute(path))\n        .withConsistentRead(true); // strictly consistent read\n    final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n    // find the children in the table\n    final ItemCollection\u003cQueryOutcome\u003e items \u003d scanOp.retry(\n        \"listChildren\",\n        path.toString(),\n        true,\n        () -\u003e table.query(spec));\n    // now wrap the result with retry logic\n    try {\n      for (Item item : wrapWithRetries(items)) {\n        metas.add(itemToPathMetadata(item, username));\n      }\n    } catch (WrappedIOException e) {\n      // failure in the iterators; unwrap.\n      throw e.getCause();\n    }\n\n    // Minor race condition here - if the path is deleted between\n    // getting the list of items and the directory metadata we might\n    // get a null in DDBPathMetadata.\n    return getDirListingMetadataFromDirMetaAndList(path, metas,\n        get(path));\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "ea25f4de236611d388e14a710ebe5d6872c421b6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16709. S3Guard: Make authoritative mode exclusive for metadata - don\u0027t check for expiry for authoritative paths (#1721). Contributed by Gabor Bota.\n\n",
      "commitDate": "26/11/19 7:36 AM",
      "commitName": "ea25f4de236611d388e14a710ebe5d6872c421b6",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "16/10/19 1:41 AM",
      "commitNameOld": "bbcf0b91d6f5eb697d09e45505b0e72e193c3d75",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 41.29,
      "commitsBetweenForRepo": 153,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,32 @@\n   public DirListingMetadata listChildren(final Path path) throws IOException {\n     checkPath(path);\n     LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n \n     // find the children in the table\n     return readOp.retry(\n         \"listChildren\",\n         path.toString(),\n         true,\n         () -\u003e {\n           final QuerySpec spec \u003d new QuerySpec()\n               .withHashKey(pathToParentKeyAttribute(path))\n               .withConsistentRead(true); // strictly consistent read\n           final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n \n           final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n           for (Item item : items) {\n             DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n             metas.add(meta);\n           }\n \n           // Minor race condition here - if the path is deleted between\n           // getting the list of items and the directory metadata we might\n           // get a null in DDBPathMetadata.\n           DDBPathMetadata dirPathMeta \u003d get(path);\n \n-          // Filter expired entries.\n           final DirListingMetadata dirListing \u003d\n               getDirListingMetadataFromDirMetaAndList(path, metas,\n                   dirPathMeta);\n-          if(dirListing !\u003d null) {\n-            dirListing.removeExpiredEntriesFromListing(\n-                ttlTimeProvider.getMetadataTtl(),\n-                ttlTimeProvider.getNow());\n-          }\n           return dirListing;\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DirListingMetadata listChildren(final Path path) throws IOException {\n    checkPath(path);\n    LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n\n    // find the children in the table\n    return readOp.retry(\n        \"listChildren\",\n        path.toString(),\n        true,\n        () -\u003e {\n          final QuerySpec spec \u003d new QuerySpec()\n              .withHashKey(pathToParentKeyAttribute(path))\n              .withConsistentRead(true); // strictly consistent read\n          final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n\n          final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n          for (Item item : items) {\n            DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n            metas.add(meta);\n          }\n\n          // Minor race condition here - if the path is deleted between\n          // getting the list of items and the directory metadata we might\n          // get a null in DDBPathMetadata.\n          DDBPathMetadata dirPathMeta \u003d get(path);\n\n          final DirListingMetadata dirListing \u003d\n              getDirListingMetadataFromDirMetaAndList(path, metas,\n                  dirPathMeta);\n          return dirListing;\n        });\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "7b219778e05a50e33cca75d727e62783322b7f80": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16433. S3Guard: Filter expired entries and tombstones when listing with MetadataStore.listChildren().\n\nContributed by Gabor Bota.\n\nThis pulls the tracking of the lastUpdated timestamp of metadata entries up from the DDB metastore into all s3guard stores, and then uses this to filter out expired tombstones from listings.\n\nChange-Id: I80f121236b49c75a024116f65a3ef29d3580b462\n",
      "commitDate": "24/07/19 10:11 AM",
      "commitName": "7b219778e05a50e33cca75d727e62783322b7f80",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "17/07/19 7:24 AM",
      "commitNameOld": "c58e11bf521d746842ce16724211a2a0339d7b61",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 7.12,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,38 @@\n   public DirListingMetadata listChildren(final Path path) throws IOException {\n     checkPath(path);\n     LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n \n     // find the children in the table\n     return readOp.retry(\n         \"listChildren\",\n         path.toString(),\n         true,\n         () -\u003e {\n           final QuerySpec spec \u003d new QuerySpec()\n               .withHashKey(pathToParentKeyAttribute(path))\n               .withConsistentRead(true); // strictly consistent read\n           final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n \n           final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n           for (Item item : items) {\n             DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n             metas.add(meta);\n           }\n \n           // Minor race condition here - if the path is deleted between\n           // getting the list of items and the directory metadata we might\n           // get a null in DDBPathMetadata.\n           DDBPathMetadata dirPathMeta \u003d get(path);\n \n-          return getDirListingMetadataFromDirMetaAndList(path, metas,\n-              dirPathMeta);\n+          // Filter expired entries.\n+          final DirListingMetadata dirListing \u003d\n+              getDirListingMetadataFromDirMetaAndList(path, metas,\n+                  dirPathMeta);\n+          if(dirListing !\u003d null) {\n+            dirListing.removeExpiredEntriesFromListing(\n+                ttlTimeProvider.getMetadataTtl(),\n+                ttlTimeProvider.getNow());\n+          }\n+          return dirListing;\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DirListingMetadata listChildren(final Path path) throws IOException {\n    checkPath(path);\n    LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n\n    // find the children in the table\n    return readOp.retry(\n        \"listChildren\",\n        path.toString(),\n        true,\n        () -\u003e {\n          final QuerySpec spec \u003d new QuerySpec()\n              .withHashKey(pathToParentKeyAttribute(path))\n              .withConsistentRead(true); // strictly consistent read\n          final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n\n          final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n          for (Item item : items) {\n            DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n            metas.add(meta);\n          }\n\n          // Minor race condition here - if the path is deleted between\n          // getting the list of items and the directory metadata we might\n          // get a null in DDBPathMetadata.\n          DDBPathMetadata dirPathMeta \u003d get(path);\n\n          // Filter expired entries.\n          final DirListingMetadata dirListing \u003d\n              getDirListingMetadataFromDirMetaAndList(path, metas,\n                  dirPathMeta);\n          if(dirListing !\u003d null) {\n            dirListing.removeExpiredEntriesFromListing(\n                ttlTimeProvider.getMetadataTtl(),\n                ttlTimeProvider.getNow());\n          }\n          return dirListing;\n        });\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "cfb01869038065defe50ab53d4d1eda4e6cdee33": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16186. S3Guard: NPE in DynamoDBMetadataStore.lambda$listChildren.\n\nAuthor:    Gabor Bota\n",
      "commitDate": "28/03/19 8:49 AM",
      "commitName": "cfb01869038065defe50ab53d4d1eda4e6cdee33",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "14/01/19 9:59 AM",
      "commitNameOld": "6d0bffe17eadedd60d4599427248b0db4a7c5502",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 72.91,
      "commitsBetweenForRepo": 592,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,30 @@\n   public DirListingMetadata listChildren(final Path path) throws IOException {\n     checkPath(path);\n     LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n \n     // find the children in the table\n     return readOp.retry(\n         \"listChildren\",\n         path.toString(),\n         true,\n         () -\u003e {\n           final QuerySpec spec \u003d new QuerySpec()\n               .withHashKey(pathToParentKeyAttribute(path))\n               .withConsistentRead(true); // strictly consistent read\n           final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n \n           final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n           for (Item item : items) {\n             DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n             metas.add(meta);\n           }\n \n+          // Minor race condition here - if the path is deleted between\n+          // getting the list of items and the directory metadata we might\n+          // get a null in DDBPathMetadata.\n           DDBPathMetadata dirPathMeta \u003d get(path);\n-          boolean isAuthoritative \u003d false;\n-          if(dirPathMeta !\u003d null) {\n-            isAuthoritative \u003d dirPathMeta.isAuthoritativeDir();\n-          }\n \n-          LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n-              tableName, region, path, metas);\n-\n-          return (metas.isEmpty() \u0026\u0026 dirPathMeta \u003d\u003d null)\n-              ? null\n-              : new DirListingMetadata(path, metas, isAuthoritative,\n-              dirPathMeta.getLastUpdated());\n+          return getDirListingMetadataFromDirMetaAndList(path, metas,\n+              dirPathMeta);\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DirListingMetadata listChildren(final Path path) throws IOException {\n    checkPath(path);\n    LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n\n    // find the children in the table\n    return readOp.retry(\n        \"listChildren\",\n        path.toString(),\n        true,\n        () -\u003e {\n          final QuerySpec spec \u003d new QuerySpec()\n              .withHashKey(pathToParentKeyAttribute(path))\n              .withConsistentRead(true); // strictly consistent read\n          final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n\n          final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n          for (Item item : items) {\n            DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n            metas.add(meta);\n          }\n\n          // Minor race condition here - if the path is deleted between\n          // getting the list of items and the directory metadata we might\n          // get a null in DDBPathMetadata.\n          DDBPathMetadata dirPathMeta \u003d get(path);\n\n          return getDirListingMetadataFromDirMetaAndList(path, metas,\n              dirPathMeta);\n        });\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "085f10e75dea5446861253cf63aced337536481c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15947. Fix ITestDynamoDBMetadataStore test error issues. Contributed by Gabor Bota.\n",
      "commitDate": "28/11/18 9:45 AM",
      "commitName": "085f10e75dea5446861253cf63aced337536481c",
      "commitAuthor": "Sean Mackrory",
      "commitDateOld": "11/10/18 6:57 AM",
      "commitNameOld": "ee816f1fd78b029b9efa567e8b1b62391563de14",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 48.16,
      "commitsBetweenForRepo": 405,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   public DirListingMetadata listChildren(final Path path) throws IOException {\n     checkPath(path);\n     LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n \n     // find the children in the table\n     return readOp.retry(\n         \"listChildren\",\n         path.toString(),\n         true,\n         () -\u003e {\n           final QuerySpec spec \u003d new QuerySpec()\n               .withHashKey(pathToParentKeyAttribute(path))\n               .withConsistentRead(true); // strictly consistent read\n           final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n \n           final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n           for (Item item : items) {\n             DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n             metas.add(meta);\n           }\n \n           DDBPathMetadata dirPathMeta \u003d get(path);\n           boolean isAuthoritative \u003d false;\n           if(dirPathMeta !\u003d null) {\n             isAuthoritative \u003d dirPathMeta.isAuthoritativeDir();\n           }\n \n           LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n               tableName, region, path, metas);\n \n-          return (metas.isEmpty() || dirPathMeta \u003d\u003d null)\n+          return (metas.isEmpty() \u0026\u0026 dirPathMeta \u003d\u003d null)\n               ? null\n               : new DirListingMetadata(path, metas, isAuthoritative,\n               dirPathMeta.getLastUpdated());\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DirListingMetadata listChildren(final Path path) throws IOException {\n    checkPath(path);\n    LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n\n    // find the children in the table\n    return readOp.retry(\n        \"listChildren\",\n        path.toString(),\n        true,\n        () -\u003e {\n          final QuerySpec spec \u003d new QuerySpec()\n              .withHashKey(pathToParentKeyAttribute(path))\n              .withConsistentRead(true); // strictly consistent read\n          final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n\n          final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n          for (Item item : items) {\n            DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n            metas.add(meta);\n          }\n\n          DDBPathMetadata dirPathMeta \u003d get(path);\n          boolean isAuthoritative \u003d false;\n          if(dirPathMeta !\u003d null) {\n            isAuthoritative \u003d dirPathMeta.isAuthoritativeDir();\n          }\n\n          LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n              tableName, region, path, metas);\n\n          return (metas.isEmpty() \u0026\u0026 dirPathMeta \u003d\u003d null)\n              ? null\n              : new DirListingMetadata(path, metas, isAuthoritative,\n              dirPathMeta.getLastUpdated());\n        });\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "7ba1cfdea7f5daf799adc4f0ed2e45f55841a058": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15827. NPE in DynamoDBMetadataStore.lambda$listChildren for root + auth S3Guard.\nContributed by Gabor Bota\n",
      "commitDate": "09/10/18 2:46 AM",
      "commitName": "7ba1cfdea7f5daf799adc4f0ed2e45f55841a058",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "02/10/18 9:22 PM",
      "commitNameOld": "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 6.22,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   public DirListingMetadata listChildren(final Path path) throws IOException {\n     checkPath(path);\n     LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n \n     // find the children in the table\n     return readOp.retry(\n         \"listChildren\",\n         path.toString(),\n         true,\n         () -\u003e {\n           final QuerySpec spec \u003d new QuerySpec()\n               .withHashKey(pathToParentKeyAttribute(path))\n               .withConsistentRead(true); // strictly consistent read\n           final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n \n           final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n           for (Item item : items) {\n             DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n             metas.add(meta);\n           }\n \n           DDBPathMetadata dirPathMeta \u003d get(path);\n           boolean isAuthoritative \u003d false;\n           if(dirPathMeta !\u003d null) {\n             isAuthoritative \u003d dirPathMeta.isAuthoritativeDir();\n           }\n \n           LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n               tableName, region, path, metas);\n \n-          return (metas.isEmpty() \u0026\u0026 dirPathMeta \u003d\u003d null)\n+          return (metas.isEmpty() || dirPathMeta \u003d\u003d null)\n               ? null\n               : new DirListingMetadata(path, metas, isAuthoritative,\n               dirPathMeta.getLastUpdated());\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DirListingMetadata listChildren(final Path path) throws IOException {\n    checkPath(path);\n    LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n\n    // find the children in the table\n    return readOp.retry(\n        \"listChildren\",\n        path.toString(),\n        true,\n        () -\u003e {\n          final QuerySpec spec \u003d new QuerySpec()\n              .withHashKey(pathToParentKeyAttribute(path))\n              .withConsistentRead(true); // strictly consistent read\n          final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n\n          final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n          for (Item item : items) {\n            DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n            metas.add(meta);\n          }\n\n          DDBPathMetadata dirPathMeta \u003d get(path);\n          boolean isAuthoritative \u003d false;\n          if(dirPathMeta !\u003d null) {\n            isAuthoritative \u003d dirPathMeta.isAuthoritativeDir();\n          }\n\n          LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n              tableName, region, path, metas);\n\n          return (metas.isEmpty() || dirPathMeta \u003d\u003d null)\n              ? null\n              : new DirListingMetadata(path, metas, isAuthoritative,\n              dirPathMeta.getLastUpdated());\n        });\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15621 S3Guard: Implement time-based (TTL) expiry for Authoritative Directory Listing. Contributed by Gabor Bota\n",
      "commitDate": "02/10/18 9:22 PM",
      "commitName": "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "12/09/18 9:04 PM",
      "commitNameOld": "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 20.01,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,36 @@\n   public DirListingMetadata listChildren(final Path path) throws IOException {\n     checkPath(path);\n     LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n \n     // find the children in the table\n     return readOp.retry(\n         \"listChildren\",\n         path.toString(),\n         true,\n         () -\u003e {\n           final QuerySpec spec \u003d new QuerySpec()\n               .withHashKey(pathToParentKeyAttribute(path))\n               .withConsistentRead(true); // strictly consistent read\n           final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n \n           final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n           for (Item item : items) {\n             DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n             metas.add(meta);\n           }\n \n           DDBPathMetadata dirPathMeta \u003d get(path);\n           boolean isAuthoritative \u003d false;\n           if(dirPathMeta !\u003d null) {\n             isAuthoritative \u003d dirPathMeta.isAuthoritativeDir();\n           }\n \n           LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n               tableName, region, path, metas);\n \n           return (metas.isEmpty() \u0026\u0026 dirPathMeta \u003d\u003d null)\n               ? null\n-              : new DirListingMetadata(path, metas, isAuthoritative);\n+              : new DirListingMetadata(path, metas, isAuthoritative,\n+              dirPathMeta.getLastUpdated());\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DirListingMetadata listChildren(final Path path) throws IOException {\n    checkPath(path);\n    LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n\n    // find the children in the table\n    return readOp.retry(\n        \"listChildren\",\n        path.toString(),\n        true,\n        () -\u003e {\n          final QuerySpec spec \u003d new QuerySpec()\n              .withHashKey(pathToParentKeyAttribute(path))\n              .withConsistentRead(true); // strictly consistent read\n          final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n\n          final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n          for (Item item : items) {\n            DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n            metas.add(meta);\n          }\n\n          DDBPathMetadata dirPathMeta \u003d get(path);\n          boolean isAuthoritative \u003d false;\n          if(dirPathMeta !\u003d null) {\n            isAuthoritative \u003d dirPathMeta.isAuthoritativeDir();\n          }\n\n          LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n              tableName, region, path, metas);\n\n          return (metas.isEmpty() \u0026\u0026 dirPathMeta \u003d\u003d null)\n              ? null\n              : new DirListingMetadata(path, metas, isAuthoritative,\n              dirPathMeta.getLastUpdated());\n        });\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15426 Make S3guard client resilient to DDB throttle events and network failures (Contributed by Steve Loughran)\n",
      "commitDate": "12/09/18 9:04 PM",
      "commitName": "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/09/18 4:36 PM",
      "commitNameOld": "d32a8d5d582725eb724b78f27310ad1efd33ed2a",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,35 @@\n   public DirListingMetadata listChildren(final Path path) throws IOException {\n     checkPath(path);\n     LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n \n     // find the children in the table\n-    return Invoker.once(\"listChildren\", path.toString(),\n+    return readOp.retry(\n+        \"listChildren\",\n+        path.toString(),\n+        true,\n         () -\u003e {\n           final QuerySpec spec \u003d new QuerySpec()\n               .withHashKey(pathToParentKeyAttribute(path))\n               .withConsistentRead(true); // strictly consistent read\n           final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n \n           final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n           for (Item item : items) {\n             DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n             metas.add(meta);\n           }\n \n           DDBPathMetadata dirPathMeta \u003d get(path);\n           boolean isAuthoritative \u003d false;\n           if(dirPathMeta !\u003d null) {\n             isAuthoritative \u003d dirPathMeta.isAuthoritativeDir();\n           }\n \n           LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n               tableName, region, path, metas);\n \n           return (metas.isEmpty() \u0026\u0026 dirPathMeta \u003d\u003d null)\n               ? null\n               : new DirListingMetadata(path, metas, isAuthoritative);\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DirListingMetadata listChildren(final Path path) throws IOException {\n    checkPath(path);\n    LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n\n    // find the children in the table\n    return readOp.retry(\n        \"listChildren\",\n        path.toString(),\n        true,\n        () -\u003e {\n          final QuerySpec spec \u003d new QuerySpec()\n              .withHashKey(pathToParentKeyAttribute(path))\n              .withConsistentRead(true); // strictly consistent read\n          final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n\n          final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n          for (Item item : items) {\n            DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n            metas.add(meta);\n          }\n\n          DDBPathMetadata dirPathMeta \u003d get(path);\n          boolean isAuthoritative \u003d false;\n          if(dirPathMeta !\u003d null) {\n            isAuthoritative \u003d dirPathMeta.isAuthoritativeDir();\n          }\n\n          LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n              tableName, region, path, metas);\n\n          return (metas.isEmpty() \u0026\u0026 dirPathMeta \u003d\u003d null)\n              ? null\n              : new DirListingMetadata(path, metas, isAuthoritative);\n        });\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "d7232857d8d1e10cdac171acdc931187e45fd6be": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14154 Persist isAuthoritative bit in DynamoDBMetaStore (Contributed by Gabor Bota)\n",
      "commitDate": "17/08/18 10:15 AM",
      "commitName": "d7232857d8d1e10cdac171acdc931187e45fd6be",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "08/08/18 10:57 PM",
      "commitNameOld": "da9a39eed138210de29b59b90c449b28da1c04f9",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 8.47,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,32 @@\n   public DirListingMetadata listChildren(final Path path) throws IOException {\n     checkPath(path);\n     LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n \n     // find the children in the table\n     return Invoker.once(\"listChildren\", path.toString(),\n         () -\u003e {\n           final QuerySpec spec \u003d new QuerySpec()\n               .withHashKey(pathToParentKeyAttribute(path))\n               .withConsistentRead(true); // strictly consistent read\n           final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n \n           final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n           for (Item item : items) {\n-            PathMetadata meta \u003d itemToPathMetadata(item, username);\n+            DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n             metas.add(meta);\n           }\n+\n+          DDBPathMetadata dirPathMeta \u003d get(path);\n+          boolean isAuthoritative \u003d false;\n+          if(dirPathMeta !\u003d null) {\n+            isAuthoritative \u003d dirPathMeta.isAuthoritativeDir();\n+          }\n+\n           LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n               tableName, region, path, metas);\n \n-          return (metas.isEmpty() \u0026\u0026 get(path) \u003d\u003d null)\n+          return (metas.isEmpty() \u0026\u0026 dirPathMeta \u003d\u003d null)\n               ? null\n-              : new DirListingMetadata(path, metas, false);\n+              : new DirListingMetadata(path, metas, isAuthoritative);\n         });\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DirListingMetadata listChildren(final Path path) throws IOException {\n    checkPath(path);\n    LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n\n    // find the children in the table\n    return Invoker.once(\"listChildren\", path.toString(),\n        () -\u003e {\n          final QuerySpec spec \u003d new QuerySpec()\n              .withHashKey(pathToParentKeyAttribute(path))\n              .withConsistentRead(true); // strictly consistent read\n          final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n\n          final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n          for (Item item : items) {\n            DDBPathMetadata meta \u003d itemToPathMetadata(item, username);\n            metas.add(meta);\n          }\n\n          DDBPathMetadata dirPathMeta \u003d get(path);\n          boolean isAuthoritative \u003d false;\n          if(dirPathMeta !\u003d null) {\n            isAuthoritative \u003d dirPathMeta.isAuthoritativeDir();\n          }\n\n          LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n              tableName, region, path, metas);\n\n          return (metas.isEmpty() \u0026\u0026 dirPathMeta \u003d\u003d null)\n              ? null\n              : new DirListingMetadata(path, metas, isAuthoritative);\n        });\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
          "commitDate": "22/11/17 7:28 AM",
          "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "25/09/17 3:59 PM",
          "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
          "commitAuthorOld": "Aaron Fabbri",
          "daysBetweenCommits": 57.69,
          "commitsBetweenForRepo": 477,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,25 @@\n-  public DirListingMetadata listChildren(Path path) throws IOException {\n-    path \u003d checkPath(path);\n+  public DirListingMetadata listChildren(final Path path) throws IOException {\n+    checkPath(path);\n     LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n \n     // find the children in the table\n-    try {\n-      final QuerySpec spec \u003d new QuerySpec()\n-          .withHashKey(pathToParentKeyAttribute(path))\n-          .withConsistentRead(true); // strictly consistent read\n-      final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n+    return Invoker.once(\"listChildren\", path.toString(),\n+        () -\u003e {\n+          final QuerySpec spec \u003d new QuerySpec()\n+              .withHashKey(pathToParentKeyAttribute(path))\n+              .withConsistentRead(true); // strictly consistent read\n+          final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n \n-      final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n-      for (Item item : items) {\n-        PathMetadata meta \u003d itemToPathMetadata(item, username);\n-        metas.add(meta);\n-      }\n-      LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n-          tableName, region, path, metas);\n+          final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n+          for (Item item : items) {\n+            PathMetadata meta \u003d itemToPathMetadata(item, username);\n+            metas.add(meta);\n+          }\n+          LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n+              tableName, region, path, metas);\n \n-      return (metas.isEmpty() \u0026\u0026 get(path) \u003d\u003d null)\n-          ? null\n-          : new DirListingMetadata(path, metas, false);\n-    } catch (AmazonClientException e) {\n-      // failure, including the path not being present\n-      throw translateException(\"listChildren\", path, e);\n-    }\n+          return (metas.isEmpty() \u0026\u0026 get(path) \u003d\u003d null)\n+              ? null\n+              : new DirListingMetadata(path, metas, false);\n+        });\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DirListingMetadata listChildren(final Path path) throws IOException {\n    checkPath(path);\n    LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n\n    // find the children in the table\n    return Invoker.once(\"listChildren\", path.toString(),\n        () -\u003e {\n          final QuerySpec spec \u003d new QuerySpec()\n              .withHashKey(pathToParentKeyAttribute(path))\n              .withConsistentRead(true); // strictly consistent read\n          final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n\n          final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n          for (Item item : items) {\n            PathMetadata meta \u003d itemToPathMetadata(item, username);\n            metas.add(meta);\n          }\n          LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n              tableName, region, path, metas);\n\n          return (metas.isEmpty() \u0026\u0026 get(path) \u003d\u003d null)\n              ? null\n              : new DirListingMetadata(path, metas, false);\n        });\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
          "commitDate": "22/11/17 7:28 AM",
          "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "25/09/17 3:59 PM",
          "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
          "commitAuthorOld": "Aaron Fabbri",
          "daysBetweenCommits": 57.69,
          "commitsBetweenForRepo": 477,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,25 @@\n-  public DirListingMetadata listChildren(Path path) throws IOException {\n-    path \u003d checkPath(path);\n+  public DirListingMetadata listChildren(final Path path) throws IOException {\n+    checkPath(path);\n     LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n \n     // find the children in the table\n-    try {\n-      final QuerySpec spec \u003d new QuerySpec()\n-          .withHashKey(pathToParentKeyAttribute(path))\n-          .withConsistentRead(true); // strictly consistent read\n-      final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n+    return Invoker.once(\"listChildren\", path.toString(),\n+        () -\u003e {\n+          final QuerySpec spec \u003d new QuerySpec()\n+              .withHashKey(pathToParentKeyAttribute(path))\n+              .withConsistentRead(true); // strictly consistent read\n+          final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n \n-      final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n-      for (Item item : items) {\n-        PathMetadata meta \u003d itemToPathMetadata(item, username);\n-        metas.add(meta);\n-      }\n-      LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n-          tableName, region, path, metas);\n+          final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n+          for (Item item : items) {\n+            PathMetadata meta \u003d itemToPathMetadata(item, username);\n+            metas.add(meta);\n+          }\n+          LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n+              tableName, region, path, metas);\n \n-      return (metas.isEmpty() \u0026\u0026 get(path) \u003d\u003d null)\n-          ? null\n-          : new DirListingMetadata(path, metas, false);\n-    } catch (AmazonClientException e) {\n-      // failure, including the path not being present\n-      throw translateException(\"listChildren\", path, e);\n-    }\n+          return (metas.isEmpty() \u0026\u0026 get(path) \u003d\u003d null)\n+              ? null\n+              : new DirListingMetadata(path, metas, false);\n+        });\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DirListingMetadata listChildren(final Path path) throws IOException {\n    checkPath(path);\n    LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n\n    // find the children in the table\n    return Invoker.once(\"listChildren\", path.toString(),\n        () -\u003e {\n          final QuerySpec spec \u003d new QuerySpec()\n              .withHashKey(pathToParentKeyAttribute(path))\n              .withConsistentRead(true); // strictly consistent read\n          final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n\n          final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n          for (Item item : items) {\n            PathMetadata meta \u003d itemToPathMetadata(item, username);\n            metas.add(meta);\n          }\n          LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n              tableName, region, path, metas);\n\n          return (metas.isEmpty() \u0026\u0026 get(path) \u003d\u003d null)\n              ? null\n              : new DirListingMetadata(path, metas, false);\n        });\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[path-Path]",
            "newValue": "[path-Path(modifiers-final)]"
          }
        }
      ]
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,27 @@\n+  public DirListingMetadata listChildren(Path path) throws IOException {\n+    path \u003d checkPath(path);\n+    LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n+\n+    // find the children in the table\n+    try {\n+      final QuerySpec spec \u003d new QuerySpec()\n+          .withHashKey(pathToParentKeyAttribute(path))\n+          .withConsistentRead(true); // strictly consistent read\n+      final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n+\n+      final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n+      for (Item item : items) {\n+        PathMetadata meta \u003d itemToPathMetadata(item, username);\n+        metas.add(meta);\n+      }\n+      LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n+          tableName, region, path, metas);\n+\n+      return (metas.isEmpty() \u0026\u0026 get(path) \u003d\u003d null)\n+          ? null\n+          : new DirListingMetadata(path, metas, false);\n+    } catch (AmazonClientException e) {\n+      // failure, including the path not being present\n+      throw translateException(\"listChildren\", path, e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public DirListingMetadata listChildren(Path path) throws IOException {\n    path \u003d checkPath(path);\n    LOG.debug(\"Listing table {} in region {}: {}\", tableName, region, path);\n\n    // find the children in the table\n    try {\n      final QuerySpec spec \u003d new QuerySpec()\n          .withHashKey(pathToParentKeyAttribute(path))\n          .withConsistentRead(true); // strictly consistent read\n      final ItemCollection\u003cQueryOutcome\u003e items \u003d table.query(spec);\n\n      final List\u003cPathMetadata\u003e metas \u003d new ArrayList\u003c\u003e();\n      for (Item item : items) {\n        PathMetadata meta \u003d itemToPathMetadata(item, username);\n        metas.add(meta);\n      }\n      LOG.trace(\"Listing table {} in region {} for {} returning {}\",\n          tableName, region, path, metas);\n\n      return (metas.isEmpty() \u0026\u0026 get(path) \u003d\u003d null)\n          ? null\n          : new DirListingMetadata(path, metas, false);\n    } catch (AmazonClientException e) {\n      // failure, including the path not being present\n      throw translateException(\"listChildren\", path, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java"
    }
  }
}