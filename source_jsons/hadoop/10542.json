{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BPServiceActor.java",
  "functionName": "offerService",
  "functionId": "offerService",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
  "functionStartLine": 643,
  "functionEndLine": 758,
  "numCommitsSeen": 160,
  "timeTaken": 15014,
  "changeHistory": [
    "cdcb77a2c5ca99502d2ac2fbf803f22463eb1343",
    "b86895485d95440de099831e0db38db037f16bdd",
    "528378784fe14e7069dd0471f3c4c478544b57c8",
    "387dbe587aa66ac99ec5f5b50827ec3e0a327613",
    "460a94a10f9c314b77a25e14efbf7c4dc3f5d9aa",
    "1290e3c647092f0bfbb250731a6805aba1be8e4b",
    "74a723852d9ef265d0fd46334f2f885bfb247a3a",
    "1168ece59640d8ad3166e355d2e82deec2fbaf14",
    "0cde9e12a7175e4d8bc4ccd5c36055b280d1fbd6",
    "c2140d05efaf18b41caae8c61d9f6d668ab0e874",
    "2759689d7d23001f007cb0dbe2521de90734dd5c",
    "d1d4e16690cc85f7f22fbead9cf596260819b561",
    "4e5e1c0f9938e51699c0437731e7b2eef699d6da",
    "d8736eb9ca351b82854601ea3b1fbc3c9fab44e4",
    "afe9ea3c12e1f5a71922400eadb642960bc87ca1",
    "12b5b06c063d93e6c683c9b6fac9a96912f59e59",
    "dfc1c4c303cf15afc6c3361ed9d3238562f73cbd",
    "60882ab26d49f05cbf0686944af6559f86b3417d",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498",
    "38262779bbf38a427bad6d044e91165567f1d206",
    "6e62a1a6728b1f782f64065424f92b292c3f163a",
    "440c3cd1050f2a871a73d44406c0013b6ff73f2e",
    "5df82fa01d26c18685ad7617128dbc2913547cb3",
    "5beeb3016954a3ee0c1fb10a2083ffd540cd2c14",
    "04cf2a768c0fb1c2c5c80d2480aa072ec7e43c3f",
    "01f37e42f050207b7659bf74e2484cf8bdae2d89",
    "52ccc6c6d539d0587c3fd9693709bd1f6e12619d",
    "ef9e1ba76357f6aaa5489ba1d5ed40ffff40a2cc",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e",
    "978a8050e28b2afb193a3e00d82a8475fa4d2428",
    "7527e943e6c8ea909f22d9d66246ac6c8bc2d6a0",
    "6016e95feec93f0e17a8a1370c0ede735ca13f55",
    "8dbb5237684bb9de78430b5cef27be40c78a8474",
    "1e346aa829519f8a2aa830e76d9856f914861805",
    "39ce694d05c6d8c428bd87bc1b9c95f94dfdf6fd",
    "1f92266516c882e43fa453b876dd8ca09893c477",
    "905a127850d5e0cba85c2e075f989fa0f5cf129a",
    "0864ef19089f703232107d8aa26c4a7571ff132e",
    "221aadbc5b35b043fbc62c417b0edc029db9d004",
    "73451ed2d9fb5eb228d80ad5f3be302a60496527",
    "e680023f8b158db25b45a050236163e9246103f3",
    "e6339be188d3f5c94df3b092d92d201b728163f5",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "cdcb77a2c5ca99502d2ac2fbf803f22463eb1343": "Ybodychange",
    "b86895485d95440de099831e0db38db037f16bdd": "Ybodychange",
    "528378784fe14e7069dd0471f3c4c478544b57c8": "Ybodychange",
    "387dbe587aa66ac99ec5f5b50827ec3e0a327613": "Ybodychange",
    "460a94a10f9c314b77a25e14efbf7c4dc3f5d9aa": "Ybodychange",
    "1290e3c647092f0bfbb250731a6805aba1be8e4b": "Ybodychange",
    "74a723852d9ef265d0fd46334f2f885bfb247a3a": "Ybodychange",
    "1168ece59640d8ad3166e355d2e82deec2fbaf14": "Ybodychange",
    "0cde9e12a7175e4d8bc4ccd5c36055b280d1fbd6": "Ybodychange",
    "c2140d05efaf18b41caae8c61d9f6d668ab0e874": "Ybodychange",
    "2759689d7d23001f007cb0dbe2521de90734dd5c": "Ybodychange",
    "d1d4e16690cc85f7f22fbead9cf596260819b561": "Ybodychange",
    "4e5e1c0f9938e51699c0437731e7b2eef699d6da": "Ybodychange",
    "d8736eb9ca351b82854601ea3b1fbc3c9fab44e4": "Ybodychange",
    "afe9ea3c12e1f5a71922400eadb642960bc87ca1": "Ybodychange",
    "12b5b06c063d93e6c683c9b6fac9a96912f59e59": "Ybodychange",
    "dfc1c4c303cf15afc6c3361ed9d3238562f73cbd": "Ybodychange",
    "60882ab26d49f05cbf0686944af6559f86b3417d": "Ybodychange",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": "Ybodychange",
    "38262779bbf38a427bad6d044e91165567f1d206": "Ybodychange",
    "6e62a1a6728b1f782f64065424f92b292c3f163a": "Ybodychange",
    "440c3cd1050f2a871a73d44406c0013b6ff73f2e": "Ybodychange",
    "5df82fa01d26c18685ad7617128dbc2913547cb3": "Ybodychange",
    "5beeb3016954a3ee0c1fb10a2083ffd540cd2c14": "Ybodychange",
    "04cf2a768c0fb1c2c5c80d2480aa072ec7e43c3f": "Ybodychange",
    "01f37e42f050207b7659bf74e2484cf8bdae2d89": "Ybodychange",
    "52ccc6c6d539d0587c3fd9693709bd1f6e12619d": "Ybodychange",
    "ef9e1ba76357f6aaa5489ba1d5ed40ffff40a2cc": "Ybodychange",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": "Ybodychange",
    "978a8050e28b2afb193a3e00d82a8475fa4d2428": "Ybodychange",
    "7527e943e6c8ea909f22d9d66246ac6c8bc2d6a0": "Ybodychange",
    "6016e95feec93f0e17a8a1370c0ede735ca13f55": "Ybodychange",
    "8dbb5237684bb9de78430b5cef27be40c78a8474": "Ybodychange",
    "1e346aa829519f8a2aa830e76d9856f914861805": "Ymultichange(Ymovefromfile,Ybodychange)",
    "39ce694d05c6d8c428bd87bc1b9c95f94dfdf6fd": "Ymultichange(Ymovefromfile,Ybodychange)",
    "1f92266516c882e43fa453b876dd8ca09893c477": "Ybodychange",
    "905a127850d5e0cba85c2e075f989fa0f5cf129a": "Ybodychange",
    "0864ef19089f703232107d8aa26c4a7571ff132e": "Ybodychange",
    "221aadbc5b35b043fbc62c417b0edc029db9d004": "Ybodychange",
    "73451ed2d9fb5eb228d80ad5f3be302a60496527": "Ybodychange",
    "e680023f8b158db25b45a050236163e9246103f3": "Ybodychange",
    "e6339be188d3f5c94df3b092d92d201b728163f5": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdcb77a2c5ca99502d2ac2fbf803f22463eb1343": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15075. Remove process command timing from BPServiceActor. Contributed by Xiaoqiao He.\n",
      "commitDate": "25/03/20 11:30 AM",
      "commitName": "cdcb77a2c5ca99502d2ac2fbf803f22463eb1343",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "13/03/20 6:55 PM",
      "commitNameOld": "e9955bb8ff44396eb478f709307d647ca884de99",
      "commitAuthorOld": "He Xiaoqiao",
      "daysBetweenCommits": 11.69,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,124 +1,116 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msecs\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msecs\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msecs\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n         + (lifelineSender !\u003d null ?\n             \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         DataNodeFaultInjector.get().startOfferService();\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime,\n                 getRpcMetricSuffix());\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n-\n-            long startProcessCommands \u003d monotonicNow();\n             commandProcessingThread.enqueue(resp.getCommands());\n-            long endProcessCommands \u003d monotonicNow();\n-            if (endProcessCommands - startProcessCommands \u003e 2000) {\n-              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n-                  + \"ms to process \" + resp.getCommands().length\n-                  + \" commands from NN\");\n-            }\n           }\n         }\n         if (!dn.areIBRDisabledForTests() \u0026\u0026\n             (ibrManager.sendImmediately()|| sendHeartbeat)) {\n           ibrManager.sendIBRs(bpNamenode, bpRegistration,\n               bpos.getBlockPoolId(), getRpcMetricSuffix());\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         commandProcessingThread.enqueue(cmds);\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n           commandProcessingThread.enqueue(cmd);\n         }\n \n         if (sendHeartbeat) {\n           dn.getMetrics().addHeartbeatTotal(\n               scheduler.monotonicNow() - startTime, getRpcMetricSuffix());\n         }\n \n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         sleepAfterException();\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n         sleepAfterException();\n       } finally {\n         DataNodeFaultInjector.get().endOfferService();\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msecs\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msecs\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msecs\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n        + (lifelineSender !\u003d null ?\n            \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        DataNodeFaultInjector.get().startOfferService();\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime,\n                getRpcMetricSuffix());\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n            commandProcessingThread.enqueue(resp.getCommands());\n          }\n        }\n        if (!dn.areIBRDisabledForTests() \u0026\u0026\n            (ibrManager.sendImmediately()|| sendHeartbeat)) {\n          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n              bpos.getBlockPoolId(), getRpcMetricSuffix());\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        commandProcessingThread.enqueue(cmds);\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          commandProcessingThread.enqueue(cmd);\n        }\n\n        if (sendHeartbeat) {\n          dn.getMetrics().addHeartbeatTotal(\n              scheduler.monotonicNow() - startTime, getRpcMetricSuffix());\n        }\n\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        sleepAfterException();\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n        sleepAfterException();\n      } finally {\n        DataNodeFaultInjector.get().endOfferService();\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "b86895485d95440de099831e0db38db037f16bdd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14997. BPServiceActor processes commands from NameNode asynchronously. Contributed by Xiaoqiao He.\n",
      "commitDate": "19/12/19 9:34 AM",
      "commitName": "b86895485d95440de099831e0db38db037f16bdd",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "21/10/19 2:33 PM",
      "commitNameOld": "c4e27ef7735acd6f91b73d2ecb0227f8dd75a2e4",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 58.83,
      "commitsBetweenForRepo": 220,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,124 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msecs\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msecs\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msecs\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n         + (lifelineSender !\u003d null ?\n             \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         DataNodeFaultInjector.get().startOfferService();\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime,\n                 getRpcMetricSuffix());\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n-            if (!processCommand(resp.getCommands()))\n-              continue;\n+            commandProcessingThread.enqueue(resp.getCommands());\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (!dn.areIBRDisabledForTests() \u0026\u0026\n             (ibrManager.sendImmediately()|| sendHeartbeat)) {\n           ibrManager.sendIBRs(bpNamenode, bpRegistration,\n               bpos.getBlockPoolId(), getRpcMetricSuffix());\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n-        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n+        commandProcessingThread.enqueue(cmds);\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n-          processCommand(new DatanodeCommand[]{ cmd });\n+          commandProcessingThread.enqueue(cmd);\n         }\n \n         if (sendHeartbeat) {\n           dn.getMetrics().addHeartbeatTotal(\n               scheduler.monotonicNow() - startTime, getRpcMetricSuffix());\n         }\n \n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         sleepAfterException();\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n         sleepAfterException();\n       } finally {\n         DataNodeFaultInjector.get().endOfferService();\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msecs\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msecs\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msecs\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n        + (lifelineSender !\u003d null ?\n            \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        DataNodeFaultInjector.get().startOfferService();\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime,\n                getRpcMetricSuffix());\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            commandProcessingThread.enqueue(resp.getCommands());\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (!dn.areIBRDisabledForTests() \u0026\u0026\n            (ibrManager.sendImmediately()|| sendHeartbeat)) {\n          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n              bpos.getBlockPoolId(), getRpcMetricSuffix());\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        commandProcessingThread.enqueue(cmds);\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          commandProcessingThread.enqueue(cmd);\n        }\n\n        if (sendHeartbeat) {\n          dn.getMetrics().addHeartbeatTotal(\n              scheduler.monotonicNow() - startTime, getRpcMetricSuffix());\n        }\n\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        sleepAfterException();\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n        sleepAfterException();\n      } finally {\n        DataNodeFaultInjector.get().endOfferService();\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "528378784fe14e7069dd0471f3c4c478544b57c8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12012. Fix spelling mistakes in BPServiceActor.java. Contributed by chencan.\n",
      "commitDate": "17/08/19 4:37 AM",
      "commitName": "528378784fe14e7069dd0471f3c4c478544b57c8",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "05/05/19 4:03 AM",
      "commitNameOld": "69b903bbd8e2dafac6b2cb1d748ea666b6f877cf",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 104.02,
      "commitsBetweenForRepo": 830,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n-        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n-        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n-        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n+        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msecs\"\n+        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msecs\"\n+        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msecs\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n         + (lifelineSender !\u003d null ?\n             \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         DataNodeFaultInjector.get().startOfferService();\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime,\n                 getRpcMetricSuffix());\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (!dn.areIBRDisabledForTests() \u0026\u0026\n             (ibrManager.sendImmediately()|| sendHeartbeat)) {\n           ibrManager.sendIBRs(bpNamenode, bpRegistration,\n               bpos.getBlockPoolId(), getRpcMetricSuffix());\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n           processCommand(new DatanodeCommand[]{ cmd });\n         }\n \n         if (sendHeartbeat) {\n           dn.getMetrics().addHeartbeatTotal(\n               scheduler.monotonicNow() - startTime, getRpcMetricSuffix());\n         }\n \n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         sleepAfterException();\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n         sleepAfterException();\n       } finally {\n         DataNodeFaultInjector.get().endOfferService();\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msecs\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msecs\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msecs\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n        + (lifelineSender !\u003d null ?\n            \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        DataNodeFaultInjector.get().startOfferService();\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime,\n                getRpcMetricSuffix());\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (!dn.areIBRDisabledForTests() \u0026\u0026\n            (ibrManager.sendImmediately()|| sendHeartbeat)) {\n          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n              bpos.getBlockPoolId(), getRpcMetricSuffix());\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          processCommand(new DatanodeCommand[]{ cmd });\n        }\n\n        if (sendHeartbeat) {\n          dn.getMetrics().addHeartbeatTotal(\n              scheduler.monotonicNow() - startTime, getRpcMetricSuffix());\n        }\n\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        sleepAfterException();\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n        sleepAfterException();\n      } finally {\n        DataNodeFaultInjector.get().endOfferService();\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "387dbe587aa66ac99ec5f5b50827ec3e0a327613": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14314. fullBlockReportLeaseId should be reset after registering to NN. Contributed by star.\n",
      "commitDate": "04/03/19 10:43 AM",
      "commitName": "387dbe587aa66ac99ec5f5b50827ec3e0a327613",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "24/12/18 9:33 AM",
      "commitNameOld": "091ad974cd29fae0cf8fbc98ab84900a1a324839",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 70.05,
      "commitsBetweenForRepo": 524,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,125 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n         + (lifelineSender !\u003d null ?\n             \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n-    long fullBlockReportLeaseId \u003d 0;\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         DataNodeFaultInjector.get().startOfferService();\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime,\n                 getRpcMetricSuffix());\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (!dn.areIBRDisabledForTests() \u0026\u0026\n             (ibrManager.sendImmediately()|| sendHeartbeat)) {\n           ibrManager.sendIBRs(bpNamenode, bpRegistration,\n               bpos.getBlockPoolId(), getRpcMetricSuffix());\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n           processCommand(new DatanodeCommand[]{ cmd });\n         }\n \n         if (sendHeartbeat) {\n           dn.getMetrics().addHeartbeatTotal(\n               scheduler.monotonicNow() - startTime, getRpcMetricSuffix());\n         }\n \n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         sleepAfterException();\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n         sleepAfterException();\n       } finally {\n         DataNodeFaultInjector.get().endOfferService();\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n        + (lifelineSender !\u003d null ?\n            \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        DataNodeFaultInjector.get().startOfferService();\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime,\n                getRpcMetricSuffix());\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (!dn.areIBRDisabledForTests() \u0026\u0026\n            (ibrManager.sendImmediately()|| sendHeartbeat)) {\n          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n              bpos.getBlockPoolId(), getRpcMetricSuffix());\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          processCommand(new DatanodeCommand[]{ cmd });\n        }\n\n        if (sendHeartbeat) {\n          dn.getMetrics().addHeartbeatTotal(\n              scheduler.monotonicNow() - startTime, getRpcMetricSuffix());\n        }\n\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        sleepAfterException();\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n        sleepAfterException();\n      } finally {\n        DataNodeFaultInjector.get().endOfferService();\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "460a94a10f9c314b77a25e14efbf7c4dc3f5d9aa": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14045. Use different metrics in DataNode to better measure latency of heartbeat/blockReports/incrementalBlockReports of Active/Standby NN. Contributed by Jiandan Yang.\n",
      "commitDate": "15/11/18 10:58 AM",
      "commitName": "460a94a10f9c314b77a25e14efbf7c4dc3f5d9aa",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "16/08/18 4:29 PM",
      "commitNameOld": "1290e3c647092f0bfbb250731a6805aba1be8e4b",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 90.81,
      "commitsBetweenForRepo": 804,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,126 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n         + (lifelineSender !\u003d null ?\n             \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n     long fullBlockReportLeaseId \u003d 0;\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         DataNodeFaultInjector.get().startOfferService();\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n-            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n+            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime,\n+                getRpcMetricSuffix());\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (!dn.areIBRDisabledForTests() \u0026\u0026\n             (ibrManager.sendImmediately()|| sendHeartbeat)) {\n           ibrManager.sendIBRs(bpNamenode, bpRegistration,\n-              bpos.getBlockPoolId());\n+              bpos.getBlockPoolId(), getRpcMetricSuffix());\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n           processCommand(new DatanodeCommand[]{ cmd });\n         }\n \n         if (sendHeartbeat) {\n           dn.getMetrics().addHeartbeatTotal(\n-              scheduler.monotonicNow() - startTime);\n+              scheduler.monotonicNow() - startTime, getRpcMetricSuffix());\n         }\n \n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         sleepAfterException();\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n         sleepAfterException();\n       } finally {\n         DataNodeFaultInjector.get().endOfferService();\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n        + (lifelineSender !\u003d null ?\n            \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n    long fullBlockReportLeaseId \u003d 0;\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        DataNodeFaultInjector.get().startOfferService();\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime,\n                getRpcMetricSuffix());\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (!dn.areIBRDisabledForTests() \u0026\u0026\n            (ibrManager.sendImmediately()|| sendHeartbeat)) {\n          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n              bpos.getBlockPoolId(), getRpcMetricSuffix());\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          processCommand(new DatanodeCommand[]{ cmd });\n        }\n\n        if (sendHeartbeat) {\n          dn.getMetrics().addHeartbeatTotal(\n              scheduler.monotonicNow() - startTime, getRpcMetricSuffix());\n        }\n\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        sleepAfterException();\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n        sleepAfterException();\n      } finally {\n        DataNodeFaultInjector.get().endOfferService();\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "1290e3c647092f0bfbb250731a6805aba1be8e4b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10240. Race between close/recoverLease leads to missing block. Contributed by Jinglun, zhouyingchao and Wei-Chiu Chuang.\n",
      "commitDate": "16/08/18 4:29 PM",
      "commitName": "1290e3c647092f0bfbb250731a6805aba1be8e4b",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "3ac07b720b7839a7fe6c83f4ccfe319b6a892501",
      "commitAuthorOld": "Uma Maheswara Rao Gangumalla",
      "daysBetweenCommits": 4.56,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,124 +1,125 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n         + (lifelineSender !\u003d null ?\n             \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n     long fullBlockReportLeaseId \u003d 0;\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         DataNodeFaultInjector.get().startOfferService();\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n-        if (ibrManager.sendImmediately() || sendHeartbeat) {\n+        if (!dn.areIBRDisabledForTests() \u0026\u0026\n+            (ibrManager.sendImmediately()|| sendHeartbeat)) {\n           ibrManager.sendIBRs(bpNamenode, bpRegistration,\n               bpos.getBlockPoolId());\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n           processCommand(new DatanodeCommand[]{ cmd });\n         }\n \n         if (sendHeartbeat) {\n           dn.getMetrics().addHeartbeatTotal(\n               scheduler.monotonicNow() - startTime);\n         }\n \n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         sleepAfterException();\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n         sleepAfterException();\n       } finally {\n         DataNodeFaultInjector.get().endOfferService();\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n        + (lifelineSender !\u003d null ?\n            \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n    long fullBlockReportLeaseId \u003d 0;\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        DataNodeFaultInjector.get().startOfferService();\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (!dn.areIBRDisabledForTests() \u0026\u0026\n            (ibrManager.sendImmediately()|| sendHeartbeat)) {\n          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n              bpos.getBlockPoolId());\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          processCommand(new DatanodeCommand[]{ cmd });\n        }\n\n        if (sendHeartbeat) {\n          dn.getMetrics().addHeartbeatTotal(\n              scheduler.monotonicNow() - startTime);\n        }\n\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        sleepAfterException();\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n        sleepAfterException();\n      } finally {\n        DataNodeFaultInjector.get().endOfferService();\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "74a723852d9ef265d0fd46334f2f885bfb247a3a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11660. TestFsDatasetCache#testPageRounder fails intermittently with AssertionError.\n",
      "commitDate": "19/04/17 6:10 PM",
      "commitName": "74a723852d9ef265d0fd46334f2f885bfb247a3a",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "11/04/17 3:29 PM",
      "commitNameOld": "3a91376707d451777b8269f81bcd48315edd9fc7",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 8.11,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,124 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n         + (lifelineSender !\u003d null ?\n             \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n     long fullBlockReportLeaseId \u003d 0;\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n+        DataNodeFaultInjector.get().startOfferService();\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (ibrManager.sendImmediately() || sendHeartbeat) {\n           ibrManager.sendIBRs(bpNamenode, bpRegistration,\n               bpos.getBlockPoolId());\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n           processCommand(new DatanodeCommand[]{ cmd });\n         }\n \n         if (sendHeartbeat) {\n           dn.getMetrics().addHeartbeatTotal(\n               scheduler.monotonicNow() - startTime);\n         }\n \n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         sleepAfterException();\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n         sleepAfterException();\n+      } finally {\n+        DataNodeFaultInjector.get().endOfferService();\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n        + (lifelineSender !\u003d null ?\n            \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n    long fullBlockReportLeaseId \u003d 0;\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        DataNodeFaultInjector.get().startOfferService();\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (ibrManager.sendImmediately() || sendHeartbeat) {\n          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n              bpos.getBlockPoolId());\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          processCommand(new DatanodeCommand[]{ cmd });\n        }\n\n        if (sendHeartbeat) {\n          dn.getMetrics().addHeartbeatTotal(\n              scheduler.monotonicNow() - startTime);\n        }\n\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        sleepAfterException();\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n        sleepAfterException();\n      } finally {\n        DataNodeFaultInjector.get().endOfferService();\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "1168ece59640d8ad3166e355d2e82deec2fbaf14": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11534. Add counters for number of blocks in pending IBR. Contributed by Xiaobing Zhou.\n",
      "commitDate": "24/03/17 2:33 PM",
      "commitName": "1168ece59640d8ad3166e355d2e82deec2fbaf14",
      "commitAuthor": "Xiaobing Zhou",
      "commitDateOld": "20/03/17 9:54 PM",
      "commitNameOld": "e7c8da614c37e36fb8081234f4c639d6054f6082",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 3.69,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,121 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n         + (lifelineSender !\u003d null ?\n             \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n     long fullBlockReportLeaseId \u003d 0;\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (ibrManager.sendImmediately() || sendHeartbeat) {\n           ibrManager.sendIBRs(bpNamenode, bpRegistration,\n-              bpos.getBlockPoolId(), dn.getMetrics());\n+              bpos.getBlockPoolId());\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n           processCommand(new DatanodeCommand[]{ cmd });\n         }\n \n         if (sendHeartbeat) {\n           dn.getMetrics().addHeartbeatTotal(\n               scheduler.monotonicNow() - startTime);\n         }\n \n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         sleepAfterException();\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n         sleepAfterException();\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n        + (lifelineSender !\u003d null ?\n            \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n    long fullBlockReportLeaseId \u003d 0;\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (ibrManager.sendImmediately() || sendHeartbeat) {\n          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n              bpos.getBlockPoolId());\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          processCommand(new DatanodeCommand[]{ cmd });\n        }\n\n        if (sendHeartbeat) {\n          dn.getMetrics().addHeartbeatTotal(\n              scheduler.monotonicNow() - startTime);\n        }\n\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        sleepAfterException();\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n        sleepAfterException();\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "0cde9e12a7175e4d8bc4ccd5c36055b280d1fbd6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10688. BPServiceActor may run into a tight loop for sending block report when hitting IOException. Contributed by Chen Liang.\n",
      "commitDate": "25/07/16 6:41 PM",
      "commitName": "0cde9e12a7175e4d8bc4ccd5c36055b280d1fbd6",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "28/06/16 4:19 AM",
      "commitNameOld": "2a0082c51da7cbe2770eddb5f72cd7f8d72fa5f6",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 27.6,
      "commitsBetweenForRepo": 271,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,121 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n         + (lifelineSender !\u003d null ?\n             \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n     long fullBlockReportLeaseId \u003d 0;\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (ibrManager.sendImmediately() || sendHeartbeat) {\n           ibrManager.sendIBRs(bpNamenode, bpRegistration,\n               bpos.getBlockPoolId(), dn.getMetrics());\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n           processCommand(new DatanodeCommand[]{ cmd });\n         }\n \n         if (sendHeartbeat) {\n           dn.getMetrics().addHeartbeatTotal(\n               scheduler.monotonicNow() - startTime);\n         }\n \n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n-        try {\n-          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n-          Thread.sleep(sleepTime);\n-        } catch (InterruptedException ie) {\n-          Thread.currentThread().interrupt();\n-        }\n+        sleepAfterException();\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n+        sleepAfterException();\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n        + (lifelineSender !\u003d null ?\n            \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n    long fullBlockReportLeaseId \u003d 0;\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (ibrManager.sendImmediately() || sendHeartbeat) {\n          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n              bpos.getBlockPoolId(), dn.getMetrics());\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          processCommand(new DatanodeCommand[]{ cmd });\n        }\n\n        if (sendHeartbeat) {\n          dn.getMetrics().addHeartbeatTotal(\n              scheduler.monotonicNow() - startTime);\n        }\n\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        sleepAfterException();\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n        sleepAfterException();\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "c2140d05efaf18b41caae8c61d9f6d668ab0e874": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9882. Add heartbeatsTotal in Datanode metrics. (Contributed by Hua Liu)\n",
      "commitDate": "07/03/16 9:10 PM",
      "commitName": "c2140d05efaf18b41caae8c61d9f6d668ab0e874",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "04/03/16 3:29 PM",
      "commitNameOld": "2759689d7d23001f007cb0dbe2521de90734dd5c",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 3.24,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,125 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n         + (lifelineSender !\u003d null ?\n             \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n     long fullBlockReportLeaseId \u003d 0;\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (ibrManager.sendImmediately() || sendHeartbeat) {\n           ibrManager.sendIBRs(bpNamenode, bpRegistration,\n               bpos.getBlockPoolId(), dn.getMetrics());\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n           processCommand(new DatanodeCommand[]{ cmd });\n         }\n \n+        if (sendHeartbeat) {\n+          dn.getMetrics().addHeartbeatTotal(\n+              scheduler.monotonicNow() - startTime);\n+        }\n+\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n        + (lifelineSender !\u003d null ?\n            \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n    long fullBlockReportLeaseId \u003d 0;\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (ibrManager.sendImmediately() || sendHeartbeat) {\n          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n              bpos.getBlockPoolId(), dn.getMetrics());\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          processCommand(new DatanodeCommand[]{ cmd });\n        }\n\n        if (sendHeartbeat) {\n          dn.getMetrics().addHeartbeatTotal(\n              scheduler.monotonicNow() - startTime);\n        }\n\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "2759689d7d23001f007cb0dbe2521de90734dd5c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9239. DataNode Lifeline Protocol: an alternative protocol for reporting DataNode liveness. Contributed by Chris Nauroth.\n",
      "commitDate": "04/03/16 3:29 PM",
      "commitName": "2759689d7d23001f007cb0dbe2521de90734dd5c",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "26/02/16 3:32 PM",
      "commitNameOld": "d1d4e16690cc85f7f22fbead9cf596260819b561",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 7.0,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,120 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n-        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n+        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n+        + (lifelineSender !\u003d null ?\n+            \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n     long fullBlockReportLeaseId \u003d 0;\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (ibrManager.sendImmediately() || sendHeartbeat) {\n           ibrManager.sendIBRs(bpNamenode, bpRegistration,\n               bpos.getBlockPoolId(), dn.getMetrics());\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n           processCommand(new DatanodeCommand[]{ cmd });\n         }\n \n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval\n        + (lifelineSender !\u003d null ?\n            \"; lifelineIntervalMs\u003d\" + dnConf.getLifelineIntervalMs() : \"\"));\n    long fullBlockReportLeaseId \u003d 0;\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (ibrManager.sendImmediately() || sendHeartbeat) {\n          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n              bpos.getBlockPoolId(), dn.getMetrics());\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          processCommand(new DatanodeCommand[]{ cmd });\n        }\n\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "d1d4e16690cc85f7f22fbead9cf596260819b561": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9710. DN can be configured to send block receipt IBRs in batches.\n",
      "commitDate": "26/02/16 3:32 PM",
      "commitName": "d1d4e16690cc85f7f22fbead9cf596260819b561",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "05/02/16 7:17 AM",
      "commitNameOld": "4e5e1c0f9938e51699c0437731e7b2eef699d6da",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 21.34,
      "commitsBetweenForRepo": 151,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,118 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n     long fullBlockReportLeaseId \u003d 0;\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (ibrManager.sendImmediately() || sendHeartbeat) {\n           ibrManager.sendIBRs(bpNamenode, bpRegistration,\n               bpos.getBlockPoolId(), dn.getMetrics());\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n           processCommand(new DatanodeCommand[]{ cmd });\n         }\n \n-        //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n-        //\n-        long waitTime \u003d scheduler.getHeartbeatWaitTime();\n-        synchronized(ibrManager) {\n-          if (waitTime \u003e 0 \u0026\u0026 !ibrManager.sendImmediately()) {\n-            try {\n-              ibrManager.wait(waitTime);\n-            } catch (InterruptedException ie) {\n-              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n-            }\n-          }\n-        } // synchronized\n+        ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n    long fullBlockReportLeaseId \u003d 0;\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (ibrManager.sendImmediately() || sendHeartbeat) {\n          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n              bpos.getBlockPoolId(), dn.getMetrics());\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          processCommand(new DatanodeCommand[]{ cmd });\n        }\n\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        ibrManager.waitTillNextIBR(scheduler.getHeartbeatWaitTime());\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "4e5e1c0f9938e51699c0437731e7b2eef699d6da": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9726. Refactor IBR code to a new class.\n",
      "commitDate": "05/02/16 7:17 AM",
      "commitName": "4e5e1c0f9938e51699c0437731e7b2eef699d6da",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "02/02/16 11:23 AM",
      "commitNameOld": "dd9ebf6eedfd4ff8b3486eae2a446de6b0c7fa8a",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 2.83,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,128 +1,129 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n     long fullBlockReportLeaseId \u003d 0;\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n-        if (sendImmediateIBR || sendHeartbeat) {\n-          reportReceivedDeletedBlocks();\n+        if (ibrManager.sendImmediately() || sendHeartbeat) {\n+          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n+              bpos.getBlockPoolId(), dn.getMetrics());\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n           processCommand(new DatanodeCommand[]{ cmd });\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d scheduler.getHeartbeatWaitTime();\n-        synchronized(pendingIncrementalBRperStorage) {\n-          if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n+        synchronized(ibrManager) {\n+          if (waitTime \u003e 0 \u0026\u0026 !ibrManager.sendImmediately()) {\n             try {\n-              pendingIncrementalBRperStorage.wait(waitTime);\n+              ibrManager.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n    long fullBlockReportLeaseId \u003d 0;\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (ibrManager.sendImmediately() || sendHeartbeat) {\n          ibrManager.sendIBRs(bpNamenode, bpRegistration,\n              bpos.getBlockPoolId(), dn.getMetrics());\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          processCommand(new DatanodeCommand[]{ cmd });\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d scheduler.getHeartbeatWaitTime();\n        synchronized(ibrManager) {\n          if (waitTime \u003e 0 \u0026\u0026 !ibrManager.sendImmediately()) {\n            try {\n              ibrManager.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "d8736eb9ca351b82854601ea3b1fbc3c9fab44e4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9305. Delayed heartbeat processing causes storm of subsequent heartbeats. (Contributed by Arpit Agarwal)\n",
      "commitDate": "26/10/15 3:54 PM",
      "commitName": "d8736eb9ca351b82854601ea3b1fbc3c9fab44e4",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "01/09/15 5:58 PM",
      "commitNameOld": "5652131d2ea68c408dd3cd8bee31723642a8cdde",
      "commitAuthorOld": "yliu",
      "daysBetweenCommits": 54.91,
      "commitsBetweenForRepo": 418,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,128 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n     long fullBlockReportLeaseId \u003d 0;\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n-          scheduler.scheduleNextHeartbeat();\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (sendImmediateIBR || sendHeartbeat) {\n           reportReceivedDeletedBlocks();\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         if (!dn.areCacheReportsDisabledForTests()) {\n           DatanodeCommand cmd \u003d cacheReport();\n           processCommand(new DatanodeCommand[]{ cmd });\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d scheduler.getHeartbeatWaitTime();\n         synchronized(pendingIncrementalBRperStorage) {\n           if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n             try {\n               pendingIncrementalBRperStorage.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n    long fullBlockReportLeaseId \u003d 0;\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (sendImmediateIBR || sendHeartbeat) {\n          reportReceivedDeletedBlocks();\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          processCommand(new DatanodeCommand[]{ cmd });\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d scheduler.getHeartbeatWaitTime();\n        synchronized(pendingIncrementalBRperStorage) {\n          if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n            try {\n              pendingIncrementalBRperStorage.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "afe9ea3c12e1f5a71922400eadb642960bc87ca1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8646. Prune cached replicas from DatanodeDescriptor state on replica invalidation.\n",
      "commitDate": "24/06/15 2:42 PM",
      "commitName": "afe9ea3c12e1f5a71922400eadb642960bc87ca1",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "17/06/15 5:01 PM",
      "commitNameOld": "45ced38f10fcb9f831218b890786aaeb7987fed4",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 6.9,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,129 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n     long fullBlockReportLeaseId \u003d 0;\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                   scheduler.isBlockReportDue(startTime);\n           scheduler.scheduleNextHeartbeat();\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n             if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n               if (fullBlockReportLeaseId !\u003d 0) {\n                 LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                         \"ID of 0x\" +\n                         Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                         \", but we already have a lease ID of 0x\" +\n                         Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                         \"Overwriting old lease ID.\");\n               }\n               fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n             }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (sendImmediateIBR || sendHeartbeat) {\n           reportReceivedDeletedBlocks();\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d null;\n         boolean forceFullBr \u003d\n             scheduler.forceFullBlockReport.getAndSet(false);\n         if (forceFullBr) {\n           LOG.info(\"Forcing a full block report to \" + nnAddr);\n         }\n         if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n           cmds \u003d blockReport(fullBlockReportLeaseId);\n           fullBlockReportLeaseId \u003d 0;\n         }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n-        DatanodeCommand cmd \u003d cacheReport();\n-        processCommand(new DatanodeCommand[]{ cmd });\n+        if (!dn.areCacheReportsDisabledForTests()) {\n+          DatanodeCommand cmd \u003d cacheReport();\n+          processCommand(new DatanodeCommand[]{ cmd });\n+        }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d scheduler.getHeartbeatWaitTime();\n         synchronized(pendingIncrementalBRperStorage) {\n           if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n             try {\n               pendingIncrementalBRperStorage.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n    long fullBlockReportLeaseId \u003d 0;\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          scheduler.scheduleNextHeartbeat();\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (sendImmediateIBR || sendHeartbeat) {\n          reportReceivedDeletedBlocks();\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        if (!dn.areCacheReportsDisabledForTests()) {\n          DatanodeCommand cmd \u003d cacheReport();\n          processCommand(new DatanodeCommand[]{ cmd });\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d scheduler.getHeartbeatWaitTime();\n        synchronized(pendingIncrementalBRperStorage) {\n          if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n            try {\n              pendingIncrementalBRperStorage.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "12b5b06c063d93e6c683c9b6fac9a96912f59e59": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7923. The DataNodes should rate-limit their full block reports by asking the NN on heartbeat messages (cmccabe)\n",
      "commitDate": "12/06/15 11:17 AM",
      "commitName": "12b5b06c063d93e6c683c9b6fac9a96912f59e59",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "19/05/15 10:50 AM",
      "commitNameOld": "470c87dbc6c24dd3b370f1ad9e7ab1f6dabd2080",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 24.02,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,127 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n-        + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n+        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n+    long fullBlockReportLeaseId \u003d 0;\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n+        HeartbeatResponse resp \u003d null;\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n+          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n+                  scheduler.isBlockReportDue(startTime);\n           scheduler.scheduleNextHeartbeat();\n           if (!dn.areHeartbeatsDisabledForTests()) {\n-            HeartbeatResponse resp \u003d sendHeartBeat();\n+            resp \u003d sendHeartBeat(requestBlockReportLease);\n             assert resp !\u003d null;\n+            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n+              if (fullBlockReportLeaseId !\u003d 0) {\n+                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n+                        \"ID of 0x\" +\n+                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n+                        \", but we already have a lease ID of 0x\" +\n+                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n+                        \"Overwriting old lease ID.\");\n+              }\n+              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n+            }\n             dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (sendImmediateIBR || sendHeartbeat) {\n           reportReceivedDeletedBlocks();\n         }\n \n-        List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n+        List\u003cDatanodeCommand\u003e cmds \u003d null;\n+        boolean forceFullBr \u003d\n+            scheduler.forceFullBlockReport.getAndSet(false);\n+        if (forceFullBr) {\n+          LOG.info(\"Forcing a full block report to \" + nnAddr);\n+        }\n+        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n+          cmds \u003d blockReport(fullBlockReportLeaseId);\n+          fullBlockReportLeaseId \u003d 0;\n+        }\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         DatanodeCommand cmd \u003d cacheReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d scheduler.getHeartbeatWaitTime();\n         synchronized(pendingIncrementalBRperStorage) {\n           if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n             try {\n               pendingIncrementalBRperStorage.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelayMs + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n    long fullBlockReportLeaseId \u003d 0;\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        HeartbeatResponse resp \u003d null;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          boolean requestBlockReportLease \u003d (fullBlockReportLeaseId \u003d\u003d 0) \u0026\u0026\n                  scheduler.isBlockReportDue(startTime);\n          scheduler.scheduleNextHeartbeat();\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            resp \u003d sendHeartBeat(requestBlockReportLease);\n            assert resp !\u003d null;\n            if (resp.getFullBlockReportLeaseId() !\u003d 0) {\n              if (fullBlockReportLeaseId !\u003d 0) {\n                LOG.warn(nnAddr + \" sent back a full block report lease \" +\n                        \"ID of 0x\" +\n                        Long.toHexString(resp.getFullBlockReportLeaseId()) +\n                        \", but we already have a lease ID of 0x\" +\n                        Long.toHexString(fullBlockReportLeaseId) + \". \" +\n                        \"Overwriting old lease ID.\");\n              }\n              fullBlockReportLeaseId \u003d resp.getFullBlockReportLeaseId();\n            }\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (sendImmediateIBR || sendHeartbeat) {\n          reportReceivedDeletedBlocks();\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d null;\n        boolean forceFullBr \u003d\n            scheduler.forceFullBlockReport.getAndSet(false);\n        if (forceFullBr) {\n          LOG.info(\"Forcing a full block report to \" + nnAddr);\n        }\n        if ((fullBlockReportLeaseId !\u003d 0) || forceFullBr) {\n          cmds \u003d blockReport(fullBlockReportLeaseId);\n          fullBlockReportLeaseId \u003d 0;\n        }\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        DatanodeCommand cmd \u003d cacheReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d scheduler.getHeartbeatWaitTime();\n        synchronized(pendingIncrementalBRperStorage) {\n          if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n            try {\n              pendingIncrementalBRperStorage.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "dfc1c4c303cf15afc6c3361ed9d3238562f73cbd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8163. Using monotonicNow for block report scheduling causes test failures on recently restarted systems. (Arpit Agarwal)\n",
      "commitDate": "21/04/15 10:58 AM",
      "commitName": "dfc1c4c303cf15afc6c3361ed9d3238562f73cbd",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "08/04/15 9:43 PM",
      "commitNameOld": "b1e059089d6a5b2b7006d7d384c6df81ed268bd9",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 12.55,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,103 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n-        final long startTime \u003d monotonicNow();\n+        final long startTime \u003d scheduler.monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n-        boolean sendHeartbeat \u003d\n-            startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval;\n+        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n         if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n-          lastHeartbeat \u003d startTime;\n+          scheduler.scheduleNextHeartbeat();\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n-            dn.getMetrics().addHeartbeat(monotonicNow() - startTime);\n+            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (sendImmediateIBR || sendHeartbeat) {\n           reportReceivedDeletedBlocks();\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         DatanodeCommand cmd \u003d cacheReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n-        long waitTime \u003d dnConf.heartBeatInterval - \n-        (monotonicNow() - lastHeartbeat);\n+        long waitTime \u003d scheduler.getHeartbeatWaitTime();\n         synchronized(pendingIncrementalBRperStorage) {\n           if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n             try {\n               pendingIncrementalBRperStorage.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d scheduler.monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        final boolean sendHeartbeat \u003d scheduler.isHeartbeatDue(startTime);\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          scheduler.scheduleNextHeartbeat();\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(scheduler.monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (sendImmediateIBR || sendHeartbeat) {\n          reportReceivedDeletedBlocks();\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        DatanodeCommand cmd \u003d cacheReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d scheduler.getHeartbeatWaitTime();\n        synchronized(pendingIncrementalBRperStorage) {\n          if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n            try {\n              pendingIncrementalBRperStorage.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "60882ab26d49f05cbf0686944af6559f86b3417d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7990. IBR delete ack should not be delayed. Contributed by Daryn Sharp.\n",
      "commitDate": "27/03/15 7:05 AM",
      "commitName": "60882ab26d49f05cbf0686944af6559f86b3417d",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "23/03/15 10:00 PM",
      "commitNameOld": "50ee8f4e67a66aa77c5359182f61f3e951844db6",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 3.38,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,105 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n-        + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n-        if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n+        boolean sendHeartbeat \u003d\n+            startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval;\n+        if (sendHeartbeat) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n-        if (sendImmediateIBR ||\n-            (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n+        if (sendImmediateIBR || sendHeartbeat) {\n           reportReceivedDeletedBlocks();\n-          lastDeletedReport \u003d startTime;\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         DatanodeCommand cmd \u003d cacheReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (monotonicNow() - lastHeartbeat);\n         synchronized(pendingIncrementalBRperStorage) {\n           if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n             try {\n               pendingIncrementalBRperStorage.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        boolean sendHeartbeat \u003d\n            startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval;\n        if (sendHeartbeat) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (sendImmediateIBR || sendHeartbeat) {\n          reportReceivedDeletedBlocks();\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        DatanodeCommand cmd \u003d cacheReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (monotonicNow() - lastHeartbeat);\n        synchronized(pendingIncrementalBRperStorage) {\n          if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n            try {\n              pendingIncrementalBRperStorage.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6841. Use Time.monotonicNow() wherever applicable instead of Time.now(). Contributed by Vinayakumar B\n",
      "commitDate": "20/03/15 12:02 PM",
      "commitName": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "13/03/15 12:23 PM",
      "commitNameOld": "d324164a51a43d72c02567248bd9f0f12b244a40",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 6.99,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n-        final long startTime \u003d now();\n+        final long startTime \u003d monotonicNow();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n-            dn.getMetrics().addHeartbeat(now() - startTime);\n+            dn.getMetrics().addHeartbeat(monotonicNow() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n-            long startProcessCommands \u003d now();\n+            long startProcessCommands \u003d monotonicNow();\n             if (!processCommand(resp.getCommands()))\n               continue;\n-            long endProcessCommands \u003d now();\n+            long endProcessCommands \u003d monotonicNow();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (sendImmediateIBR ||\n             (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         DatanodeCommand cmd \u003d cacheReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n-        (Time.now() - lastHeartbeat);\n+        (monotonicNow() - lastHeartbeat);\n         synchronized(pendingIncrementalBRperStorage) {\n           if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n             try {\n               pendingIncrementalBRperStorage.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n       processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d monotonicNow();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(monotonicNow() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d monotonicNow();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d monotonicNow();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (sendImmediateIBR ||\n            (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        DatanodeCommand cmd \u003d cacheReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (monotonicNow() - lastHeartbeat);\n        synchronized(pendingIncrementalBRperStorage) {\n          if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n            try {\n              pendingIncrementalBRperStorage.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "38262779bbf38a427bad6d044e91165567f1d206": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7704. DN heartbeat to Active NN may be blocked and expire if connection to Standby NN continues to time out. Contributed by Rushabh Shah.\n",
      "commitDate": "12/02/15 7:15 AM",
      "commitName": "38262779bbf38a427bad6d044e91165567f1d206",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "09/02/15 9:13 PM",
      "commitNameOld": "3d15728ff5301296801e541d9b23bd1687c4adad",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 2.42,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,106 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d now();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (sendImmediateIBR ||\n             (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         DatanodeCommand cmd \u003d cacheReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (Time.now() - lastHeartbeat);\n         synchronized(pendingIncrementalBRperStorage) {\n           if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n             try {\n               pendingIncrementalBRperStorage.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n+      processQueueMessages();\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (sendImmediateIBR ||\n            (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        DatanodeCommand cmd \u003d cacheReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (Time.now() - lastHeartbeat);\n        synchronized(pendingIncrementalBRperStorage) {\n          if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n            try {\n              pendingIncrementalBRperStorage.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n      processQueueMessages();\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "6e62a1a6728b1f782f64065424f92b292c3f163a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7430. Refactor the BlockScanner to use O(1) memory and use multiple threads (cmccabe)\n",
      "commitDate": "21/01/15 7:00 PM",
      "commitName": "6e62a1a6728b1f782f64065424f92b292c3f163a",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "08/01/15 3:12 PM",
      "commitNameOld": "7e2d9a32426d04b5f08c2835f61882b053612a20",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 13.16,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,105 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             if (state \u003d\u003d HAServiceState.ACTIVE) {\n               handleRollingUpgradeStatus(resp);\n             }\n \n             long startProcessCommands \u003d now();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (sendImmediateIBR ||\n             (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         DatanodeCommand cmd \u003d cacheReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n-        // Now safe to start scanning the block pool.\n-        // If it has already been started, this is a no-op.\n-        if (dn.blockScanner !\u003d null) {\n-          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n-        }\n-\n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (Time.now() - lastHeartbeat);\n         synchronized(pendingIncrementalBRperStorage) {\n           if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n             try {\n               pendingIncrementalBRperStorage.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (sendImmediateIBR ||\n            (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        DatanodeCommand cmd \u003d cacheReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (Time.now() - lastHeartbeat);\n        synchronized(pendingIncrementalBRperStorage) {\n          if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n            try {\n              pendingIncrementalBRperStorage.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "440c3cd1050f2a871a73d44406c0013b6ff73f2e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5922. DN heartbeat thread can get stuck in tight loop. (Arpit Agarwal)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1571542 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/02/14 6:16 PM",
      "commitName": "440c3cd1050f2a871a73d44406c0013b6ff73f2e",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "31/01/14 1:00 PM",
      "commitNameOld": "5beeb3016954a3ee0c1fb10a2083ffd540cd2c14",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 24.22,
      "commitsBetweenForRepo": 192,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,107 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             long startProcessCommands \u003d now();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n-        if (pendingReceivedRequests \u003e 0\n-            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n+        if (sendImmediateIBR ||\n+            (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         DatanodeCommand cmd \u003d cacheReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         // Now safe to start scanning the block pool.\n         // If it has already been started, this is a no-op.\n         if (dn.blockScanner !\u003d null) {\n           dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (Time.now() - lastHeartbeat);\n         synchronized(pendingIncrementalBRperStorage) {\n-          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n+          if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n             try {\n               pendingIncrementalBRperStorage.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (sendImmediateIBR ||\n            (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        DatanodeCommand cmd \u003d cacheReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool.\n        // If it has already been started, this is a no-op.\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (Time.now() - lastHeartbeat);\n        synchronized(pendingIncrementalBRperStorage) {\n          if (waitTime \u003e 0 \u0026\u0026 !sendImmediateIBR) {\n            try {\n              pendingIncrementalBRperStorage.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "5df82fa01d26c18685ad7617128dbc2913547cb3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5907. BlockPoolSliceStorage trash to handle block deletions during rolling upgrade. (Arpit Agarwal)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1568346 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/02/14 8:37 AM",
      "commitName": "5df82fa01d26c18685ad7617128dbc2913547cb3",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "07/02/14 10:25 AM",
      "commitNameOld": "300e4906af6d16f4fed5119028d87d8d5a8bddbb",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 6.93,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,111 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         final long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n+            if (state \u003d\u003d HAServiceState.ACTIVE) {\n+              handleRollingUpgradeStatus(resp);\n+            }\n+\n             long startProcessCommands \u003d now();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (pendingReceivedRequests \u003e 0\n             || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n         processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n         DatanodeCommand cmd \u003d cacheReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         // Now safe to start scanning the block pool.\n         // If it has already been started, this is a no-op.\n         if (dn.blockScanner !\u003d null) {\n           dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (Time.now() - lastHeartbeat);\n         synchronized(pendingIncrementalBRperStorage) {\n           if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n             try {\n               pendingIncrementalBRperStorage.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            if (state \u003d\u003d HAServiceState.ACTIVE) {\n              handleRollingUpgradeStatus(resp);\n            }\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        DatanodeCommand cmd \u003d cacheReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool.\n        // If it has already been started, this is a no-op.\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (Time.now() - lastHeartbeat);\n        synchronized(pendingIncrementalBRperStorage) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              pendingIncrementalBRperStorage.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "5beeb3016954a3ee0c1fb10a2083ffd540cd2c14": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5153. Datanode should send block reports for each storage in a separate message. (Arpit Agarwal)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1563254 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/01/14 1:00 PM",
      "commitName": "5beeb3016954a3ee0c1fb10a2083ffd540cd2c14",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "15/12/13 4:58 PM",
      "commitNameOld": "938565925adb9d866e8c6951361cd5582076e013",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 46.83,
      "commitsBetweenForRepo": 246,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,107 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n-        long startTime \u003d now();\n+        final long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n             state \u003d resp.getNameNodeHaState().getState();\n \n             long startProcessCommands \u003d now();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (pendingReceivedRequests \u003e 0\n             || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n-        DatanodeCommand cmd \u003d blockReport();\n-        processCommand(new DatanodeCommand[]{ cmd });\n+        List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n+        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n \n-        cmd \u003d cacheReport();\n+        DatanodeCommand cmd \u003d cacheReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         // Now safe to start scanning the block pool.\n         // If it has already been started, this is a no-op.\n         if (dn.blockScanner !\u003d null) {\n           dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (Time.now() - lastHeartbeat);\n         synchronized(pendingIncrementalBRperStorage) {\n           if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n             try {\n               pendingIncrementalBRperStorage.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        final long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        List\u003cDatanodeCommand\u003e cmds \u003d blockReport();\n        processCommand(cmds \u003d\u003d null ? null : cmds.toArray(new DatanodeCommand[cmds.size()]));\n\n        DatanodeCommand cmd \u003d cacheReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool.\n        // If it has already been started, this is a no-op.\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (Time.now() - lastHeartbeat);\n        synchronized(pendingIncrementalBRperStorage) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              pendingIncrementalBRperStorage.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "04cf2a768c0fb1c2c5c80d2480aa072ec7e43c3f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5014. Process register commands with out holding BPOfferService lock. Contributed by Vinay.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543861 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/11/13 8:27 AM",
      "commitName": "04cf2a768c0fb1c2c5c80d2480aa072ec7e43c3f",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "11/11/13 10:30 AM",
      "commitNameOld": "9673baa7e8b43fa6300080f72ebce0189ea775e5",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 8.91,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,107 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using\"\n         + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n         + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n         + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n         + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n         + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n+            state \u003d resp.getNameNodeHaState().getState();\n \n             long startProcessCommands \u003d now();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (pendingReceivedRequests \u003e 0\n             || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         DatanodeCommand cmd \u003d blockReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         cmd \u003d cacheReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         // Now safe to start scanning the block pool.\n         // If it has already been started, this is a no-op.\n         if (dn.blockScanner !\u003d null) {\n           dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (Time.now() - lastHeartbeat);\n         synchronized(pendingIncrementalBR) {\n           if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n             try {\n               pendingIncrementalBR.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n            state \u003d resp.getNameNodeHaState().getState();\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        DatanodeCommand cmd \u003d blockReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        cmd \u003d cacheReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool.\n        // If it has already been started, this is a no-op.\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (Time.now() - lastHeartbeat);\n        synchronized(pendingIncrementalBR) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              pendingIncrementalBR.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "01f37e42f050207b7659bf74e2484cf8bdae2d89": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5390. Send one incremental block report per storage directory.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1534891 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/10/13 6:28 PM",
      "commitName": "01f37e42f050207b7659bf74e2484cf8bdae2d89",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "21/10/13 7:22 PM",
      "commitNameOld": "0ebab3a88a5f172a1180f4e88a91cf6194b273ca",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n         + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n         + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n         + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n         + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n \n             long startProcessCommands \u003d now();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (pendingReceivedRequests \u003e 0\n             || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         DatanodeCommand cmd \u003d blockReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         // Now safe to start scanning the block pool.\n         // If it has already been started, this is a no-op.\n         if (dn.blockScanner !\u003d null) {\n           dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (Time.now() - lastHeartbeat);\n-        synchronized(pendingIncrementalBR) {\n+        synchronized(pendingIncrementalBRperStorage) {\n           if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n             try {\n-              pendingIncrementalBR.wait(waitTime);\n+              pendingIncrementalBRperStorage.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n        + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        DatanodeCommand cmd \u003d blockReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool.\n        // If it has already been started, this is a no-op.\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (Time.now() - lastHeartbeat);\n        synchronized(pendingIncrementalBRperStorage) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              pendingIncrementalBRperStorage.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "52ccc6c6d539d0587c3fd9693709bd1f6e12619d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5051.  Propagate cache status information from the DataNode to the NameNode  (Andrew Wang via Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1513653 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/08/13 2:05 PM",
      "commitName": "52ccc6c6d539d0587c3fd9693709bd1f6e12619d",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "01/04/13 7:11 PM",
      "commitNameOld": "ef9e1ba76357f6aaa5489ba1d5ed40ffff40a2cc",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 133.79,
      "commitsBetweenForRepo": 772,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,106 @@\n   private void offerService() throws Exception {\n-    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n-        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n-        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n-        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n-        + dnConf.heartBeatInterval);\n+    LOG.info(\"For namenode \" + nnAddr + \" using\"\n+        + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n+        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n+        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n+        + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n+        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n \n             long startProcessCommands \u003d now();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (pendingReceivedRequests \u003e 0\n             || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         DatanodeCommand cmd \u003d blockReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n+        cmd \u003d cacheReport();\n+        processCommand(new DatanodeCommand[]{ cmd });\n+\n         // Now safe to start scanning the block pool.\n         // If it has already been started, this is a no-op.\n         if (dn.blockScanner !\u003d null) {\n           dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (Time.now() - lastHeartbeat);\n         synchronized(pendingIncrementalBR) {\n           if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n             try {\n               pendingIncrementalBR.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using\"\n        + \" DELETEREPORT_INTERVAL of \" + dnConf.deleteReportInterval + \" msec \"\n        + \" BLOCKREPORT_INTERVAL of \" + dnConf.blockReportInterval + \"msec\"\n        + \" CACHEREPORT_INTERVAL of \" + dnConf.cacheReportInterval + \"msec\"\n        + \" Initial delay: \" + dnConf.initialBlockReportDelay + \"msec\"\n        + \"; heartBeatInterval\u003d\" + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        DatanodeCommand cmd \u003d blockReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        cmd \u003d cacheReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool.\n        // If it has already been started, this is a no-op.\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (Time.now() - lastHeartbeat);\n        synchronized(pendingIncrementalBR) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              pendingIncrementalBR.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "ef9e1ba76357f6aaa5489ba1d5ed40ffff40a2cc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4656. DN heartbeat loop can be briefly tight. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1463357 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/04/13 7:11 PM",
      "commitName": "ef9e1ba76357f6aaa5489ba1d5ed40ffff40a2cc",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "28/10/12 4:10 PM",
      "commitNameOld": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 155.13,
      "commitsBetweenForRepo": 703,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n         + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n         + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n         + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n         + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n-        if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n+        if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n \n             long startProcessCommands \u003d now();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (pendingReceivedRequests \u003e 0\n             || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         DatanodeCommand cmd \u003d blockReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         // Now safe to start scanning the block pool.\n         // If it has already been started, this is a no-op.\n         if (dn.blockScanner !\u003d null) {\n           dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (Time.now() - lastHeartbeat);\n         synchronized(pendingIncrementalBR) {\n           if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n             try {\n               pendingIncrementalBR.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n        + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e\u003d dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        DatanodeCommand cmd \u003d blockReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool.\n        // If it has already been started, this is a no-op.\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (Time.now() - lastHeartbeat);\n        synchronized(pendingIncrementalBR) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              pendingIncrementalBR.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3641. Move server Util time methods to common and use now instead of System#currentTimeMillis. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1360858 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 12:01 PM",
      "commitName": "4a5ba3b7bd2360fd9605863630b477d362874e1e",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "03/05/12 12:05 PM",
      "commitNameOld": "9aae7c22acfcc7b337cf06149864319d2cc877f8",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 70.0,
      "commitsBetweenForRepo": 359,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n         + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n         + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n         + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n         + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n \n             long startProcessCommands \u003d now();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (pendingReceivedRequests \u003e 0\n             || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         DatanodeCommand cmd \u003d blockReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         // Now safe to start scanning the block pool.\n         // If it has already been started, this is a no-op.\n         if (dn.blockScanner !\u003d null) {\n           dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n-        (System.currentTimeMillis() - lastHeartbeat);\n+        (Time.now() - lastHeartbeat);\n         synchronized(pendingIncrementalBR) {\n           if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n             try {\n               pendingIncrementalBR.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n        + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        DatanodeCommand cmd \u003d blockReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool.\n        // If it has already been started, this is a no-op.\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (Time.now() - lastHeartbeat);\n        synchronized(pendingIncrementalBR) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              pendingIncrementalBR.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "978a8050e28b2afb193a3e00d82a8475fa4d2428": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2920. fix remaining TODO items. Contributed by Aaron T. Myers and Todd Lipcon.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1294923 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/02/12 5:09 PM",
      "commitName": "978a8050e28b2afb193a3e00d82a8475fa4d2428",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "22/02/12 12:37 PM",
      "commitNameOld": "7527e943e6c8ea909f22d9d66246ac6c8bc2d6a0",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 6.19,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n         + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n         + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n         + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n         + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n \n             long startProcessCommands \u003d now();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (pendingReceivedRequests \u003e 0\n             || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         DatanodeCommand cmd \u003d blockReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n-        // Now safe to start scanning the block pool\n-        // TODO(HA): this doesn\u0027t seem quite right\n+        // Now safe to start scanning the block pool.\n+        // If it has already been started, this is a no-op.\n         if (dn.blockScanner !\u003d null) {\n           dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (System.currentTimeMillis() - lastHeartbeat);\n         synchronized(pendingIncrementalBR) {\n           if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n             try {\n               pendingIncrementalBR.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n        + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        DatanodeCommand cmd \u003d blockReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool.\n        // If it has already been started, this is a no-op.\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (System.currentTimeMillis() - lastHeartbeat);\n        synchronized(pendingIncrementalBR) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              pendingIncrementalBR.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "7527e943e6c8ea909f22d9d66246ac6c8bc2d6a0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2972. Small optimization building incremental block report. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1292497 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/02/12 12:37 PM",
      "commitName": "7527e943e6c8ea909f22d9d66246ac6c8bc2d6a0",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "13/02/12 1:00 PM",
      "commitNameOld": "db187cf40ee307524c48cededd58710a4dfb4812",
      "commitAuthorOld": "",
      "daysBetweenCommits": 8.98,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n         + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n         + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n         + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n         + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n             assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n             // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n             // then let the BPOfferService update itself.\n             //\n             // Important that this happens before processCommand below,\n             // since the first heartbeat to a new active might have commands\n             // that we should actually process.\n             bpos.updateActorStatesFromHeartbeat(\n                 this, resp.getNameNodeHaState());\n \n             long startProcessCommands \u003d now();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (pendingReceivedRequests \u003e 0\n             || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         DatanodeCommand cmd \u003d blockReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         // Now safe to start scanning the block pool\n         // TODO(HA): this doesn\u0027t seem quite right\n         if (dn.blockScanner !\u003d null) {\n           dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (System.currentTimeMillis() - lastHeartbeat);\n-        synchronized(receivedAndDeletedBlockList) {\n+        synchronized(pendingIncrementalBR) {\n           if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n             try {\n-              receivedAndDeletedBlockList.wait(waitTime);\n+              pendingIncrementalBR.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n        + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        DatanodeCommand cmd \u003d blockReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool\n        // TODO(HA): this doesn\u0027t seem quite right\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (System.currentTimeMillis() - lastHeartbeat);\n        synchronized(pendingIncrementalBR) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              pendingIncrementalBR.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "6016e95feec93f0e17a8a1370c0ede735ca13f55": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2627. Determine DN\u0027s view of which NN is active based on heartbeat responses. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1211735 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/12/11 6:00 PM",
      "commitName": "6016e95feec93f0e17a8a1370c0ede735ca13f55",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "04/12/11 10:36 PM",
      "commitNameOld": "b3f28dbb3d1ab6b2f686efdd7bdb064426177f21",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 2.81,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,102 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n         + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n         + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n         + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n         + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             HeartbeatResponse resp \u003d sendHeartBeat();\n+            assert resp !\u003d null;\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n+            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n+            // then let the BPOfferService update itself.\n+            //\n+            // Important that this happens before processCommand below,\n+            // since the first heartbeat to a new active might have commands\n+            // that we should actually process.\n+            bpos.updateActorStatesFromHeartbeat(\n+                this, resp.getNameNodeHaState());\n+\n             long startProcessCommands \u003d now();\n             if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                   + \"ms to process \" + resp.getCommands().length\n                   + \" commands from NN\");\n             }\n           }\n         }\n         if (pendingReceivedRequests \u003e 0\n             || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         DatanodeCommand cmd \u003d blockReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         // Now safe to start scanning the block pool\n         // TODO(HA): this doesn\u0027t seem quite right\n         if (dn.blockScanner !\u003d null) {\n           dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (System.currentTimeMillis() - lastHeartbeat);\n         synchronized(receivedAndDeletedBlockList) {\n           if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n             try {\n               receivedAndDeletedBlockList.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n        + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            assert resp !\u003d null;\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            // If the state of this NN has changed (eg STANDBY-\u003eACTIVE)\n            // then let the BPOfferService update itself.\n            //\n            // Important that this happens before processCommand below,\n            // since the first heartbeat to a new active might have commands\n            // that we should actually process.\n            bpos.updateActorStatesFromHeartbeat(\n                this, resp.getNameNodeHaState());\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        DatanodeCommand cmd \u003d blockReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool\n        // TODO(HA): this doesn\u0027t seem quite right\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (System.currentTimeMillis() - lastHeartbeat);\n        synchronized(receivedAndDeletedBlockList) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              receivedAndDeletedBlockList.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "8dbb5237684bb9de78430b5cef27be40c78a8474": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2616. Change DatanodeProtocol#sendHeartbeat() to return HeartbeatResponse. (suresh)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1208987 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/12/11 12:03 AM",
      "commitName": "8dbb5237684bb9de78430b5cef27be40c78a8474",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "30/11/11 5:10 PM",
      "commitNameOld": "1e346aa829519f8a2aa830e76d9856f914861805",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,92 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n         + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n         + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n         + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n         + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n-            DatanodeCommand[] cmds \u003d sendHeartBeat();\n+            HeartbeatResponse resp \u003d sendHeartBeat();\n             dn.getMetrics().addHeartbeat(now() - startTime);\n \n             long startProcessCommands \u003d now();\n-            if (!processCommand(cmds))\n+            if (!processCommand(resp.getCommands()))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n-              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n-                  \"ms to process \" + cmds.length + \" commands from NN\");\n+              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n+                  + \"ms to process \" + resp.getCommands().length\n+                  + \" commands from NN\");\n             }\n           }\n         }\n         if (pendingReceivedRequests \u003e 0\n             || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         DatanodeCommand cmd \u003d blockReport();\n         processCommand(new DatanodeCommand[]{ cmd });\n \n         // Now safe to start scanning the block pool\n         // TODO(HA): this doesn\u0027t seem quite right\n         if (dn.blockScanner !\u003d null) {\n           dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (System.currentTimeMillis() - lastHeartbeat);\n         synchronized(receivedAndDeletedBlockList) {\n           if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n             try {\n               receivedAndDeletedBlockList.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
      "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n        + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            HeartbeatResponse resp \u003d sendHeartBeat();\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(resp.getCommands()))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands)\n                  + \"ms to process \" + resp.getCommands().length\n                  + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        DatanodeCommand cmd \u003d blockReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool\n        // TODO(HA): this doesn\u0027t seem quite right\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (System.currentTimeMillis() - lastHeartbeat);\n        synchronized(receivedAndDeletedBlockList) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              receivedAndDeletedBlockList.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
      "extendedDetails": {}
    },
    "1e346aa829519f8a2aa830e76d9856f914861805": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "HDFS-1971. Send block report from datanode to both active and standby namenodes. (sanjay, todd via suresh)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1208925 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/11/11 5:10 PM",
      "commitName": "1e346aa829519f8a2aa830e76d9856f914861805",
      "commitAuthor": "Suresh Srinivas",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-1971. Send block report from datanode to both active and standby namenodes. (sanjay, todd via suresh)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1208925 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/11/11 5:10 PM",
          "commitName": "1e346aa829519f8a2aa830e76d9856f914861805",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "30/11/11 1:46 PM",
          "commitNameOld": "f87a4b40bc99e76602a75906df31747cfdbff78a",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,90 +1,91 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n         + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n         + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n         + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n         + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             DatanodeCommand[] cmds \u003d sendHeartBeat();\n-            dn.metrics.addHeartbeat(now() - startTime);\n+            dn.getMetrics().addHeartbeat(now() - startTime);\n \n             long startProcessCommands \u003d now();\n             if (!processCommand(cmds))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n                   \"ms to process \" + cmds.length + \" commands from NN\");\n             }\n           }\n         }\n         if (pendingReceivedRequests \u003e 0\n             || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         DatanodeCommand cmd \u003d blockReport();\n-        processCommand(cmd);\n+        processCommand(new DatanodeCommand[]{ cmd });\n \n         // Now safe to start scanning the block pool\n+        // TODO(HA): this doesn\u0027t seem quite right\n         if (dn.blockScanner !\u003d null) {\n-          dn.blockScanner.addBlockPool(this.getBlockPoolId());\n+          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (System.currentTimeMillis() - lastHeartbeat);\n         synchronized(receivedAndDeletedBlockList) {\n           if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n             try {\n               receivedAndDeletedBlockList.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
          "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n        + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            DatanodeCommand[] cmds \u003d sendHeartBeat();\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(cmds))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n                  \"ms to process \" + cmds.length + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        DatanodeCommand cmd \u003d blockReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool\n        // TODO(HA): this doesn\u0027t seem quite right\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (System.currentTimeMillis() - lastHeartbeat);\n        synchronized(receivedAndDeletedBlockList) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              receivedAndDeletedBlockList.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPOfferService.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
            "oldMethodName": "offerService",
            "newMethodName": "offerService"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-1971. Send block report from datanode to both active and standby namenodes. (sanjay, todd via suresh)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1208925 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/11/11 5:10 PM",
          "commitName": "1e346aa829519f8a2aa830e76d9856f914861805",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "30/11/11 1:46 PM",
          "commitNameOld": "f87a4b40bc99e76602a75906df31747cfdbff78a",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,90 +1,91 @@\n   private void offerService() throws Exception {\n     LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n         + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n         + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n         + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n         + dnConf.heartBeatInterval);\n \n     //\n     // Now loop for a long time....\n     //\n     while (shouldRun()) {\n       try {\n         long startTime \u003d now();\n \n         //\n         // Every so often, send heartbeat or block-report\n         //\n         if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n           //\n           // All heartbeat messages include following info:\n           // -- Datanode name\n           // -- data transfer port\n           // -- Total capacity\n           // -- Bytes remaining\n           //\n           lastHeartbeat \u003d startTime;\n           if (!dn.areHeartbeatsDisabledForTests()) {\n             DatanodeCommand[] cmds \u003d sendHeartBeat();\n-            dn.metrics.addHeartbeat(now() - startTime);\n+            dn.getMetrics().addHeartbeat(now() - startTime);\n \n             long startProcessCommands \u003d now();\n             if (!processCommand(cmds))\n               continue;\n             long endProcessCommands \u003d now();\n             if (endProcessCommands - startProcessCommands \u003e 2000) {\n               LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n                   \"ms to process \" + cmds.length + \" commands from NN\");\n             }\n           }\n         }\n         if (pendingReceivedRequests \u003e 0\n             || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n           reportReceivedDeletedBlocks();\n           lastDeletedReport \u003d startTime;\n         }\n \n         DatanodeCommand cmd \u003d blockReport();\n-        processCommand(cmd);\n+        processCommand(new DatanodeCommand[]{ cmd });\n \n         // Now safe to start scanning the block pool\n+        // TODO(HA): this doesn\u0027t seem quite right\n         if (dn.blockScanner !\u003d null) {\n-          dn.blockScanner.addBlockPool(this.getBlockPoolId());\n+          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n         }\n \n         //\n         // There is no work to do;  sleep until hearbeat timer elapses, \n         // or work arrives, and then iterate again.\n         //\n         long waitTime \u003d dnConf.heartBeatInterval - \n         (System.currentTimeMillis() - lastHeartbeat);\n         synchronized(receivedAndDeletedBlockList) {\n           if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n             try {\n               receivedAndDeletedBlockList.wait(waitTime);\n             } catch (InterruptedException ie) {\n               LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n             }\n           }\n         } // synchronized\n       } catch(RemoteException re) {\n         String reClass \u003d re.getClassName();\n         if (UnregisteredNodeException.class.getName().equals(reClass) ||\n             DisallowedDatanodeException.class.getName().equals(reClass) ||\n             IncorrectVersionException.class.getName().equals(reClass)) {\n           LOG.warn(this + \" is shutting down\", re);\n           shouldServiceRun \u003d false;\n           return;\n         }\n         LOG.warn(\"RemoteException in offerService\", re);\n         try {\n           long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n           Thread.sleep(sleepTime);\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n         }\n       } catch (IOException e) {\n         LOG.warn(\"IOException in offerService\", e);\n       }\n     } // while (shouldRun())\n   } // offerService\n\\ No newline at end of file\n",
          "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n        + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            DatanodeCommand[] cmds \u003d sendHeartBeat();\n            dn.getMetrics().addHeartbeat(now() - startTime);\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(cmds))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n                  \"ms to process \" + cmds.length + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        DatanodeCommand cmd \u003d blockReport();\n        processCommand(new DatanodeCommand[]{ cmd });\n\n        // Now safe to start scanning the block pool\n        // TODO(HA): this doesn\u0027t seem quite right\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(bpos.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (System.currentTimeMillis() - lastHeartbeat);\n        synchronized(receivedAndDeletedBlockList) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              receivedAndDeletedBlockList.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPServiceActor.java",
          "extendedDetails": {}
        }
      ]
    },
    "39ce694d05c6d8c428bd87bc1b9c95f94dfdf6fd": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "HDFS-2566. Move BPOfferService to be a non-inner class. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1204659 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/11/11 11:27 AM",
      "commitName": "39ce694d05c6d8c428bd87bc1b9c95f94dfdf6fd",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-2566. Move BPOfferService to be a non-inner class. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1204659 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/11/11 11:27 AM",
          "commitName": "39ce694d05c6d8c428bd87bc1b9c95f94dfdf6fd",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "21/11/11 11:03 AM",
          "commitNameOld": "68173af69d2fbda3292404c90a5077483e14d6f4",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,90 +1,90 @@\n-    private void offerService() throws Exception {\n-      LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n-          + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n-          + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n-          + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n-          + dnConf.heartBeatInterval);\n+  private void offerService() throws Exception {\n+    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n+        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n+        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n+        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n+        + dnConf.heartBeatInterval);\n \n-      //\n-      // Now loop for a long time....\n-      //\n-      while (shouldRun()) {\n-        try {\n-          long startTime \u003d now();\n+    //\n+    // Now loop for a long time....\n+    //\n+    while (shouldRun()) {\n+      try {\n+        long startTime \u003d now();\n \n+        //\n+        // Every so often, send heartbeat or block-report\n+        //\n+        if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n           //\n-          // Every so often, send heartbeat or block-report\n+          // All heartbeat messages include following info:\n+          // -- Datanode name\n+          // -- data transfer port\n+          // -- Total capacity\n+          // -- Bytes remaining\n           //\n-          if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n-            //\n-            // All heartbeat messages include following info:\n-            // -- Datanode name\n-            // -- data transfer port\n-            // -- Total capacity\n-            // -- Bytes remaining\n-            //\n-            lastHeartbeat \u003d startTime;\n-            if (!dn.heartbeatsDisabledForTests) {\n-              DatanodeCommand[] cmds \u003d sendHeartBeat();\n-              dn.metrics.addHeartbeat(now() - startTime);\n+          lastHeartbeat \u003d startTime;\n+          if (!dn.areHeartbeatsDisabledForTests()) {\n+            DatanodeCommand[] cmds \u003d sendHeartBeat();\n+            dn.metrics.addHeartbeat(now() - startTime);\n \n-              long startProcessCommands \u003d now();\n-              if (!processCommand(cmds))\n-                continue;\n-              long endProcessCommands \u003d now();\n-              if (endProcessCommands - startProcessCommands \u003e 2000) {\n-                LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n-                    \"ms to process \" + cmds.length + \" commands from NN\");\n-              }\n+            long startProcessCommands \u003d now();\n+            if (!processCommand(cmds))\n+              continue;\n+            long endProcessCommands \u003d now();\n+            if (endProcessCommands - startProcessCommands \u003e 2000) {\n+              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n+                  \"ms to process \" + cmds.length + \" commands from NN\");\n             }\n           }\n-          if (pendingReceivedRequests \u003e 0\n-              || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n-            reportReceivedDeletedBlocks();\n-            lastDeletedReport \u003d startTime;\n-          }\n-\n-          DatanodeCommand cmd \u003d blockReport();\n-          processCommand(cmd);\n-\n-          // Now safe to start scanning the block pool\n-          if (dn.blockScanner !\u003d null) {\n-            dn.blockScanner.addBlockPool(this.getBlockPoolId());\n-          }\n-\n-          //\n-          // There is no work to do;  sleep until hearbeat timer elapses, \n-          // or work arrives, and then iterate again.\n-          //\n-          long waitTime \u003d dnConf.heartBeatInterval - \n-          (System.currentTimeMillis() - lastHeartbeat);\n-          synchronized(receivedAndDeletedBlockList) {\n-            if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n-              try {\n-                receivedAndDeletedBlockList.wait(waitTime);\n-              } catch (InterruptedException ie) {\n-                LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n-              }\n-            }\n-          } // synchronized\n-        } catch(RemoteException re) {\n-          String reClass \u003d re.getClassName();\n-          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n-              DisallowedDatanodeException.class.getName().equals(reClass) ||\n-              IncorrectVersionException.class.getName().equals(reClass)) {\n-            LOG.warn(this + \" is shutting down\", re);\n-            shouldServiceRun \u003d false;\n-            return;\n-          }\n-          LOG.warn(\"RemoteException in offerService\", re);\n-          try {\n-            long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n-            Thread.sleep(sleepTime);\n-          } catch (InterruptedException ie) {\n-            Thread.currentThread().interrupt();\n-          }\n-        } catch (IOException e) {\n-          LOG.warn(\"IOException in offerService\", e);\n         }\n-      } // while (shouldRun())\n-    } // offerService\n\\ No newline at end of file\n+        if (pendingReceivedRequests \u003e 0\n+            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n+          reportReceivedDeletedBlocks();\n+          lastDeletedReport \u003d startTime;\n+        }\n+\n+        DatanodeCommand cmd \u003d blockReport();\n+        processCommand(cmd);\n+\n+        // Now safe to start scanning the block pool\n+        if (dn.blockScanner !\u003d null) {\n+          dn.blockScanner.addBlockPool(this.getBlockPoolId());\n+        }\n+\n+        //\n+        // There is no work to do;  sleep until hearbeat timer elapses, \n+        // or work arrives, and then iterate again.\n+        //\n+        long waitTime \u003d dnConf.heartBeatInterval - \n+        (System.currentTimeMillis() - lastHeartbeat);\n+        synchronized(receivedAndDeletedBlockList) {\n+          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n+            try {\n+              receivedAndDeletedBlockList.wait(waitTime);\n+            } catch (InterruptedException ie) {\n+              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n+            }\n+          }\n+        } // synchronized\n+      } catch(RemoteException re) {\n+        String reClass \u003d re.getClassName();\n+        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n+            DisallowedDatanodeException.class.getName().equals(reClass) ||\n+            IncorrectVersionException.class.getName().equals(reClass)) {\n+          LOG.warn(this + \" is shutting down\", re);\n+          shouldServiceRun \u003d false;\n+          return;\n+        }\n+        LOG.warn(\"RemoteException in offerService\", re);\n+        try {\n+          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n+          Thread.sleep(sleepTime);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+        }\n+      } catch (IOException e) {\n+        LOG.warn(\"IOException in offerService\", e);\n+      }\n+    } // while (shouldRun())\n+  } // offerService\n\\ No newline at end of file\n",
          "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n        + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            DatanodeCommand[] cmds \u003d sendHeartBeat();\n            dn.metrics.addHeartbeat(now() - startTime);\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(cmds))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n                  \"ms to process \" + cmds.length + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        DatanodeCommand cmd \u003d blockReport();\n        processCommand(cmd);\n\n        // Now safe to start scanning the block pool\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(this.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (System.currentTimeMillis() - lastHeartbeat);\n        synchronized(receivedAndDeletedBlockList) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              receivedAndDeletedBlockList.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPOfferService.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPOfferService.java",
            "oldMethodName": "offerService",
            "newMethodName": "offerService"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2566. Move BPOfferService to be a non-inner class. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1204659 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/11/11 11:27 AM",
          "commitName": "39ce694d05c6d8c428bd87bc1b9c95f94dfdf6fd",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "21/11/11 11:03 AM",
          "commitNameOld": "68173af69d2fbda3292404c90a5077483e14d6f4",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,90 +1,90 @@\n-    private void offerService() throws Exception {\n-      LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n-          + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n-          + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n-          + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n-          + dnConf.heartBeatInterval);\n+  private void offerService() throws Exception {\n+    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n+        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n+        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n+        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n+        + dnConf.heartBeatInterval);\n \n-      //\n-      // Now loop for a long time....\n-      //\n-      while (shouldRun()) {\n-        try {\n-          long startTime \u003d now();\n+    //\n+    // Now loop for a long time....\n+    //\n+    while (shouldRun()) {\n+      try {\n+        long startTime \u003d now();\n \n+        //\n+        // Every so often, send heartbeat or block-report\n+        //\n+        if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n           //\n-          // Every so often, send heartbeat or block-report\n+          // All heartbeat messages include following info:\n+          // -- Datanode name\n+          // -- data transfer port\n+          // -- Total capacity\n+          // -- Bytes remaining\n           //\n-          if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n-            //\n-            // All heartbeat messages include following info:\n-            // -- Datanode name\n-            // -- data transfer port\n-            // -- Total capacity\n-            // -- Bytes remaining\n-            //\n-            lastHeartbeat \u003d startTime;\n-            if (!dn.heartbeatsDisabledForTests) {\n-              DatanodeCommand[] cmds \u003d sendHeartBeat();\n-              dn.metrics.addHeartbeat(now() - startTime);\n+          lastHeartbeat \u003d startTime;\n+          if (!dn.areHeartbeatsDisabledForTests()) {\n+            DatanodeCommand[] cmds \u003d sendHeartBeat();\n+            dn.metrics.addHeartbeat(now() - startTime);\n \n-              long startProcessCommands \u003d now();\n-              if (!processCommand(cmds))\n-                continue;\n-              long endProcessCommands \u003d now();\n-              if (endProcessCommands - startProcessCommands \u003e 2000) {\n-                LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n-                    \"ms to process \" + cmds.length + \" commands from NN\");\n-              }\n+            long startProcessCommands \u003d now();\n+            if (!processCommand(cmds))\n+              continue;\n+            long endProcessCommands \u003d now();\n+            if (endProcessCommands - startProcessCommands \u003e 2000) {\n+              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n+                  \"ms to process \" + cmds.length + \" commands from NN\");\n             }\n           }\n-          if (pendingReceivedRequests \u003e 0\n-              || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n-            reportReceivedDeletedBlocks();\n-            lastDeletedReport \u003d startTime;\n-          }\n-\n-          DatanodeCommand cmd \u003d blockReport();\n-          processCommand(cmd);\n-\n-          // Now safe to start scanning the block pool\n-          if (dn.blockScanner !\u003d null) {\n-            dn.blockScanner.addBlockPool(this.getBlockPoolId());\n-          }\n-\n-          //\n-          // There is no work to do;  sleep until hearbeat timer elapses, \n-          // or work arrives, and then iterate again.\n-          //\n-          long waitTime \u003d dnConf.heartBeatInterval - \n-          (System.currentTimeMillis() - lastHeartbeat);\n-          synchronized(receivedAndDeletedBlockList) {\n-            if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n-              try {\n-                receivedAndDeletedBlockList.wait(waitTime);\n-              } catch (InterruptedException ie) {\n-                LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n-              }\n-            }\n-          } // synchronized\n-        } catch(RemoteException re) {\n-          String reClass \u003d re.getClassName();\n-          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n-              DisallowedDatanodeException.class.getName().equals(reClass) ||\n-              IncorrectVersionException.class.getName().equals(reClass)) {\n-            LOG.warn(this + \" is shutting down\", re);\n-            shouldServiceRun \u003d false;\n-            return;\n-          }\n-          LOG.warn(\"RemoteException in offerService\", re);\n-          try {\n-            long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n-            Thread.sleep(sleepTime);\n-          } catch (InterruptedException ie) {\n-            Thread.currentThread().interrupt();\n-          }\n-        } catch (IOException e) {\n-          LOG.warn(\"IOException in offerService\", e);\n         }\n-      } // while (shouldRun())\n-    } // offerService\n\\ No newline at end of file\n+        if (pendingReceivedRequests \u003e 0\n+            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n+          reportReceivedDeletedBlocks();\n+          lastDeletedReport \u003d startTime;\n+        }\n+\n+        DatanodeCommand cmd \u003d blockReport();\n+        processCommand(cmd);\n+\n+        // Now safe to start scanning the block pool\n+        if (dn.blockScanner !\u003d null) {\n+          dn.blockScanner.addBlockPool(this.getBlockPoolId());\n+        }\n+\n+        //\n+        // There is no work to do;  sleep until hearbeat timer elapses, \n+        // or work arrives, and then iterate again.\n+        //\n+        long waitTime \u003d dnConf.heartBeatInterval - \n+        (System.currentTimeMillis() - lastHeartbeat);\n+        synchronized(receivedAndDeletedBlockList) {\n+          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n+            try {\n+              receivedAndDeletedBlockList.wait(waitTime);\n+            } catch (InterruptedException ie) {\n+              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n+            }\n+          }\n+        } // synchronized\n+      } catch(RemoteException re) {\n+        String reClass \u003d re.getClassName();\n+        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n+            DisallowedDatanodeException.class.getName().equals(reClass) ||\n+            IncorrectVersionException.class.getName().equals(reClass)) {\n+          LOG.warn(this + \" is shutting down\", re);\n+          shouldServiceRun \u003d false;\n+          return;\n+        }\n+        LOG.warn(\"RemoteException in offerService\", re);\n+        try {\n+          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n+          Thread.sleep(sleepTime);\n+        } catch (InterruptedException ie) {\n+          Thread.currentThread().interrupt();\n+        }\n+      } catch (IOException e) {\n+        LOG.warn(\"IOException in offerService\", e);\n+      }\n+    } // while (shouldRun())\n+  } // offerService\n\\ No newline at end of file\n",
          "actualSource": "  private void offerService() throws Exception {\n    LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n        + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n        + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n        + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n        + dnConf.heartBeatInterval);\n\n    //\n    // Now loop for a long time....\n    //\n    while (shouldRun()) {\n      try {\n        long startTime \u003d now();\n\n        //\n        // Every so often, send heartbeat or block-report\n        //\n        if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n          //\n          // All heartbeat messages include following info:\n          // -- Datanode name\n          // -- data transfer port\n          // -- Total capacity\n          // -- Bytes remaining\n          //\n          lastHeartbeat \u003d startTime;\n          if (!dn.areHeartbeatsDisabledForTests()) {\n            DatanodeCommand[] cmds \u003d sendHeartBeat();\n            dn.metrics.addHeartbeat(now() - startTime);\n\n            long startProcessCommands \u003d now();\n            if (!processCommand(cmds))\n              continue;\n            long endProcessCommands \u003d now();\n            if (endProcessCommands - startProcessCommands \u003e 2000) {\n              LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n                  \"ms to process \" + cmds.length + \" commands from NN\");\n            }\n          }\n        }\n        if (pendingReceivedRequests \u003e 0\n            || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n          reportReceivedDeletedBlocks();\n          lastDeletedReport \u003d startTime;\n        }\n\n        DatanodeCommand cmd \u003d blockReport();\n        processCommand(cmd);\n\n        // Now safe to start scanning the block pool\n        if (dn.blockScanner !\u003d null) {\n          dn.blockScanner.addBlockPool(this.getBlockPoolId());\n        }\n\n        //\n        // There is no work to do;  sleep until hearbeat timer elapses, \n        // or work arrives, and then iterate again.\n        //\n        long waitTime \u003d dnConf.heartBeatInterval - \n        (System.currentTimeMillis() - lastHeartbeat);\n        synchronized(receivedAndDeletedBlockList) {\n          if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n            try {\n              receivedAndDeletedBlockList.wait(waitTime);\n            } catch (InterruptedException ie) {\n              LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n            }\n          }\n        } // synchronized\n      } catch(RemoteException re) {\n        String reClass \u003d re.getClassName();\n        if (UnregisteredNodeException.class.getName().equals(reClass) ||\n            DisallowedDatanodeException.class.getName().equals(reClass) ||\n            IncorrectVersionException.class.getName().equals(reClass)) {\n          LOG.warn(this + \" is shutting down\", re);\n          shouldServiceRun \u003d false;\n          return;\n        }\n        LOG.warn(\"RemoteException in offerService\", re);\n        try {\n          long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      } catch (IOException e) {\n        LOG.warn(\"IOException in offerService\", e);\n      }\n    } // while (shouldRun())\n  } // offerService",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BPOfferService.java",
          "extendedDetails": {}
        }
      ]
    },
    "1f92266516c882e43fa453b876dd8ca09893c477": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2563. Some cleanup in BPOfferService. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1203943 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/11 5:31 PM",
      "commitName": "1f92266516c882e43fa453b876dd8ca09893c477",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "18/11/11 1:04 AM",
      "commitNameOld": "905a127850d5e0cba85c2e075f989fa0f5cf129a",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,90 @@\n     private void offerService() throws Exception {\n       LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n           + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n           + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n           + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n           + dnConf.heartBeatInterval);\n \n       //\n       // Now loop for a long time....\n       //\n-      while (dn.shouldRun \u0026\u0026 shouldServiceRun) {\n+      while (shouldRun()) {\n         try {\n           long startTime \u003d now();\n \n           //\n           // Every so often, send heartbeat or block-report\n           //\n           if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n             //\n             // All heartbeat messages include following info:\n             // -- Datanode name\n             // -- data transfer port\n             // -- Total capacity\n             // -- Bytes remaining\n             //\n             lastHeartbeat \u003d startTime;\n             if (!dn.heartbeatsDisabledForTests) {\n               DatanodeCommand[] cmds \u003d sendHeartBeat();\n               dn.metrics.addHeartbeat(now() - startTime);\n \n               long startProcessCommands \u003d now();\n               if (!processCommand(cmds))\n                 continue;\n               long endProcessCommands \u003d now();\n               if (endProcessCommands - startProcessCommands \u003e 2000) {\n                 LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n                     \"ms to process \" + cmds.length + \" commands from NN\");\n               }\n             }\n           }\n           if (pendingReceivedRequests \u003e 0\n               || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n             reportReceivedDeletedBlocks();\n             lastDeletedReport \u003d startTime;\n           }\n \n           DatanodeCommand cmd \u003d blockReport();\n           processCommand(cmd);\n \n           // Now safe to start scanning the block pool\n           if (dn.blockScanner !\u003d null) {\n-            dn.blockScanner.addBlockPool(this.blockPoolId);\n+            dn.blockScanner.addBlockPool(this.getBlockPoolId());\n           }\n \n           //\n           // There is no work to do;  sleep until hearbeat timer elapses, \n           // or work arrives, and then iterate again.\n           //\n           long waitTime \u003d dnConf.heartBeatInterval - \n           (System.currentTimeMillis() - lastHeartbeat);\n           synchronized(receivedAndDeletedBlockList) {\n             if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n               try {\n                 receivedAndDeletedBlockList.wait(waitTime);\n               } catch (InterruptedException ie) {\n-                LOG.warn(\"BPOfferService for block pool\u003d\"\n-                    + this.getBlockPoolId() + \" received exception:\" + ie);\n+                LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n               }\n             }\n           } // synchronized\n         } catch(RemoteException re) {\n           String reClass \u003d re.getClassName();\n           if (UnregisteredNodeException.class.getName().equals(reClass) ||\n               DisallowedDatanodeException.class.getName().equals(reClass) ||\n               IncorrectVersionException.class.getName().equals(reClass)) {\n-            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n+            LOG.warn(this + \" is shutting down\", re);\n             shouldServiceRun \u003d false;\n             return;\n           }\n           LOG.warn(\"RemoteException in offerService\", re);\n           try {\n             long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n             Thread.sleep(sleepTime);\n           } catch (InterruptedException ie) {\n             Thread.currentThread().interrupt();\n           }\n         } catch (IOException e) {\n           LOG.warn(\"IOException in offerService\", e);\n         }\n-      } // while (shouldRun \u0026\u0026 shouldServiceRun)\n+      } // while (shouldRun())\n     } // offerService\n\\ No newline at end of file\n",
      "actualSource": "    private void offerService() throws Exception {\n      LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n          + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n          + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n          + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n          + dnConf.heartBeatInterval);\n\n      //\n      // Now loop for a long time....\n      //\n      while (shouldRun()) {\n        try {\n          long startTime \u003d now();\n\n          //\n          // Every so often, send heartbeat or block-report\n          //\n          if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n            //\n            // All heartbeat messages include following info:\n            // -- Datanode name\n            // -- data transfer port\n            // -- Total capacity\n            // -- Bytes remaining\n            //\n            lastHeartbeat \u003d startTime;\n            if (!dn.heartbeatsDisabledForTests) {\n              DatanodeCommand[] cmds \u003d sendHeartBeat();\n              dn.metrics.addHeartbeat(now() - startTime);\n\n              long startProcessCommands \u003d now();\n              if (!processCommand(cmds))\n                continue;\n              long endProcessCommands \u003d now();\n              if (endProcessCommands - startProcessCommands \u003e 2000) {\n                LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n                    \"ms to process \" + cmds.length + \" commands from NN\");\n              }\n            }\n          }\n          if (pendingReceivedRequests \u003e 0\n              || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n            reportReceivedDeletedBlocks();\n            lastDeletedReport \u003d startTime;\n          }\n\n          DatanodeCommand cmd \u003d blockReport();\n          processCommand(cmd);\n\n          // Now safe to start scanning the block pool\n          if (dn.blockScanner !\u003d null) {\n            dn.blockScanner.addBlockPool(this.getBlockPoolId());\n          }\n\n          //\n          // There is no work to do;  sleep until hearbeat timer elapses, \n          // or work arrives, and then iterate again.\n          //\n          long waitTime \u003d dnConf.heartBeatInterval - \n          (System.currentTimeMillis() - lastHeartbeat);\n          synchronized(receivedAndDeletedBlockList) {\n            if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n              try {\n                receivedAndDeletedBlockList.wait(waitTime);\n              } catch (InterruptedException ie) {\n                LOG.warn(\"BPOfferService for \" + this + \" interrupted\");\n              }\n            }\n          } // synchronized\n        } catch(RemoteException re) {\n          String reClass \u003d re.getClassName();\n          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n              DisallowedDatanodeException.class.getName().equals(reClass) ||\n              IncorrectVersionException.class.getName().equals(reClass)) {\n            LOG.warn(this + \" is shutting down\", re);\n            shouldServiceRun \u003d false;\n            return;\n          }\n          LOG.warn(\"RemoteException in offerService\", re);\n          try {\n            long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n            Thread.sleep(sleepTime);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        } catch (IOException e) {\n          LOG.warn(\"IOException in offerService\", e);\n        }\n      } // while (shouldRun())\n    } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "905a127850d5e0cba85c2e075f989fa0f5cf129a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2562. Refactor DN configuration variables out of DataNode class. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1203543 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/11 1:04 AM",
      "commitName": "905a127850d5e0cba85c2e075f989fa0f5cf129a",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "17/11/11 4:45 PM",
      "commitNameOld": "0864ef19089f703232107d8aa26c4a7571ff132e",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.35,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,91 @@\n     private void offerService() throws Exception {\n       LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n-          + dn.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n-          + dn.blockReportInterval + \"msec\" + \" Initial delay: \"\n-          + dn.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n-          + dn.heartBeatInterval);\n+          + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n+          + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n+          + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n+          + dnConf.heartBeatInterval);\n \n       //\n       // Now loop for a long time....\n       //\n       while (dn.shouldRun \u0026\u0026 shouldServiceRun) {\n         try {\n           long startTime \u003d now();\n \n           //\n           // Every so often, send heartbeat or block-report\n           //\n-          if (startTime - lastHeartbeat \u003e dn.heartBeatInterval) {\n+          if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n             //\n             // All heartbeat messages include following info:\n             // -- Datanode name\n             // -- data transfer port\n             // -- Total capacity\n             // -- Bytes remaining\n             //\n             lastHeartbeat \u003d startTime;\n             if (!dn.heartbeatsDisabledForTests) {\n               DatanodeCommand[] cmds \u003d sendHeartBeat();\n               dn.metrics.addHeartbeat(now() - startTime);\n \n               long startProcessCommands \u003d now();\n               if (!processCommand(cmds))\n                 continue;\n               long endProcessCommands \u003d now();\n               if (endProcessCommands - startProcessCommands \u003e 2000) {\n                 LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n                     \"ms to process \" + cmds.length + \" commands from NN\");\n               }\n             }\n           }\n           if (pendingReceivedRequests \u003e 0\n-              || (startTime - lastDeletedReport \u003e dn.deleteReportInterval)) {\n+              || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n             reportReceivedDeletedBlocks();\n             lastDeletedReport \u003d startTime;\n           }\n \n           DatanodeCommand cmd \u003d blockReport();\n           processCommand(cmd);\n \n           // Now safe to start scanning the block pool\n           if (dn.blockScanner !\u003d null) {\n             dn.blockScanner.addBlockPool(this.blockPoolId);\n           }\n \n           //\n           // There is no work to do;  sleep until hearbeat timer elapses, \n           // or work arrives, and then iterate again.\n           //\n-          long waitTime \u003d dn.heartBeatInterval - \n+          long waitTime \u003d dnConf.heartBeatInterval - \n           (System.currentTimeMillis() - lastHeartbeat);\n           synchronized(receivedAndDeletedBlockList) {\n             if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n               try {\n                 receivedAndDeletedBlockList.wait(waitTime);\n               } catch (InterruptedException ie) {\n                 LOG.warn(\"BPOfferService for block pool\u003d\"\n                     + this.getBlockPoolId() + \" received exception:\" + ie);\n               }\n             }\n           } // synchronized\n         } catch(RemoteException re) {\n           String reClass \u003d re.getClassName();\n           if (UnregisteredNodeException.class.getName().equals(reClass) ||\n               DisallowedDatanodeException.class.getName().equals(reClass) ||\n               IncorrectVersionException.class.getName().equals(reClass)) {\n             LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n             shouldServiceRun \u003d false;\n             return;\n           }\n           LOG.warn(\"RemoteException in offerService\", re);\n           try {\n-            long sleepTime \u003d Math.min(1000, dn.heartBeatInterval);\n+            long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n             Thread.sleep(sleepTime);\n           } catch (InterruptedException ie) {\n             Thread.currentThread().interrupt();\n           }\n         } catch (IOException e) {\n           LOG.warn(\"IOException in offerService\", e);\n         }\n       } // while (shouldRun \u0026\u0026 shouldServiceRun)\n     } // offerService\n\\ No newline at end of file\n",
      "actualSource": "    private void offerService() throws Exception {\n      LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n          + dnConf.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n          + dnConf.blockReportInterval + \"msec\" + \" Initial delay: \"\n          + dnConf.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n          + dnConf.heartBeatInterval);\n\n      //\n      // Now loop for a long time....\n      //\n      while (dn.shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          long startTime \u003d now();\n\n          //\n          // Every so often, send heartbeat or block-report\n          //\n          if (startTime - lastHeartbeat \u003e dnConf.heartBeatInterval) {\n            //\n            // All heartbeat messages include following info:\n            // -- Datanode name\n            // -- data transfer port\n            // -- Total capacity\n            // -- Bytes remaining\n            //\n            lastHeartbeat \u003d startTime;\n            if (!dn.heartbeatsDisabledForTests) {\n              DatanodeCommand[] cmds \u003d sendHeartBeat();\n              dn.metrics.addHeartbeat(now() - startTime);\n\n              long startProcessCommands \u003d now();\n              if (!processCommand(cmds))\n                continue;\n              long endProcessCommands \u003d now();\n              if (endProcessCommands - startProcessCommands \u003e 2000) {\n                LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n                    \"ms to process \" + cmds.length + \" commands from NN\");\n              }\n            }\n          }\n          if (pendingReceivedRequests \u003e 0\n              || (startTime - lastDeletedReport \u003e dnConf.deleteReportInterval)) {\n            reportReceivedDeletedBlocks();\n            lastDeletedReport \u003d startTime;\n          }\n\n          DatanodeCommand cmd \u003d blockReport();\n          processCommand(cmd);\n\n          // Now safe to start scanning the block pool\n          if (dn.blockScanner !\u003d null) {\n            dn.blockScanner.addBlockPool(this.blockPoolId);\n          }\n\n          //\n          // There is no work to do;  sleep until hearbeat timer elapses, \n          // or work arrives, and then iterate again.\n          //\n          long waitTime \u003d dnConf.heartBeatInterval - \n          (System.currentTimeMillis() - lastHeartbeat);\n          synchronized(receivedAndDeletedBlockList) {\n            if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n              try {\n                receivedAndDeletedBlockList.wait(waitTime);\n              } catch (InterruptedException ie) {\n                LOG.warn(\"BPOfferService for block pool\u003d\"\n                    + this.getBlockPoolId() + \" received exception:\" + ie);\n              }\n            }\n          } // synchronized\n        } catch(RemoteException re) {\n          String reClass \u003d re.getClassName();\n          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n              DisallowedDatanodeException.class.getName().equals(reClass) ||\n              IncorrectVersionException.class.getName().equals(reClass)) {\n            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n            shouldServiceRun \u003d false;\n            return;\n          }\n          LOG.warn(\"RemoteException in offerService\", re);\n          try {\n            long sleepTime \u003d Math.min(1000, dnConf.heartBeatInterval);\n            Thread.sleep(sleepTime);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        } catch (IOException e) {\n          LOG.warn(\"IOException in offerService\", e);\n        }\n      } // while (shouldRun \u0026\u0026 shouldServiceRun)\n    } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "0864ef19089f703232107d8aa26c4a7571ff132e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2560. Refactor BPOfferService to be a static inner class. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1203444 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/11/11 4:45 PM",
      "commitName": "0864ef19089f703232107d8aa26c4a7571ff132e",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "31/10/11 10:17 PM",
      "commitNameOld": "1c940637b14eee777a65d153d0d712a1aea3866c",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 16.81,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,91 @@\n     private void offerService() throws Exception {\n       LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n-          + deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n-          + blockReportInterval + \"msec\" + \" Initial delay: \"\n-          + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n-          + heartBeatInterval);\n+          + dn.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n+          + dn.blockReportInterval + \"msec\" + \" Initial delay: \"\n+          + dn.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n+          + dn.heartBeatInterval);\n \n       //\n       // Now loop for a long time....\n       //\n-      while (shouldRun \u0026\u0026 shouldServiceRun) {\n+      while (dn.shouldRun \u0026\u0026 shouldServiceRun) {\n         try {\n           long startTime \u003d now();\n \n           //\n           // Every so often, send heartbeat or block-report\n           //\n-          if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n+          if (startTime - lastHeartbeat \u003e dn.heartBeatInterval) {\n             //\n             // All heartbeat messages include following info:\n             // -- Datanode name\n             // -- data transfer port\n             // -- Total capacity\n             // -- Bytes remaining\n             //\n             lastHeartbeat \u003d startTime;\n-            if (!heartbeatsDisabledForTests) {\n+            if (!dn.heartbeatsDisabledForTests) {\n               DatanodeCommand[] cmds \u003d sendHeartBeat();\n-              metrics.addHeartbeat(now() - startTime);\n+              dn.metrics.addHeartbeat(now() - startTime);\n \n               long startProcessCommands \u003d now();\n               if (!processCommand(cmds))\n                 continue;\n               long endProcessCommands \u003d now();\n               if (endProcessCommands - startProcessCommands \u003e 2000) {\n                 LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n                     \"ms to process \" + cmds.length + \" commands from NN\");\n               }\n             }\n           }\n           if (pendingReceivedRequests \u003e 0\n-              || (startTime - lastDeletedReport \u003e deleteReportInterval)) {\n+              || (startTime - lastDeletedReport \u003e dn.deleteReportInterval)) {\n             reportReceivedDeletedBlocks();\n             lastDeletedReport \u003d startTime;\n           }\n \n           DatanodeCommand cmd \u003d blockReport();\n           processCommand(cmd);\n \n           // Now safe to start scanning the block pool\n-          if (blockScanner !\u003d null) {\n-            blockScanner.addBlockPool(this.blockPoolId);\n+          if (dn.blockScanner !\u003d null) {\n+            dn.blockScanner.addBlockPool(this.blockPoolId);\n           }\n \n           //\n           // There is no work to do;  sleep until hearbeat timer elapses, \n           // or work arrives, and then iterate again.\n           //\n-          long waitTime \u003d heartBeatInterval - \n+          long waitTime \u003d dn.heartBeatInterval - \n           (System.currentTimeMillis() - lastHeartbeat);\n           synchronized(receivedAndDeletedBlockList) {\n             if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n               try {\n                 receivedAndDeletedBlockList.wait(waitTime);\n               } catch (InterruptedException ie) {\n                 LOG.warn(\"BPOfferService for block pool\u003d\"\n                     + this.getBlockPoolId() + \" received exception:\" + ie);\n               }\n             }\n           } // synchronized\n         } catch(RemoteException re) {\n           String reClass \u003d re.getClassName();\n           if (UnregisteredNodeException.class.getName().equals(reClass) ||\n               DisallowedDatanodeException.class.getName().equals(reClass) ||\n               IncorrectVersionException.class.getName().equals(reClass)) {\n             LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n             shouldServiceRun \u003d false;\n             return;\n           }\n           LOG.warn(\"RemoteException in offerService\", re);\n           try {\n-            long sleepTime \u003d Math.min(1000, heartBeatInterval);\n+            long sleepTime \u003d Math.min(1000, dn.heartBeatInterval);\n             Thread.sleep(sleepTime);\n           } catch (InterruptedException ie) {\n             Thread.currentThread().interrupt();\n           }\n         } catch (IOException e) {\n           LOG.warn(\"IOException in offerService\", e);\n         }\n       } // while (shouldRun \u0026\u0026 shouldServiceRun)\n     } // offerService\n\\ No newline at end of file\n",
      "actualSource": "    private void offerService() throws Exception {\n      LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n          + dn.deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n          + dn.blockReportInterval + \"msec\" + \" Initial delay: \"\n          + dn.initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n          + dn.heartBeatInterval);\n\n      //\n      // Now loop for a long time....\n      //\n      while (dn.shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          long startTime \u003d now();\n\n          //\n          // Every so often, send heartbeat or block-report\n          //\n          if (startTime - lastHeartbeat \u003e dn.heartBeatInterval) {\n            //\n            // All heartbeat messages include following info:\n            // -- Datanode name\n            // -- data transfer port\n            // -- Total capacity\n            // -- Bytes remaining\n            //\n            lastHeartbeat \u003d startTime;\n            if (!dn.heartbeatsDisabledForTests) {\n              DatanodeCommand[] cmds \u003d sendHeartBeat();\n              dn.metrics.addHeartbeat(now() - startTime);\n\n              long startProcessCommands \u003d now();\n              if (!processCommand(cmds))\n                continue;\n              long endProcessCommands \u003d now();\n              if (endProcessCommands - startProcessCommands \u003e 2000) {\n                LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n                    \"ms to process \" + cmds.length + \" commands from NN\");\n              }\n            }\n          }\n          if (pendingReceivedRequests \u003e 0\n              || (startTime - lastDeletedReport \u003e dn.deleteReportInterval)) {\n            reportReceivedDeletedBlocks();\n            lastDeletedReport \u003d startTime;\n          }\n\n          DatanodeCommand cmd \u003d blockReport();\n          processCommand(cmd);\n\n          // Now safe to start scanning the block pool\n          if (dn.blockScanner !\u003d null) {\n            dn.blockScanner.addBlockPool(this.blockPoolId);\n          }\n\n          //\n          // There is no work to do;  sleep until hearbeat timer elapses, \n          // or work arrives, and then iterate again.\n          //\n          long waitTime \u003d dn.heartBeatInterval - \n          (System.currentTimeMillis() - lastHeartbeat);\n          synchronized(receivedAndDeletedBlockList) {\n            if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n              try {\n                receivedAndDeletedBlockList.wait(waitTime);\n              } catch (InterruptedException ie) {\n                LOG.warn(\"BPOfferService for block pool\u003d\"\n                    + this.getBlockPoolId() + \" received exception:\" + ie);\n              }\n            }\n          } // synchronized\n        } catch(RemoteException re) {\n          String reClass \u003d re.getClassName();\n          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n              DisallowedDatanodeException.class.getName().equals(reClass) ||\n              IncorrectVersionException.class.getName().equals(reClass)) {\n            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n            shouldServiceRun \u003d false;\n            return;\n          }\n          LOG.warn(\"RemoteException in offerService\", re);\n          try {\n            long sleepTime \u003d Math.min(1000, dn.heartBeatInterval);\n            Thread.sleep(sleepTime);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        } catch (IOException e) {\n          LOG.warn(\"IOException in offerService\", e);\n        }\n      } // while (shouldRun \u0026\u0026 shouldServiceRun)\n    } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "221aadbc5b35b043fbc62c417b0edc029db9d004": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2500. Avoid file system operations in BPOfferService thread while processing deletes. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190071 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 3:47 PM",
      "commitName": "221aadbc5b35b043fbc62c417b0edc029db9d004",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "25/10/11 10:16 PM",
      "commitNameOld": "8335995630e2c4288795fa0dfa9b670090a6790b",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 1.73,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,91 @@\n     private void offerService() throws Exception {\n       LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n           + deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n           + blockReportInterval + \"msec\" + \" Initial delay: \"\n           + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n           + heartBeatInterval);\n \n       //\n       // Now loop for a long time....\n       //\n       while (shouldRun \u0026\u0026 shouldServiceRun) {\n         try {\n           long startTime \u003d now();\n \n           //\n           // Every so often, send heartbeat or block-report\n           //\n           if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n             //\n             // All heartbeat messages include following info:\n             // -- Datanode name\n             // -- data transfer port\n             // -- Total capacity\n             // -- Bytes remaining\n             //\n             lastHeartbeat \u003d startTime;\n             if (!heartbeatsDisabledForTests) {\n               DatanodeCommand[] cmds \u003d sendHeartBeat();\n               metrics.addHeartbeat(now() - startTime);\n+\n+              long startProcessCommands \u003d now();\n               if (!processCommand(cmds))\n                 continue;\n+              long endProcessCommands \u003d now();\n+              if (endProcessCommands - startProcessCommands \u003e 2000) {\n+                LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n+                    \"ms to process \" + cmds.length + \" commands from NN\");\n+              }\n             }\n           }\n           if (pendingReceivedRequests \u003e 0\n               || (startTime - lastDeletedReport \u003e deleteReportInterval)) {\n             reportReceivedDeletedBlocks();\n             lastDeletedReport \u003d startTime;\n           }\n \n           DatanodeCommand cmd \u003d blockReport();\n           processCommand(cmd);\n \n           // Now safe to start scanning the block pool\n           if (blockScanner !\u003d null) {\n             blockScanner.addBlockPool(this.blockPoolId);\n           }\n \n           //\n           // There is no work to do;  sleep until hearbeat timer elapses, \n           // or work arrives, and then iterate again.\n           //\n           long waitTime \u003d heartBeatInterval - \n           (System.currentTimeMillis() - lastHeartbeat);\n           synchronized(receivedAndDeletedBlockList) {\n             if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n               try {\n                 receivedAndDeletedBlockList.wait(waitTime);\n               } catch (InterruptedException ie) {\n                 LOG.warn(\"BPOfferService for block pool\u003d\"\n                     + this.getBlockPoolId() + \" received exception:\" + ie);\n               }\n             }\n           } // synchronized\n         } catch(RemoteException re) {\n           String reClass \u003d re.getClassName();\n           if (UnregisteredNodeException.class.getName().equals(reClass) ||\n               DisallowedDatanodeException.class.getName().equals(reClass) ||\n               IncorrectVersionException.class.getName().equals(reClass)) {\n             LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n             shouldServiceRun \u003d false;\n             return;\n           }\n           LOG.warn(\"RemoteException in offerService\", re);\n           try {\n             long sleepTime \u003d Math.min(1000, heartBeatInterval);\n             Thread.sleep(sleepTime);\n           } catch (InterruptedException ie) {\n             Thread.currentThread().interrupt();\n           }\n         } catch (IOException e) {\n           LOG.warn(\"IOException in offerService\", e);\n         }\n       } // while (shouldRun \u0026\u0026 shouldServiceRun)\n     } // offerService\n\\ No newline at end of file\n",
      "actualSource": "    private void offerService() throws Exception {\n      LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n          + deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n          + blockReportInterval + \"msec\" + \" Initial delay: \"\n          + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n          + heartBeatInterval);\n\n      //\n      // Now loop for a long time....\n      //\n      while (shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          long startTime \u003d now();\n\n          //\n          // Every so often, send heartbeat or block-report\n          //\n          if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n            //\n            // All heartbeat messages include following info:\n            // -- Datanode name\n            // -- data transfer port\n            // -- Total capacity\n            // -- Bytes remaining\n            //\n            lastHeartbeat \u003d startTime;\n            if (!heartbeatsDisabledForTests) {\n              DatanodeCommand[] cmds \u003d sendHeartBeat();\n              metrics.addHeartbeat(now() - startTime);\n\n              long startProcessCommands \u003d now();\n              if (!processCommand(cmds))\n                continue;\n              long endProcessCommands \u003d now();\n              if (endProcessCommands - startProcessCommands \u003e 2000) {\n                LOG.info(\"Took \" + (endProcessCommands - startProcessCommands) +\n                    \"ms to process \" + cmds.length + \" commands from NN\");\n              }\n            }\n          }\n          if (pendingReceivedRequests \u003e 0\n              || (startTime - lastDeletedReport \u003e deleteReportInterval)) {\n            reportReceivedDeletedBlocks();\n            lastDeletedReport \u003d startTime;\n          }\n\n          DatanodeCommand cmd \u003d blockReport();\n          processCommand(cmd);\n\n          // Now safe to start scanning the block pool\n          if (blockScanner !\u003d null) {\n            blockScanner.addBlockPool(this.blockPoolId);\n          }\n\n          //\n          // There is no work to do;  sleep until hearbeat timer elapses, \n          // or work arrives, and then iterate again.\n          //\n          long waitTime \u003d heartBeatInterval - \n          (System.currentTimeMillis() - lastHeartbeat);\n          synchronized(receivedAndDeletedBlockList) {\n            if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n              try {\n                receivedAndDeletedBlockList.wait(waitTime);\n              } catch (InterruptedException ie) {\n                LOG.warn(\"BPOfferService for block pool\u003d\"\n                    + this.getBlockPoolId() + \" received exception:\" + ie);\n              }\n            }\n          } // synchronized\n        } catch(RemoteException re) {\n          String reClass \u003d re.getClassName();\n          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n              DisallowedDatanodeException.class.getName().equals(reClass) ||\n              IncorrectVersionException.class.getName().equals(reClass)) {\n            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n            shouldServiceRun \u003d false;\n            return;\n          }\n          LOG.warn(\"RemoteException in offerService\", re);\n          try {\n            long sleepTime \u003d Math.min(1000, heartBeatInterval);\n            Thread.sleep(sleepTime);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        } catch (IOException e) {\n          LOG.warn(\"IOException in offerService\", e);\n        }\n      } // while (shouldRun \u0026\u0026 shouldServiceRun)\n    } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "73451ed2d9fb5eb228d80ad5f3be302a60496527": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-395.  DFS Scalability: Incremental block reports. Contributed by Tomasz Nykiel.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161992 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/08/11 9:46 PM",
      "commitName": "73451ed2d9fb5eb228d80ad5f3be302a60496527",
      "commitAuthor": "Hairong Kuang",
      "commitDateOld": "25/08/11 9:41 PM",
      "commitNameOld": "e680023f8b158db25b45a050236163e9246103f3",
      "commitAuthorOld": "Hairong Kuang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,84 @@\n     private void offerService() throws Exception {\n-      LOG.info(\"For namenode \" + nnAddr + \" using BLOCKREPORT_INTERVAL of \"\n+      LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n+          + deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n           + blockReportInterval + \"msec\" + \" Initial delay: \"\n           + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n           + heartBeatInterval);\n \n       //\n       // Now loop for a long time....\n       //\n       while (shouldRun \u0026\u0026 shouldServiceRun) {\n         try {\n           long startTime \u003d now();\n \n           //\n           // Every so often, send heartbeat or block-report\n           //\n           if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n             //\n             // All heartbeat messages include following info:\n             // -- Datanode name\n             // -- data transfer port\n             // -- Total capacity\n             // -- Bytes remaining\n             //\n             lastHeartbeat \u003d startTime;\n             if (!heartbeatsDisabledForTests) {\n               DatanodeCommand[] cmds \u003d sendHeartBeat();\n               metrics.addHeartbeat(now() - startTime);\n               if (!processCommand(cmds))\n                 continue;\n             }\n           }\n-\n-          reportReceivedBlocks();\n+          if (pendingReceivedRequests \u003e 0\n+              || (startTime - lastDeletedReport \u003e deleteReportInterval)) {\n+            reportReceivedDeletedBlocks();\n+            lastDeletedReport \u003d startTime;\n+          }\n \n           DatanodeCommand cmd \u003d blockReport();\n           processCommand(cmd);\n \n           // Now safe to start scanning the block pool\n           if (blockScanner !\u003d null) {\n             blockScanner.addBlockPool(this.blockPoolId);\n           }\n \n           //\n           // There is no work to do;  sleep until hearbeat timer elapses, \n           // or work arrives, and then iterate again.\n           //\n           long waitTime \u003d heartBeatInterval - \n           (System.currentTimeMillis() - lastHeartbeat);\n-          synchronized(receivedBlockList) {\n-            if (waitTime \u003e 0 \u0026\u0026 receivedBlockList.size() \u003d\u003d 0) {\n+          synchronized(receivedAndDeletedBlockList) {\n+            if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n               try {\n-                receivedBlockList.wait(waitTime);\n+                receivedAndDeletedBlockList.wait(waitTime);\n               } catch (InterruptedException ie) {\n                 LOG.warn(\"BPOfferService for block pool\u003d\"\n                     + this.getBlockPoolId() + \" received exception:\" + ie);\n               }\n             }\n           } // synchronized\n         } catch(RemoteException re) {\n           String reClass \u003d re.getClassName();\n           if (UnregisteredNodeException.class.getName().equals(reClass) ||\n               DisallowedDatanodeException.class.getName().equals(reClass) ||\n               IncorrectVersionException.class.getName().equals(reClass)) {\n             LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n             shouldServiceRun \u003d false;\n             return;\n           }\n           LOG.warn(\"RemoteException in offerService\", re);\n           try {\n             long sleepTime \u003d Math.min(1000, heartBeatInterval);\n             Thread.sleep(sleepTime);\n           } catch (InterruptedException ie) {\n             Thread.currentThread().interrupt();\n           }\n         } catch (IOException e) {\n           LOG.warn(\"IOException in offerService\", e);\n         }\n       } // while (shouldRun \u0026\u0026 shouldServiceRun)\n     } // offerService\n\\ No newline at end of file\n",
      "actualSource": "    private void offerService() throws Exception {\n      LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n          + deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n          + blockReportInterval + \"msec\" + \" Initial delay: \"\n          + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n          + heartBeatInterval);\n\n      //\n      // Now loop for a long time....\n      //\n      while (shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          long startTime \u003d now();\n\n          //\n          // Every so often, send heartbeat or block-report\n          //\n          if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n            //\n            // All heartbeat messages include following info:\n            // -- Datanode name\n            // -- data transfer port\n            // -- Total capacity\n            // -- Bytes remaining\n            //\n            lastHeartbeat \u003d startTime;\n            if (!heartbeatsDisabledForTests) {\n              DatanodeCommand[] cmds \u003d sendHeartBeat();\n              metrics.addHeartbeat(now() - startTime);\n              if (!processCommand(cmds))\n                continue;\n            }\n          }\n          if (pendingReceivedRequests \u003e 0\n              || (startTime - lastDeletedReport \u003e deleteReportInterval)) {\n            reportReceivedDeletedBlocks();\n            lastDeletedReport \u003d startTime;\n          }\n\n          DatanodeCommand cmd \u003d blockReport();\n          processCommand(cmd);\n\n          // Now safe to start scanning the block pool\n          if (blockScanner !\u003d null) {\n            blockScanner.addBlockPool(this.blockPoolId);\n          }\n\n          //\n          // There is no work to do;  sleep until hearbeat timer elapses, \n          // or work arrives, and then iterate again.\n          //\n          long waitTime \u003d heartBeatInterval - \n          (System.currentTimeMillis() - lastHeartbeat);\n          synchronized(receivedAndDeletedBlockList) {\n            if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n              try {\n                receivedAndDeletedBlockList.wait(waitTime);\n              } catch (InterruptedException ie) {\n                LOG.warn(\"BPOfferService for block pool\u003d\"\n                    + this.getBlockPoolId() + \" received exception:\" + ie);\n              }\n            }\n          } // synchronized\n        } catch(RemoteException re) {\n          String reClass \u003d re.getClassName();\n          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n              DisallowedDatanodeException.class.getName().equals(reClass) ||\n              IncorrectVersionException.class.getName().equals(reClass)) {\n            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n            shouldServiceRun \u003d false;\n            return;\n          }\n          LOG.warn(\"RemoteException in offerService\", re);\n          try {\n            long sleepTime \u003d Math.min(1000, heartBeatInterval);\n            Thread.sleep(sleepTime);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        } catch (IOException e) {\n          LOG.warn(\"IOException in offerService\", e);\n        }\n      } // while (shouldRun \u0026\u0026 shouldServiceRun)\n    } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "e680023f8b158db25b45a050236163e9246103f3": {
      "type": "Ybodychange",
      "commitMessage": "Revert 1161976 since the log message was incorrectly marked the issue as HDFS-349.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161991 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/08/11 9:41 PM",
      "commitName": "e680023f8b158db25b45a050236163e9246103f3",
      "commitAuthor": "Hairong Kuang",
      "commitDateOld": "25/08/11 8:10 PM",
      "commitNameOld": "e6339be188d3f5c94df3b092d92d201b728163f5",
      "commitAuthorOld": "Hairong Kuang",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,80 @@\n     private void offerService() throws Exception {\n-      LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n-          + deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n+      LOG.info(\"For namenode \" + nnAddr + \" using BLOCKREPORT_INTERVAL of \"\n           + blockReportInterval + \"msec\" + \" Initial delay: \"\n           + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n           + heartBeatInterval);\n \n       //\n       // Now loop for a long time....\n       //\n       while (shouldRun \u0026\u0026 shouldServiceRun) {\n         try {\n           long startTime \u003d now();\n \n           //\n           // Every so often, send heartbeat or block-report\n           //\n           if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n             //\n             // All heartbeat messages include following info:\n             // -- Datanode name\n             // -- data transfer port\n             // -- Total capacity\n             // -- Bytes remaining\n             //\n             lastHeartbeat \u003d startTime;\n             if (!heartbeatsDisabledForTests) {\n               DatanodeCommand[] cmds \u003d sendHeartBeat();\n               metrics.addHeartbeat(now() - startTime);\n               if (!processCommand(cmds))\n                 continue;\n             }\n           }\n-          if (pendingReceivedRequests \u003e 0\n-              || (startTime - lastDeletedReport \u003e deleteReportInterval)) {\n-            reportReceivedDeletedBlocks();\n-            lastDeletedReport \u003d startTime;\n-          }\n+\n+          reportReceivedBlocks();\n \n           DatanodeCommand cmd \u003d blockReport();\n           processCommand(cmd);\n \n           // Now safe to start scanning the block pool\n           if (blockScanner !\u003d null) {\n             blockScanner.addBlockPool(this.blockPoolId);\n           }\n \n           //\n           // There is no work to do;  sleep until hearbeat timer elapses, \n           // or work arrives, and then iterate again.\n           //\n           long waitTime \u003d heartBeatInterval - \n           (System.currentTimeMillis() - lastHeartbeat);\n-          synchronized(receivedAndDeletedBlockList) {\n-            if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n+          synchronized(receivedBlockList) {\n+            if (waitTime \u003e 0 \u0026\u0026 receivedBlockList.size() \u003d\u003d 0) {\n               try {\n-                receivedAndDeletedBlockList.wait(waitTime);\n+                receivedBlockList.wait(waitTime);\n               } catch (InterruptedException ie) {\n                 LOG.warn(\"BPOfferService for block pool\u003d\"\n                     + this.getBlockPoolId() + \" received exception:\" + ie);\n               }\n             }\n           } // synchronized\n         } catch(RemoteException re) {\n           String reClass \u003d re.getClassName();\n           if (UnregisteredNodeException.class.getName().equals(reClass) ||\n               DisallowedDatanodeException.class.getName().equals(reClass) ||\n               IncorrectVersionException.class.getName().equals(reClass)) {\n             LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n             shouldServiceRun \u003d false;\n             return;\n           }\n           LOG.warn(\"RemoteException in offerService\", re);\n           try {\n             long sleepTime \u003d Math.min(1000, heartBeatInterval);\n             Thread.sleep(sleepTime);\n           } catch (InterruptedException ie) {\n             Thread.currentThread().interrupt();\n           }\n         } catch (IOException e) {\n           LOG.warn(\"IOException in offerService\", e);\n         }\n       } // while (shouldRun \u0026\u0026 shouldServiceRun)\n     } // offerService\n\\ No newline at end of file\n",
      "actualSource": "    private void offerService() throws Exception {\n      LOG.info(\"For namenode \" + nnAddr + \" using BLOCKREPORT_INTERVAL of \"\n          + blockReportInterval + \"msec\" + \" Initial delay: \"\n          + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n          + heartBeatInterval);\n\n      //\n      // Now loop for a long time....\n      //\n      while (shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          long startTime \u003d now();\n\n          //\n          // Every so often, send heartbeat or block-report\n          //\n          if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n            //\n            // All heartbeat messages include following info:\n            // -- Datanode name\n            // -- data transfer port\n            // -- Total capacity\n            // -- Bytes remaining\n            //\n            lastHeartbeat \u003d startTime;\n            if (!heartbeatsDisabledForTests) {\n              DatanodeCommand[] cmds \u003d sendHeartBeat();\n              metrics.addHeartbeat(now() - startTime);\n              if (!processCommand(cmds))\n                continue;\n            }\n          }\n\n          reportReceivedBlocks();\n\n          DatanodeCommand cmd \u003d blockReport();\n          processCommand(cmd);\n\n          // Now safe to start scanning the block pool\n          if (blockScanner !\u003d null) {\n            blockScanner.addBlockPool(this.blockPoolId);\n          }\n\n          //\n          // There is no work to do;  sleep until hearbeat timer elapses, \n          // or work arrives, and then iterate again.\n          //\n          long waitTime \u003d heartBeatInterval - \n          (System.currentTimeMillis() - lastHeartbeat);\n          synchronized(receivedBlockList) {\n            if (waitTime \u003e 0 \u0026\u0026 receivedBlockList.size() \u003d\u003d 0) {\n              try {\n                receivedBlockList.wait(waitTime);\n              } catch (InterruptedException ie) {\n                LOG.warn(\"BPOfferService for block pool\u003d\"\n                    + this.getBlockPoolId() + \" received exception:\" + ie);\n              }\n            }\n          } // synchronized\n        } catch(RemoteException re) {\n          String reClass \u003d re.getClassName();\n          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n              DisallowedDatanodeException.class.getName().equals(reClass) ||\n              IncorrectVersionException.class.getName().equals(reClass)) {\n            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n            shouldServiceRun \u003d false;\n            return;\n          }\n          LOG.warn(\"RemoteException in offerService\", re);\n          try {\n            long sleepTime \u003d Math.min(1000, heartBeatInterval);\n            Thread.sleep(sleepTime);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        } catch (IOException e) {\n          LOG.warn(\"IOException in offerService\", e);\n        }\n      } // while (shouldRun \u0026\u0026 shouldServiceRun)\n    } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "e6339be188d3f5c94df3b092d92d201b728163f5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-349.  DFS Scalability: Incremental block reports. Contributed by Tomasz Nykiel.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161976 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/08/11 8:10 PM",
      "commitName": "e6339be188d3f5c94df3b092d92d201b728163f5",
      "commitAuthor": "Hairong Kuang",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,84 @@\n     private void offerService() throws Exception {\n-      LOG.info(\"For namenode \" + nnAddr + \" using BLOCKREPORT_INTERVAL of \"\n+      LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n+          + deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n           + blockReportInterval + \"msec\" + \" Initial delay: \"\n           + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n           + heartBeatInterval);\n \n       //\n       // Now loop for a long time....\n       //\n       while (shouldRun \u0026\u0026 shouldServiceRun) {\n         try {\n           long startTime \u003d now();\n \n           //\n           // Every so often, send heartbeat or block-report\n           //\n           if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n             //\n             // All heartbeat messages include following info:\n             // -- Datanode name\n             // -- data transfer port\n             // -- Total capacity\n             // -- Bytes remaining\n             //\n             lastHeartbeat \u003d startTime;\n             if (!heartbeatsDisabledForTests) {\n               DatanodeCommand[] cmds \u003d sendHeartBeat();\n               metrics.addHeartbeat(now() - startTime);\n               if (!processCommand(cmds))\n                 continue;\n             }\n           }\n-\n-          reportReceivedBlocks();\n+          if (pendingReceivedRequests \u003e 0\n+              || (startTime - lastDeletedReport \u003e deleteReportInterval)) {\n+            reportReceivedDeletedBlocks();\n+            lastDeletedReport \u003d startTime;\n+          }\n \n           DatanodeCommand cmd \u003d blockReport();\n           processCommand(cmd);\n \n           // Now safe to start scanning the block pool\n           if (blockScanner !\u003d null) {\n             blockScanner.addBlockPool(this.blockPoolId);\n           }\n \n           //\n           // There is no work to do;  sleep until hearbeat timer elapses, \n           // or work arrives, and then iterate again.\n           //\n           long waitTime \u003d heartBeatInterval - \n           (System.currentTimeMillis() - lastHeartbeat);\n-          synchronized(receivedBlockList) {\n-            if (waitTime \u003e 0 \u0026\u0026 receivedBlockList.size() \u003d\u003d 0) {\n+          synchronized(receivedAndDeletedBlockList) {\n+            if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n               try {\n-                receivedBlockList.wait(waitTime);\n+                receivedAndDeletedBlockList.wait(waitTime);\n               } catch (InterruptedException ie) {\n                 LOG.warn(\"BPOfferService for block pool\u003d\"\n                     + this.getBlockPoolId() + \" received exception:\" + ie);\n               }\n             }\n           } // synchronized\n         } catch(RemoteException re) {\n           String reClass \u003d re.getClassName();\n           if (UnregisteredNodeException.class.getName().equals(reClass) ||\n               DisallowedDatanodeException.class.getName().equals(reClass) ||\n               IncorrectVersionException.class.getName().equals(reClass)) {\n             LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n             shouldServiceRun \u003d false;\n             return;\n           }\n           LOG.warn(\"RemoteException in offerService\", re);\n           try {\n             long sleepTime \u003d Math.min(1000, heartBeatInterval);\n             Thread.sleep(sleepTime);\n           } catch (InterruptedException ie) {\n             Thread.currentThread().interrupt();\n           }\n         } catch (IOException e) {\n           LOG.warn(\"IOException in offerService\", e);\n         }\n       } // while (shouldRun \u0026\u0026 shouldServiceRun)\n     } // offerService\n\\ No newline at end of file\n",
      "actualSource": "    private void offerService() throws Exception {\n      LOG.info(\"For namenode \" + nnAddr + \" using DELETEREPORT_INTERVAL of \"\n          + deleteReportInterval + \" msec \" + \" BLOCKREPORT_INTERVAL of \"\n          + blockReportInterval + \"msec\" + \" Initial delay: \"\n          + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n          + heartBeatInterval);\n\n      //\n      // Now loop for a long time....\n      //\n      while (shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          long startTime \u003d now();\n\n          //\n          // Every so often, send heartbeat or block-report\n          //\n          if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n            //\n            // All heartbeat messages include following info:\n            // -- Datanode name\n            // -- data transfer port\n            // -- Total capacity\n            // -- Bytes remaining\n            //\n            lastHeartbeat \u003d startTime;\n            if (!heartbeatsDisabledForTests) {\n              DatanodeCommand[] cmds \u003d sendHeartBeat();\n              metrics.addHeartbeat(now() - startTime);\n              if (!processCommand(cmds))\n                continue;\n            }\n          }\n          if (pendingReceivedRequests \u003e 0\n              || (startTime - lastDeletedReport \u003e deleteReportInterval)) {\n            reportReceivedDeletedBlocks();\n            lastDeletedReport \u003d startTime;\n          }\n\n          DatanodeCommand cmd \u003d blockReport();\n          processCommand(cmd);\n\n          // Now safe to start scanning the block pool\n          if (blockScanner !\u003d null) {\n            blockScanner.addBlockPool(this.blockPoolId);\n          }\n\n          //\n          // There is no work to do;  sleep until hearbeat timer elapses, \n          // or work arrives, and then iterate again.\n          //\n          long waitTime \u003d heartBeatInterval - \n          (System.currentTimeMillis() - lastHeartbeat);\n          synchronized(receivedAndDeletedBlockList) {\n            if (waitTime \u003e 0 \u0026\u0026 pendingReceivedRequests \u003d\u003d 0) {\n              try {\n                receivedAndDeletedBlockList.wait(waitTime);\n              } catch (InterruptedException ie) {\n                LOG.warn(\"BPOfferService for block pool\u003d\"\n                    + this.getBlockPoolId() + \" received exception:\" + ie);\n              }\n            }\n          } // synchronized\n        } catch(RemoteException re) {\n          String reClass \u003d re.getClassName();\n          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n              DisallowedDatanodeException.class.getName().equals(reClass) ||\n              IncorrectVersionException.class.getName().equals(reClass)) {\n            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n            shouldServiceRun \u003d false;\n            return;\n          }\n          LOG.warn(\"RemoteException in offerService\", re);\n          try {\n            long sleepTime \u003d Math.min(1000, heartBeatInterval);\n            Thread.sleep(sleepTime);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        } catch (IOException e) {\n          LOG.warn(\"IOException in offerService\", e);\n        }\n      } // while (shouldRun \u0026\u0026 shouldServiceRun)\n    } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void offerService() throws Exception {\n      LOG.info(\"For namenode \" + nnAddr + \" using BLOCKREPORT_INTERVAL of \"\n          + blockReportInterval + \"msec\" + \" Initial delay: \"\n          + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n          + heartBeatInterval);\n\n      //\n      // Now loop for a long time....\n      //\n      while (shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          long startTime \u003d now();\n\n          //\n          // Every so often, send heartbeat or block-report\n          //\n          if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n            //\n            // All heartbeat messages include following info:\n            // -- Datanode name\n            // -- data transfer port\n            // -- Total capacity\n            // -- Bytes remaining\n            //\n            lastHeartbeat \u003d startTime;\n            if (!heartbeatsDisabledForTests) {\n              DatanodeCommand[] cmds \u003d sendHeartBeat();\n              metrics.addHeartbeat(now() - startTime);\n              if (!processCommand(cmds))\n                continue;\n            }\n          }\n\n          reportReceivedBlocks();\n\n          DatanodeCommand cmd \u003d blockReport();\n          processCommand(cmd);\n\n          // Now safe to start scanning the block pool\n          if (blockScanner !\u003d null) {\n            blockScanner.addBlockPool(this.blockPoolId);\n          }\n\n          //\n          // There is no work to do;  sleep until hearbeat timer elapses, \n          // or work arrives, and then iterate again.\n          //\n          long waitTime \u003d heartBeatInterval - \n          (System.currentTimeMillis() - lastHeartbeat);\n          synchronized(receivedBlockList) {\n            if (waitTime \u003e 0 \u0026\u0026 receivedBlockList.size() \u003d\u003d 0) {\n              try {\n                receivedBlockList.wait(waitTime);\n              } catch (InterruptedException ie) {\n                LOG.warn(\"BPOfferService for block pool\u003d\"\n                    + this.getBlockPoolId() + \" received exception:\" + ie);\n              }\n            }\n          } // synchronized\n        } catch(RemoteException re) {\n          String reClass \u003d re.getClassName();\n          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n              DisallowedDatanodeException.class.getName().equals(reClass) ||\n              IncorrectVersionException.class.getName().equals(reClass)) {\n            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n            shouldServiceRun \u003d false;\n            return;\n          }\n          LOG.warn(\"RemoteException in offerService\", re);\n          try {\n            long sleepTime \u003d Math.min(1000, heartBeatInterval);\n            Thread.sleep(sleepTime);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        } catch (IOException e) {\n          LOG.warn(\"IOException in offerService\", e);\n        }\n      } // while (shouldRun \u0026\u0026 shouldServiceRun)\n    } // offerService",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void offerService() throws Exception {\n      LOG.info(\"For namenode \" + nnAddr + \" using BLOCKREPORT_INTERVAL of \"\n          + blockReportInterval + \"msec\" + \" Initial delay: \"\n          + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n          + heartBeatInterval);\n\n      //\n      // Now loop for a long time....\n      //\n      while (shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          long startTime \u003d now();\n\n          //\n          // Every so often, send heartbeat or block-report\n          //\n          if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n            //\n            // All heartbeat messages include following info:\n            // -- Datanode name\n            // -- data transfer port\n            // -- Total capacity\n            // -- Bytes remaining\n            //\n            lastHeartbeat \u003d startTime;\n            if (!heartbeatsDisabledForTests) {\n              DatanodeCommand[] cmds \u003d sendHeartBeat();\n              metrics.addHeartbeat(now() - startTime);\n              if (!processCommand(cmds))\n                continue;\n            }\n          }\n\n          reportReceivedBlocks();\n\n          DatanodeCommand cmd \u003d blockReport();\n          processCommand(cmd);\n\n          // Now safe to start scanning the block pool\n          if (blockScanner !\u003d null) {\n            blockScanner.addBlockPool(this.blockPoolId);\n          }\n\n          //\n          // There is no work to do;  sleep until hearbeat timer elapses, \n          // or work arrives, and then iterate again.\n          //\n          long waitTime \u003d heartBeatInterval - \n          (System.currentTimeMillis() - lastHeartbeat);\n          synchronized(receivedBlockList) {\n            if (waitTime \u003e 0 \u0026\u0026 receivedBlockList.size() \u003d\u003d 0) {\n              try {\n                receivedBlockList.wait(waitTime);\n              } catch (InterruptedException ie) {\n                LOG.warn(\"BPOfferService for block pool\u003d\"\n                    + this.getBlockPoolId() + \" received exception:\" + ie);\n              }\n            }\n          } // synchronized\n        } catch(RemoteException re) {\n          String reClass \u003d re.getClassName();\n          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n              DisallowedDatanodeException.class.getName().equals(reClass) ||\n              IncorrectVersionException.class.getName().equals(reClass)) {\n            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n            shouldServiceRun \u003d false;\n            return;\n          }\n          LOG.warn(\"RemoteException in offerService\", re);\n          try {\n            long sleepTime \u003d Math.min(1000, heartBeatInterval);\n            Thread.sleep(sleepTime);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        } catch (IOException e) {\n          LOG.warn(\"IOException in offerService\", e);\n        }\n      } // while (shouldRun \u0026\u0026 shouldServiceRun)\n    } // offerService",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java"
      }
    },
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1977. Stop using StringUtils.stringifyException(). Contributed by Bharath Mundlapudi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1145834 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/11 6:11 PM",
      "commitName": "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "30/06/11 1:56 PM",
      "commitNameOld": "3af51887b40df8de7482040cf8a90600a2c4305f",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 12.18,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,80 @@\n     private void offerService() throws Exception {\n       LOG.info(\"For namenode \" + nnAddr + \" using BLOCKREPORT_INTERVAL of \"\n           + blockReportInterval + \"msec\" + \" Initial delay: \"\n           + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n           + heartBeatInterval);\n \n       //\n       // Now loop for a long time....\n       //\n       while (shouldRun \u0026\u0026 shouldServiceRun) {\n         try {\n           long startTime \u003d now();\n \n           //\n           // Every so often, send heartbeat or block-report\n           //\n           if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n             //\n             // All heartbeat messages include following info:\n             // -- Datanode name\n             // -- data transfer port\n             // -- Total capacity\n             // -- Bytes remaining\n             //\n             lastHeartbeat \u003d startTime;\n             if (!heartbeatsDisabledForTests) {\n               DatanodeCommand[] cmds \u003d sendHeartBeat();\n               metrics.addHeartbeat(now() - startTime);\n               if (!processCommand(cmds))\n                 continue;\n             }\n           }\n \n           reportReceivedBlocks();\n \n           DatanodeCommand cmd \u003d blockReport();\n           processCommand(cmd);\n \n           // Now safe to start scanning the block pool\n           if (blockScanner !\u003d null) {\n             blockScanner.addBlockPool(this.blockPoolId);\n           }\n \n           //\n           // There is no work to do;  sleep until hearbeat timer elapses, \n           // or work arrives, and then iterate again.\n           //\n           long waitTime \u003d heartBeatInterval - \n           (System.currentTimeMillis() - lastHeartbeat);\n           synchronized(receivedBlockList) {\n             if (waitTime \u003e 0 \u0026\u0026 receivedBlockList.size() \u003d\u003d 0) {\n               try {\n                 receivedBlockList.wait(waitTime);\n               } catch (InterruptedException ie) {\n                 LOG.warn(\"BPOfferService for block pool\u003d\"\n                     + this.getBlockPoolId() + \" received exception:\" + ie);\n               }\n             }\n           } // synchronized\n         } catch(RemoteException re) {\n           String reClass \u003d re.getClassName();\n           if (UnregisteredNodeException.class.getName().equals(reClass) ||\n               DisallowedDatanodeException.class.getName().equals(reClass) ||\n               IncorrectVersionException.class.getName().equals(reClass)) {\n-            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down: \" + \n-                StringUtils.stringifyException(re));\n+            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n             shouldServiceRun \u003d false;\n             return;\n           }\n-          LOG.warn(StringUtils.stringifyException(re));\n+          LOG.warn(\"RemoteException in offerService\", re);\n           try {\n             long sleepTime \u003d Math.min(1000, heartBeatInterval);\n             Thread.sleep(sleepTime);\n           } catch (InterruptedException ie) {\n             Thread.currentThread().interrupt();\n           }\n         } catch (IOException e) {\n-          LOG.warn(StringUtils.stringifyException(e));\n+          LOG.warn(\"IOException in offerService\", e);\n         }\n       } // while (shouldRun \u0026\u0026 shouldServiceRun)\n     } // offerService\n\\ No newline at end of file\n",
      "actualSource": "    private void offerService() throws Exception {\n      LOG.info(\"For namenode \" + nnAddr + \" using BLOCKREPORT_INTERVAL of \"\n          + blockReportInterval + \"msec\" + \" Initial delay: \"\n          + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n          + heartBeatInterval);\n\n      //\n      // Now loop for a long time....\n      //\n      while (shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          long startTime \u003d now();\n\n          //\n          // Every so often, send heartbeat or block-report\n          //\n          if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n            //\n            // All heartbeat messages include following info:\n            // -- Datanode name\n            // -- data transfer port\n            // -- Total capacity\n            // -- Bytes remaining\n            //\n            lastHeartbeat \u003d startTime;\n            if (!heartbeatsDisabledForTests) {\n              DatanodeCommand[] cmds \u003d sendHeartBeat();\n              metrics.addHeartbeat(now() - startTime);\n              if (!processCommand(cmds))\n                continue;\n            }\n          }\n\n          reportReceivedBlocks();\n\n          DatanodeCommand cmd \u003d blockReport();\n          processCommand(cmd);\n\n          // Now safe to start scanning the block pool\n          if (blockScanner !\u003d null) {\n            blockScanner.addBlockPool(this.blockPoolId);\n          }\n\n          //\n          // There is no work to do;  sleep until hearbeat timer elapses, \n          // or work arrives, and then iterate again.\n          //\n          long waitTime \u003d heartBeatInterval - \n          (System.currentTimeMillis() - lastHeartbeat);\n          synchronized(receivedBlockList) {\n            if (waitTime \u003e 0 \u0026\u0026 receivedBlockList.size() \u003d\u003d 0) {\n              try {\n                receivedBlockList.wait(waitTime);\n              } catch (InterruptedException ie) {\n                LOG.warn(\"BPOfferService for block pool\u003d\"\n                    + this.getBlockPoolId() + \" received exception:\" + ie);\n              }\n            }\n          } // synchronized\n        } catch(RemoteException re) {\n          String reClass \u003d re.getClassName();\n          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n              DisallowedDatanodeException.class.getName().equals(reClass) ||\n              IncorrectVersionException.class.getName().equals(reClass)) {\n            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down\", re);\n            shouldServiceRun \u003d false;\n            return;\n          }\n          LOG.warn(\"RemoteException in offerService\", re);\n          try {\n            long sleepTime \u003d Math.min(1000, heartBeatInterval);\n            Thread.sleep(sleepTime);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        } catch (IOException e) {\n          LOG.warn(\"IOException in offerService\", e);\n        }\n      } // while (shouldRun \u0026\u0026 shouldServiceRun)\n    } // offerService",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,81 @@\n+    private void offerService() throws Exception {\n+      LOG.info(\"For namenode \" + nnAddr + \" using BLOCKREPORT_INTERVAL of \"\n+          + blockReportInterval + \"msec\" + \" Initial delay: \"\n+          + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n+          + heartBeatInterval);\n+\n+      //\n+      // Now loop for a long time....\n+      //\n+      while (shouldRun \u0026\u0026 shouldServiceRun) {\n+        try {\n+          long startTime \u003d now();\n+\n+          //\n+          // Every so often, send heartbeat or block-report\n+          //\n+          if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n+            //\n+            // All heartbeat messages include following info:\n+            // -- Datanode name\n+            // -- data transfer port\n+            // -- Total capacity\n+            // -- Bytes remaining\n+            //\n+            lastHeartbeat \u003d startTime;\n+            if (!heartbeatsDisabledForTests) {\n+              DatanodeCommand[] cmds \u003d sendHeartBeat();\n+              metrics.addHeartbeat(now() - startTime);\n+              if (!processCommand(cmds))\n+                continue;\n+            }\n+          }\n+\n+          reportReceivedBlocks();\n+\n+          DatanodeCommand cmd \u003d blockReport();\n+          processCommand(cmd);\n+\n+          // Now safe to start scanning the block pool\n+          if (blockScanner !\u003d null) {\n+            blockScanner.addBlockPool(this.blockPoolId);\n+          }\n+\n+          //\n+          // There is no work to do;  sleep until hearbeat timer elapses, \n+          // or work arrives, and then iterate again.\n+          //\n+          long waitTime \u003d heartBeatInterval - \n+          (System.currentTimeMillis() - lastHeartbeat);\n+          synchronized(receivedBlockList) {\n+            if (waitTime \u003e 0 \u0026\u0026 receivedBlockList.size() \u003d\u003d 0) {\n+              try {\n+                receivedBlockList.wait(waitTime);\n+              } catch (InterruptedException ie) {\n+                LOG.warn(\"BPOfferService for block pool\u003d\"\n+                    + this.getBlockPoolId() + \" received exception:\" + ie);\n+              }\n+            }\n+          } // synchronized\n+        } catch(RemoteException re) {\n+          String reClass \u003d re.getClassName();\n+          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n+              DisallowedDatanodeException.class.getName().equals(reClass) ||\n+              IncorrectVersionException.class.getName().equals(reClass)) {\n+            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down: \" + \n+                StringUtils.stringifyException(re));\n+            shouldServiceRun \u003d false;\n+            return;\n+          }\n+          LOG.warn(StringUtils.stringifyException(re));\n+          try {\n+            long sleepTime \u003d Math.min(1000, heartBeatInterval);\n+            Thread.sleep(sleepTime);\n+          } catch (InterruptedException ie) {\n+            Thread.currentThread().interrupt();\n+          }\n+        } catch (IOException e) {\n+          LOG.warn(StringUtils.stringifyException(e));\n+        }\n+      } // while (shouldRun \u0026\u0026 shouldServiceRun)\n+    } // offerService\n\\ No newline at end of file\n",
      "actualSource": "    private void offerService() throws Exception {\n      LOG.info(\"For namenode \" + nnAddr + \" using BLOCKREPORT_INTERVAL of \"\n          + blockReportInterval + \"msec\" + \" Initial delay: \"\n          + initialBlockReportDelay + \"msec\" + \"; heartBeatInterval\u003d\"\n          + heartBeatInterval);\n\n      //\n      // Now loop for a long time....\n      //\n      while (shouldRun \u0026\u0026 shouldServiceRun) {\n        try {\n          long startTime \u003d now();\n\n          //\n          // Every so often, send heartbeat or block-report\n          //\n          if (startTime - lastHeartbeat \u003e heartBeatInterval) {\n            //\n            // All heartbeat messages include following info:\n            // -- Datanode name\n            // -- data transfer port\n            // -- Total capacity\n            // -- Bytes remaining\n            //\n            lastHeartbeat \u003d startTime;\n            if (!heartbeatsDisabledForTests) {\n              DatanodeCommand[] cmds \u003d sendHeartBeat();\n              metrics.addHeartbeat(now() - startTime);\n              if (!processCommand(cmds))\n                continue;\n            }\n          }\n\n          reportReceivedBlocks();\n\n          DatanodeCommand cmd \u003d blockReport();\n          processCommand(cmd);\n\n          // Now safe to start scanning the block pool\n          if (blockScanner !\u003d null) {\n            blockScanner.addBlockPool(this.blockPoolId);\n          }\n\n          //\n          // There is no work to do;  sleep until hearbeat timer elapses, \n          // or work arrives, and then iterate again.\n          //\n          long waitTime \u003d heartBeatInterval - \n          (System.currentTimeMillis() - lastHeartbeat);\n          synchronized(receivedBlockList) {\n            if (waitTime \u003e 0 \u0026\u0026 receivedBlockList.size() \u003d\u003d 0) {\n              try {\n                receivedBlockList.wait(waitTime);\n              } catch (InterruptedException ie) {\n                LOG.warn(\"BPOfferService for block pool\u003d\"\n                    + this.getBlockPoolId() + \" received exception:\" + ie);\n              }\n            }\n          } // synchronized\n        } catch(RemoteException re) {\n          String reClass \u003d re.getClassName();\n          if (UnregisteredNodeException.class.getName().equals(reClass) ||\n              DisallowedDatanodeException.class.getName().equals(reClass) ||\n              IncorrectVersionException.class.getName().equals(reClass)) {\n            LOG.warn(\"blockpool \" + blockPoolId + \" is shutting down: \" + \n                StringUtils.stringifyException(re));\n            shouldServiceRun \u003d false;\n            return;\n          }\n          LOG.warn(StringUtils.stringifyException(re));\n          try {\n            long sleepTime \u003d Math.min(1000, heartBeatInterval);\n            Thread.sleep(sleepTime);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n          }\n        } catch (IOException e) {\n          LOG.warn(StringUtils.stringifyException(e));\n        }\n      } // while (shouldRun \u0026\u0026 shouldServiceRun)\n    } // offerService",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java"
    }
  }
}