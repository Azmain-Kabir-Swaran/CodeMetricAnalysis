{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TimelineParserForDataToRetrieve.java",
  "functionName": "parse",
  "functionId": "parse",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/reader/TimelineParserForDataToRetrieve.java",
  "functionStartLine": 47,
  "functionEndLine": 90,
  "numCommitsSeen": 1,
  "timeTaken": 674,
  "changeHistory": [
    "089caf49fe968cf4cd3fd4f9637da89ee143991a"
  ],
  "changeHistoryShort": {
    "089caf49fe968cf4cd3fd4f9637da89ee143991a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "089caf49fe968cf4cd3fd4f9637da89ee143991a": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4447. Provide a mechanism to represent complex filters and parse them at the REST layer (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "089caf49fe968cf4cd3fd4f9637da89ee143991a",
      "commitAuthor": "Sangjin Lee",
      "diff": "@@ -0,0 +1,44 @@\n+  public TimelineFilterList parse() throws TimelineParseException {\n+    if (expr \u003d\u003d null || exprLength \u003d\u003d 0) {\n+      return null;\n+    }\n+    TimelineCompareOp compareOp \u003d null;\n+    int openingBracketIndex \u003d\n+        expr.indexOf(TimelineParseConstants.OPENING_BRACKET_CHAR);\n+    if (expr.charAt(0) \u003d\u003d TimelineParseConstants.NOT_CHAR) {\n+      if (openingBracketIndex \u003d\u003d -1) {\n+        throw new TimelineParseException(\"Invalid config/metric to retrieve \" +\n+            \"expression\");\n+      }\n+      if (openingBracketIndex !\u003d 1 \u0026\u0026\n+          expr.substring(1, openingBracketIndex + 1).trim().length() !\u003d 1) {\n+        throw new TimelineParseException(\"Invalid config/metric to retrieve \" +\n+            \"expression\");\n+      }\n+      compareOp \u003d TimelineCompareOp.NOT_EQUAL;\n+    } else if (openingBracketIndex \u003c\u003d 0) {\n+      compareOp \u003d TimelineCompareOp.EQUAL;\n+    }\n+    char lastChar \u003d expr.charAt(exprLength - 1);\n+    if (compareOp \u003d\u003d TimelineCompareOp.NOT_EQUAL \u0026\u0026\n+        lastChar !\u003d TimelineParseConstants.CLOSING_BRACKET_CHAR) {\n+      throw new TimelineParseException(\"Invalid config/metric to retrieve \" +\n+          \"expression\");\n+    }\n+    if (openingBracketIndex !\u003d -1 \u0026\u0026\n+        expr.charAt(exprLength - 1) \u003d\u003d\n+            TimelineParseConstants.CLOSING_BRACKET_CHAR) {\n+      expr \u003d expr.substring(openingBracketIndex + 1, exprLength - 1).trim();\n+    }\n+    if (expr.isEmpty()) {\n+      return null;\n+    }\n+    Operator op \u003d\n+        (compareOp \u003d\u003d TimelineCompareOp.NOT_EQUAL) ? Operator.AND : Operator.OR;\n+    TimelineFilterList list \u003d new TimelineFilterList(op);\n+    String[] splits \u003d expr.split(TimelineParseConstants.COMMA_DELIMITER);\n+    for (String split : splits) {\n+      list.addFilter(new TimelinePrefixFilter(compareOp, split.trim()));\n+    }\n+    return list;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public TimelineFilterList parse() throws TimelineParseException {\n    if (expr \u003d\u003d null || exprLength \u003d\u003d 0) {\n      return null;\n    }\n    TimelineCompareOp compareOp \u003d null;\n    int openingBracketIndex \u003d\n        expr.indexOf(TimelineParseConstants.OPENING_BRACKET_CHAR);\n    if (expr.charAt(0) \u003d\u003d TimelineParseConstants.NOT_CHAR) {\n      if (openingBracketIndex \u003d\u003d -1) {\n        throw new TimelineParseException(\"Invalid config/metric to retrieve \" +\n            \"expression\");\n      }\n      if (openingBracketIndex !\u003d 1 \u0026\u0026\n          expr.substring(1, openingBracketIndex + 1).trim().length() !\u003d 1) {\n        throw new TimelineParseException(\"Invalid config/metric to retrieve \" +\n            \"expression\");\n      }\n      compareOp \u003d TimelineCompareOp.NOT_EQUAL;\n    } else if (openingBracketIndex \u003c\u003d 0) {\n      compareOp \u003d TimelineCompareOp.EQUAL;\n    }\n    char lastChar \u003d expr.charAt(exprLength - 1);\n    if (compareOp \u003d\u003d TimelineCompareOp.NOT_EQUAL \u0026\u0026\n        lastChar !\u003d TimelineParseConstants.CLOSING_BRACKET_CHAR) {\n      throw new TimelineParseException(\"Invalid config/metric to retrieve \" +\n          \"expression\");\n    }\n    if (openingBracketIndex !\u003d -1 \u0026\u0026\n        expr.charAt(exprLength - 1) \u003d\u003d\n            TimelineParseConstants.CLOSING_BRACKET_CHAR) {\n      expr \u003d expr.substring(openingBracketIndex + 1, exprLength - 1).trim();\n    }\n    if (expr.isEmpty()) {\n      return null;\n    }\n    Operator op \u003d\n        (compareOp \u003d\u003d TimelineCompareOp.NOT_EQUAL) ? Operator.AND : Operator.OR;\n    TimelineFilterList list \u003d new TimelineFilterList(op);\n    String[] splits \u003d expr.split(TimelineParseConstants.COMMA_DELIMITER);\n    for (String split : splits) {\n      list.addFilter(new TimelinePrefixFilter(compareOp, split.trim()));\n    }\n    return list;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/reader/TimelineParserForDataToRetrieve.java"
    }
  }
}