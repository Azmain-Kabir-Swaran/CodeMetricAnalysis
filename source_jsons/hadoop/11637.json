{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockPoolSlice.java",
  "functionName": "readReplicasFromCache",
  "functionId": "readReplicasFromCache___volumeMap-ReplicaMap__lazyWriteReplicaMap-RamDiskReplicaTracker(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice.java",
  "functionStartLine": 896,
  "functionEndLine": 970,
  "numCommitsSeen": 58,
  "timeTaken": 6001,
  "changeHistory": [
    "1a636da041f2d4f2541a2da9c87f94c3ed234fb0",
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
    "5ff22d4c3a417292c496a4bb02e8b19fad66ec63",
    "6eba79232f36b36e0196163adc8fe4219a6b6bf9",
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389",
    "1b5cceaffbdde50a87ede81552dc380832db8e79",
    "b9522e86a55564c2ccb5ca3f1ca871965cbe74de",
    "8ae4729107d33c6001cf1fdc8837afb71ea6c0d3",
    "63ac2db59af2b50e74dc892cae1dbc4d2e061423",
    "d6fa34e014b0e2a61b24f05dd08ebe12354267fd",
    "fc1031af749435dc95efea6745b1b2300ce29446"
  ],
  "changeHistoryShort": {
    "1a636da041f2d4f2541a2da9c87f94c3ed234fb0": "Ybodychange",
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8": "Ybodychange",
    "5ff22d4c3a417292c496a4bb02e8b19fad66ec63": "Ybodychange",
    "6eba79232f36b36e0196163adc8fe4219a6b6bf9": "Ybodychange",
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389": "Ybodychange",
    "1b5cceaffbdde50a87ede81552dc380832db8e79": "Ybodychange",
    "b9522e86a55564c2ccb5ca3f1ca871965cbe74de": "Ybodychange",
    "8ae4729107d33c6001cf1fdc8837afb71ea6c0d3": "Ybodychange",
    "63ac2db59af2b50e74dc892cae1dbc4d2e061423": "Ybodychange",
    "d6fa34e014b0e2a61b24f05dd08ebe12354267fd": "Ybodychange",
    "fc1031af749435dc95efea6745b1b2300ce29446": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1a636da041f2d4f2541a2da9c87f94c3ed234fb0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15033. Support to save replica cached files to other place and make expired time configurable. Contributed by Yang Yun.\n",
      "commitDate": "28/02/20 8:25 PM",
      "commitName": "1a636da041f2d4f2541a2da9c87f94c3ed234fb0",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "11/02/20 8:00 AM",
      "commitNameOld": "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
      "commitAuthorOld": "Stephen O\u0027Donnell",
      "daysBetweenCommits": 17.52,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n   private boolean readReplicasFromCache(ReplicaMap volumeMap,\n       final RamDiskReplicaTracker lazyWriteReplicaMap) {\n     ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new ReentrantReadWriteLock());\n-    File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n+    File replicaFile \u003d new File(replicaCacheDir, REPLICA_CACHE_FILE);\n     // Check whether the file exists or not.\n     if (!replicaFile.exists()) {\n       LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n           \" doesn\u0027t exist \");\n       return false;\n     }\n     long fileLastModifiedTime \u003d replicaFile.lastModified();\n     if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n       LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n           \" has gone stale\");\n       // Just to make findbugs happy\n       if (!replicaFile.delete()) {\n         LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n             \" cannot be deleted\");\n       }\n       return false;\n     }\n     FileInputStream inputStream \u003d null;\n     try {\n       inputStream \u003d fileIoProvider.getFileInputStream(volume, replicaFile);\n       BlockListAsLongs blocksList \u003d\n           BlockListAsLongs.readFrom(inputStream, maxDataLength);\n       if (blocksList \u003d\u003d null) {\n         return false;\n       }\n \n       for (BlockReportReplica replica : blocksList) {\n         switch (replica.getState()) {\n         case FINALIZED:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n           break;\n         case RUR:\n         case RBW:\n         case RWR:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n           break;\n         default:\n           break;\n         }\n       }\n       // Now it is safe to add the replica into volumeMap\n       // In case of any exception during parsing this cache file, fall back\n       // to scan all the files on disk.\n       for (Iterator\u003cReplicaInfo\u003e iter \u003d\n           tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n         ReplicaInfo info \u003d iter.next();\n         // We use a lightweight GSet to store replicaInfo, we need to remove\n         // it from one GSet before adding to another.\n         iter.remove();\n         volumeMap.add(bpid, info);\n       }\n       LOG.info(\"Successfully read replica from cache file : \"\n           + replicaFile.getPath());\n       return true;\n     } catch (Exception e) {\n       // Any exception we need to revert back to read from disk\n       // Log the error and return false\n       LOG.info(\"Exception occurred while reading the replicas cache file: \"\n           + replicaFile.getPath(), e );\n       return false;\n     }\n     finally {\n       // close the inputStream\n       IOUtils.closeStream(inputStream);\n \n       if (!fileIoProvider.delete(volume, replicaFile)) {\n         LOG.info(\"Failed to delete replica cache file: \" +\n             replicaFile.getPath());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean readReplicasFromCache(ReplicaMap volumeMap,\n      final RamDiskReplicaTracker lazyWriteReplicaMap) {\n    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new ReentrantReadWriteLock());\n    File replicaFile \u003d new File(replicaCacheDir, REPLICA_CACHE_FILE);\n    // Check whether the file exists or not.\n    if (!replicaFile.exists()) {\n      LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n          \" doesn\u0027t exist \");\n      return false;\n    }\n    long fileLastModifiedTime \u003d replicaFile.lastModified();\n    if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n      LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n          \" has gone stale\");\n      // Just to make findbugs happy\n      if (!replicaFile.delete()) {\n        LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n            \" cannot be deleted\");\n      }\n      return false;\n    }\n    FileInputStream inputStream \u003d null;\n    try {\n      inputStream \u003d fileIoProvider.getFileInputStream(volume, replicaFile);\n      BlockListAsLongs blocksList \u003d\n          BlockListAsLongs.readFrom(inputStream, maxDataLength);\n      if (blocksList \u003d\u003d null) {\n        return false;\n      }\n\n      for (BlockReportReplica replica : blocksList) {\n        switch (replica.getState()) {\n        case FINALIZED:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n          break;\n        case RUR:\n        case RBW:\n        case RWR:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n          break;\n        default:\n          break;\n        }\n      }\n      // Now it is safe to add the replica into volumeMap\n      // In case of any exception during parsing this cache file, fall back\n      // to scan all the files on disk.\n      for (Iterator\u003cReplicaInfo\u003e iter \u003d\n          tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n        ReplicaInfo info \u003d iter.next();\n        // We use a lightweight GSet to store replicaInfo, we need to remove\n        // it from one GSet before adding to another.\n        iter.remove();\n        volumeMap.add(bpid, info);\n      }\n      LOG.info(\"Successfully read replica from cache file : \"\n          + replicaFile.getPath());\n      return true;\n    } catch (Exception e) {\n      // Any exception we need to revert back to read from disk\n      // Log the error and return false\n      LOG.info(\"Exception occurred while reading the replicas cache file: \"\n          + replicaFile.getPath(), e );\n      return false;\n    }\n    finally {\n      // close the inputStream\n      IOUtils.closeStream(inputStream);\n\n      if (!fileIoProvider.delete(volume, replicaFile)) {\n        LOG.info(\"Failed to delete replica cache file: \" +\n            replicaFile.getPath());\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice.java",
      "extendedDetails": {}
    },
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15150. Introduce read write lock to Datanode. Contributed Stephen O\u0027Donnell.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "11/02/20 8:00 AM",
      "commitName": "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
      "commitAuthor": "Stephen O\u0027Donnell",
      "commitDateOld": "28/11/19 10:19 AM",
      "commitNameOld": "0384687811446a52009b96cc85bf961a3e83afc4",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 74.9,
      "commitsBetweenForRepo": 238,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n   private boolean readReplicasFromCache(ReplicaMap volumeMap,\n       final RamDiskReplicaTracker lazyWriteReplicaMap) {\n-    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new AutoCloseableLock());\n+    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new ReentrantReadWriteLock());\n     File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n     // Check whether the file exists or not.\n     if (!replicaFile.exists()) {\n       LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n           \" doesn\u0027t exist \");\n       return false;\n     }\n     long fileLastModifiedTime \u003d replicaFile.lastModified();\n     if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n       LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n           \" has gone stale\");\n       // Just to make findbugs happy\n       if (!replicaFile.delete()) {\n         LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n             \" cannot be deleted\");\n       }\n       return false;\n     }\n     FileInputStream inputStream \u003d null;\n     try {\n       inputStream \u003d fileIoProvider.getFileInputStream(volume, replicaFile);\n       BlockListAsLongs blocksList \u003d\n           BlockListAsLongs.readFrom(inputStream, maxDataLength);\n       if (blocksList \u003d\u003d null) {\n         return false;\n       }\n \n       for (BlockReportReplica replica : blocksList) {\n         switch (replica.getState()) {\n         case FINALIZED:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n           break;\n         case RUR:\n         case RBW:\n         case RWR:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n           break;\n         default:\n           break;\n         }\n       }\n       // Now it is safe to add the replica into volumeMap\n       // In case of any exception during parsing this cache file, fall back\n       // to scan all the files on disk.\n       for (Iterator\u003cReplicaInfo\u003e iter \u003d\n           tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n         ReplicaInfo info \u003d iter.next();\n         // We use a lightweight GSet to store replicaInfo, we need to remove\n         // it from one GSet before adding to another.\n         iter.remove();\n         volumeMap.add(bpid, info);\n       }\n       LOG.info(\"Successfully read replica from cache file : \"\n           + replicaFile.getPath());\n       return true;\n     } catch (Exception e) {\n       // Any exception we need to revert back to read from disk\n       // Log the error and return false\n       LOG.info(\"Exception occurred while reading the replicas cache file: \"\n           + replicaFile.getPath(), e );\n       return false;\n     }\n     finally {\n       // close the inputStream\n       IOUtils.closeStream(inputStream);\n \n       if (!fileIoProvider.delete(volume, replicaFile)) {\n         LOG.info(\"Failed to delete replica cache file: \" +\n             replicaFile.getPath());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean readReplicasFromCache(ReplicaMap volumeMap,\n      final RamDiskReplicaTracker lazyWriteReplicaMap) {\n    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new ReentrantReadWriteLock());\n    File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n    // Check whether the file exists or not.\n    if (!replicaFile.exists()) {\n      LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n          \" doesn\u0027t exist \");\n      return false;\n    }\n    long fileLastModifiedTime \u003d replicaFile.lastModified();\n    if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n      LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n          \" has gone stale\");\n      // Just to make findbugs happy\n      if (!replicaFile.delete()) {\n        LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n            \" cannot be deleted\");\n      }\n      return false;\n    }\n    FileInputStream inputStream \u003d null;\n    try {\n      inputStream \u003d fileIoProvider.getFileInputStream(volume, replicaFile);\n      BlockListAsLongs blocksList \u003d\n          BlockListAsLongs.readFrom(inputStream, maxDataLength);\n      if (blocksList \u003d\u003d null) {\n        return false;\n      }\n\n      for (BlockReportReplica replica : blocksList) {\n        switch (replica.getState()) {\n        case FINALIZED:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n          break;\n        case RUR:\n        case RBW:\n        case RWR:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n          break;\n        default:\n          break;\n        }\n      }\n      // Now it is safe to add the replica into volumeMap\n      // In case of any exception during parsing this cache file, fall back\n      // to scan all the files on disk.\n      for (Iterator\u003cReplicaInfo\u003e iter \u003d\n          tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n        ReplicaInfo info \u003d iter.next();\n        // We use a lightweight GSet to store replicaInfo, we need to remove\n        // it from one GSet before adding to another.\n        iter.remove();\n        volumeMap.add(bpid, info);\n      }\n      LOG.info(\"Successfully read replica from cache file : \"\n          + replicaFile.getPath());\n      return true;\n    } catch (Exception e) {\n      // Any exception we need to revert back to read from disk\n      // Log the error and return false\n      LOG.info(\"Exception occurred while reading the replicas cache file: \"\n          + replicaFile.getPath(), e );\n      return false;\n    }\n    finally {\n      // close the inputStream\n      IOUtils.closeStream(inputStream);\n\n      if (!fileIoProvider.delete(volume, replicaFile)) {\n        LOG.info(\"Failed to delete replica cache file: \" +\n            replicaFile.getPath());\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice.java",
      "extendedDetails": {}
    },
    "5ff22d4c3a417292c496a4bb02e8b19fad66ec63": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13246. FileInputStream redundant closes in readReplicasFromCache. Contributed by liaoyuxiangqin.\n",
      "commitDate": "14/03/18 9:59 PM",
      "commitName": "5ff22d4c3a417292c496a4bb02e8b19fad66ec63",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "12/01/18 8:04 AM",
      "commitNameOld": "b278f7b29305cb67d22ef0bb08b067c422381f48",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 61.54,
      "commitsBetweenForRepo": 417,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n   private boolean readReplicasFromCache(ReplicaMap volumeMap,\n       final RamDiskReplicaTracker lazyWriteReplicaMap) {\n     ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new AutoCloseableLock());\n     File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n     // Check whether the file exists or not.\n     if (!replicaFile.exists()) {\n       LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n           \" doesn\u0027t exist \");\n       return false;\n     }\n     long fileLastModifiedTime \u003d replicaFile.lastModified();\n     if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n       LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n           \" has gone stale\");\n       // Just to make findbugs happy\n       if (!replicaFile.delete()) {\n         LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n             \" cannot be deleted\");\n       }\n       return false;\n     }\n     FileInputStream inputStream \u003d null;\n     try {\n       inputStream \u003d fileIoProvider.getFileInputStream(volume, replicaFile);\n       BlockListAsLongs blocksList \u003d\n           BlockListAsLongs.readFrom(inputStream, maxDataLength);\n       if (blocksList \u003d\u003d null) {\n         return false;\n       }\n \n       for (BlockReportReplica replica : blocksList) {\n         switch (replica.getState()) {\n         case FINALIZED:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n           break;\n         case RUR:\n         case RBW:\n         case RWR:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n           break;\n         default:\n           break;\n         }\n       }\n-      inputStream.close();\n       // Now it is safe to add the replica into volumeMap\n       // In case of any exception during parsing this cache file, fall back\n       // to scan all the files on disk.\n       for (Iterator\u003cReplicaInfo\u003e iter \u003d\n           tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n         ReplicaInfo info \u003d iter.next();\n         // We use a lightweight GSet to store replicaInfo, we need to remove\n         // it from one GSet before adding to another.\n         iter.remove();\n         volumeMap.add(bpid, info);\n       }\n       LOG.info(\"Successfully read replica from cache file : \"\n           + replicaFile.getPath());\n       return true;\n     } catch (Exception e) {\n       // Any exception we need to revert back to read from disk\n       // Log the error and return false\n       LOG.info(\"Exception occurred while reading the replicas cache file: \"\n           + replicaFile.getPath(), e );\n       return false;\n     }\n     finally {\n+      // close the inputStream\n+      IOUtils.closeStream(inputStream);\n+\n       if (!fileIoProvider.delete(volume, replicaFile)) {\n         LOG.info(\"Failed to delete replica cache file: \" +\n             replicaFile.getPath());\n       }\n-      // close the inputStream\n-      IOUtils.closeStream(inputStream);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean readReplicasFromCache(ReplicaMap volumeMap,\n      final RamDiskReplicaTracker lazyWriteReplicaMap) {\n    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new AutoCloseableLock());\n    File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n    // Check whether the file exists or not.\n    if (!replicaFile.exists()) {\n      LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n          \" doesn\u0027t exist \");\n      return false;\n    }\n    long fileLastModifiedTime \u003d replicaFile.lastModified();\n    if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n      LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n          \" has gone stale\");\n      // Just to make findbugs happy\n      if (!replicaFile.delete()) {\n        LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n            \" cannot be deleted\");\n      }\n      return false;\n    }\n    FileInputStream inputStream \u003d null;\n    try {\n      inputStream \u003d fileIoProvider.getFileInputStream(volume, replicaFile);\n      BlockListAsLongs blocksList \u003d\n          BlockListAsLongs.readFrom(inputStream, maxDataLength);\n      if (blocksList \u003d\u003d null) {\n        return false;\n      }\n\n      for (BlockReportReplica replica : blocksList) {\n        switch (replica.getState()) {\n        case FINALIZED:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n          break;\n        case RUR:\n        case RBW:\n        case RWR:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n          break;\n        default:\n          break;\n        }\n      }\n      // Now it is safe to add the replica into volumeMap\n      // In case of any exception during parsing this cache file, fall back\n      // to scan all the files on disk.\n      for (Iterator\u003cReplicaInfo\u003e iter \u003d\n          tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n        ReplicaInfo info \u003d iter.next();\n        // We use a lightweight GSet to store replicaInfo, we need to remove\n        // it from one GSet before adding to another.\n        iter.remove();\n        volumeMap.add(bpid, info);\n      }\n      LOG.info(\"Successfully read replica from cache file : \"\n          + replicaFile.getPath());\n      return true;\n    } catch (Exception e) {\n      // Any exception we need to revert back to read from disk\n      // Log the error and return false\n      LOG.info(\"Exception occurred while reading the replicas cache file: \"\n          + replicaFile.getPath(), e );\n      return false;\n    }\n    finally {\n      // close the inputStream\n      IOUtils.closeStream(inputStream);\n\n      if (!fileIoProvider.delete(volume, replicaFile)) {\n        LOG.info(\"Failed to delete replica cache file: \" +\n            replicaFile.getPath());\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice.java",
      "extendedDetails": {}
    },
    "6eba79232f36b36e0196163adc8fe4219a6b6bf9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14271. Correct spelling of \u0027occurred\u0027 and variants. Contributed by Yeliang Cang\n",
      "commitDate": "03/04/17 8:13 PM",
      "commitName": "6eba79232f36b36e0196163adc8fe4219a6b6bf9",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "28/12/16 10:08 PM",
      "commitNameOld": "603f3ef1386048111940b66f3a0750ab84d0588f",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 95.88,
      "commitsBetweenForRepo": 509,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n   private boolean readReplicasFromCache(ReplicaMap volumeMap,\n       final RamDiskReplicaTracker lazyWriteReplicaMap) {\n     ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new AutoCloseableLock());\n     File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n     // Check whether the file exists or not.\n     if (!replicaFile.exists()) {\n       LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n           \" doesn\u0027t exist \");\n       return false;\n     }\n     long fileLastModifiedTime \u003d replicaFile.lastModified();\n     if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n       LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n           \" has gone stale\");\n       // Just to make findbugs happy\n       if (!replicaFile.delete()) {\n         LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n             \" cannot be deleted\");\n       }\n       return false;\n     }\n     FileInputStream inputStream \u003d null;\n     try {\n       inputStream \u003d fileIoProvider.getFileInputStream(volume, replicaFile);\n       BlockListAsLongs blocksList \u003d\n           BlockListAsLongs.readFrom(inputStream, maxDataLength);\n       if (blocksList \u003d\u003d null) {\n         return false;\n       }\n \n       for (BlockReportReplica replica : blocksList) {\n         switch (replica.getState()) {\n         case FINALIZED:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n           break;\n         case RUR:\n         case RBW:\n         case RWR:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n           break;\n         default:\n           break;\n         }\n       }\n       inputStream.close();\n       // Now it is safe to add the replica into volumeMap\n       // In case of any exception during parsing this cache file, fall back\n       // to scan all the files on disk.\n       for (Iterator\u003cReplicaInfo\u003e iter \u003d\n           tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n         ReplicaInfo info \u003d iter.next();\n         // We use a lightweight GSet to store replicaInfo, we need to remove\n         // it from one GSet before adding to another.\n         iter.remove();\n         volumeMap.add(bpid, info);\n       }\n       LOG.info(\"Successfully read replica from cache file : \"\n           + replicaFile.getPath());\n       return true;\n     } catch (Exception e) {\n       // Any exception we need to revert back to read from disk\n       // Log the error and return false\n-      LOG.info(\"Exception occured while reading the replicas cache file: \"\n+      LOG.info(\"Exception occurred while reading the replicas cache file: \"\n           + replicaFile.getPath(), e );\n       return false;\n     }\n     finally {\n       if (!fileIoProvider.delete(volume, replicaFile)) {\n         LOG.info(\"Failed to delete replica cache file: \" +\n             replicaFile.getPath());\n       }\n       // close the inputStream\n       IOUtils.closeStream(inputStream);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean readReplicasFromCache(ReplicaMap volumeMap,\n      final RamDiskReplicaTracker lazyWriteReplicaMap) {\n    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new AutoCloseableLock());\n    File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n    // Check whether the file exists or not.\n    if (!replicaFile.exists()) {\n      LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n          \" doesn\u0027t exist \");\n      return false;\n    }\n    long fileLastModifiedTime \u003d replicaFile.lastModified();\n    if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n      LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n          \" has gone stale\");\n      // Just to make findbugs happy\n      if (!replicaFile.delete()) {\n        LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n            \" cannot be deleted\");\n      }\n      return false;\n    }\n    FileInputStream inputStream \u003d null;\n    try {\n      inputStream \u003d fileIoProvider.getFileInputStream(volume, replicaFile);\n      BlockListAsLongs blocksList \u003d\n          BlockListAsLongs.readFrom(inputStream, maxDataLength);\n      if (blocksList \u003d\u003d null) {\n        return false;\n      }\n\n      for (BlockReportReplica replica : blocksList) {\n        switch (replica.getState()) {\n        case FINALIZED:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n          break;\n        case RUR:\n        case RBW:\n        case RWR:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n          break;\n        default:\n          break;\n        }\n      }\n      inputStream.close();\n      // Now it is safe to add the replica into volumeMap\n      // In case of any exception during parsing this cache file, fall back\n      // to scan all the files on disk.\n      for (Iterator\u003cReplicaInfo\u003e iter \u003d\n          tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n        ReplicaInfo info \u003d iter.next();\n        // We use a lightweight GSet to store replicaInfo, we need to remove\n        // it from one GSet before adding to another.\n        iter.remove();\n        volumeMap.add(bpid, info);\n      }\n      LOG.info(\"Successfully read replica from cache file : \"\n          + replicaFile.getPath());\n      return true;\n    } catch (Exception e) {\n      // Any exception we need to revert back to read from disk\n      // Log the error and return false\n      LOG.info(\"Exception occurred while reading the replicas cache file: \"\n          + replicaFile.getPath(), e );\n      return false;\n    }\n    finally {\n      if (!fileIoProvider.delete(volume, replicaFile)) {\n        LOG.info(\"Failed to delete replica cache file: \" +\n            replicaFile.getPath());\n      }\n      // close the inputStream\n      IOUtils.closeStream(inputStream);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice.java",
      "extendedDetails": {}
    },
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10958. Add instrumentation hooks around Datanode disk IO.\n",
      "commitDate": "14/12/16 11:18 AM",
      "commitName": "6ba9587d370fbf39c129c08c00ebbb894ccc1389",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "06/12/16 11:05 AM",
      "commitNameOld": "df983b524ab68ea0c70cee9033bfff2d28052cbf",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 8.01,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,75 @@\n   private boolean readReplicasFromCache(ReplicaMap volumeMap,\n       final RamDiskReplicaTracker lazyWriteReplicaMap) {\n     ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new AutoCloseableLock());\n     File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n     // Check whether the file exists or not.\n     if (!replicaFile.exists()) {\n       LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n           \" doesn\u0027t exist \");\n       return false;\n     }\n     long fileLastModifiedTime \u003d replicaFile.lastModified();\n     if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n       LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n           \" has gone stale\");\n       // Just to make findbugs happy\n       if (!replicaFile.delete()) {\n         LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n             \" cannot be deleted\");\n       }\n       return false;\n     }\n     FileInputStream inputStream \u003d null;\n     try {\n-      inputStream \u003d new FileInputStream(replicaFile);\n+      inputStream \u003d fileIoProvider.getFileInputStream(volume, replicaFile);\n       BlockListAsLongs blocksList \u003d\n           BlockListAsLongs.readFrom(inputStream, maxDataLength);\n-      Iterator\u003cBlockReportReplica\u003e iterator \u003d blocksList.iterator();\n-      while (iterator.hasNext()) {\n-        BlockReportReplica replica \u003d iterator.next();\n+      if (blocksList \u003d\u003d null) {\n+        return false;\n+      }\n+\n+      for (BlockReportReplica replica : blocksList) {\n         switch (replica.getState()) {\n         case FINALIZED:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n           break;\n         case RUR:\n         case RBW:\n         case RWR:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n           break;\n         default:\n           break;\n         }\n       }\n       inputStream.close();\n       // Now it is safe to add the replica into volumeMap\n       // In case of any exception during parsing this cache file, fall back\n       // to scan all the files on disk.\n       for (Iterator\u003cReplicaInfo\u003e iter \u003d\n           tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n         ReplicaInfo info \u003d iter.next();\n         // We use a lightweight GSet to store replicaInfo, we need to remove\n         // it from one GSet before adding to another.\n         iter.remove();\n         volumeMap.add(bpid, info);\n       }\n       LOG.info(\"Successfully read replica from cache file : \"\n           + replicaFile.getPath());\n       return true;\n     } catch (Exception e) {\n       // Any exception we need to revert back to read from disk\n       // Log the error and return false\n       LOG.info(\"Exception occured while reading the replicas cache file: \"\n           + replicaFile.getPath(), e );\n       return false;\n     }\n     finally {\n-      if (!replicaFile.delete()) {\n+      if (!fileIoProvider.delete(volume, replicaFile)) {\n         LOG.info(\"Failed to delete replica cache file: \" +\n             replicaFile.getPath());\n       }\n       // close the inputStream\n       IOUtils.closeStream(inputStream);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean readReplicasFromCache(ReplicaMap volumeMap,\n      final RamDiskReplicaTracker lazyWriteReplicaMap) {\n    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new AutoCloseableLock());\n    File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n    // Check whether the file exists or not.\n    if (!replicaFile.exists()) {\n      LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n          \" doesn\u0027t exist \");\n      return false;\n    }\n    long fileLastModifiedTime \u003d replicaFile.lastModified();\n    if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n      LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n          \" has gone stale\");\n      // Just to make findbugs happy\n      if (!replicaFile.delete()) {\n        LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n            \" cannot be deleted\");\n      }\n      return false;\n    }\n    FileInputStream inputStream \u003d null;\n    try {\n      inputStream \u003d fileIoProvider.getFileInputStream(volume, replicaFile);\n      BlockListAsLongs blocksList \u003d\n          BlockListAsLongs.readFrom(inputStream, maxDataLength);\n      if (blocksList \u003d\u003d null) {\n        return false;\n      }\n\n      for (BlockReportReplica replica : blocksList) {\n        switch (replica.getState()) {\n        case FINALIZED:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n          break;\n        case RUR:\n        case RBW:\n        case RWR:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n          break;\n        default:\n          break;\n        }\n      }\n      inputStream.close();\n      // Now it is safe to add the replica into volumeMap\n      // In case of any exception during parsing this cache file, fall back\n      // to scan all the files on disk.\n      for (Iterator\u003cReplicaInfo\u003e iter \u003d\n          tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n        ReplicaInfo info \u003d iter.next();\n        // We use a lightweight GSet to store replicaInfo, we need to remove\n        // it from one GSet before adding to another.\n        iter.remove();\n        volumeMap.add(bpid, info);\n      }\n      LOG.info(\"Successfully read replica from cache file : \"\n          + replicaFile.getPath());\n      return true;\n    } catch (Exception e) {\n      // Any exception we need to revert back to read from disk\n      // Log the error and return false\n      LOG.info(\"Exception occured while reading the replicas cache file: \"\n          + replicaFile.getPath(), e );\n      return false;\n    }\n    finally {\n      if (!fileIoProvider.delete(volume, replicaFile)) {\n        LOG.info(\"Failed to delete replica cache file: \" +\n            replicaFile.getPath());\n      }\n      // close the inputStream\n      IOUtils.closeStream(inputStream);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice.java",
      "extendedDetails": {}
    },
    "1b5cceaffbdde50a87ede81552dc380832db8e79": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-11201. Spelling errors in the logging, help, assertions and exception messages. Contributed by Grant Sohn.\"\n\nThis reverts commit b9522e86a55564c2ccb5ca3f1ca871965cbe74de.\n",
      "commitDate": "05/12/16 10:54 AM",
      "commitName": "1b5cceaffbdde50a87ede81552dc380832db8e79",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "05/12/16 10:48 AM",
      "commitNameOld": "b9522e86a55564c2ccb5ca3f1ca871965cbe74de",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private boolean readReplicasFromCache(ReplicaMap volumeMap,\n       final RamDiskReplicaTracker lazyWriteReplicaMap) {\n     ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new AutoCloseableLock());\n     File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n     // Check whether the file exists or not.\n     if (!replicaFile.exists()) {\n       LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n           \" doesn\u0027t exist \");\n       return false;\n     }\n     long fileLastModifiedTime \u003d replicaFile.lastModified();\n     if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n       LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n           \" has gone stale\");\n       // Just to make findbugs happy\n       if (!replicaFile.delete()) {\n         LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n             \" cannot be deleted\");\n       }\n       return false;\n     }\n     FileInputStream inputStream \u003d null;\n     try {\n       inputStream \u003d new FileInputStream(replicaFile);\n       BlockListAsLongs blocksList \u003d\n           BlockListAsLongs.readFrom(inputStream, maxDataLength);\n       Iterator\u003cBlockReportReplica\u003e iterator \u003d blocksList.iterator();\n       while (iterator.hasNext()) {\n         BlockReportReplica replica \u003d iterator.next();\n         switch (replica.getState()) {\n         case FINALIZED:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n           break;\n         case RUR:\n         case RBW:\n         case RWR:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n           break;\n         default:\n           break;\n         }\n       }\n       inputStream.close();\n       // Now it is safe to add the replica into volumeMap\n       // In case of any exception during parsing this cache file, fall back\n       // to scan all the files on disk.\n       for (Iterator\u003cReplicaInfo\u003e iter \u003d\n           tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n         ReplicaInfo info \u003d iter.next();\n         // We use a lightweight GSet to store replicaInfo, we need to remove\n         // it from one GSet before adding to another.\n         iter.remove();\n         volumeMap.add(bpid, info);\n       }\n       LOG.info(\"Successfully read replica from cache file : \"\n           + replicaFile.getPath());\n       return true;\n     } catch (Exception e) {\n       // Any exception we need to revert back to read from disk\n       // Log the error and return false\n-      LOG.info(\"Exception occurred while reading the replicas cache file: \"\n+      LOG.info(\"Exception occured while reading the replicas cache file: \"\n           + replicaFile.getPath(), e );\n       return false;\n     }\n     finally {\n       if (!replicaFile.delete()) {\n         LOG.info(\"Failed to delete replica cache file: \" +\n             replicaFile.getPath());\n       }\n       // close the inputStream\n       IOUtils.closeStream(inputStream);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean readReplicasFromCache(ReplicaMap volumeMap,\n      final RamDiskReplicaTracker lazyWriteReplicaMap) {\n    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new AutoCloseableLock());\n    File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n    // Check whether the file exists or not.\n    if (!replicaFile.exists()) {\n      LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n          \" doesn\u0027t exist \");\n      return false;\n    }\n    long fileLastModifiedTime \u003d replicaFile.lastModified();\n    if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n      LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n          \" has gone stale\");\n      // Just to make findbugs happy\n      if (!replicaFile.delete()) {\n        LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n            \" cannot be deleted\");\n      }\n      return false;\n    }\n    FileInputStream inputStream \u003d null;\n    try {\n      inputStream \u003d new FileInputStream(replicaFile);\n      BlockListAsLongs blocksList \u003d\n          BlockListAsLongs.readFrom(inputStream, maxDataLength);\n      Iterator\u003cBlockReportReplica\u003e iterator \u003d blocksList.iterator();\n      while (iterator.hasNext()) {\n        BlockReportReplica replica \u003d iterator.next();\n        switch (replica.getState()) {\n        case FINALIZED:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n          break;\n        case RUR:\n        case RBW:\n        case RWR:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n          break;\n        default:\n          break;\n        }\n      }\n      inputStream.close();\n      // Now it is safe to add the replica into volumeMap\n      // In case of any exception during parsing this cache file, fall back\n      // to scan all the files on disk.\n      for (Iterator\u003cReplicaInfo\u003e iter \u003d\n          tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n        ReplicaInfo info \u003d iter.next();\n        // We use a lightweight GSet to store replicaInfo, we need to remove\n        // it from one GSet before adding to another.\n        iter.remove();\n        volumeMap.add(bpid, info);\n      }\n      LOG.info(\"Successfully read replica from cache file : \"\n          + replicaFile.getPath());\n      return true;\n    } catch (Exception e) {\n      // Any exception we need to revert back to read from disk\n      // Log the error and return false\n      LOG.info(\"Exception occured while reading the replicas cache file: \"\n          + replicaFile.getPath(), e );\n      return false;\n    }\n    finally {\n      if (!replicaFile.delete()) {\n        LOG.info(\"Failed to delete replica cache file: \" +\n            replicaFile.getPath());\n      }\n      // close the inputStream\n      IOUtils.closeStream(inputStream);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice.java",
      "extendedDetails": {}
    },
    "b9522e86a55564c2ccb5ca3f1ca871965cbe74de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11201. Spelling errors in the logging, help, assertions and exception messages. Contributed by Grant Sohn.\n",
      "commitDate": "05/12/16 10:48 AM",
      "commitName": "b9522e86a55564c2ccb5ca3f1ca871965cbe74de",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "29/11/16 8:52 PM",
      "commitNameOld": "aeecfa24f4fb6af289920cbf8830c394e66bd78e",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 5.58,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private boolean readReplicasFromCache(ReplicaMap volumeMap,\n       final RamDiskReplicaTracker lazyWriteReplicaMap) {\n     ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new AutoCloseableLock());\n     File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n     // Check whether the file exists or not.\n     if (!replicaFile.exists()) {\n       LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n           \" doesn\u0027t exist \");\n       return false;\n     }\n     long fileLastModifiedTime \u003d replicaFile.lastModified();\n     if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n       LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n           \" has gone stale\");\n       // Just to make findbugs happy\n       if (!replicaFile.delete()) {\n         LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n             \" cannot be deleted\");\n       }\n       return false;\n     }\n     FileInputStream inputStream \u003d null;\n     try {\n       inputStream \u003d new FileInputStream(replicaFile);\n       BlockListAsLongs blocksList \u003d\n           BlockListAsLongs.readFrom(inputStream, maxDataLength);\n       Iterator\u003cBlockReportReplica\u003e iterator \u003d blocksList.iterator();\n       while (iterator.hasNext()) {\n         BlockReportReplica replica \u003d iterator.next();\n         switch (replica.getState()) {\n         case FINALIZED:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n           break;\n         case RUR:\n         case RBW:\n         case RWR:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n           break;\n         default:\n           break;\n         }\n       }\n       inputStream.close();\n       // Now it is safe to add the replica into volumeMap\n       // In case of any exception during parsing this cache file, fall back\n       // to scan all the files on disk.\n       for (Iterator\u003cReplicaInfo\u003e iter \u003d\n           tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n         ReplicaInfo info \u003d iter.next();\n         // We use a lightweight GSet to store replicaInfo, we need to remove\n         // it from one GSet before adding to another.\n         iter.remove();\n         volumeMap.add(bpid, info);\n       }\n       LOG.info(\"Successfully read replica from cache file : \"\n           + replicaFile.getPath());\n       return true;\n     } catch (Exception e) {\n       // Any exception we need to revert back to read from disk\n       // Log the error and return false\n-      LOG.info(\"Exception occured while reading the replicas cache file: \"\n+      LOG.info(\"Exception occurred while reading the replicas cache file: \"\n           + replicaFile.getPath(), e );\n       return false;\n     }\n     finally {\n       if (!replicaFile.delete()) {\n         LOG.info(\"Failed to delete replica cache file: \" +\n             replicaFile.getPath());\n       }\n       // close the inputStream\n       IOUtils.closeStream(inputStream);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean readReplicasFromCache(ReplicaMap volumeMap,\n      final RamDiskReplicaTracker lazyWriteReplicaMap) {\n    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new AutoCloseableLock());\n    File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n    // Check whether the file exists or not.\n    if (!replicaFile.exists()) {\n      LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n          \" doesn\u0027t exist \");\n      return false;\n    }\n    long fileLastModifiedTime \u003d replicaFile.lastModified();\n    if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n      LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n          \" has gone stale\");\n      // Just to make findbugs happy\n      if (!replicaFile.delete()) {\n        LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n            \" cannot be deleted\");\n      }\n      return false;\n    }\n    FileInputStream inputStream \u003d null;\n    try {\n      inputStream \u003d new FileInputStream(replicaFile);\n      BlockListAsLongs blocksList \u003d\n          BlockListAsLongs.readFrom(inputStream, maxDataLength);\n      Iterator\u003cBlockReportReplica\u003e iterator \u003d blocksList.iterator();\n      while (iterator.hasNext()) {\n        BlockReportReplica replica \u003d iterator.next();\n        switch (replica.getState()) {\n        case FINALIZED:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n          break;\n        case RUR:\n        case RBW:\n        case RWR:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n          break;\n        default:\n          break;\n        }\n      }\n      inputStream.close();\n      // Now it is safe to add the replica into volumeMap\n      // In case of any exception during parsing this cache file, fall back\n      // to scan all the files on disk.\n      for (Iterator\u003cReplicaInfo\u003e iter \u003d\n          tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n        ReplicaInfo info \u003d iter.next();\n        // We use a lightweight GSet to store replicaInfo, we need to remove\n        // it from one GSet before adding to another.\n        iter.remove();\n        volumeMap.add(bpid, info);\n      }\n      LOG.info(\"Successfully read replica from cache file : \"\n          + replicaFile.getPath());\n      return true;\n    } catch (Exception e) {\n      // Any exception we need to revert back to read from disk\n      // Log the error and return false\n      LOG.info(\"Exception occurred while reading the replicas cache file: \"\n          + replicaFile.getPath(), e );\n      return false;\n    }\n    finally {\n      if (!replicaFile.delete()) {\n        LOG.info(\"Failed to delete replica cache file: \" +\n            replicaFile.getPath());\n      }\n      // close the inputStream\n      IOUtils.closeStream(inputStream);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice.java",
      "extendedDetails": {}
    },
    "8ae4729107d33c6001cf1fdc8837afb71ea6c0d3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10828. Fix usage of FsDatasetImpl object lock in ReplicaMap. (Arpit Agarwal)\n",
      "commitDate": "27/09/16 10:02 AM",
      "commitName": "8ae4729107d33c6001cf1fdc8837afb71ea6c0d3",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "13/09/16 12:54 PM",
      "commitNameOld": "86c9862bec0248d671e657aa56094a2919b8ac14",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 13.88,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private boolean readReplicasFromCache(ReplicaMap volumeMap,\n       final RamDiskReplicaTracker lazyWriteReplicaMap) {\n-    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(this);\n+    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new AutoCloseableLock());\n     File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n     // Check whether the file exists or not.\n     if (!replicaFile.exists()) {\n       LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n           \" doesn\u0027t exist \");\n       return false;\n     }\n     long fileLastModifiedTime \u003d replicaFile.lastModified();\n     if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n       LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n           \" has gone stale\");\n       // Just to make findbugs happy\n       if (!replicaFile.delete()) {\n         LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n             \" cannot be deleted\");\n       }\n       return false;\n     }\n     FileInputStream inputStream \u003d null;\n     try {\n       inputStream \u003d new FileInputStream(replicaFile);\n       BlockListAsLongs blocksList \u003d\n           BlockListAsLongs.readFrom(inputStream, maxDataLength);\n       Iterator\u003cBlockReportReplica\u003e iterator \u003d blocksList.iterator();\n       while (iterator.hasNext()) {\n         BlockReportReplica replica \u003d iterator.next();\n         switch (replica.getState()) {\n         case FINALIZED:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n           break;\n         case RUR:\n         case RBW:\n         case RWR:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n           break;\n         default:\n           break;\n         }\n       }\n       inputStream.close();\n       // Now it is safe to add the replica into volumeMap\n       // In case of any exception during parsing this cache file, fall back\n       // to scan all the files on disk.\n       for (Iterator\u003cReplicaInfo\u003e iter \u003d\n           tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n         ReplicaInfo info \u003d iter.next();\n         // We use a lightweight GSet to store replicaInfo, we need to remove\n         // it from one GSet before adding to another.\n         iter.remove();\n         volumeMap.add(bpid, info);\n       }\n       LOG.info(\"Successfully read replica from cache file : \"\n           + replicaFile.getPath());\n       return true;\n     } catch (Exception e) {\n       // Any exception we need to revert back to read from disk\n       // Log the error and return false\n       LOG.info(\"Exception occured while reading the replicas cache file: \"\n           + replicaFile.getPath(), e );\n       return false;\n     }\n     finally {\n       if (!replicaFile.delete()) {\n         LOG.info(\"Failed to delete replica cache file: \" +\n             replicaFile.getPath());\n       }\n       // close the inputStream\n       IOUtils.closeStream(inputStream);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean readReplicasFromCache(ReplicaMap volumeMap,\n      final RamDiskReplicaTracker lazyWriteReplicaMap) {\n    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(new AutoCloseableLock());\n    File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n    // Check whether the file exists or not.\n    if (!replicaFile.exists()) {\n      LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n          \" doesn\u0027t exist \");\n      return false;\n    }\n    long fileLastModifiedTime \u003d replicaFile.lastModified();\n    if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n      LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n          \" has gone stale\");\n      // Just to make findbugs happy\n      if (!replicaFile.delete()) {\n        LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n            \" cannot be deleted\");\n      }\n      return false;\n    }\n    FileInputStream inputStream \u003d null;\n    try {\n      inputStream \u003d new FileInputStream(replicaFile);\n      BlockListAsLongs blocksList \u003d\n          BlockListAsLongs.readFrom(inputStream, maxDataLength);\n      Iterator\u003cBlockReportReplica\u003e iterator \u003d blocksList.iterator();\n      while (iterator.hasNext()) {\n        BlockReportReplica replica \u003d iterator.next();\n        switch (replica.getState()) {\n        case FINALIZED:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n          break;\n        case RUR:\n        case RBW:\n        case RWR:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n          break;\n        default:\n          break;\n        }\n      }\n      inputStream.close();\n      // Now it is safe to add the replica into volumeMap\n      // In case of any exception during parsing this cache file, fall back\n      // to scan all the files on disk.\n      for (Iterator\u003cReplicaInfo\u003e iter \u003d\n          tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n        ReplicaInfo info \u003d iter.next();\n        // We use a lightweight GSet to store replicaInfo, we need to remove\n        // it from one GSet before adding to another.\n        iter.remove();\n        volumeMap.add(bpid, info);\n      }\n      LOG.info(\"Successfully read replica from cache file : \"\n          + replicaFile.getPath());\n      return true;\n    } catch (Exception e) {\n      // Any exception we need to revert back to read from disk\n      // Log the error and return false\n      LOG.info(\"Exception occured while reading the replicas cache file: \"\n          + replicaFile.getPath(), e );\n      return false;\n    }\n    finally {\n      if (!replicaFile.delete()) {\n        LOG.info(\"Failed to delete replica cache file: \" +\n            replicaFile.getPath());\n      }\n      // close the inputStream\n      IOUtils.closeStream(inputStream);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice.java",
      "extendedDetails": {}
    },
    "63ac2db59af2b50e74dc892cae1dbc4d2e061423": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10312. Large block reports may fail to decode at NameNode due to 64 MB protobuf maximum length restriction. Contributed by Chris Nauroth.\n",
      "commitDate": "20/04/16 1:39 PM",
      "commitName": "63ac2db59af2b50e74dc892cae1dbc4d2e061423",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "12/04/16 4:28 PM",
      "commitNameOld": "35f07705552ef5636f8b8d2599a6af5ec1426203",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 7.88,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,73 @@\n   private boolean readReplicasFromCache(ReplicaMap volumeMap,\n       final RamDiskReplicaTracker lazyWriteReplicaMap) {\n     ReplicaMap tmpReplicaMap \u003d new ReplicaMap(this);\n     File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n     // Check whether the file exists or not.\n     if (!replicaFile.exists()) {\n       LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n           \" doesn\u0027t exist \");\n       return false;\n     }\n     long fileLastModifiedTime \u003d replicaFile.lastModified();\n     if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n       LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n           \" has gone stale\");\n       // Just to make findbugs happy\n       if (!replicaFile.delete()) {\n         LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n             \" cannot be deleted\");\n       }\n       return false;\n     }\n     FileInputStream inputStream \u003d null;\n     try {\n       inputStream \u003d new FileInputStream(replicaFile);\n-      BlockListAsLongs blocksList \u003d  BlockListAsLongs.readFrom(inputStream);\n+      BlockListAsLongs blocksList \u003d\n+          BlockListAsLongs.readFrom(inputStream, maxDataLength);\n       Iterator\u003cBlockReportReplica\u003e iterator \u003d blocksList.iterator();\n       while (iterator.hasNext()) {\n         BlockReportReplica replica \u003d iterator.next();\n         switch (replica.getState()) {\n         case FINALIZED:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n           break;\n         case RUR:\n         case RBW:\n         case RWR:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n           break;\n         default:\n           break;\n         }\n       }\n       inputStream.close();\n       // Now it is safe to add the replica into volumeMap\n       // In case of any exception during parsing this cache file, fall back\n       // to scan all the files on disk.\n       for (Iterator\u003cReplicaInfo\u003e iter \u003d\n           tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n         ReplicaInfo info \u003d iter.next();\n         // We use a lightweight GSet to store replicaInfo, we need to remove\n         // it from one GSet before adding to another.\n         iter.remove();\n         volumeMap.add(bpid, info);\n       }\n       LOG.info(\"Successfully read replica from cache file : \"\n           + replicaFile.getPath());\n       return true;\n     } catch (Exception e) {\n       // Any exception we need to revert back to read from disk\n       // Log the error and return false\n       LOG.info(\"Exception occured while reading the replicas cache file: \"\n           + replicaFile.getPath(), e );\n       return false;\n     }\n     finally {\n       if (!replicaFile.delete()) {\n         LOG.info(\"Failed to delete replica cache file: \" +\n             replicaFile.getPath());\n       }\n       // close the inputStream\n       IOUtils.closeStream(inputStream);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean readReplicasFromCache(ReplicaMap volumeMap,\n      final RamDiskReplicaTracker lazyWriteReplicaMap) {\n    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(this);\n    File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n    // Check whether the file exists or not.\n    if (!replicaFile.exists()) {\n      LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() +\n          \" doesn\u0027t exist \");\n      return false;\n    }\n    long fileLastModifiedTime \u003d replicaFile.lastModified();\n    if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n      LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n          \" has gone stale\");\n      // Just to make findbugs happy\n      if (!replicaFile.delete()) {\n        LOG.info(\"Replica Cache file: \" + replicaFile.getPath() +\n            \" cannot be deleted\");\n      }\n      return false;\n    }\n    FileInputStream inputStream \u003d null;\n    try {\n      inputStream \u003d new FileInputStream(replicaFile);\n      BlockListAsLongs blocksList \u003d\n          BlockListAsLongs.readFrom(inputStream, maxDataLength);\n      Iterator\u003cBlockReportReplica\u003e iterator \u003d blocksList.iterator();\n      while (iterator.hasNext()) {\n        BlockReportReplica replica \u003d iterator.next();\n        switch (replica.getState()) {\n        case FINALIZED:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n          break;\n        case RUR:\n        case RBW:\n        case RWR:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n          break;\n        default:\n          break;\n        }\n      }\n      inputStream.close();\n      // Now it is safe to add the replica into volumeMap\n      // In case of any exception during parsing this cache file, fall back\n      // to scan all the files on disk.\n      for (Iterator\u003cReplicaInfo\u003e iter \u003d\n          tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n        ReplicaInfo info \u003d iter.next();\n        // We use a lightweight GSet to store replicaInfo, we need to remove\n        // it from one GSet before adding to another.\n        iter.remove();\n        volumeMap.add(bpid, info);\n      }\n      LOG.info(\"Successfully read replica from cache file : \"\n          + replicaFile.getPath());\n      return true;\n    } catch (Exception e) {\n      // Any exception we need to revert back to read from disk\n      // Log the error and return false\n      LOG.info(\"Exception occured while reading the replicas cache file: \"\n          + replicaFile.getPath(), e );\n      return false;\n    }\n    finally {\n      if (!replicaFile.delete()) {\n        LOG.info(\"Failed to delete replica cache file: \" +\n            replicaFile.getPath());\n      }\n      // close the inputStream\n      IOUtils.closeStream(inputStream);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice.java",
      "extendedDetails": {}
    },
    "d6fa34e014b0e2a61b24f05dd08ebe12354267fd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8859. Improve DataNode ReplicaMap memory footprint to save about 45%. (yliu)\n",
      "commitDate": "29/09/15 1:20 AM",
      "commitName": "d6fa34e014b0e2a61b24f05dd08ebe12354267fd",
      "commitAuthor": "yliu",
      "commitDateOld": "26/09/15 11:08 AM",
      "commitNameOld": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 2.59,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,72 @@\n   private boolean readReplicasFromCache(ReplicaMap volumeMap,\n       final RamDiskReplicaTracker lazyWriteReplicaMap) {\n     ReplicaMap tmpReplicaMap \u003d new ReplicaMap(this);\n     File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n     // Check whether the file exists or not.\n     if (!replicaFile.exists()) {\n       LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() + \n           \" doesn\u0027t exist \");\n       return false;\n     }\n     long fileLastModifiedTime \u003d replicaFile.lastModified();\n     if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n       LOG.info(\"Replica Cache file: \" + replicaFile.getPath() + \n           \" has gone stale\");\n       // Just to make findbugs happy\n       if (!replicaFile.delete()) {\n         LOG.info(\"Replica Cache file: \" + replicaFile.getPath() + \n             \" cannot be deleted\");\n       }\n       return false;\n     }\n     FileInputStream inputStream \u003d null;\n     try {\n       inputStream \u003d new FileInputStream(replicaFile);\n       BlockListAsLongs blocksList \u003d  BlockListAsLongs.readFrom(inputStream);\n       Iterator\u003cBlockReportReplica\u003e iterator \u003d blocksList.iterator();\n       while (iterator.hasNext()) {\n         BlockReportReplica replica \u003d iterator.next();\n         switch (replica.getState()) {\n         case FINALIZED:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n           break;\n         case RUR:\n         case RBW:\n         case RWR:\n           addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n           break;\n         default:\n           break;\n         }\n       }\n       inputStream.close();\n       // Now it is safe to add the replica into volumeMap\n       // In case of any exception during parsing this cache file, fall back\n       // to scan all the files on disk.\n-      for (ReplicaInfo info: tmpReplicaMap.replicas(bpid)) {\n+      for (Iterator\u003cReplicaInfo\u003e iter \u003d\n+          tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n+        ReplicaInfo info \u003d iter.next();\n+        // We use a lightweight GSet to store replicaInfo, we need to remove\n+        // it from one GSet before adding to another.\n+        iter.remove();\n         volumeMap.add(bpid, info);\n       }\n       LOG.info(\"Successfully read replica from cache file : \" \n           + replicaFile.getPath());\n       return true;\n     } catch (Exception e) {\n       // Any exception we need to revert back to read from disk\n       // Log the error and return false\n       LOG.info(\"Exception occured while reading the replicas cache file: \"\n           + replicaFile.getPath(), e );\n       return false;\n     }\n     finally {\n       if (!replicaFile.delete()) {\n         LOG.info(\"Failed to delete replica cache file: \" +\n             replicaFile.getPath());\n       }\n       // close the inputStream\n       IOUtils.closeStream(inputStream);\n     }\n   } \n\\ No newline at end of file\n",
      "actualSource": "  private boolean readReplicasFromCache(ReplicaMap volumeMap,\n      final RamDiskReplicaTracker lazyWriteReplicaMap) {\n    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(this);\n    File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n    // Check whether the file exists or not.\n    if (!replicaFile.exists()) {\n      LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() + \n          \" doesn\u0027t exist \");\n      return false;\n    }\n    long fileLastModifiedTime \u003d replicaFile.lastModified();\n    if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n      LOG.info(\"Replica Cache file: \" + replicaFile.getPath() + \n          \" has gone stale\");\n      // Just to make findbugs happy\n      if (!replicaFile.delete()) {\n        LOG.info(\"Replica Cache file: \" + replicaFile.getPath() + \n            \" cannot be deleted\");\n      }\n      return false;\n    }\n    FileInputStream inputStream \u003d null;\n    try {\n      inputStream \u003d new FileInputStream(replicaFile);\n      BlockListAsLongs blocksList \u003d  BlockListAsLongs.readFrom(inputStream);\n      Iterator\u003cBlockReportReplica\u003e iterator \u003d blocksList.iterator();\n      while (iterator.hasNext()) {\n        BlockReportReplica replica \u003d iterator.next();\n        switch (replica.getState()) {\n        case FINALIZED:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n          break;\n        case RUR:\n        case RBW:\n        case RWR:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n          break;\n        default:\n          break;\n        }\n      }\n      inputStream.close();\n      // Now it is safe to add the replica into volumeMap\n      // In case of any exception during parsing this cache file, fall back\n      // to scan all the files on disk.\n      for (Iterator\u003cReplicaInfo\u003e iter \u003d\n          tmpReplicaMap.replicas(bpid).iterator(); iter.hasNext(); ) {\n        ReplicaInfo info \u003d iter.next();\n        // We use a lightweight GSet to store replicaInfo, we need to remove\n        // it from one GSet before adding to another.\n        iter.remove();\n        volumeMap.add(bpid, info);\n      }\n      LOG.info(\"Successfully read replica from cache file : \" \n          + replicaFile.getPath());\n      return true;\n    } catch (Exception e) {\n      // Any exception we need to revert back to read from disk\n      // Log the error and return false\n      LOG.info(\"Exception occured while reading the replicas cache file: \"\n          + replicaFile.getPath(), e );\n      return false;\n    }\n    finally {\n      if (!replicaFile.delete()) {\n        LOG.info(\"Failed to delete replica cache file: \" +\n            replicaFile.getPath());\n      }\n      // close the inputStream\n      IOUtils.closeStream(inputStream);\n    }\n  } ",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice.java",
      "extendedDetails": {}
    },
    "fc1031af749435dc95efea6745b1b2300ce29446": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-7928. Scanning blocks from disk during rolling upgrade startup takes a lot of time if disks are busy. Contributed by Rushabh Shah.\n",
      "commitDate": "25/03/15 12:42 PM",
      "commitName": "fc1031af749435dc95efea6745b1b2300ce29446",
      "commitAuthor": "Kihwal Lee",
      "diff": "@@ -0,0 +1,67 @@\n+  private boolean readReplicasFromCache(ReplicaMap volumeMap,\n+      final RamDiskReplicaTracker lazyWriteReplicaMap) {\n+    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(this);\n+    File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n+    // Check whether the file exists or not.\n+    if (!replicaFile.exists()) {\n+      LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() + \n+          \" doesn\u0027t exist \");\n+      return false;\n+    }\n+    long fileLastModifiedTime \u003d replicaFile.lastModified();\n+    if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n+      LOG.info(\"Replica Cache file: \" + replicaFile.getPath() + \n+          \" has gone stale\");\n+      // Just to make findbugs happy\n+      if (!replicaFile.delete()) {\n+        LOG.info(\"Replica Cache file: \" + replicaFile.getPath() + \n+            \" cannot be deleted\");\n+      }\n+      return false;\n+    }\n+    FileInputStream inputStream \u003d null;\n+    try {\n+      inputStream \u003d new FileInputStream(replicaFile);\n+      BlockListAsLongs blocksList \u003d  BlockListAsLongs.readFrom(inputStream);\n+      Iterator\u003cBlockReportReplica\u003e iterator \u003d blocksList.iterator();\n+      while (iterator.hasNext()) {\n+        BlockReportReplica replica \u003d iterator.next();\n+        switch (replica.getState()) {\n+        case FINALIZED:\n+          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n+          break;\n+        case RUR:\n+        case RBW:\n+        case RWR:\n+          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n+          break;\n+        default:\n+          break;\n+        }\n+      }\n+      inputStream.close();\n+      // Now it is safe to add the replica into volumeMap\n+      // In case of any exception during parsing this cache file, fall back\n+      // to scan all the files on disk.\n+      for (ReplicaInfo info: tmpReplicaMap.replicas(bpid)) {\n+        volumeMap.add(bpid, info);\n+      }\n+      LOG.info(\"Successfully read replica from cache file : \" \n+          + replicaFile.getPath());\n+      return true;\n+    } catch (Exception e) {\n+      // Any exception we need to revert back to read from disk\n+      // Log the error and return false\n+      LOG.info(\"Exception occured while reading the replicas cache file: \"\n+          + replicaFile.getPath(), e );\n+      return false;\n+    }\n+    finally {\n+      if (!replicaFile.delete()) {\n+        LOG.info(\"Failed to delete replica cache file: \" +\n+            replicaFile.getPath());\n+      }\n+      // close the inputStream\n+      IOUtils.closeStream(inputStream);\n+    }\n+  } \n\\ No newline at end of file\n",
      "actualSource": "  private boolean readReplicasFromCache(ReplicaMap volumeMap,\n      final RamDiskReplicaTracker lazyWriteReplicaMap) {\n    ReplicaMap tmpReplicaMap \u003d new ReplicaMap(this);\n    File replicaFile \u003d new File(currentDir, REPLICA_CACHE_FILE);\n    // Check whether the file exists or not.\n    if (!replicaFile.exists()) {\n      LOG.info(\"Replica Cache file: \"+  replicaFile.getPath() + \n          \" doesn\u0027t exist \");\n      return false;\n    }\n    long fileLastModifiedTime \u003d replicaFile.lastModified();\n    if (System.currentTimeMillis() \u003e fileLastModifiedTime + replicaCacheExpiry) {\n      LOG.info(\"Replica Cache file: \" + replicaFile.getPath() + \n          \" has gone stale\");\n      // Just to make findbugs happy\n      if (!replicaFile.delete()) {\n        LOG.info(\"Replica Cache file: \" + replicaFile.getPath() + \n            \" cannot be deleted\");\n      }\n      return false;\n    }\n    FileInputStream inputStream \u003d null;\n    try {\n      inputStream \u003d new FileInputStream(replicaFile);\n      BlockListAsLongs blocksList \u003d  BlockListAsLongs.readFrom(inputStream);\n      Iterator\u003cBlockReportReplica\u003e iterator \u003d blocksList.iterator();\n      while (iterator.hasNext()) {\n        BlockReportReplica replica \u003d iterator.next();\n        switch (replica.getState()) {\n        case FINALIZED:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, true);\n          break;\n        case RUR:\n        case RBW:\n        case RWR:\n          addReplicaToReplicasMap(replica, tmpReplicaMap, lazyWriteReplicaMap, false);\n          break;\n        default:\n          break;\n        }\n      }\n      inputStream.close();\n      // Now it is safe to add the replica into volumeMap\n      // In case of any exception during parsing this cache file, fall back\n      // to scan all the files on disk.\n      for (ReplicaInfo info: tmpReplicaMap.replicas(bpid)) {\n        volumeMap.add(bpid, info);\n      }\n      LOG.info(\"Successfully read replica from cache file : \" \n          + replicaFile.getPath());\n      return true;\n    } catch (Exception e) {\n      // Any exception we need to revert back to read from disk\n      // Log the error and return false\n      LOG.info(\"Exception occured while reading the replicas cache file: \"\n          + replicaFile.getPath(), e );\n      return false;\n    }\n    finally {\n      if (!replicaFile.delete()) {\n        LOG.info(\"Failed to delete replica cache file: \" +\n            replicaFile.getPath());\n      }\n      // close the inputStream\n      IOUtils.closeStream(inputStream);\n    }\n  } ",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/BlockPoolSlice.java"
    }
  }
}