{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LogAggregationIndexedFileController.java",
  "functionName": "loadIndexedLogsMeta",
  "functionId": "loadIndexedLogsMeta___remoteLogPath-Path__end-long__appId-ApplicationId",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
  "functionStartLine": 846,
  "functionEndLine": 902,
  "numCommitsSeen": 21,
  "timeTaken": 3493,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "b779f4f0f614fe47e05bc2be5494cf3cbcf6f63c",
    "d4c98579e36df7eeb788352d7b76cd2c7448c511",
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "b779f4f0f614fe47e05bc2be5494cf3cbcf6f63c": "Ybodychange",
    "d4c98579e36df7eeb788352d7b76cd2c7448c511": "Ymultichange(Yparameterchange,Ybodychange)",
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "30/07/18 10:55 AM",
      "commitNameOld": "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 228.23,
      "commitsBetweenForRepo": 1861,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,57 @@\n   public IndexedLogsMeta loadIndexedLogsMeta(Path remoteLogPath, long end,\n       ApplicationId appId) throws IOException {\n     FileContext fileContext \u003d\n         FileContext.getFileContext(remoteLogPath.toUri(), conf);\n     FSDataInputStream fsDataIStream \u003d null;\n     try {\n       fsDataIStream \u003d fileContext.open(remoteLogPath);\n       if (end \u003d\u003d 0) {\n         return null;\n       }\n       long fileLength \u003d end \u003c 0 ? fileContext.getFileStatus(\n           remoteLogPath).getLen() : end;\n \n       fsDataIStream.seek(fileLength - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n       int offset \u003d fsDataIStream.readInt();\n       // If the offset/log meta size is larger than 64M,\n       // output a warn message for better debug.\n       if (offset \u003e 64 * 1024 * 1024) {\n         LOG.warn(\"The log meta size read from \" + remoteLogPath\n             + \" is \" + offset);\n       }\n \n       // Load UUID and make sure the UUID is correct.\n       byte[] uuidRead \u003d new byte[UUID_LENGTH];\n       int uuidReadLen \u003d fsDataIStream.read(uuidRead);\n       if (this.uuid \u003d\u003d null) {\n         this.uuid \u003d createUUID(appId);\n       }\n       if (uuidReadLen !\u003d UUID_LENGTH || !Arrays.equals(this.uuid, uuidRead)) {\n         if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"the length of loaded UUID:\" + uuidReadLen);\n-          LOG.debug(\"the loaded UUID:\" + new String(uuidRead,\n+          LOG.debug(\"the length of loaded UUID:{}\", uuidReadLen);\n+          LOG.debug(\"the loaded UUID:{}\", new String(uuidRead,\n               Charset.forName(\"UTF-8\")));\n-          LOG.debug(\"the expected UUID:\" + new String(this.uuid,\n+          LOG.debug(\"the expected UUID:{}\", new String(this.uuid,\n               Charset.forName(\"UTF-8\")));\n         }\n         throw new IOException(\"The UUID from \"\n             + remoteLogPath + \" is not correct. The offset of loaded UUID is \"\n             + (fileLength - UUID_LENGTH));\n       }\n \n       // Load Log Meta\n       byte[] array \u003d new byte[offset];\n       fsDataIStream.seek(\n           fileLength - offset - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n       fsDataIStream.readFully(array);\n       int actual \u003d array.length;\n       if (actual !\u003d offset) {\n         throw new IOException(\"Error on loading log meta from \"\n             + remoteLogPath);\n       }\n       return (IndexedLogsMeta)SerializationUtils\n           .deserialize(array);\n     } finally {\n       IOUtils.cleanupWithLogger(LOG, fsDataIStream);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public IndexedLogsMeta loadIndexedLogsMeta(Path remoteLogPath, long end,\n      ApplicationId appId) throws IOException {\n    FileContext fileContext \u003d\n        FileContext.getFileContext(remoteLogPath.toUri(), conf);\n    FSDataInputStream fsDataIStream \u003d null;\n    try {\n      fsDataIStream \u003d fileContext.open(remoteLogPath);\n      if (end \u003d\u003d 0) {\n        return null;\n      }\n      long fileLength \u003d end \u003c 0 ? fileContext.getFileStatus(\n          remoteLogPath).getLen() : end;\n\n      fsDataIStream.seek(fileLength - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n      int offset \u003d fsDataIStream.readInt();\n      // If the offset/log meta size is larger than 64M,\n      // output a warn message for better debug.\n      if (offset \u003e 64 * 1024 * 1024) {\n        LOG.warn(\"The log meta size read from \" + remoteLogPath\n            + \" is \" + offset);\n      }\n\n      // Load UUID and make sure the UUID is correct.\n      byte[] uuidRead \u003d new byte[UUID_LENGTH];\n      int uuidReadLen \u003d fsDataIStream.read(uuidRead);\n      if (this.uuid \u003d\u003d null) {\n        this.uuid \u003d createUUID(appId);\n      }\n      if (uuidReadLen !\u003d UUID_LENGTH || !Arrays.equals(this.uuid, uuidRead)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"the length of loaded UUID:{}\", uuidReadLen);\n          LOG.debug(\"the loaded UUID:{}\", new String(uuidRead,\n              Charset.forName(\"UTF-8\")));\n          LOG.debug(\"the expected UUID:{}\", new String(this.uuid,\n              Charset.forName(\"UTF-8\")));\n        }\n        throw new IOException(\"The UUID from \"\n            + remoteLogPath + \" is not correct. The offset of loaded UUID is \"\n            + (fileLength - UUID_LENGTH));\n      }\n\n      // Load Log Meta\n      byte[] array \u003d new byte[offset];\n      fsDataIStream.seek(\n          fileLength - offset - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n      fsDataIStream.readFully(array);\n      int actual \u003d array.length;\n      if (actual !\u003d offset) {\n        throw new IOException(\"Error on loading log meta from \"\n            + remoteLogPath);\n      }\n      return (IndexedLogsMeta)SerializationUtils\n          .deserialize(array);\n    } finally {\n      IOUtils.cleanupWithLogger(LOG, fsDataIStream);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "b779f4f0f614fe47e05bc2be5494cf3cbcf6f63c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8106. Update LogAggregationIndexedFileController to use readFull instead read to avoid IOException while loading log meta. (Prabhu Joseph via wangda)\n\nChange-Id: I63a65f73f8d1636e2c99ed9c8c2bbd05efcff80f\n",
      "commitDate": "03/04/18 9:06 PM",
      "commitName": "b779f4f0f614fe47e05bc2be5494cf3cbcf6f63c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/03/18 3:46 PM",
      "commitNameOld": "583f4594314b3db25b57b1e46ea8026eab21f932",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 27.18,
      "commitsBetweenForRepo": 306,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,57 @@\n   public IndexedLogsMeta loadIndexedLogsMeta(Path remoteLogPath, long end,\n       ApplicationId appId) throws IOException {\n     FileContext fileContext \u003d\n         FileContext.getFileContext(remoteLogPath.toUri(), conf);\n     FSDataInputStream fsDataIStream \u003d null;\n     try {\n       fsDataIStream \u003d fileContext.open(remoteLogPath);\n       if (end \u003d\u003d 0) {\n         return null;\n       }\n       long fileLength \u003d end \u003c 0 ? fileContext.getFileStatus(\n           remoteLogPath).getLen() : end;\n \n       fsDataIStream.seek(fileLength - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n       int offset \u003d fsDataIStream.readInt();\n       // If the offset/log meta size is larger than 64M,\n       // output a warn message for better debug.\n       if (offset \u003e 64 * 1024 * 1024) {\n         LOG.warn(\"The log meta size read from \" + remoteLogPath\n             + \" is \" + offset);\n       }\n \n       // Load UUID and make sure the UUID is correct.\n       byte[] uuidRead \u003d new byte[UUID_LENGTH];\n       int uuidReadLen \u003d fsDataIStream.read(uuidRead);\n       if (this.uuid \u003d\u003d null) {\n         this.uuid \u003d createUUID(appId);\n       }\n       if (uuidReadLen !\u003d UUID_LENGTH || !Arrays.equals(this.uuid, uuidRead)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"the length of loaded UUID:\" + uuidReadLen);\n           LOG.debug(\"the loaded UUID:\" + new String(uuidRead,\n               Charset.forName(\"UTF-8\")));\n           LOG.debug(\"the expected UUID:\" + new String(this.uuid,\n               Charset.forName(\"UTF-8\")));\n         }\n         throw new IOException(\"The UUID from \"\n             + remoteLogPath + \" is not correct. The offset of loaded UUID is \"\n             + (fileLength - UUID_LENGTH));\n       }\n \n       // Load Log Meta\n       byte[] array \u003d new byte[offset];\n       fsDataIStream.seek(\n           fileLength - offset - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n-      int actual \u003d fsDataIStream.read(array);\n+      fsDataIStream.readFully(array);\n+      int actual \u003d array.length;\n       if (actual !\u003d offset) {\n         throw new IOException(\"Error on loading log meta from \"\n             + remoteLogPath);\n       }\n       return (IndexedLogsMeta)SerializationUtils\n           .deserialize(array);\n     } finally {\n       IOUtils.cleanupWithLogger(LOG, fsDataIStream);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public IndexedLogsMeta loadIndexedLogsMeta(Path remoteLogPath, long end,\n      ApplicationId appId) throws IOException {\n    FileContext fileContext \u003d\n        FileContext.getFileContext(remoteLogPath.toUri(), conf);\n    FSDataInputStream fsDataIStream \u003d null;\n    try {\n      fsDataIStream \u003d fileContext.open(remoteLogPath);\n      if (end \u003d\u003d 0) {\n        return null;\n      }\n      long fileLength \u003d end \u003c 0 ? fileContext.getFileStatus(\n          remoteLogPath).getLen() : end;\n\n      fsDataIStream.seek(fileLength - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n      int offset \u003d fsDataIStream.readInt();\n      // If the offset/log meta size is larger than 64M,\n      // output a warn message for better debug.\n      if (offset \u003e 64 * 1024 * 1024) {\n        LOG.warn(\"The log meta size read from \" + remoteLogPath\n            + \" is \" + offset);\n      }\n\n      // Load UUID and make sure the UUID is correct.\n      byte[] uuidRead \u003d new byte[UUID_LENGTH];\n      int uuidReadLen \u003d fsDataIStream.read(uuidRead);\n      if (this.uuid \u003d\u003d null) {\n        this.uuid \u003d createUUID(appId);\n      }\n      if (uuidReadLen !\u003d UUID_LENGTH || !Arrays.equals(this.uuid, uuidRead)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"the length of loaded UUID:\" + uuidReadLen);\n          LOG.debug(\"the loaded UUID:\" + new String(uuidRead,\n              Charset.forName(\"UTF-8\")));\n          LOG.debug(\"the expected UUID:\" + new String(this.uuid,\n              Charset.forName(\"UTF-8\")));\n        }\n        throw new IOException(\"The UUID from \"\n            + remoteLogPath + \" is not correct. The offset of loaded UUID is \"\n            + (fileLength - UUID_LENGTH));\n      }\n\n      // Load Log Meta\n      byte[] array \u003d new byte[offset];\n      fsDataIStream.seek(\n          fileLength - offset - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n      fsDataIStream.readFully(array);\n      int actual \u003d array.length;\n      if (actual !\u003d offset) {\n        throw new IOException(\"Error on loading log meta from \"\n            + remoteLogPath);\n      }\n      return (IndexedLogsMeta)SerializationUtils\n          .deserialize(array);\n    } finally {\n      IOUtils.cleanupWithLogger(LOG, fsDataIStream);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "d4c98579e36df7eeb788352d7b76cd2c7448c511": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7697. NM goes down with OOM due to leak in log-aggregation. (Xuan Gong via wangda)\n\nChange-Id: Ie4fc7979d834e25f37a033c314f3efceeb8f4a9e\n",
      "commitDate": "11/02/18 6:28 PM",
      "commitName": "d4c98579e36df7eeb788352d7b76cd2c7448c511",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7697. NM goes down with OOM due to leak in log-aggregation. (Xuan Gong via wangda)\n\nChange-Id: Ie4fc7979d834e25f37a033c314f3efceeb8f4a9e\n",
          "commitDate": "11/02/18 6:28 PM",
          "commitName": "d4c98579e36df7eeb788352d7b76cd2c7448c511",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "02/10/17 3:30 PM",
          "commitNameOld": "280080fad01304c85a9ede4d4f7b707eb36c0155",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 132.17,
          "commitsBetweenForRepo": 906,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,28 +1,56 @@\n-  public IndexedLogsMeta loadIndexedLogsMeta(Path remoteLogPath, long end)\n-      throws IOException {\n+  public IndexedLogsMeta loadIndexedLogsMeta(Path remoteLogPath, long end,\n+      ApplicationId appId) throws IOException {\n     FileContext fileContext \u003d\n         FileContext.getFileContext(remoteLogPath.toUri(), conf);\n     FSDataInputStream fsDataIStream \u003d null;\n     try {\n       fsDataIStream \u003d fileContext.open(remoteLogPath);\n       if (end \u003d\u003d 0) {\n         return null;\n       }\n       long fileLength \u003d end \u003c 0 ? fileContext.getFileStatus(\n           remoteLogPath).getLen() : end;\n+\n       fsDataIStream.seek(fileLength - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n       int offset \u003d fsDataIStream.readInt();\n+      // If the offset/log meta size is larger than 64M,\n+      // output a warn message for better debug.\n+      if (offset \u003e 64 * 1024 * 1024) {\n+        LOG.warn(\"The log meta size read from \" + remoteLogPath\n+            + \" is \" + offset);\n+      }\n+\n+      // Load UUID and make sure the UUID is correct.\n+      byte[] uuidRead \u003d new byte[UUID_LENGTH];\n+      int uuidReadLen \u003d fsDataIStream.read(uuidRead);\n+      if (this.uuid \u003d\u003d null) {\n+        this.uuid \u003d createUUID(appId);\n+      }\n+      if (uuidReadLen !\u003d UUID_LENGTH || !Arrays.equals(this.uuid, uuidRead)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"the length of loaded UUID:\" + uuidReadLen);\n+          LOG.debug(\"the loaded UUID:\" + new String(uuidRead,\n+              Charset.forName(\"UTF-8\")));\n+          LOG.debug(\"the expected UUID:\" + new String(this.uuid,\n+              Charset.forName(\"UTF-8\")));\n+        }\n+        throw new IOException(\"The UUID from \"\n+            + remoteLogPath + \" is not correct. The offset of loaded UUID is \"\n+            + (fileLength - UUID_LENGTH));\n+      }\n+\n+      // Load Log Meta\n       byte[] array \u003d new byte[offset];\n       fsDataIStream.seek(\n           fileLength - offset - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n       int actual \u003d fsDataIStream.read(array);\n       if (actual !\u003d offset) {\n         throw new IOException(\"Error on loading log meta from \"\n             + remoteLogPath);\n       }\n       return (IndexedLogsMeta)SerializationUtils\n           .deserialize(array);\n     } finally {\n       IOUtils.cleanupWithLogger(LOG, fsDataIStream);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public IndexedLogsMeta loadIndexedLogsMeta(Path remoteLogPath, long end,\n      ApplicationId appId) throws IOException {\n    FileContext fileContext \u003d\n        FileContext.getFileContext(remoteLogPath.toUri(), conf);\n    FSDataInputStream fsDataIStream \u003d null;\n    try {\n      fsDataIStream \u003d fileContext.open(remoteLogPath);\n      if (end \u003d\u003d 0) {\n        return null;\n      }\n      long fileLength \u003d end \u003c 0 ? fileContext.getFileStatus(\n          remoteLogPath).getLen() : end;\n\n      fsDataIStream.seek(fileLength - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n      int offset \u003d fsDataIStream.readInt();\n      // If the offset/log meta size is larger than 64M,\n      // output a warn message for better debug.\n      if (offset \u003e 64 * 1024 * 1024) {\n        LOG.warn(\"The log meta size read from \" + remoteLogPath\n            + \" is \" + offset);\n      }\n\n      // Load UUID and make sure the UUID is correct.\n      byte[] uuidRead \u003d new byte[UUID_LENGTH];\n      int uuidReadLen \u003d fsDataIStream.read(uuidRead);\n      if (this.uuid \u003d\u003d null) {\n        this.uuid \u003d createUUID(appId);\n      }\n      if (uuidReadLen !\u003d UUID_LENGTH || !Arrays.equals(this.uuid, uuidRead)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"the length of loaded UUID:\" + uuidReadLen);\n          LOG.debug(\"the loaded UUID:\" + new String(uuidRead,\n              Charset.forName(\"UTF-8\")));\n          LOG.debug(\"the expected UUID:\" + new String(this.uuid,\n              Charset.forName(\"UTF-8\")));\n        }\n        throw new IOException(\"The UUID from \"\n            + remoteLogPath + \" is not correct. The offset of loaded UUID is \"\n            + (fileLength - UUID_LENGTH));\n      }\n\n      // Load Log Meta\n      byte[] array \u003d new byte[offset];\n      fsDataIStream.seek(\n          fileLength - offset - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n      int actual \u003d fsDataIStream.read(array);\n      if (actual !\u003d offset) {\n        throw new IOException(\"Error on loading log meta from \"\n            + remoteLogPath);\n      }\n      return (IndexedLogsMeta)SerializationUtils\n          .deserialize(array);\n    } finally {\n      IOUtils.cleanupWithLogger(LOG, fsDataIStream);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
          "extendedDetails": {
            "oldValue": "[remoteLogPath-Path, end-long]",
            "newValue": "[remoteLogPath-Path, end-long, appId-ApplicationId]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7697. NM goes down with OOM due to leak in log-aggregation. (Xuan Gong via wangda)\n\nChange-Id: Ie4fc7979d834e25f37a033c314f3efceeb8f4a9e\n",
          "commitDate": "11/02/18 6:28 PM",
          "commitName": "d4c98579e36df7eeb788352d7b76cd2c7448c511",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "02/10/17 3:30 PM",
          "commitNameOld": "280080fad01304c85a9ede4d4f7b707eb36c0155",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 132.17,
          "commitsBetweenForRepo": 906,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,28 +1,56 @@\n-  public IndexedLogsMeta loadIndexedLogsMeta(Path remoteLogPath, long end)\n-      throws IOException {\n+  public IndexedLogsMeta loadIndexedLogsMeta(Path remoteLogPath, long end,\n+      ApplicationId appId) throws IOException {\n     FileContext fileContext \u003d\n         FileContext.getFileContext(remoteLogPath.toUri(), conf);\n     FSDataInputStream fsDataIStream \u003d null;\n     try {\n       fsDataIStream \u003d fileContext.open(remoteLogPath);\n       if (end \u003d\u003d 0) {\n         return null;\n       }\n       long fileLength \u003d end \u003c 0 ? fileContext.getFileStatus(\n           remoteLogPath).getLen() : end;\n+\n       fsDataIStream.seek(fileLength - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n       int offset \u003d fsDataIStream.readInt();\n+      // If the offset/log meta size is larger than 64M,\n+      // output a warn message for better debug.\n+      if (offset \u003e 64 * 1024 * 1024) {\n+        LOG.warn(\"The log meta size read from \" + remoteLogPath\n+            + \" is \" + offset);\n+      }\n+\n+      // Load UUID and make sure the UUID is correct.\n+      byte[] uuidRead \u003d new byte[UUID_LENGTH];\n+      int uuidReadLen \u003d fsDataIStream.read(uuidRead);\n+      if (this.uuid \u003d\u003d null) {\n+        this.uuid \u003d createUUID(appId);\n+      }\n+      if (uuidReadLen !\u003d UUID_LENGTH || !Arrays.equals(this.uuid, uuidRead)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"the length of loaded UUID:\" + uuidReadLen);\n+          LOG.debug(\"the loaded UUID:\" + new String(uuidRead,\n+              Charset.forName(\"UTF-8\")));\n+          LOG.debug(\"the expected UUID:\" + new String(this.uuid,\n+              Charset.forName(\"UTF-8\")));\n+        }\n+        throw new IOException(\"The UUID from \"\n+            + remoteLogPath + \" is not correct. The offset of loaded UUID is \"\n+            + (fileLength - UUID_LENGTH));\n+      }\n+\n+      // Load Log Meta\n       byte[] array \u003d new byte[offset];\n       fsDataIStream.seek(\n           fileLength - offset - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n       int actual \u003d fsDataIStream.read(array);\n       if (actual !\u003d offset) {\n         throw new IOException(\"Error on loading log meta from \"\n             + remoteLogPath);\n       }\n       return (IndexedLogsMeta)SerializationUtils\n           .deserialize(array);\n     } finally {\n       IOUtils.cleanupWithLogger(LOG, fsDataIStream);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public IndexedLogsMeta loadIndexedLogsMeta(Path remoteLogPath, long end,\n      ApplicationId appId) throws IOException {\n    FileContext fileContext \u003d\n        FileContext.getFileContext(remoteLogPath.toUri(), conf);\n    FSDataInputStream fsDataIStream \u003d null;\n    try {\n      fsDataIStream \u003d fileContext.open(remoteLogPath);\n      if (end \u003d\u003d 0) {\n        return null;\n      }\n      long fileLength \u003d end \u003c 0 ? fileContext.getFileStatus(\n          remoteLogPath).getLen() : end;\n\n      fsDataIStream.seek(fileLength - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n      int offset \u003d fsDataIStream.readInt();\n      // If the offset/log meta size is larger than 64M,\n      // output a warn message for better debug.\n      if (offset \u003e 64 * 1024 * 1024) {\n        LOG.warn(\"The log meta size read from \" + remoteLogPath\n            + \" is \" + offset);\n      }\n\n      // Load UUID and make sure the UUID is correct.\n      byte[] uuidRead \u003d new byte[UUID_LENGTH];\n      int uuidReadLen \u003d fsDataIStream.read(uuidRead);\n      if (this.uuid \u003d\u003d null) {\n        this.uuid \u003d createUUID(appId);\n      }\n      if (uuidReadLen !\u003d UUID_LENGTH || !Arrays.equals(this.uuid, uuidRead)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"the length of loaded UUID:\" + uuidReadLen);\n          LOG.debug(\"the loaded UUID:\" + new String(uuidRead,\n              Charset.forName(\"UTF-8\")));\n          LOG.debug(\"the expected UUID:\" + new String(this.uuid,\n              Charset.forName(\"UTF-8\")));\n        }\n        throw new IOException(\"The UUID from \"\n            + remoteLogPath + \" is not correct. The offset of loaded UUID is \"\n            + (fileLength - UUID_LENGTH));\n      }\n\n      // Load Log Meta\n      byte[] array \u003d new byte[offset];\n      fsDataIStream.seek(\n          fileLength - offset - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n      int actual \u003d fsDataIStream.read(array);\n      if (actual !\u003d offset) {\n        throw new IOException(\"Error on loading log meta from \"\n            + remoteLogPath);\n      }\n      return (IndexedLogsMeta)SerializationUtils\n          .deserialize(array);\n    } finally {\n      IOUtils.cleanupWithLogger(LOG, fsDataIStream);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
          "extendedDetails": {}
        }
      ]
    },
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7072. Add a new log aggregation file format controller. Contributed by Xuan Gong.\n",
      "commitDate": "08/09/17 3:16 PM",
      "commitName": "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,28 @@\n+  public IndexedLogsMeta loadIndexedLogsMeta(Path remoteLogPath, long end)\n+      throws IOException {\n+    FileContext fileContext \u003d\n+        FileContext.getFileContext(remoteLogPath.toUri(), conf);\n+    FSDataInputStream fsDataIStream \u003d null;\n+    try {\n+      fsDataIStream \u003d fileContext.open(remoteLogPath);\n+      if (end \u003d\u003d 0) {\n+        return null;\n+      }\n+      long fileLength \u003d end \u003c 0 ? fileContext.getFileStatus(\n+          remoteLogPath).getLen() : end;\n+      fsDataIStream.seek(fileLength - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n+      int offset \u003d fsDataIStream.readInt();\n+      byte[] array \u003d new byte[offset];\n+      fsDataIStream.seek(\n+          fileLength - offset - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n+      int actual \u003d fsDataIStream.read(array);\n+      if (actual !\u003d offset) {\n+        throw new IOException(\"Error on loading log meta from \"\n+            + remoteLogPath);\n+      }\n+      return (IndexedLogsMeta)SerializationUtils\n+          .deserialize(array);\n+    } finally {\n+      IOUtils.cleanupWithLogger(LOG, fsDataIStream);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public IndexedLogsMeta loadIndexedLogsMeta(Path remoteLogPath, long end)\n      throws IOException {\n    FileContext fileContext \u003d\n        FileContext.getFileContext(remoteLogPath.toUri(), conf);\n    FSDataInputStream fsDataIStream \u003d null;\n    try {\n      fsDataIStream \u003d fileContext.open(remoteLogPath);\n      if (end \u003d\u003d 0) {\n        return null;\n      }\n      long fileLength \u003d end \u003c 0 ? fileContext.getFileStatus(\n          remoteLogPath).getLen() : end;\n      fsDataIStream.seek(fileLength - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n      int offset \u003d fsDataIStream.readInt();\n      byte[] array \u003d new byte[offset];\n      fsDataIStream.seek(\n          fileLength - offset - Integer.SIZE/ Byte.SIZE - UUID_LENGTH);\n      int actual \u003d fsDataIStream.read(array);\n      if (actual !\u003d offset) {\n        throw new IOException(\"Error on loading log meta from \"\n            + remoteLogPath);\n      }\n      return (IndexedLogsMeta)SerializationUtils\n          .deserialize(array);\n    } finally {\n      IOUtils.cleanupWithLogger(LOG, fsDataIStream);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java"
    }
  }
}