{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LogCLIHelpers.java",
  "functionName": "dumpAContainerLogsForLogTypeWithoutNodeId",
  "functionId": "dumpAContainerLogsForLogTypeWithoutNodeId___options-ContainerLogsRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
  "functionStartLine": 212,
  "functionEndLine": 230,
  "numCommitsSeen": 69,
  "timeTaken": 6374,
  "changeHistory": [
    "63231a2a3008794c5ebcbc9d3855638fc5f28216",
    "91cc070d67533ebb3325b982eba2135e0d175a82",
    "871dc420f8a4f151189c0925e062c64859a8f275",
    "e605d47df05619c6b1c18aca59f709899498da75",
    "dc2f4b6ac8a6f8848457046cf9e1362d8f48495d",
    "eb471632349deac4b62f8dec853c8ceb64c9617a",
    "6ab5aa1c1f82f81726c6daa38b3db90d8c3ad856",
    "25064fb2fb79751cedbb8019900d811e07549ecf",
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
    "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1",
    "ef1757790d89cc72f88f5330761b1c8901c59e94",
    "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835",
    "66b07d83740a2ec3e6bfb2bfd064863bae37a1b5"
  ],
  "changeHistoryShort": {
    "63231a2a3008794c5ebcbc9d3855638fc5f28216": "Ybodychange",
    "91cc070d67533ebb3325b982eba2135e0d175a82": "Ybodychange",
    "871dc420f8a4f151189c0925e062c64859a8f275": "Ybodychange",
    "e605d47df05619c6b1c18aca59f709899498da75": "Ybodychange",
    "dc2f4b6ac8a6f8848457046cf9e1362d8f48495d": "Ybodychange",
    "eb471632349deac4b62f8dec853c8ceb64c9617a": "Ybodychange",
    "6ab5aa1c1f82f81726c6daa38b3db90d8c3ad856": "Yrename",
    "25064fb2fb79751cedbb8019900d811e07549ecf": "Ybodychange",
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf": "Ybodychange",
    "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1": "Ymultichange(Yparameterchange,Ybodychange)",
    "ef1757790d89cc72f88f5330761b1c8901c59e94": "Ymultichange(Yparameterchange,Ybodychange)",
    "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835": "Ybodychange",
    "66b07d83740a2ec3e6bfb2bfd064863bae37a1b5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "63231a2a3008794c5ebcbc9d3855638fc5f28216": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7148. TestLogsCLI fails in trunk and branch-2 and javadoc error. Contributed by Xuan Gong.\n",
      "commitDate": "06/09/17 1:19 PM",
      "commitName": "63231a2a3008794c5ebcbc9d3855638fc5f28216",
      "commitAuthor": "Junping Du",
      "commitDateOld": "31/08/17 4:41 PM",
      "commitNameOld": "91cc070d67533ebb3325b982eba2135e0d175a82",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 5.86,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,11 +1,19 @@\n   public int dumpAContainerLogsForLogTypeWithoutNodeId(\n       ContainerLogsRequest options) throws IOException {\n-    boolean foundAnyLogs \u003d getFileController(options.getAppId(),\n-        options.getAppOwner()).readAggregatedLogs(\n-        options, null);\n+    LogAggregationFileController fc \u003d null;\n+    try {\n+      fc \u003d this.getFileController(\n+          options.getAppId(), options.getAppOwner());\n+    } catch (IOException ex) {\n+      System.err.println(ex);\n+    }\n+    boolean foundAnyLogs \u003d false;\n+    if (fc !\u003d null) {\n+      foundAnyLogs \u003d fc.readAggregatedLogs(options, null);\n+    }\n     if (!foundAnyLogs) {\n       containerLogNotFound(options.getContainerId());\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int dumpAContainerLogsForLogTypeWithoutNodeId(\n      ContainerLogsRequest options) throws IOException {\n    LogAggregationFileController fc \u003d null;\n    try {\n      fc \u003d this.getFileController(\n          options.getAppId(), options.getAppOwner());\n    } catch (IOException ex) {\n      System.err.println(ex);\n    }\n    boolean foundAnyLogs \u003d false;\n    if (fc !\u003d null) {\n      foundAnyLogs \u003d fc.readAggregatedLogs(options, null);\n    }\n    if (!foundAnyLogs) {\n      containerLogNotFound(options.getContainerId());\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
      "extendedDetails": {}
    },
    "91cc070d67533ebb3325b982eba2135e0d175a82": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6877. Create an abstract log reader for extendability. Contributed by Xuan Gong.\n",
      "commitDate": "31/08/17 4:41 PM",
      "commitName": "91cc070d67533ebb3325b982eba2135e0d175a82",
      "commitAuthor": "Junping Du",
      "commitDateOld": "14/03/17 12:58 PM",
      "commitNameOld": "871dc420f8a4f151189c0925e062c64859a8f275",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 170.16,
      "commitsBetweenForRepo": 1032,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,11 @@\n   public int dumpAContainerLogsForLogTypeWithoutNodeId(\n       ContainerLogsRequest options) throws IOException {\n-    ApplicationId applicationId \u003d options.getAppId();\n-    String jobOwner \u003d options.getAppOwner();\n-    String containerId \u003d options.getContainerId();\n-    String localDir \u003d options.getOutputLocalDir();\n-    List\u003cString\u003e logType \u003d new ArrayList\u003cString\u003e(options.getLogTypes());\n-    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n-        applicationId, jobOwner);\n-    if (nodeFiles \u003d\u003d null) {\n-      return -1;\n-    }\n-    boolean foundContainerLogs \u003d false;\n-    while(nodeFiles.hasNext()) {\n-      FileStatus thisNodeFile \u003d nodeFiles.next();\n-      if (!thisNodeFile.getPath().getName().endsWith(\n-          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n-        AggregatedLogFormat.LogReader reader \u003d null;\n-        PrintStream out \u003d System.out;\n-        try {\n-          reader \u003d\n-              new AggregatedLogFormat.LogReader(getConf(),\n-              thisNodeFile.getPath());\n-          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n-            continue;\n-          }\n-          // We have to re-create reader object to reset the stream index\n-          // after calling getContainerLogsStream which would move the stream\n-          // index to the end of the log file.\n-          reader \u003d\n-              new AggregatedLogFormat.LogReader(getConf(),\n-              thisNodeFile.getPath());\n-          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n-              containerId);\n-          String containerString \u003d String.format(CONTAINER_ON_NODE_PATTERN,\n-              containerId, thisNodeFile.getPath().getName());\n-          out.println(containerString);\n-          out.println(\"LogAggregationType: AGGREGATED\");\n-          out.println(StringUtils.repeat(\"\u003d\", containerString.length()));\n-          if (logType \u003d\u003d null || logType.isEmpty()) {\n-            if (dumpAContainerLogs(containerId, reader, out,\n-                thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n-              foundContainerLogs \u003d true;\n-            }\n-          } else {\n-            if (dumpAContainerLogsForALogType(containerId, reader, out,\n-                thisNodeFile.getModificationTime(), logType,\n-                options.getBytes()) \u003e -1) {\n-              foundContainerLogs \u003d true;\n-            }\n-          }\n-        } finally {\n-          if (reader !\u003d null) {\n-            reader.close();\n-          }\n-          closePrintStream(out);\n-        }\n-      }\n-    }\n-    if (!foundContainerLogs) {\n-      containerLogNotFound(containerId);\n+    boolean foundAnyLogs \u003d getFileController(options.getAppId(),\n+        options.getAppOwner()).readAggregatedLogs(\n+        options, null);\n+    if (!foundAnyLogs) {\n+      containerLogNotFound(options.getContainerId());\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int dumpAContainerLogsForLogTypeWithoutNodeId(\n      ContainerLogsRequest options) throws IOException {\n    boolean foundAnyLogs \u003d getFileController(options.getAppId(),\n        options.getAppOwner()).readAggregatedLogs(\n        options, null);\n    if (!foundAnyLogs) {\n      containerLogNotFound(options.getContainerId());\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
      "extendedDetails": {}
    },
    "871dc420f8a4f151189c0925e062c64859a8f275": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6313. YARN logs cli should provide logs for a completed container even when application is still running. Contributed by Xuan Gong.\n\n(cherry picked from commit b88f5e0f7858d1d89b79dfd325b767c34416052d)\n",
      "commitDate": "14/03/17 12:58 PM",
      "commitName": "871dc420f8a4f151189c0925e062c64859a8f275",
      "commitAuthor": "Junping Du",
      "commitDateOld": "24/01/17 3:26 PM",
      "commitNameOld": "8528d85a68c0e6ea71026df4d3026e7edc206b2d",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 48.86,
      "commitsBetweenForRepo": 264,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,65 @@\n   public int dumpAContainerLogsForLogTypeWithoutNodeId(\n       ContainerLogsRequest options) throws IOException {\n     ApplicationId applicationId \u003d options.getAppId();\n     String jobOwner \u003d options.getAppOwner();\n     String containerId \u003d options.getContainerId();\n     String localDir \u003d options.getOutputLocalDir();\n     List\u003cString\u003e logType \u003d new ArrayList\u003cString\u003e(options.getLogTypes());\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n         applicationId, jobOwner);\n     if (nodeFiles \u003d\u003d null) {\n       return -1;\n     }\n     boolean foundContainerLogs \u003d false;\n     while(nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (!thisNodeFile.getPath().getName().endsWith(\n           LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         PrintStream out \u003d System.out;\n         try {\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n             continue;\n           }\n           // We have to re-create reader object to reset the stream index\n           // after calling getContainerLogsStream which would move the stream\n           // index to the end of the log file.\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n               containerId);\n           String containerString \u003d String.format(CONTAINER_ON_NODE_PATTERN,\n               containerId, thisNodeFile.getPath().getName());\n           out.println(containerString);\n+          out.println(\"LogAggregationType: AGGREGATED\");\n           out.println(StringUtils.repeat(\"\u003d\", containerString.length()));\n           if (logType \u003d\u003d null || logType.isEmpty()) {\n             if (dumpAContainerLogs(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           } else {\n             if (dumpAContainerLogsForALogType(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), logType,\n                 options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           }\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n           closePrintStream(out);\n         }\n       }\n     }\n     if (!foundContainerLogs) {\n       containerLogNotFound(containerId);\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int dumpAContainerLogsForLogTypeWithoutNodeId(\n      ContainerLogsRequest options) throws IOException {\n    ApplicationId applicationId \u003d options.getAppId();\n    String jobOwner \u003d options.getAppOwner();\n    String containerId \u003d options.getContainerId();\n    String localDir \u003d options.getOutputLocalDir();\n    List\u003cString\u003e logType \u003d new ArrayList\u003cString\u003e(options.getLogTypes());\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n        applicationId, jobOwner);\n    if (nodeFiles \u003d\u003d null) {\n      return -1;\n    }\n    boolean foundContainerLogs \u003d false;\n    while(nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (!thisNodeFile.getPath().getName().endsWith(\n          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        PrintStream out \u003d System.out;\n        try {\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n            continue;\n          }\n          // We have to re-create reader object to reset the stream index\n          // after calling getContainerLogsStream which would move the stream\n          // index to the end of the log file.\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n              containerId);\n          String containerString \u003d String.format(CONTAINER_ON_NODE_PATTERN,\n              containerId, thisNodeFile.getPath().getName());\n          out.println(containerString);\n          out.println(\"LogAggregationType: AGGREGATED\");\n          out.println(StringUtils.repeat(\"\u003d\", containerString.length()));\n          if (logType \u003d\u003d null || logType.isEmpty()) {\n            if (dumpAContainerLogs(containerId, reader, out,\n                thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          } else {\n            if (dumpAContainerLogsForALogType(containerId, reader, out,\n                thisNodeFile.getModificationTime(), logType,\n                options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          }\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n          closePrintStream(out);\n        }\n      }\n    }\n    if (!foundContainerLogs) {\n      containerLogNotFound(containerId);\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
      "extendedDetails": {}
    },
    "e605d47df05619c6b1c18aca59f709899498da75": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5470. Differentiate exactly match with regex in yarn log CLI. Contributed by Xuan Gong.\n",
      "commitDate": "05/08/16 10:55 AM",
      "commitName": "e605d47df05619c6b1c18aca59f709899498da75",
      "commitAuthor": "Junping Du",
      "commitDateOld": "19/07/16 7:17 AM",
      "commitNameOld": "dc2f4b6ac8a6f8848457046cf9e1362d8f48495d",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 17.15,
      "commitsBetweenForRepo": 128,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   public int dumpAContainerLogsForLogTypeWithoutNodeId(\n       ContainerLogsRequest options) throws IOException {\n     ApplicationId applicationId \u003d options.getAppId();\n     String jobOwner \u003d options.getAppOwner();\n     String containerId \u003d options.getContainerId();\n     String localDir \u003d options.getOutputLocalDir();\n-    List\u003cString\u003e logType \u003d options.getLogTypes();\n+    List\u003cString\u003e logType \u003d new ArrayList\u003cString\u003e(options.getLogTypes());\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n         applicationId, jobOwner);\n     if (nodeFiles \u003d\u003d null) {\n       return -1;\n     }\n     boolean foundContainerLogs \u003d false;\n     while(nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (!thisNodeFile.getPath().getName().endsWith(\n           LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         PrintStream out \u003d System.out;\n         try {\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n             continue;\n           }\n           // We have to re-create reader object to reset the stream index\n           // after calling getContainerLogsStream which would move the stream\n           // index to the end of the log file.\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n               containerId);\n           String containerString \u003d String.format(CONTAINER_ON_NODE_PATTERN,\n               containerId, thisNodeFile.getPath().getName());\n           out.println(containerString);\n           out.println(StringUtils.repeat(\"\u003d\", containerString.length()));\n           if (logType \u003d\u003d null || logType.isEmpty()) {\n             if (dumpAContainerLogs(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           } else {\n             if (dumpAContainerLogsForALogType(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), logType,\n                 options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           }\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n           closePrintStream(out);\n         }\n       }\n     }\n     if (!foundContainerLogs) {\n       containerLogNotFound(containerId);\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int dumpAContainerLogsForLogTypeWithoutNodeId(\n      ContainerLogsRequest options) throws IOException {\n    ApplicationId applicationId \u003d options.getAppId();\n    String jobOwner \u003d options.getAppOwner();\n    String containerId \u003d options.getContainerId();\n    String localDir \u003d options.getOutputLocalDir();\n    List\u003cString\u003e logType \u003d new ArrayList\u003cString\u003e(options.getLogTypes());\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n        applicationId, jobOwner);\n    if (nodeFiles \u003d\u003d null) {\n      return -1;\n    }\n    boolean foundContainerLogs \u003d false;\n    while(nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (!thisNodeFile.getPath().getName().endsWith(\n          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        PrintStream out \u003d System.out;\n        try {\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n            continue;\n          }\n          // We have to re-create reader object to reset the stream index\n          // after calling getContainerLogsStream which would move the stream\n          // index to the end of the log file.\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n              containerId);\n          String containerString \u003d String.format(CONTAINER_ON_NODE_PATTERN,\n              containerId, thisNodeFile.getPath().getName());\n          out.println(containerString);\n          out.println(StringUtils.repeat(\"\u003d\", containerString.length()));\n          if (logType \u003d\u003d null || logType.isEmpty()) {\n            if (dumpAContainerLogs(containerId, reader, out,\n                thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          } else {\n            if (dumpAContainerLogsForALogType(containerId, reader, out,\n                thisNodeFile.getModificationTime(), logType,\n                options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          }\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n          closePrintStream(out);\n        }\n      }\n    }\n    if (!foundContainerLogs) {\n      containerLogNotFound(containerId);\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
      "extendedDetails": {}
    },
    "dc2f4b6ac8a6f8848457046cf9e1362d8f48495d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5213. Fix a bug in LogCLIHelpers which cause TestLogsCLI#testFetchApplictionLogs fails intermittently. Contributed by Xuan Gong.\n",
      "commitDate": "19/07/16 7:17 AM",
      "commitName": "dc2f4b6ac8a6f8848457046cf9e1362d8f48495d",
      "commitAuthor": "Junping Du",
      "commitDateOld": "13/07/16 10:54 AM",
      "commitNameOld": "eb471632349deac4b62f8dec853c8ceb64c9617a",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.85,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,64 @@\n   public int dumpAContainerLogsForLogTypeWithoutNodeId(\n       ContainerLogsRequest options) throws IOException {\n     ApplicationId applicationId \u003d options.getAppId();\n     String jobOwner \u003d options.getAppOwner();\n     String containerId \u003d options.getContainerId();\n     String localDir \u003d options.getOutputLocalDir();\n     List\u003cString\u003e logType \u003d options.getLogTypes();\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n         applicationId, jobOwner);\n     if (nodeFiles \u003d\u003d null) {\n       return -1;\n     }\n     boolean foundContainerLogs \u003d false;\n     while(nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (!thisNodeFile.getPath().getName().endsWith(\n           LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         PrintStream out \u003d System.out;\n         try {\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n             continue;\n           }\n+          // We have to re-create reader object to reset the stream index\n+          // after calling getContainerLogsStream which would move the stream\n+          // index to the end of the log file.\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n               containerId);\n           String containerString \u003d String.format(CONTAINER_ON_NODE_PATTERN,\n               containerId, thisNodeFile.getPath().getName());\n           out.println(containerString);\n           out.println(StringUtils.repeat(\"\u003d\", containerString.length()));\n           if (logType \u003d\u003d null || logType.isEmpty()) {\n             if (dumpAContainerLogs(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           } else {\n             if (dumpAContainerLogsForALogType(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), logType,\n                 options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           }\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n           closePrintStream(out);\n         }\n       }\n     }\n     if (!foundContainerLogs) {\n       containerLogNotFound(containerId);\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int dumpAContainerLogsForLogTypeWithoutNodeId(\n      ContainerLogsRequest options) throws IOException {\n    ApplicationId applicationId \u003d options.getAppId();\n    String jobOwner \u003d options.getAppOwner();\n    String containerId \u003d options.getContainerId();\n    String localDir \u003d options.getOutputLocalDir();\n    List\u003cString\u003e logType \u003d options.getLogTypes();\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n        applicationId, jobOwner);\n    if (nodeFiles \u003d\u003d null) {\n      return -1;\n    }\n    boolean foundContainerLogs \u003d false;\n    while(nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (!thisNodeFile.getPath().getName().endsWith(\n          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        PrintStream out \u003d System.out;\n        try {\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n            continue;\n          }\n          // We have to re-create reader object to reset the stream index\n          // after calling getContainerLogsStream which would move the stream\n          // index to the end of the log file.\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n              containerId);\n          String containerString \u003d String.format(CONTAINER_ON_NODE_PATTERN,\n              containerId, thisNodeFile.getPath().getName());\n          out.println(containerString);\n          out.println(StringUtils.repeat(\"\u003d\", containerString.length()));\n          if (logType \u003d\u003d null || logType.isEmpty()) {\n            if (dumpAContainerLogs(containerId, reader, out,\n                thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          } else {\n            if (dumpAContainerLogsForALogType(containerId, reader, out,\n                thisNodeFile.getModificationTime(), logType,\n                options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          }\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n          closePrintStream(out);\n        }\n      }\n    }\n    if (!foundContainerLogs) {\n      containerLogNotFound(containerId);\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
      "extendedDetails": {}
    },
    "eb471632349deac4b62f8dec853c8ceb64c9617a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5200. Enhanced \"yarn logs\" to be able to get a list of containers whose logs are aggregated via a \"show_container_log_info\" option. Contributed by Xuan Gong.\n",
      "commitDate": "13/07/16 10:54 AM",
      "commitName": "eb471632349deac4b62f8dec853c8ceb64c9617a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "22/06/16 9:48 PM",
      "commitNameOld": "6ab5aa1c1f82f81726c6daa38b3db90d8c3ad856",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 20.55,
      "commitsBetweenForRepo": 266,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,61 @@\n   public int dumpAContainerLogsForLogTypeWithoutNodeId(\n       ContainerLogsRequest options) throws IOException {\n     ApplicationId applicationId \u003d options.getAppId();\n     String jobOwner \u003d options.getAppOwner();\n     String containerId \u003d options.getContainerId();\n     String localDir \u003d options.getOutputLocalDir();\n     List\u003cString\u003e logType \u003d options.getLogTypes();\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n         applicationId, jobOwner);\n     if (nodeFiles \u003d\u003d null) {\n       return -1;\n     }\n     boolean foundContainerLogs \u003d false;\n     while(nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (!thisNodeFile.getPath().getName().endsWith(\n           LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         PrintStream out \u003d System.out;\n         try {\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n             continue;\n           }\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n               containerId);\n-          out.println(containerId + \" on \" + thisNodeFile.getPath().getName());\n-          out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n+          String containerString \u003d String.format(CONTAINER_ON_NODE_PATTERN,\n+              containerId, thisNodeFile.getPath().getName());\n+          out.println(containerString);\n+          out.println(StringUtils.repeat(\"\u003d\", containerString.length()));\n           if (logType \u003d\u003d null || logType.isEmpty()) {\n             if (dumpAContainerLogs(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           } else {\n             if (dumpAContainerLogsForALogType(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), logType,\n                 options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           }\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n           closePrintStream(out);\n         }\n       }\n     }\n     if (!foundContainerLogs) {\n       containerLogNotFound(containerId);\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int dumpAContainerLogsForLogTypeWithoutNodeId(\n      ContainerLogsRequest options) throws IOException {\n    ApplicationId applicationId \u003d options.getAppId();\n    String jobOwner \u003d options.getAppOwner();\n    String containerId \u003d options.getContainerId();\n    String localDir \u003d options.getOutputLocalDir();\n    List\u003cString\u003e logType \u003d options.getLogTypes();\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n        applicationId, jobOwner);\n    if (nodeFiles \u003d\u003d null) {\n      return -1;\n    }\n    boolean foundContainerLogs \u003d false;\n    while(nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (!thisNodeFile.getPath().getName().endsWith(\n          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        PrintStream out \u003d System.out;\n        try {\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n            continue;\n          }\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n              containerId);\n          String containerString \u003d String.format(CONTAINER_ON_NODE_PATTERN,\n              containerId, thisNodeFile.getPath().getName());\n          out.println(containerString);\n          out.println(StringUtils.repeat(\"\u003d\", containerString.length()));\n          if (logType \u003d\u003d null || logType.isEmpty()) {\n            if (dumpAContainerLogs(containerId, reader, out,\n                thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          } else {\n            if (dumpAContainerLogsForALogType(containerId, reader, out,\n                thisNodeFile.getModificationTime(), logType,\n                options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          }\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n          closePrintStream(out);\n        }\n      }\n    }\n    if (!foundContainerLogs) {\n      containerLogNotFound(containerId);\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
      "extendedDetails": {}
    },
    "6ab5aa1c1f82f81726c6daa38b3db90d8c3ad856": {
      "type": "Yrename",
      "commitMessage": "YARN-5266. Wrong exit code while trying to get app logs using regex via CLI. Contributed by Xuan Gong\n",
      "commitDate": "22/06/16 9:48 PM",
      "commitName": "6ab5aa1c1f82f81726c6daa38b3db90d8c3ad856",
      "commitAuthor": "Xuan",
      "commitDateOld": "15/06/16 12:12 AM",
      "commitNameOld": "25064fb2fb79751cedbb8019900d811e07549ecf",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 7.9,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n-  public int dumpAContainersLogsForALogTypeWithoutNodeId(\n+  public int dumpAContainerLogsForLogTypeWithoutNodeId(\n       ContainerLogsRequest options) throws IOException {\n     ApplicationId applicationId \u003d options.getAppId();\n     String jobOwner \u003d options.getAppOwner();\n     String containerId \u003d options.getContainerId();\n     String localDir \u003d options.getOutputLocalDir();\n     List\u003cString\u003e logType \u003d options.getLogTypes();\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n         applicationId, jobOwner);\n     if (nodeFiles \u003d\u003d null) {\n       return -1;\n     }\n     boolean foundContainerLogs \u003d false;\n     while(nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (!thisNodeFile.getPath().getName().endsWith(\n           LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         PrintStream out \u003d System.out;\n         try {\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n             continue;\n           }\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n               containerId);\n           out.println(containerId + \" on \" + thisNodeFile.getPath().getName());\n           out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n           if (logType \u003d\u003d null || logType.isEmpty()) {\n             if (dumpAContainerLogs(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           } else {\n             if (dumpAContainerLogsForALogType(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), logType,\n                 options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           }\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n           closePrintStream(out);\n         }\n       }\n     }\n     if (!foundContainerLogs) {\n       containerLogNotFound(containerId);\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int dumpAContainerLogsForLogTypeWithoutNodeId(\n      ContainerLogsRequest options) throws IOException {\n    ApplicationId applicationId \u003d options.getAppId();\n    String jobOwner \u003d options.getAppOwner();\n    String containerId \u003d options.getContainerId();\n    String localDir \u003d options.getOutputLocalDir();\n    List\u003cString\u003e logType \u003d options.getLogTypes();\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n        applicationId, jobOwner);\n    if (nodeFiles \u003d\u003d null) {\n      return -1;\n    }\n    boolean foundContainerLogs \u003d false;\n    while(nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (!thisNodeFile.getPath().getName().endsWith(\n          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        PrintStream out \u003d System.out;\n        try {\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n            continue;\n          }\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n              containerId);\n          out.println(containerId + \" on \" + thisNodeFile.getPath().getName());\n          out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n          if (logType \u003d\u003d null || logType.isEmpty()) {\n            if (dumpAContainerLogs(containerId, reader, out,\n                thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          } else {\n            if (dumpAContainerLogsForALogType(containerId, reader, out,\n                thisNodeFile.getModificationTime(), logType,\n                options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          }\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n          closePrintStream(out);\n        }\n      }\n    }\n    if (!foundContainerLogs) {\n      containerLogNotFound(containerId);\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
      "extendedDetails": {
        "oldValue": "dumpAContainersLogsForALogTypeWithoutNodeId",
        "newValue": "dumpAContainerLogsForLogTypeWithoutNodeId"
      }
    },
    "25064fb2fb79751cedbb8019900d811e07549ecf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5223. Container line in yarn logs output for a live application should include the hostname for the container. Contributed by Xuan Gong.\n",
      "commitDate": "15/06/16 12:12 AM",
      "commitName": "25064fb2fb79751cedbb8019900d811e07549ecf",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "14/06/16 3:06 PM",
      "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.38,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   public int dumpAContainersLogsForALogTypeWithoutNodeId(\n       ContainerLogsRequest options) throws IOException {\n     ApplicationId applicationId \u003d options.getAppId();\n     String jobOwner \u003d options.getAppOwner();\n     String containerId \u003d options.getContainerId();\n     String localDir \u003d options.getOutputLocalDir();\n     List\u003cString\u003e logType \u003d options.getLogTypes();\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n         applicationId, jobOwner);\n     if (nodeFiles \u003d\u003d null) {\n       return -1;\n     }\n     boolean foundContainerLogs \u003d false;\n     while(nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (!thisNodeFile.getPath().getName().endsWith(\n           LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         PrintStream out \u003d System.out;\n         try {\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n             continue;\n           }\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n               containerId);\n-          out.println(containerId);\n+          out.println(containerId + \" on \" + thisNodeFile.getPath().getName());\n           out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n           if (logType \u003d\u003d null || logType.isEmpty()) {\n             if (dumpAContainerLogs(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           } else {\n             if (dumpAContainerLogsForALogType(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), logType,\n                 options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           }\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n           closePrintStream(out);\n         }\n       }\n     }\n     if (!foundContainerLogs) {\n       containerLogNotFound(containerId);\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int dumpAContainersLogsForALogTypeWithoutNodeId(\n      ContainerLogsRequest options) throws IOException {\n    ApplicationId applicationId \u003d options.getAppId();\n    String jobOwner \u003d options.getAppOwner();\n    String containerId \u003d options.getContainerId();\n    String localDir \u003d options.getOutputLocalDir();\n    List\u003cString\u003e logType \u003d options.getLogTypes();\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n        applicationId, jobOwner);\n    if (nodeFiles \u003d\u003d null) {\n      return -1;\n    }\n    boolean foundContainerLogs \u003d false;\n    while(nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (!thisNodeFile.getPath().getName().endsWith(\n          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        PrintStream out \u003d System.out;\n        try {\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n            continue;\n          }\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n              containerId);\n          out.println(containerId + \" on \" + thisNodeFile.getPath().getName());\n          out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n          if (logType \u003d\u003d null || logType.isEmpty()) {\n            if (dumpAContainerLogs(containerId, reader, out,\n                thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          } else {\n            if (dumpAContainerLogsForALogType(containerId, reader, out,\n                thisNodeFile.getModificationTime(), logType,\n                options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          }\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n          closePrintStream(out);\n        }\n      }\n    }\n    if (!foundContainerLogs) {\n      containerLogNotFound(containerId);\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
      "extendedDetails": {}
    },
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5088. Improve \"yarn log\" command-line to read the last K bytes for the log files. Contributed by Xuan Gong\n",
      "commitDate": "01/06/16 1:44 PM",
      "commitName": "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
      "commitAuthor": "Xuan",
      "commitDateOld": "26/05/16 11:49 PM",
      "commitNameOld": "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 5.58,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,59 @@\n   public int dumpAContainersLogsForALogTypeWithoutNodeId(\n       ContainerLogsRequest options) throws IOException {\n     ApplicationId applicationId \u003d options.getAppId();\n     String jobOwner \u003d options.getAppOwner();\n     String containerId \u003d options.getContainerId();\n     String localDir \u003d options.getOutputLocalDir();\n     List\u003cString\u003e logType \u003d options.getLogTypes();\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n         applicationId, jobOwner);\n     if (nodeFiles \u003d\u003d null) {\n       return -1;\n     }\n     boolean foundContainerLogs \u003d false;\n     while(nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (!thisNodeFile.getPath().getName().endsWith(\n           LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         PrintStream out \u003d System.out;\n         try {\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n             continue;\n           }\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n               containerId);\n           out.println(containerId);\n           out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n           if (logType \u003d\u003d null || logType.isEmpty()) {\n             if (dumpAContainerLogs(containerId, reader, out,\n-                thisNodeFile.getModificationTime()) \u003e -1) {\n+                thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           } else {\n             if (dumpAContainerLogsForALogType(containerId, reader, out,\n-                thisNodeFile.getModificationTime(), logType) \u003e -1) {\n+                thisNodeFile.getModificationTime(), logType,\n+                options.getBytes()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           }\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n           closePrintStream(out);\n         }\n       }\n     }\n     if (!foundContainerLogs) {\n       containerLogNotFound(containerId);\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int dumpAContainersLogsForALogTypeWithoutNodeId(\n      ContainerLogsRequest options) throws IOException {\n    ApplicationId applicationId \u003d options.getAppId();\n    String jobOwner \u003d options.getAppOwner();\n    String containerId \u003d options.getContainerId();\n    String localDir \u003d options.getOutputLocalDir();\n    List\u003cString\u003e logType \u003d options.getLogTypes();\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n        applicationId, jobOwner);\n    if (nodeFiles \u003d\u003d null) {\n      return -1;\n    }\n    boolean foundContainerLogs \u003d false;\n    while(nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (!thisNodeFile.getPath().getName().endsWith(\n          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        PrintStream out \u003d System.out;\n        try {\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n            continue;\n          }\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n              containerId);\n          out.println(containerId);\n          out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n          if (logType \u003d\u003d null || logType.isEmpty()) {\n            if (dumpAContainerLogs(containerId, reader, out,\n                thisNodeFile.getModificationTime(), options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          } else {\n            if (dumpAContainerLogsForALogType(containerId, reader, out,\n                thisNodeFile.getModificationTime(), logType,\n                options.getBytes()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          }\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n          closePrintStream(out);\n        }\n      }\n    }\n    if (!foundContainerLogs) {\n      containerLogNotFound(containerId);\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
      "extendedDetails": {}
    },
    "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5089. Improve \"yarn log\" command-line \"logFiles\" option to support\nregex. Contributed by Xuan Gong\n",
      "commitDate": "26/05/16 11:49 PM",
      "commitName": "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1",
      "commitAuthor": "Xuan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5089. Improve \"yarn log\" command-line \"logFiles\" option to support\nregex. Contributed by Xuan Gong\n",
          "commitDate": "26/05/16 11:49 PM",
          "commitName": "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1",
          "commitAuthor": "Xuan",
          "commitDateOld": "18/05/16 10:14 AM",
          "commitNameOld": "ef1757790d89cc72f88f5330761b1c8901c59e94",
          "commitAuthorOld": "Varun Vasudev",
          "daysBetweenCommits": 8.57,
          "commitsBetweenForRepo": 66,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,55 +1,58 @@\n-  public int dumpAContainersLogsForALogTypeWithoutNodeId(String appId,\n-      String containerId, String jobOwner, List\u003cString\u003e logType,\n-      String localDir) throws IOException {\n-    ApplicationId applicationId \u003d ConverterUtils.toApplicationId(appId);\n+  public int dumpAContainersLogsForALogTypeWithoutNodeId(\n+      ContainerLogsRequest options) throws IOException {\n+    ApplicationId applicationId \u003d options.getAppId();\n+    String jobOwner \u003d options.getAppOwner();\n+    String containerId \u003d options.getContainerId();\n+    String localDir \u003d options.getOutputLocalDir();\n+    List\u003cString\u003e logType \u003d options.getLogTypes();\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n         applicationId, jobOwner);\n     if (nodeFiles \u003d\u003d null) {\n       return -1;\n     }\n     boolean foundContainerLogs \u003d false;\n     while(nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (!thisNodeFile.getPath().getName().endsWith(\n           LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         PrintStream out \u003d System.out;\n         try {\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n             continue;\n           }\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n               containerId);\n           out.println(containerId);\n           out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n-          if (logType \u003d\u003d null) {\n+          if (logType \u003d\u003d null || logType.isEmpty()) {\n             if (dumpAContainerLogs(containerId, reader, out,\n                 thisNodeFile.getModificationTime()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           } else {\n             if (dumpAContainerLogsForALogType(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), logType) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           }\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n           closePrintStream(out);\n         }\n       }\n     }\n     if (!foundContainerLogs) {\n       containerLogNotFound(containerId);\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int dumpAContainersLogsForALogTypeWithoutNodeId(\n      ContainerLogsRequest options) throws IOException {\n    ApplicationId applicationId \u003d options.getAppId();\n    String jobOwner \u003d options.getAppOwner();\n    String containerId \u003d options.getContainerId();\n    String localDir \u003d options.getOutputLocalDir();\n    List\u003cString\u003e logType \u003d options.getLogTypes();\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n        applicationId, jobOwner);\n    if (nodeFiles \u003d\u003d null) {\n      return -1;\n    }\n    boolean foundContainerLogs \u003d false;\n    while(nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (!thisNodeFile.getPath().getName().endsWith(\n          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        PrintStream out \u003d System.out;\n        try {\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n            continue;\n          }\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n              containerId);\n          out.println(containerId);\n          out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n          if (logType \u003d\u003d null || logType.isEmpty()) {\n            if (dumpAContainerLogs(containerId, reader, out,\n                thisNodeFile.getModificationTime()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          } else {\n            if (dumpAContainerLogsForALogType(containerId, reader, out,\n                thisNodeFile.getModificationTime(), logType) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          }\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n          closePrintStream(out);\n        }\n      }\n    }\n    if (!foundContainerLogs) {\n      containerLogNotFound(containerId);\n      return -1;\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
          "extendedDetails": {
            "oldValue": "[appId-String, containerId-String, jobOwner-String, logType-List\u003cString\u003e, localDir-String]",
            "newValue": "[options-ContainerLogsRequest]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5089. Improve \"yarn log\" command-line \"logFiles\" option to support\nregex. Contributed by Xuan Gong\n",
          "commitDate": "26/05/16 11:49 PM",
          "commitName": "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1",
          "commitAuthor": "Xuan",
          "commitDateOld": "18/05/16 10:14 AM",
          "commitNameOld": "ef1757790d89cc72f88f5330761b1c8901c59e94",
          "commitAuthorOld": "Varun Vasudev",
          "daysBetweenCommits": 8.57,
          "commitsBetweenForRepo": 66,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,55 +1,58 @@\n-  public int dumpAContainersLogsForALogTypeWithoutNodeId(String appId,\n-      String containerId, String jobOwner, List\u003cString\u003e logType,\n-      String localDir) throws IOException {\n-    ApplicationId applicationId \u003d ConverterUtils.toApplicationId(appId);\n+  public int dumpAContainersLogsForALogTypeWithoutNodeId(\n+      ContainerLogsRequest options) throws IOException {\n+    ApplicationId applicationId \u003d options.getAppId();\n+    String jobOwner \u003d options.getAppOwner();\n+    String containerId \u003d options.getContainerId();\n+    String localDir \u003d options.getOutputLocalDir();\n+    List\u003cString\u003e logType \u003d options.getLogTypes();\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n         applicationId, jobOwner);\n     if (nodeFiles \u003d\u003d null) {\n       return -1;\n     }\n     boolean foundContainerLogs \u003d false;\n     while(nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (!thisNodeFile.getPath().getName().endsWith(\n           LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         PrintStream out \u003d System.out;\n         try {\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n             continue;\n           }\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n               containerId);\n           out.println(containerId);\n           out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n-          if (logType \u003d\u003d null) {\n+          if (logType \u003d\u003d null || logType.isEmpty()) {\n             if (dumpAContainerLogs(containerId, reader, out,\n                 thisNodeFile.getModificationTime()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           } else {\n             if (dumpAContainerLogsForALogType(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), logType) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           }\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n           closePrintStream(out);\n         }\n       }\n     }\n     if (!foundContainerLogs) {\n       containerLogNotFound(containerId);\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int dumpAContainersLogsForALogTypeWithoutNodeId(\n      ContainerLogsRequest options) throws IOException {\n    ApplicationId applicationId \u003d options.getAppId();\n    String jobOwner \u003d options.getAppOwner();\n    String containerId \u003d options.getContainerId();\n    String localDir \u003d options.getOutputLocalDir();\n    List\u003cString\u003e logType \u003d options.getLogTypes();\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n        applicationId, jobOwner);\n    if (nodeFiles \u003d\u003d null) {\n      return -1;\n    }\n    boolean foundContainerLogs \u003d false;\n    while(nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (!thisNodeFile.getPath().getName().endsWith(\n          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        PrintStream out \u003d System.out;\n        try {\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n            continue;\n          }\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n              containerId);\n          out.println(containerId);\n          out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n          if (logType \u003d\u003d null || logType.isEmpty()) {\n            if (dumpAContainerLogs(containerId, reader, out,\n                thisNodeFile.getModificationTime()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          } else {\n            if (dumpAContainerLogsForALogType(containerId, reader, out,\n                thisNodeFile.getModificationTime(), logType) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          }\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n          closePrintStream(out);\n        }\n      }\n    }\n    if (!foundContainerLogs) {\n      containerLogNotFound(containerId);\n      return -1;\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
          "extendedDetails": {}
        }
      ]
    },
    "ef1757790d89cc72f88f5330761b1c8901c59e94": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4913. Yarn logs should take a -out option to write to a directory. Contributed by Xuan Gong.\n",
      "commitDate": "18/05/16 10:14 AM",
      "commitName": "ef1757790d89cc72f88f5330761b1c8901c59e94",
      "commitAuthor": "Varun Vasudev",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4913. Yarn logs should take a -out option to write to a directory. Contributed by Xuan Gong.\n",
          "commitDate": "18/05/16 10:14 AM",
          "commitName": "ef1757790d89cc72f88f5330761b1c8901c59e94",
          "commitAuthor": "Varun Vasudev",
          "commitDateOld": "09/05/16 10:41 PM",
          "commitNameOld": "87f5e351337a905af5215af76c72b9312616cd4f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 8.48,
          "commitsBetweenForRepo": 78,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,55 @@\n   public int dumpAContainersLogsForALogTypeWithoutNodeId(String appId,\n-      String containerId, String jobOwner, List\u003cString\u003e logType)\n-    throws IOException {\n+      String containerId, String jobOwner, List\u003cString\u003e logType,\n+      String localDir) throws IOException {\n     ApplicationId applicationId \u003d ConverterUtils.toApplicationId(appId);\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n         applicationId, jobOwner);\n     if (nodeFiles \u003d\u003d null) {\n       return -1;\n     }\n     boolean foundContainerLogs \u003d false;\n     while(nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (!thisNodeFile.getPath().getName().endsWith(\n           LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n+        PrintStream out \u003d System.out;\n         try {\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n+          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n+            continue;\n+          }\n+          reader \u003d\n+              new AggregatedLogFormat.LogReader(getConf(),\n+              thisNodeFile.getPath());\n+          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n+              containerId);\n+          out.println(containerId);\n+          out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n           if (logType \u003d\u003d null) {\n-            if (dumpAContainerLogs(containerId, reader, System.out,\n+            if (dumpAContainerLogs(containerId, reader, out,\n                 thisNodeFile.getModificationTime()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           } else {\n-            if (dumpAContainerLogsForALogType(containerId, reader, System.out,\n+            if (dumpAContainerLogsForALogType(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), logType) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           }\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n+          closePrintStream(out);\n         }\n       }\n     }\n     if (!foundContainerLogs) {\n       containerLogNotFound(containerId);\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int dumpAContainersLogsForALogTypeWithoutNodeId(String appId,\n      String containerId, String jobOwner, List\u003cString\u003e logType,\n      String localDir) throws IOException {\n    ApplicationId applicationId \u003d ConverterUtils.toApplicationId(appId);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n        applicationId, jobOwner);\n    if (nodeFiles \u003d\u003d null) {\n      return -1;\n    }\n    boolean foundContainerLogs \u003d false;\n    while(nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (!thisNodeFile.getPath().getName().endsWith(\n          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        PrintStream out \u003d System.out;\n        try {\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n            continue;\n          }\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n              containerId);\n          out.println(containerId);\n          out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n          if (logType \u003d\u003d null) {\n            if (dumpAContainerLogs(containerId, reader, out,\n                thisNodeFile.getModificationTime()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          } else {\n            if (dumpAContainerLogsForALogType(containerId, reader, out,\n                thisNodeFile.getModificationTime(), logType) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          }\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n          closePrintStream(out);\n        }\n      }\n    }\n    if (!foundContainerLogs) {\n      containerLogNotFound(containerId);\n      return -1;\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
          "extendedDetails": {
            "oldValue": "[appId-String, containerId-String, jobOwner-String, logType-List\u003cString\u003e]",
            "newValue": "[appId-String, containerId-String, jobOwner-String, logType-List\u003cString\u003e, localDir-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4913. Yarn logs should take a -out option to write to a directory. Contributed by Xuan Gong.\n",
          "commitDate": "18/05/16 10:14 AM",
          "commitName": "ef1757790d89cc72f88f5330761b1c8901c59e94",
          "commitAuthor": "Varun Vasudev",
          "commitDateOld": "09/05/16 10:41 PM",
          "commitNameOld": "87f5e351337a905af5215af76c72b9312616cd4f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 8.48,
          "commitsBetweenForRepo": 78,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,55 @@\n   public int dumpAContainersLogsForALogTypeWithoutNodeId(String appId,\n-      String containerId, String jobOwner, List\u003cString\u003e logType)\n-    throws IOException {\n+      String containerId, String jobOwner, List\u003cString\u003e logType,\n+      String localDir) throws IOException {\n     ApplicationId applicationId \u003d ConverterUtils.toApplicationId(appId);\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n         applicationId, jobOwner);\n     if (nodeFiles \u003d\u003d null) {\n       return -1;\n     }\n     boolean foundContainerLogs \u003d false;\n     while(nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (!thisNodeFile.getPath().getName().endsWith(\n           LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n+        PrintStream out \u003d System.out;\n         try {\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n+          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n+            continue;\n+          }\n+          reader \u003d\n+              new AggregatedLogFormat.LogReader(getConf(),\n+              thisNodeFile.getPath());\n+          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n+              containerId);\n+          out.println(containerId);\n+          out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n           if (logType \u003d\u003d null) {\n-            if (dumpAContainerLogs(containerId, reader, System.out,\n+            if (dumpAContainerLogs(containerId, reader, out,\n                 thisNodeFile.getModificationTime()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           } else {\n-            if (dumpAContainerLogsForALogType(containerId, reader, System.out,\n+            if (dumpAContainerLogsForALogType(containerId, reader, out,\n                 thisNodeFile.getModificationTime(), logType) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           }\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n+          closePrintStream(out);\n         }\n       }\n     }\n     if (!foundContainerLogs) {\n       containerLogNotFound(containerId);\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int dumpAContainersLogsForALogTypeWithoutNodeId(String appId,\n      String containerId, String jobOwner, List\u003cString\u003e logType,\n      String localDir) throws IOException {\n    ApplicationId applicationId \u003d ConverterUtils.toApplicationId(appId);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n        applicationId, jobOwner);\n    if (nodeFiles \u003d\u003d null) {\n      return -1;\n    }\n    boolean foundContainerLogs \u003d false;\n    while(nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (!thisNodeFile.getPath().getName().endsWith(\n          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        PrintStream out \u003d System.out;\n        try {\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          if (getContainerLogsStream(containerId, reader) \u003d\u003d null) {\n            continue;\n          }\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          out \u003d createPrintStream(localDir, thisNodeFile.getPath().getName(),\n              containerId);\n          out.println(containerId);\n          out.println(StringUtils.repeat(\"\u003d\", containerId.length()));\n          if (logType \u003d\u003d null) {\n            if (dumpAContainerLogs(containerId, reader, out,\n                thisNodeFile.getModificationTime()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          } else {\n            if (dumpAContainerLogsForALogType(containerId, reader, out,\n                thisNodeFile.getModificationTime(), logType) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          }\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n          closePrintStream(out);\n        }\n      }\n    }\n    if (!foundContainerLogs) {\n      containerLogNotFound(containerId);\n      return -1;\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
          "extendedDetails": {}
        }
      ]
    },
    "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4905. Improved \"yarn logs\" command-line to optionally show log metadata also. Contributed by Xuan Gong.\n",
      "commitDate": "04/05/16 2:16 PM",
      "commitName": "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/04/16 3:26 AM",
      "commitNameOld": "66b07d83740a2ec3e6bfb2bfd064863bae37a1b5",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 7.45,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,43 @@\n   public int dumpAContainersLogsForALogTypeWithoutNodeId(String appId,\n       String containerId, String jobOwner, List\u003cString\u003e logType)\n     throws IOException {\n-    Path remoteRootLogDir \u003d new Path(getConf().get(\n-        YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n-        YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n     ApplicationId applicationId \u003d ConverterUtils.toApplicationId(appId);\n-    String user \u003d jobOwner;\n-    String logDirSuffix \u003d LogAggregationUtils.getRemoteNodeLogDirSuffix(\n-        getConf());\n-    Path remoteAppLogDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n-        remoteRootLogDir, applicationId, user, logDirSuffix);\n-    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n-    try {\n-      Path qualifiedLogDir \u003d\n-          FileContext.getFileContext(getConf()).makeQualified(remoteAppLogDir);\n-      nodeFiles \u003d FileContext.getFileContext(qualifiedLogDir.toUri(),\n-          getConf()).listStatus(remoteAppLogDir);\n-    } catch (FileNotFoundException fnf) {\n-      logDirNotExist(remoteAppLogDir.toString());\n+    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n+        applicationId, jobOwner);\n+    if (nodeFiles \u003d\u003d null) {\n       return -1;\n     }\n     boolean foundContainerLogs \u003d false;\n     while(nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (!thisNodeFile.getPath().getName().endsWith(\n           LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         try {\n           reader \u003d\n               new AggregatedLogFormat.LogReader(getConf(),\n               thisNodeFile.getPath());\n           if (logType \u003d\u003d null) {\n             if (dumpAContainerLogs(containerId, reader, System.out,\n                 thisNodeFile.getModificationTime()) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           } else {\n             if (dumpAContainerLogsForALogType(containerId, reader, System.out,\n                 thisNodeFile.getModificationTime(), logType) \u003e -1) {\n               foundContainerLogs \u003d true;\n             }\n           }\n         } finally {\n           if (reader !\u003d null) {\n             reader.close();\n           }\n         }\n       }\n     }\n     if (!foundContainerLogs) {\n       containerLogNotFound(containerId);\n       return -1;\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int dumpAContainersLogsForALogTypeWithoutNodeId(String appId,\n      String containerId, String jobOwner, List\u003cString\u003e logType)\n    throws IOException {\n    ApplicationId applicationId \u003d ConverterUtils.toApplicationId(appId);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d getRemoteNodeFileDir(\n        applicationId, jobOwner);\n    if (nodeFiles \u003d\u003d null) {\n      return -1;\n    }\n    boolean foundContainerLogs \u003d false;\n    while(nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (!thisNodeFile.getPath().getName().endsWith(\n          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        try {\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          if (logType \u003d\u003d null) {\n            if (dumpAContainerLogs(containerId, reader, System.out,\n                thisNodeFile.getModificationTime()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          } else {\n            if (dumpAContainerLogsForALogType(containerId, reader, System.out,\n                thisNodeFile.getModificationTime(), logType) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          }\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n        }\n      }\n    }\n    if (!foundContainerLogs) {\n      containerLogNotFound(containerId);\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java",
      "extendedDetails": {}
    },
    "66b07d83740a2ec3e6bfb2bfd064863bae37a1b5": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4966. Improve yarn logs to fetch container logs without specifying nodeId. Contributed by Xuan Gong.\n",
      "commitDate": "27/04/16 3:26 AM",
      "commitName": "66b07d83740a2ec3e6bfb2bfd064863bae37a1b5",
      "commitAuthor": "Varun Vasudev",
      "diff": "@@ -0,0 +1,56 @@\n+  public int dumpAContainersLogsForALogTypeWithoutNodeId(String appId,\n+      String containerId, String jobOwner, List\u003cString\u003e logType)\n+    throws IOException {\n+    Path remoteRootLogDir \u003d new Path(getConf().get(\n+        YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n+        YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n+    ApplicationId applicationId \u003d ConverterUtils.toApplicationId(appId);\n+    String user \u003d jobOwner;\n+    String logDirSuffix \u003d LogAggregationUtils.getRemoteNodeLogDirSuffix(\n+        getConf());\n+    Path remoteAppLogDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n+        remoteRootLogDir, applicationId, user, logDirSuffix);\n+    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n+    try {\n+      Path qualifiedLogDir \u003d\n+          FileContext.getFileContext(getConf()).makeQualified(remoteAppLogDir);\n+      nodeFiles \u003d FileContext.getFileContext(qualifiedLogDir.toUri(),\n+          getConf()).listStatus(remoteAppLogDir);\n+    } catch (FileNotFoundException fnf) {\n+      logDirNotExist(remoteAppLogDir.toString());\n+      return -1;\n+    }\n+    boolean foundContainerLogs \u003d false;\n+    while(nodeFiles.hasNext()) {\n+      FileStatus thisNodeFile \u003d nodeFiles.next();\n+      if (!thisNodeFile.getPath().getName().endsWith(\n+          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n+        AggregatedLogFormat.LogReader reader \u003d null;\n+        try {\n+          reader \u003d\n+              new AggregatedLogFormat.LogReader(getConf(),\n+              thisNodeFile.getPath());\n+          if (logType \u003d\u003d null) {\n+            if (dumpAContainerLogs(containerId, reader, System.out,\n+                thisNodeFile.getModificationTime()) \u003e -1) {\n+              foundContainerLogs \u003d true;\n+            }\n+          } else {\n+            if (dumpAContainerLogsForALogType(containerId, reader, System.out,\n+                thisNodeFile.getModificationTime(), logType) \u003e -1) {\n+              foundContainerLogs \u003d true;\n+            }\n+          }\n+        } finally {\n+          if (reader !\u003d null) {\n+            reader.close();\n+          }\n+        }\n+      }\n+    }\n+    if (!foundContainerLogs) {\n+      containerLogNotFound(containerId);\n+      return -1;\n+    }\n+    return 0;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public int dumpAContainersLogsForALogTypeWithoutNodeId(String appId,\n      String containerId, String jobOwner, List\u003cString\u003e logType)\n    throws IOException {\n    Path remoteRootLogDir \u003d new Path(getConf().get(\n        YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n        YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n    ApplicationId applicationId \u003d ConverterUtils.toApplicationId(appId);\n    String user \u003d jobOwner;\n    String logDirSuffix \u003d LogAggregationUtils.getRemoteNodeLogDirSuffix(\n        getConf());\n    Path remoteAppLogDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n        remoteRootLogDir, applicationId, user, logDirSuffix);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n    try {\n      Path qualifiedLogDir \u003d\n          FileContext.getFileContext(getConf()).makeQualified(remoteAppLogDir);\n      nodeFiles \u003d FileContext.getFileContext(qualifiedLogDir.toUri(),\n          getConf()).listStatus(remoteAppLogDir);\n    } catch (FileNotFoundException fnf) {\n      logDirNotExist(remoteAppLogDir.toString());\n      return -1;\n    }\n    boolean foundContainerLogs \u003d false;\n    while(nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (!thisNodeFile.getPath().getName().endsWith(\n          LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        try {\n          reader \u003d\n              new AggregatedLogFormat.LogReader(getConf(),\n              thisNodeFile.getPath());\n          if (logType \u003d\u003d null) {\n            if (dumpAContainerLogs(containerId, reader, System.out,\n                thisNodeFile.getModificationTime()) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          } else {\n            if (dumpAContainerLogsForALogType(containerId, reader, System.out,\n                thisNodeFile.getModificationTime(), logType) \u003e -1) {\n              foundContainerLogs \u003d true;\n            }\n          }\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n        }\n      }\n    }\n    if (!foundContainerLogs) {\n      containerLogNotFound(containerId);\n      return -1;\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/LogCLIHelpers.java"
    }
  }
}