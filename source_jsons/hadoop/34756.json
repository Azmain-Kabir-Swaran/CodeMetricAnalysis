{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AMRMProxyService.java",
  "functionName": "initializePipeline",
  "functionId": "initializePipeline___applicationAttemptId-ApplicationAttemptId__user-String__amrmToken-Token__AMRMTokenIdentifier____localToken-Token__AMRMTokenIdentifier____recoveredDataMap-Map__String,byte[]____isRecovery-boolean__credentials-Credentials",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/AMRMProxyService.java",
  "functionStartLine": 443,
  "functionEndLine": 537,
  "numCommitsSeen": 38,
  "timeTaken": 4856,
  "changeHistory": [
    "d5f66888b8d767ee6706fab9950c194a1bf26d32",
    "49aa60e50d20f8c18ed6f00fa8966244536fe7da",
    "749e5c09b9990590c282ea944e24735b795351fc",
    "cd9ff27ffc9369820d0c39200a11bf00e6a767c8",
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02"
  ],
  "changeHistoryShort": {
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": "Ymultichange(Yparameterchange,Ybodychange)",
    "49aa60e50d20f8c18ed6f00fa8966244536fe7da": "Ymultichange(Yparameterchange,Ybodychange)",
    "749e5c09b9990590c282ea944e24735b795351fc": "Ybodychange",
    "cd9ff27ffc9369820d0c39200a11bf00e6a767c8": "Ybodychange",
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6128. Add support for AMRMProxy HA. (Botong Huang via Subru).\n",
      "commitDate": "17/11/17 5:39 PM",
      "commitName": "d5f66888b8d767ee6706fab9950c194a1bf26d32",
      "commitAuthor": "Subru Krishnan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6128. Add support for AMRMProxy HA. (Botong Huang via Subru).\n",
          "commitDate": "17/11/17 5:39 PM",
          "commitName": "d5f66888b8d767ee6706fab9950c194a1bf26d32",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "22/06/17 11:27 AM",
          "commitNameOld": "49aa60e50d20f8c18ed6f00fa8966244536fe7da",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 148.3,
          "commitsBetweenForRepo": 1203,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,95 @@\n   protected void initializePipeline(ApplicationAttemptId applicationAttemptId,\n       String user, Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n       Token\u003cAMRMTokenIdentifier\u003e localToken,\n-      Map\u003cString, byte[]\u003e recoveredDataMap, boolean isRecovery) {\n+      Map\u003cString, byte[]\u003e recoveredDataMap, boolean isRecovery,\n+      Credentials credentials) {\n     RequestInterceptorChainWrapper chainWrapper \u003d null;\n     synchronized (applPipelineMap) {\n       if (applPipelineMap\n           .containsKey(applicationAttemptId.getApplicationId())) {\n         LOG.warn(\"Request to start an already existing appId was received. \"\n             + \" This can happen if an application failed and a new attempt \"\n             + \"was created on this machine.  ApplicationId: \"\n             + applicationAttemptId.toString());\n \n         RequestInterceptorChainWrapper chainWrapperBackup \u003d\n             this.applPipelineMap.get(applicationAttemptId.getApplicationId());\n         if (chainWrapperBackup !\u003d null\n             \u0026\u0026 chainWrapperBackup.getApplicationAttemptId() !\u003d null\n             \u0026\u0026 !chainWrapperBackup.getApplicationAttemptId()\n                 .equals(applicationAttemptId)) {\n           // TODO: revisit in AMRMProxy HA in YARN-6128\n           // Remove the existing pipeline\n           LOG.info(\"Remove the previous pipeline for ApplicationId: \"\n               + applicationAttemptId.toString());\n           RequestInterceptorChainWrapper pipeline \u003d\n               applPipelineMap.remove(applicationAttemptId.getApplicationId());\n \n           if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n             try {\n               this.nmContext.getNMStateStore()\n                   .removeAMRMProxyAppContext(applicationAttemptId);\n             } catch (IOException e) {\n               LOG.error(\"Error removing AMRMProxy application context for \"\n                   + applicationAttemptId, e);\n             }\n           }\n \n           try {\n             pipeline.getRootInterceptor().shutdown();\n           } catch (Throwable ex) {\n             LOG.warn(\n                 \"Failed to shutdown the request processing pipeline for app:\"\n                     + applicationAttemptId.getApplicationId(),\n                 ex);\n           }\n         } else {\n           return;\n         }\n       }\n \n       chainWrapper \u003d new RequestInterceptorChainWrapper();\n       this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n           chainWrapper);\n     }\n \n     // We register the pipeline instance in the map first and then initialize it\n     // later because chain initialization can be expensive and we would like to\n     // release the lock as soon as possible to prevent other applications from\n     // blocking when one application\u0027s chain is initializing\n     LOG.info(\"Initializing request processing pipeline for application. \"\n         + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n         + user);\n \n     try {\n       RequestInterceptor interceptorChain \u003d\n           this.createRequestInterceptorChain();\n-      interceptorChain.init(createApplicationMasterContext(this.nmContext,\n-          applicationAttemptId, user, amrmToken, localToken));\n+      interceptorChain.init(\n+          createApplicationMasterContext(this.nmContext, applicationAttemptId,\n+              user, amrmToken, localToken, credentials, this.registry));\n       if (isRecovery) {\n         if (recoveredDataMap \u003d\u003d null) {\n           throw new YarnRuntimeException(\n               \"null recoveredDataMap recieved for recover\");\n         }\n         interceptorChain.recover(recoveredDataMap);\n       }\n       chainWrapper.init(interceptorChain, applicationAttemptId);\n \n       if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n         try {\n           this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n               applicationAttemptId, NMSS_USER_KEY, user.getBytes(\"UTF-8\"));\n           this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n               applicationAttemptId, NMSS_AMRMTOKEN_KEY,\n               amrmToken.encodeToUrlString().getBytes(\"UTF-8\"));\n         } catch (IOException e) {\n           LOG.error(\"Error storing AMRMProxy application context entry for \"\n               + applicationAttemptId, e);\n         }\n       }\n     } catch (Exception e) {\n       this.applPipelineMap.remove(applicationAttemptId.getApplicationId());\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void initializePipeline(ApplicationAttemptId applicationAttemptId,\n      String user, Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n      Token\u003cAMRMTokenIdentifier\u003e localToken,\n      Map\u003cString, byte[]\u003e recoveredDataMap, boolean isRecovery,\n      Credentials credentials) {\n    RequestInterceptorChainWrapper chainWrapper \u003d null;\n    synchronized (applPipelineMap) {\n      if (applPipelineMap\n          .containsKey(applicationAttemptId.getApplicationId())) {\n        LOG.warn(\"Request to start an already existing appId was received. \"\n            + \" This can happen if an application failed and a new attempt \"\n            + \"was created on this machine.  ApplicationId: \"\n            + applicationAttemptId.toString());\n\n        RequestInterceptorChainWrapper chainWrapperBackup \u003d\n            this.applPipelineMap.get(applicationAttemptId.getApplicationId());\n        if (chainWrapperBackup !\u003d null\n            \u0026\u0026 chainWrapperBackup.getApplicationAttemptId() !\u003d null\n            \u0026\u0026 !chainWrapperBackup.getApplicationAttemptId()\n                .equals(applicationAttemptId)) {\n          // TODO: revisit in AMRMProxy HA in YARN-6128\n          // Remove the existing pipeline\n          LOG.info(\"Remove the previous pipeline for ApplicationId: \"\n              + applicationAttemptId.toString());\n          RequestInterceptorChainWrapper pipeline \u003d\n              applPipelineMap.remove(applicationAttemptId.getApplicationId());\n\n          if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n            try {\n              this.nmContext.getNMStateStore()\n                  .removeAMRMProxyAppContext(applicationAttemptId);\n            } catch (IOException e) {\n              LOG.error(\"Error removing AMRMProxy application context for \"\n                  + applicationAttemptId, e);\n            }\n          }\n\n          try {\n            pipeline.getRootInterceptor().shutdown();\n          } catch (Throwable ex) {\n            LOG.warn(\n                \"Failed to shutdown the request processing pipeline for app:\"\n                    + applicationAttemptId.getApplicationId(),\n                ex);\n          }\n        } else {\n          return;\n        }\n      }\n\n      chainWrapper \u003d new RequestInterceptorChainWrapper();\n      this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n          chainWrapper);\n    }\n\n    // We register the pipeline instance in the map first and then initialize it\n    // later because chain initialization can be expensive and we would like to\n    // release the lock as soon as possible to prevent other applications from\n    // blocking when one application\u0027s chain is initializing\n    LOG.info(\"Initializing request processing pipeline for application. \"\n        + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n        + user);\n\n    try {\n      RequestInterceptor interceptorChain \u003d\n          this.createRequestInterceptorChain();\n      interceptorChain.init(\n          createApplicationMasterContext(this.nmContext, applicationAttemptId,\n              user, amrmToken, localToken, credentials, this.registry));\n      if (isRecovery) {\n        if (recoveredDataMap \u003d\u003d null) {\n          throw new YarnRuntimeException(\n              \"null recoveredDataMap recieved for recover\");\n        }\n        interceptorChain.recover(recoveredDataMap);\n      }\n      chainWrapper.init(interceptorChain, applicationAttemptId);\n\n      if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n        try {\n          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n              applicationAttemptId, NMSS_USER_KEY, user.getBytes(\"UTF-8\"));\n          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n              applicationAttemptId, NMSS_AMRMTOKEN_KEY,\n              amrmToken.encodeToUrlString().getBytes(\"UTF-8\"));\n        } catch (IOException e) {\n          LOG.error(\"Error storing AMRMProxy application context entry for \"\n              + applicationAttemptId, e);\n        }\n      }\n    } catch (Exception e) {\n      this.applPipelineMap.remove(applicationAttemptId.getApplicationId());\n      throw e;\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/AMRMProxyService.java",
          "extendedDetails": {
            "oldValue": "[applicationAttemptId-ApplicationAttemptId, user-String, amrmToken-Token\u003cAMRMTokenIdentifier\u003e, localToken-Token\u003cAMRMTokenIdentifier\u003e, recoveredDataMap-Map\u003cString,byte[]\u003e, isRecovery-boolean]",
            "newValue": "[applicationAttemptId-ApplicationAttemptId, user-String, amrmToken-Token\u003cAMRMTokenIdentifier\u003e, localToken-Token\u003cAMRMTokenIdentifier\u003e, recoveredDataMap-Map\u003cString,byte[]\u003e, isRecovery-boolean, credentials-Credentials]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6128. Add support for AMRMProxy HA. (Botong Huang via Subru).\n",
          "commitDate": "17/11/17 5:39 PM",
          "commitName": "d5f66888b8d767ee6706fab9950c194a1bf26d32",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "22/06/17 11:27 AM",
          "commitNameOld": "49aa60e50d20f8c18ed6f00fa8966244536fe7da",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 148.3,
          "commitsBetweenForRepo": 1203,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,95 @@\n   protected void initializePipeline(ApplicationAttemptId applicationAttemptId,\n       String user, Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n       Token\u003cAMRMTokenIdentifier\u003e localToken,\n-      Map\u003cString, byte[]\u003e recoveredDataMap, boolean isRecovery) {\n+      Map\u003cString, byte[]\u003e recoveredDataMap, boolean isRecovery,\n+      Credentials credentials) {\n     RequestInterceptorChainWrapper chainWrapper \u003d null;\n     synchronized (applPipelineMap) {\n       if (applPipelineMap\n           .containsKey(applicationAttemptId.getApplicationId())) {\n         LOG.warn(\"Request to start an already existing appId was received. \"\n             + \" This can happen if an application failed and a new attempt \"\n             + \"was created on this machine.  ApplicationId: \"\n             + applicationAttemptId.toString());\n \n         RequestInterceptorChainWrapper chainWrapperBackup \u003d\n             this.applPipelineMap.get(applicationAttemptId.getApplicationId());\n         if (chainWrapperBackup !\u003d null\n             \u0026\u0026 chainWrapperBackup.getApplicationAttemptId() !\u003d null\n             \u0026\u0026 !chainWrapperBackup.getApplicationAttemptId()\n                 .equals(applicationAttemptId)) {\n           // TODO: revisit in AMRMProxy HA in YARN-6128\n           // Remove the existing pipeline\n           LOG.info(\"Remove the previous pipeline for ApplicationId: \"\n               + applicationAttemptId.toString());\n           RequestInterceptorChainWrapper pipeline \u003d\n               applPipelineMap.remove(applicationAttemptId.getApplicationId());\n \n           if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n             try {\n               this.nmContext.getNMStateStore()\n                   .removeAMRMProxyAppContext(applicationAttemptId);\n             } catch (IOException e) {\n               LOG.error(\"Error removing AMRMProxy application context for \"\n                   + applicationAttemptId, e);\n             }\n           }\n \n           try {\n             pipeline.getRootInterceptor().shutdown();\n           } catch (Throwable ex) {\n             LOG.warn(\n                 \"Failed to shutdown the request processing pipeline for app:\"\n                     + applicationAttemptId.getApplicationId(),\n                 ex);\n           }\n         } else {\n           return;\n         }\n       }\n \n       chainWrapper \u003d new RequestInterceptorChainWrapper();\n       this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n           chainWrapper);\n     }\n \n     // We register the pipeline instance in the map first and then initialize it\n     // later because chain initialization can be expensive and we would like to\n     // release the lock as soon as possible to prevent other applications from\n     // blocking when one application\u0027s chain is initializing\n     LOG.info(\"Initializing request processing pipeline for application. \"\n         + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n         + user);\n \n     try {\n       RequestInterceptor interceptorChain \u003d\n           this.createRequestInterceptorChain();\n-      interceptorChain.init(createApplicationMasterContext(this.nmContext,\n-          applicationAttemptId, user, amrmToken, localToken));\n+      interceptorChain.init(\n+          createApplicationMasterContext(this.nmContext, applicationAttemptId,\n+              user, amrmToken, localToken, credentials, this.registry));\n       if (isRecovery) {\n         if (recoveredDataMap \u003d\u003d null) {\n           throw new YarnRuntimeException(\n               \"null recoveredDataMap recieved for recover\");\n         }\n         interceptorChain.recover(recoveredDataMap);\n       }\n       chainWrapper.init(interceptorChain, applicationAttemptId);\n \n       if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n         try {\n           this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n               applicationAttemptId, NMSS_USER_KEY, user.getBytes(\"UTF-8\"));\n           this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n               applicationAttemptId, NMSS_AMRMTOKEN_KEY,\n               amrmToken.encodeToUrlString().getBytes(\"UTF-8\"));\n         } catch (IOException e) {\n           LOG.error(\"Error storing AMRMProxy application context entry for \"\n               + applicationAttemptId, e);\n         }\n       }\n     } catch (Exception e) {\n       this.applPipelineMap.remove(applicationAttemptId.getApplicationId());\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void initializePipeline(ApplicationAttemptId applicationAttemptId,\n      String user, Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n      Token\u003cAMRMTokenIdentifier\u003e localToken,\n      Map\u003cString, byte[]\u003e recoveredDataMap, boolean isRecovery,\n      Credentials credentials) {\n    RequestInterceptorChainWrapper chainWrapper \u003d null;\n    synchronized (applPipelineMap) {\n      if (applPipelineMap\n          .containsKey(applicationAttemptId.getApplicationId())) {\n        LOG.warn(\"Request to start an already existing appId was received. \"\n            + \" This can happen if an application failed and a new attempt \"\n            + \"was created on this machine.  ApplicationId: \"\n            + applicationAttemptId.toString());\n\n        RequestInterceptorChainWrapper chainWrapperBackup \u003d\n            this.applPipelineMap.get(applicationAttemptId.getApplicationId());\n        if (chainWrapperBackup !\u003d null\n            \u0026\u0026 chainWrapperBackup.getApplicationAttemptId() !\u003d null\n            \u0026\u0026 !chainWrapperBackup.getApplicationAttemptId()\n                .equals(applicationAttemptId)) {\n          // TODO: revisit in AMRMProxy HA in YARN-6128\n          // Remove the existing pipeline\n          LOG.info(\"Remove the previous pipeline for ApplicationId: \"\n              + applicationAttemptId.toString());\n          RequestInterceptorChainWrapper pipeline \u003d\n              applPipelineMap.remove(applicationAttemptId.getApplicationId());\n\n          if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n            try {\n              this.nmContext.getNMStateStore()\n                  .removeAMRMProxyAppContext(applicationAttemptId);\n            } catch (IOException e) {\n              LOG.error(\"Error removing AMRMProxy application context for \"\n                  + applicationAttemptId, e);\n            }\n          }\n\n          try {\n            pipeline.getRootInterceptor().shutdown();\n          } catch (Throwable ex) {\n            LOG.warn(\n                \"Failed to shutdown the request processing pipeline for app:\"\n                    + applicationAttemptId.getApplicationId(),\n                ex);\n          }\n        } else {\n          return;\n        }\n      }\n\n      chainWrapper \u003d new RequestInterceptorChainWrapper();\n      this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n          chainWrapper);\n    }\n\n    // We register the pipeline instance in the map first and then initialize it\n    // later because chain initialization can be expensive and we would like to\n    // release the lock as soon as possible to prevent other applications from\n    // blocking when one application\u0027s chain is initializing\n    LOG.info(\"Initializing request processing pipeline for application. \"\n        + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n        + user);\n\n    try {\n      RequestInterceptor interceptorChain \u003d\n          this.createRequestInterceptorChain();\n      interceptorChain.init(\n          createApplicationMasterContext(this.nmContext, applicationAttemptId,\n              user, amrmToken, localToken, credentials, this.registry));\n      if (isRecovery) {\n        if (recoveredDataMap \u003d\u003d null) {\n          throw new YarnRuntimeException(\n              \"null recoveredDataMap recieved for recover\");\n        }\n        interceptorChain.recover(recoveredDataMap);\n      }\n      chainWrapper.init(interceptorChain, applicationAttemptId);\n\n      if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n        try {\n          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n              applicationAttemptId, NMSS_USER_KEY, user.getBytes(\"UTF-8\"));\n          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n              applicationAttemptId, NMSS_AMRMTOKEN_KEY,\n              amrmToken.encodeToUrlString().getBytes(\"UTF-8\"));\n        } catch (IOException e) {\n          LOG.error(\"Error storing AMRMProxy application context entry for \"\n              + applicationAttemptId, e);\n        }\n      }\n    } catch (Exception e) {\n      this.applPipelineMap.remove(applicationAttemptId.getApplicationId());\n      throw e;\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/AMRMProxyService.java",
          "extendedDetails": {}
        }
      ]
    },
    "49aa60e50d20f8c18ed6f00fa8966244536fe7da": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6127. Add support for work preserving NM restart when AMRMProxy is enabled. (Botong Huang via asuresh).\n",
      "commitDate": "22/06/17 11:27 AM",
      "commitName": "49aa60e50d20f8c18ed6f00fa8966244536fe7da",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6127. Add support for work preserving NM restart when AMRMProxy is enabled. (Botong Huang via asuresh).\n",
          "commitDate": "22/06/17 11:27 AM",
          "commitName": "49aa60e50d20f8c18ed6f00fa8966244536fe7da",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "08/05/17 4:55 PM",
          "commitNameOld": "749e5c09b9990590c282ea944e24735b795351fc",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 44.77,
          "commitsBetweenForRepo": 224,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,93 @@\n   protected void initializePipeline(ApplicationAttemptId applicationAttemptId,\n       String user, Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n-      Token\u003cAMRMTokenIdentifier\u003e localToken) {\n+      Token\u003cAMRMTokenIdentifier\u003e localToken,\n+      Map\u003cString, byte[]\u003e recoveredDataMap, boolean isRecovery) {\n     RequestInterceptorChainWrapper chainWrapper \u003d null;\n     synchronized (applPipelineMap) {\n       if (applPipelineMap\n           .containsKey(applicationAttemptId.getApplicationId())) {\n         LOG.warn(\"Request to start an already existing appId was received. \"\n             + \" This can happen if an application failed and a new attempt \"\n             + \"was created on this machine.  ApplicationId: \"\n             + applicationAttemptId.toString());\n \n         RequestInterceptorChainWrapper chainWrapperBackup \u003d\n             this.applPipelineMap.get(applicationAttemptId.getApplicationId());\n         if (chainWrapperBackup !\u003d null\n             \u0026\u0026 chainWrapperBackup.getApplicationAttemptId() !\u003d null\n             \u0026\u0026 !chainWrapperBackup.getApplicationAttemptId()\n                 .equals(applicationAttemptId)) {\n+          // TODO: revisit in AMRMProxy HA in YARN-6128\n           // Remove the existing pipeline\n           LOG.info(\"Remove the previous pipeline for ApplicationId: \"\n               + applicationAttemptId.toString());\n           RequestInterceptorChainWrapper pipeline \u003d\n               applPipelineMap.remove(applicationAttemptId.getApplicationId());\n+\n+          if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n+            try {\n+              this.nmContext.getNMStateStore()\n+                  .removeAMRMProxyAppContext(applicationAttemptId);\n+            } catch (IOException e) {\n+              LOG.error(\"Error removing AMRMProxy application context for \"\n+                  + applicationAttemptId, e);\n+            }\n+          }\n+\n           try {\n             pipeline.getRootInterceptor().shutdown();\n           } catch (Throwable ex) {\n             LOG.warn(\n                 \"Failed to shutdown the request processing pipeline for app:\"\n                     + applicationAttemptId.getApplicationId(),\n                 ex);\n           }\n         } else {\n           return;\n         }\n       }\n \n       chainWrapper \u003d new RequestInterceptorChainWrapper();\n       this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n           chainWrapper);\n     }\n \n     // We register the pipeline instance in the map first and then initialize it\n     // later because chain initialization can be expensive and we would like to\n     // release the lock as soon as possible to prevent other applications from\n     // blocking when one application\u0027s chain is initializing\n     LOG.info(\"Initializing request processing pipeline for application. \"\n         + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n         + user);\n \n     try {\n       RequestInterceptor interceptorChain \u003d\n           this.createRequestInterceptorChain();\n       interceptorChain.init(createApplicationMasterContext(this.nmContext,\n           applicationAttemptId, user, amrmToken, localToken));\n+      if (isRecovery) {\n+        if (recoveredDataMap \u003d\u003d null) {\n+          throw new YarnRuntimeException(\n+              \"null recoveredDataMap recieved for recover\");\n+        }\n+        interceptorChain.recover(recoveredDataMap);\n+      }\n       chainWrapper.init(interceptorChain, applicationAttemptId);\n+\n+      if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n+        try {\n+          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n+              applicationAttemptId, NMSS_USER_KEY, user.getBytes(\"UTF-8\"));\n+          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n+              applicationAttemptId, NMSS_AMRMTOKEN_KEY,\n+              amrmToken.encodeToUrlString().getBytes(\"UTF-8\"));\n+        } catch (IOException e) {\n+          LOG.error(\"Error storing AMRMProxy application context entry for \"\n+              + applicationAttemptId, e);\n+        }\n+      }\n     } catch (Exception e) {\n       this.applPipelineMap.remove(applicationAttemptId.getApplicationId());\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void initializePipeline(ApplicationAttemptId applicationAttemptId,\n      String user, Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n      Token\u003cAMRMTokenIdentifier\u003e localToken,\n      Map\u003cString, byte[]\u003e recoveredDataMap, boolean isRecovery) {\n    RequestInterceptorChainWrapper chainWrapper \u003d null;\n    synchronized (applPipelineMap) {\n      if (applPipelineMap\n          .containsKey(applicationAttemptId.getApplicationId())) {\n        LOG.warn(\"Request to start an already existing appId was received. \"\n            + \" This can happen if an application failed and a new attempt \"\n            + \"was created on this machine.  ApplicationId: \"\n            + applicationAttemptId.toString());\n\n        RequestInterceptorChainWrapper chainWrapperBackup \u003d\n            this.applPipelineMap.get(applicationAttemptId.getApplicationId());\n        if (chainWrapperBackup !\u003d null\n            \u0026\u0026 chainWrapperBackup.getApplicationAttemptId() !\u003d null\n            \u0026\u0026 !chainWrapperBackup.getApplicationAttemptId()\n                .equals(applicationAttemptId)) {\n          // TODO: revisit in AMRMProxy HA in YARN-6128\n          // Remove the existing pipeline\n          LOG.info(\"Remove the previous pipeline for ApplicationId: \"\n              + applicationAttemptId.toString());\n          RequestInterceptorChainWrapper pipeline \u003d\n              applPipelineMap.remove(applicationAttemptId.getApplicationId());\n\n          if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n            try {\n              this.nmContext.getNMStateStore()\n                  .removeAMRMProxyAppContext(applicationAttemptId);\n            } catch (IOException e) {\n              LOG.error(\"Error removing AMRMProxy application context for \"\n                  + applicationAttemptId, e);\n            }\n          }\n\n          try {\n            pipeline.getRootInterceptor().shutdown();\n          } catch (Throwable ex) {\n            LOG.warn(\n                \"Failed to shutdown the request processing pipeline for app:\"\n                    + applicationAttemptId.getApplicationId(),\n                ex);\n          }\n        } else {\n          return;\n        }\n      }\n\n      chainWrapper \u003d new RequestInterceptorChainWrapper();\n      this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n          chainWrapper);\n    }\n\n    // We register the pipeline instance in the map first and then initialize it\n    // later because chain initialization can be expensive and we would like to\n    // release the lock as soon as possible to prevent other applications from\n    // blocking when one application\u0027s chain is initializing\n    LOG.info(\"Initializing request processing pipeline for application. \"\n        + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n        + user);\n\n    try {\n      RequestInterceptor interceptorChain \u003d\n          this.createRequestInterceptorChain();\n      interceptorChain.init(createApplicationMasterContext(this.nmContext,\n          applicationAttemptId, user, amrmToken, localToken));\n      if (isRecovery) {\n        if (recoveredDataMap \u003d\u003d null) {\n          throw new YarnRuntimeException(\n              \"null recoveredDataMap recieved for recover\");\n        }\n        interceptorChain.recover(recoveredDataMap);\n      }\n      chainWrapper.init(interceptorChain, applicationAttemptId);\n\n      if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n        try {\n          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n              applicationAttemptId, NMSS_USER_KEY, user.getBytes(\"UTF-8\"));\n          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n              applicationAttemptId, NMSS_AMRMTOKEN_KEY,\n              amrmToken.encodeToUrlString().getBytes(\"UTF-8\"));\n        } catch (IOException e) {\n          LOG.error(\"Error storing AMRMProxy application context entry for \"\n              + applicationAttemptId, e);\n        }\n      }\n    } catch (Exception e) {\n      this.applPipelineMap.remove(applicationAttemptId.getApplicationId());\n      throw e;\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/AMRMProxyService.java",
          "extendedDetails": {
            "oldValue": "[applicationAttemptId-ApplicationAttemptId, user-String, amrmToken-Token\u003cAMRMTokenIdentifier\u003e, localToken-Token\u003cAMRMTokenIdentifier\u003e]",
            "newValue": "[applicationAttemptId-ApplicationAttemptId, user-String, amrmToken-Token\u003cAMRMTokenIdentifier\u003e, localToken-Token\u003cAMRMTokenIdentifier\u003e, recoveredDataMap-Map\u003cString,byte[]\u003e, isRecovery-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6127. Add support for work preserving NM restart when AMRMProxy is enabled. (Botong Huang via asuresh).\n",
          "commitDate": "22/06/17 11:27 AM",
          "commitName": "49aa60e50d20f8c18ed6f00fa8966244536fe7da",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "08/05/17 4:55 PM",
          "commitNameOld": "749e5c09b9990590c282ea944e24735b795351fc",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 44.77,
          "commitsBetweenForRepo": 224,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,93 @@\n   protected void initializePipeline(ApplicationAttemptId applicationAttemptId,\n       String user, Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n-      Token\u003cAMRMTokenIdentifier\u003e localToken) {\n+      Token\u003cAMRMTokenIdentifier\u003e localToken,\n+      Map\u003cString, byte[]\u003e recoveredDataMap, boolean isRecovery) {\n     RequestInterceptorChainWrapper chainWrapper \u003d null;\n     synchronized (applPipelineMap) {\n       if (applPipelineMap\n           .containsKey(applicationAttemptId.getApplicationId())) {\n         LOG.warn(\"Request to start an already existing appId was received. \"\n             + \" This can happen if an application failed and a new attempt \"\n             + \"was created on this machine.  ApplicationId: \"\n             + applicationAttemptId.toString());\n \n         RequestInterceptorChainWrapper chainWrapperBackup \u003d\n             this.applPipelineMap.get(applicationAttemptId.getApplicationId());\n         if (chainWrapperBackup !\u003d null\n             \u0026\u0026 chainWrapperBackup.getApplicationAttemptId() !\u003d null\n             \u0026\u0026 !chainWrapperBackup.getApplicationAttemptId()\n                 .equals(applicationAttemptId)) {\n+          // TODO: revisit in AMRMProxy HA in YARN-6128\n           // Remove the existing pipeline\n           LOG.info(\"Remove the previous pipeline for ApplicationId: \"\n               + applicationAttemptId.toString());\n           RequestInterceptorChainWrapper pipeline \u003d\n               applPipelineMap.remove(applicationAttemptId.getApplicationId());\n+\n+          if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n+            try {\n+              this.nmContext.getNMStateStore()\n+                  .removeAMRMProxyAppContext(applicationAttemptId);\n+            } catch (IOException e) {\n+              LOG.error(\"Error removing AMRMProxy application context for \"\n+                  + applicationAttemptId, e);\n+            }\n+          }\n+\n           try {\n             pipeline.getRootInterceptor().shutdown();\n           } catch (Throwable ex) {\n             LOG.warn(\n                 \"Failed to shutdown the request processing pipeline for app:\"\n                     + applicationAttemptId.getApplicationId(),\n                 ex);\n           }\n         } else {\n           return;\n         }\n       }\n \n       chainWrapper \u003d new RequestInterceptorChainWrapper();\n       this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n           chainWrapper);\n     }\n \n     // We register the pipeline instance in the map first and then initialize it\n     // later because chain initialization can be expensive and we would like to\n     // release the lock as soon as possible to prevent other applications from\n     // blocking when one application\u0027s chain is initializing\n     LOG.info(\"Initializing request processing pipeline for application. \"\n         + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n         + user);\n \n     try {\n       RequestInterceptor interceptorChain \u003d\n           this.createRequestInterceptorChain();\n       interceptorChain.init(createApplicationMasterContext(this.nmContext,\n           applicationAttemptId, user, amrmToken, localToken));\n+      if (isRecovery) {\n+        if (recoveredDataMap \u003d\u003d null) {\n+          throw new YarnRuntimeException(\n+              \"null recoveredDataMap recieved for recover\");\n+        }\n+        interceptorChain.recover(recoveredDataMap);\n+      }\n       chainWrapper.init(interceptorChain, applicationAttemptId);\n+\n+      if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n+        try {\n+          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n+              applicationAttemptId, NMSS_USER_KEY, user.getBytes(\"UTF-8\"));\n+          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n+              applicationAttemptId, NMSS_AMRMTOKEN_KEY,\n+              amrmToken.encodeToUrlString().getBytes(\"UTF-8\"));\n+        } catch (IOException e) {\n+          LOG.error(\"Error storing AMRMProxy application context entry for \"\n+              + applicationAttemptId, e);\n+        }\n+      }\n     } catch (Exception e) {\n       this.applPipelineMap.remove(applicationAttemptId.getApplicationId());\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void initializePipeline(ApplicationAttemptId applicationAttemptId,\n      String user, Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n      Token\u003cAMRMTokenIdentifier\u003e localToken,\n      Map\u003cString, byte[]\u003e recoveredDataMap, boolean isRecovery) {\n    RequestInterceptorChainWrapper chainWrapper \u003d null;\n    synchronized (applPipelineMap) {\n      if (applPipelineMap\n          .containsKey(applicationAttemptId.getApplicationId())) {\n        LOG.warn(\"Request to start an already existing appId was received. \"\n            + \" This can happen if an application failed and a new attempt \"\n            + \"was created on this machine.  ApplicationId: \"\n            + applicationAttemptId.toString());\n\n        RequestInterceptorChainWrapper chainWrapperBackup \u003d\n            this.applPipelineMap.get(applicationAttemptId.getApplicationId());\n        if (chainWrapperBackup !\u003d null\n            \u0026\u0026 chainWrapperBackup.getApplicationAttemptId() !\u003d null\n            \u0026\u0026 !chainWrapperBackup.getApplicationAttemptId()\n                .equals(applicationAttemptId)) {\n          // TODO: revisit in AMRMProxy HA in YARN-6128\n          // Remove the existing pipeline\n          LOG.info(\"Remove the previous pipeline for ApplicationId: \"\n              + applicationAttemptId.toString());\n          RequestInterceptorChainWrapper pipeline \u003d\n              applPipelineMap.remove(applicationAttemptId.getApplicationId());\n\n          if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n            try {\n              this.nmContext.getNMStateStore()\n                  .removeAMRMProxyAppContext(applicationAttemptId);\n            } catch (IOException e) {\n              LOG.error(\"Error removing AMRMProxy application context for \"\n                  + applicationAttemptId, e);\n            }\n          }\n\n          try {\n            pipeline.getRootInterceptor().shutdown();\n          } catch (Throwable ex) {\n            LOG.warn(\n                \"Failed to shutdown the request processing pipeline for app:\"\n                    + applicationAttemptId.getApplicationId(),\n                ex);\n          }\n        } else {\n          return;\n        }\n      }\n\n      chainWrapper \u003d new RequestInterceptorChainWrapper();\n      this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n          chainWrapper);\n    }\n\n    // We register the pipeline instance in the map first and then initialize it\n    // later because chain initialization can be expensive and we would like to\n    // release the lock as soon as possible to prevent other applications from\n    // blocking when one application\u0027s chain is initializing\n    LOG.info(\"Initializing request processing pipeline for application. \"\n        + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n        + user);\n\n    try {\n      RequestInterceptor interceptorChain \u003d\n          this.createRequestInterceptorChain();\n      interceptorChain.init(createApplicationMasterContext(this.nmContext,\n          applicationAttemptId, user, amrmToken, localToken));\n      if (isRecovery) {\n        if (recoveredDataMap \u003d\u003d null) {\n          throw new YarnRuntimeException(\n              \"null recoveredDataMap recieved for recover\");\n        }\n        interceptorChain.recover(recoveredDataMap);\n      }\n      chainWrapper.init(interceptorChain, applicationAttemptId);\n\n      if (!isRecovery \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n        try {\n          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n              applicationAttemptId, NMSS_USER_KEY, user.getBytes(\"UTF-8\"));\n          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n              applicationAttemptId, NMSS_AMRMTOKEN_KEY,\n              amrmToken.encodeToUrlString().getBytes(\"UTF-8\"));\n        } catch (IOException e) {\n          LOG.error(\"Error storing AMRMProxy application context entry for \"\n              + applicationAttemptId, e);\n        }\n      }\n    } catch (Exception e) {\n      this.applPipelineMap.remove(applicationAttemptId.getApplicationId());\n      throw e;\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/AMRMProxyService.java",
          "extendedDetails": {}
        }
      ]
    },
    "749e5c09b9990590c282ea944e24735b795351fc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6281. Cleanup when AMRMProxy fails to initialize a new interceptor chain. (Botong Huang via Subru)\n\n(cherry picked from commit 57a9afbd45b7ef8e6021cc58f96bd0074bf1389d)\n",
      "commitDate": "08/05/17 4:55 PM",
      "commitName": "749e5c09b9990590c282ea944e24735b795351fc",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "08/05/17 4:41 PM",
      "commitNameOld": "cd9ff27ffc9369820d0c39200a11bf00e6a767c8",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,60 @@\n   protected void initializePipeline(ApplicationAttemptId applicationAttemptId,\n       String user, Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n       Token\u003cAMRMTokenIdentifier\u003e localToken) {\n     RequestInterceptorChainWrapper chainWrapper \u003d null;\n     synchronized (applPipelineMap) {\n       if (applPipelineMap\n           .containsKey(applicationAttemptId.getApplicationId())) {\n         LOG.warn(\"Request to start an already existing appId was received. \"\n             + \" This can happen if an application failed and a new attempt \"\n             + \"was created on this machine.  ApplicationId: \"\n             + applicationAttemptId.toString());\n \n         RequestInterceptorChainWrapper chainWrapperBackup \u003d\n             this.applPipelineMap.get(applicationAttemptId.getApplicationId());\n         if (chainWrapperBackup !\u003d null\n             \u0026\u0026 chainWrapperBackup.getApplicationAttemptId() !\u003d null\n             \u0026\u0026 !chainWrapperBackup.getApplicationAttemptId()\n                 .equals(applicationAttemptId)) {\n           // Remove the existing pipeline\n           LOG.info(\"Remove the previous pipeline for ApplicationId: \"\n               + applicationAttemptId.toString());\n           RequestInterceptorChainWrapper pipeline \u003d\n               applPipelineMap.remove(applicationAttemptId.getApplicationId());\n           try {\n             pipeline.getRootInterceptor().shutdown();\n           } catch (Throwable ex) {\n             LOG.warn(\n                 \"Failed to shutdown the request processing pipeline for app:\"\n                     + applicationAttemptId.getApplicationId(),\n                 ex);\n           }\n         } else {\n           return;\n         }\n       }\n \n       chainWrapper \u003d new RequestInterceptorChainWrapper();\n       this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n           chainWrapper);\n     }\n \n     // We register the pipeline instance in the map first and then initialize it\n     // later because chain initialization can be expensive and we would like to\n     // release the lock as soon as possible to prevent other applications from\n     // blocking when one application\u0027s chain is initializing\n     LOG.info(\"Initializing request processing pipeline for application. \"\n         + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n         + user);\n \n-    RequestInterceptor interceptorChain \u003d\n-        this.createRequestInterceptorChain();\n-    interceptorChain.init(createApplicationMasterContext(\n-        applicationAttemptId, user, amrmToken, localToken));\n-    chainWrapper.init(interceptorChain, applicationAttemptId);\n+    try {\n+      RequestInterceptor interceptorChain \u003d\n+          this.createRequestInterceptorChain();\n+      interceptorChain.init(createApplicationMasterContext(this.nmContext,\n+          applicationAttemptId, user, amrmToken, localToken));\n+      chainWrapper.init(interceptorChain, applicationAttemptId);\n+    } catch (Exception e) {\n+      this.applPipelineMap.remove(applicationAttemptId.getApplicationId());\n+      throw e;\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initializePipeline(ApplicationAttemptId applicationAttemptId,\n      String user, Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n      Token\u003cAMRMTokenIdentifier\u003e localToken) {\n    RequestInterceptorChainWrapper chainWrapper \u003d null;\n    synchronized (applPipelineMap) {\n      if (applPipelineMap\n          .containsKey(applicationAttemptId.getApplicationId())) {\n        LOG.warn(\"Request to start an already existing appId was received. \"\n            + \" This can happen if an application failed and a new attempt \"\n            + \"was created on this machine.  ApplicationId: \"\n            + applicationAttemptId.toString());\n\n        RequestInterceptorChainWrapper chainWrapperBackup \u003d\n            this.applPipelineMap.get(applicationAttemptId.getApplicationId());\n        if (chainWrapperBackup !\u003d null\n            \u0026\u0026 chainWrapperBackup.getApplicationAttemptId() !\u003d null\n            \u0026\u0026 !chainWrapperBackup.getApplicationAttemptId()\n                .equals(applicationAttemptId)) {\n          // Remove the existing pipeline\n          LOG.info(\"Remove the previous pipeline for ApplicationId: \"\n              + applicationAttemptId.toString());\n          RequestInterceptorChainWrapper pipeline \u003d\n              applPipelineMap.remove(applicationAttemptId.getApplicationId());\n          try {\n            pipeline.getRootInterceptor().shutdown();\n          } catch (Throwable ex) {\n            LOG.warn(\n                \"Failed to shutdown the request processing pipeline for app:\"\n                    + applicationAttemptId.getApplicationId(),\n                ex);\n          }\n        } else {\n          return;\n        }\n      }\n\n      chainWrapper \u003d new RequestInterceptorChainWrapper();\n      this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n          chainWrapper);\n    }\n\n    // We register the pipeline instance in the map first and then initialize it\n    // later because chain initialization can be expensive and we would like to\n    // release the lock as soon as possible to prevent other applications from\n    // blocking when one application\u0027s chain is initializing\n    LOG.info(\"Initializing request processing pipeline for application. \"\n        + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n        + user);\n\n    try {\n      RequestInterceptor interceptorChain \u003d\n          this.createRequestInterceptorChain();\n      interceptorChain.init(createApplicationMasterContext(this.nmContext,\n          applicationAttemptId, user, amrmToken, localToken));\n      chainWrapper.init(interceptorChain, applicationAttemptId);\n    } catch (Exception e) {\n      this.applPipelineMap.remove(applicationAttemptId.getApplicationId());\n      throw e;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/AMRMProxyService.java",
      "extendedDetails": {}
    },
    "cd9ff27ffc9369820d0c39200a11bf00e6a767c8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6234. Support multiple attempts on the node when AMRMProxy is enabled. (Giovanni Matteo Fumarola via Subru).\n",
      "commitDate": "08/05/17 4:41 PM",
      "commitName": "cd9ff27ffc9369820d0c39200a11bf00e6a767c8",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "05/05/17 4:27 PM",
      "commitNameOld": "d6eed5acca222a281401c1d524824f0460ea7826",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 3.01,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,55 @@\n-  protected void initializePipeline(\n-      ApplicationAttemptId applicationAttemptId, String user,\n-      Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n+  protected void initializePipeline(ApplicationAttemptId applicationAttemptId,\n+      String user, Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n       Token\u003cAMRMTokenIdentifier\u003e localToken) {\n     RequestInterceptorChainWrapper chainWrapper \u003d null;\n     synchronized (applPipelineMap) {\n-      if (applPipelineMap.containsKey(applicationAttemptId.getApplicationId())) {\n+      if (applPipelineMap\n+          .containsKey(applicationAttemptId.getApplicationId())) {\n         LOG.warn(\"Request to start an already existing appId was received. \"\n             + \" This can happen if an application failed and a new attempt \"\n             + \"was created on this machine.  ApplicationId: \"\n             + applicationAttemptId.toString());\n-        return;\n+\n+        RequestInterceptorChainWrapper chainWrapperBackup \u003d\n+            this.applPipelineMap.get(applicationAttemptId.getApplicationId());\n+        if (chainWrapperBackup !\u003d null\n+            \u0026\u0026 chainWrapperBackup.getApplicationAttemptId() !\u003d null\n+            \u0026\u0026 !chainWrapperBackup.getApplicationAttemptId()\n+                .equals(applicationAttemptId)) {\n+          // Remove the existing pipeline\n+          LOG.info(\"Remove the previous pipeline for ApplicationId: \"\n+              + applicationAttemptId.toString());\n+          RequestInterceptorChainWrapper pipeline \u003d\n+              applPipelineMap.remove(applicationAttemptId.getApplicationId());\n+          try {\n+            pipeline.getRootInterceptor().shutdown();\n+          } catch (Throwable ex) {\n+            LOG.warn(\n+                \"Failed to shutdown the request processing pipeline for app:\"\n+                    + applicationAttemptId.getApplicationId(),\n+                ex);\n+          }\n+        } else {\n+          return;\n+        }\n       }\n \n       chainWrapper \u003d new RequestInterceptorChainWrapper();\n       this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n           chainWrapper);\n     }\n \n     // We register the pipeline instance in the map first and then initialize it\n     // later because chain initialization can be expensive and we would like to\n     // release the lock as soon as possible to prevent other applications from\n     // blocking when one application\u0027s chain is initializing\n     LOG.info(\"Initializing request processing pipeline for application. \"\n         + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n         + user);\n \n     RequestInterceptor interceptorChain \u003d\n         this.createRequestInterceptorChain();\n     interceptorChain.init(createApplicationMasterContext(\n         applicationAttemptId, user, amrmToken, localToken));\n     chainWrapper.init(interceptorChain, applicationAttemptId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initializePipeline(ApplicationAttemptId applicationAttemptId,\n      String user, Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n      Token\u003cAMRMTokenIdentifier\u003e localToken) {\n    RequestInterceptorChainWrapper chainWrapper \u003d null;\n    synchronized (applPipelineMap) {\n      if (applPipelineMap\n          .containsKey(applicationAttemptId.getApplicationId())) {\n        LOG.warn(\"Request to start an already existing appId was received. \"\n            + \" This can happen if an application failed and a new attempt \"\n            + \"was created on this machine.  ApplicationId: \"\n            + applicationAttemptId.toString());\n\n        RequestInterceptorChainWrapper chainWrapperBackup \u003d\n            this.applPipelineMap.get(applicationAttemptId.getApplicationId());\n        if (chainWrapperBackup !\u003d null\n            \u0026\u0026 chainWrapperBackup.getApplicationAttemptId() !\u003d null\n            \u0026\u0026 !chainWrapperBackup.getApplicationAttemptId()\n                .equals(applicationAttemptId)) {\n          // Remove the existing pipeline\n          LOG.info(\"Remove the previous pipeline for ApplicationId: \"\n              + applicationAttemptId.toString());\n          RequestInterceptorChainWrapper pipeline \u003d\n              applPipelineMap.remove(applicationAttemptId.getApplicationId());\n          try {\n            pipeline.getRootInterceptor().shutdown();\n          } catch (Throwable ex) {\n            LOG.warn(\n                \"Failed to shutdown the request processing pipeline for app:\"\n                    + applicationAttemptId.getApplicationId(),\n                ex);\n          }\n        } else {\n          return;\n        }\n      }\n\n      chainWrapper \u003d new RequestInterceptorChainWrapper();\n      this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n          chainWrapper);\n    }\n\n    // We register the pipeline instance in the map first and then initialize it\n    // later because chain initialization can be expensive and we would like to\n    // release the lock as soon as possible to prevent other applications from\n    // blocking when one application\u0027s chain is initializing\n    LOG.info(\"Initializing request processing pipeline for application. \"\n        + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n        + user);\n\n    RequestInterceptor interceptorChain \u003d\n        this.createRequestInterceptorChain();\n    interceptorChain.init(createApplicationMasterContext(\n        applicationAttemptId, user, amrmToken, localToken));\n    chainWrapper.init(interceptorChain, applicationAttemptId);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/AMRMProxyService.java",
      "extendedDetails": {}
    },
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2884. Added a proxy service in NM to proxy the the communication between AM and RM. Contributed by Kishore Chaliparambil\n",
      "commitDate": "07/09/15 6:35 PM",
      "commitName": "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,33 @@\n+  protected void initializePipeline(\n+      ApplicationAttemptId applicationAttemptId, String user,\n+      Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n+      Token\u003cAMRMTokenIdentifier\u003e localToken) {\n+    RequestInterceptorChainWrapper chainWrapper \u003d null;\n+    synchronized (applPipelineMap) {\n+      if (applPipelineMap.containsKey(applicationAttemptId.getApplicationId())) {\n+        LOG.warn(\"Request to start an already existing appId was received. \"\n+            + \" This can happen if an application failed and a new attempt \"\n+            + \"was created on this machine.  ApplicationId: \"\n+            + applicationAttemptId.toString());\n+        return;\n+      }\n+\n+      chainWrapper \u003d new RequestInterceptorChainWrapper();\n+      this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n+          chainWrapper);\n+    }\n+\n+    // We register the pipeline instance in the map first and then initialize it\n+    // later because chain initialization can be expensive and we would like to\n+    // release the lock as soon as possible to prevent other applications from\n+    // blocking when one application\u0027s chain is initializing\n+    LOG.info(\"Initializing request processing pipeline for application. \"\n+        + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n+        + user);\n+\n+    RequestInterceptor interceptorChain \u003d\n+        this.createRequestInterceptorChain();\n+    interceptorChain.init(createApplicationMasterContext(\n+        applicationAttemptId, user, amrmToken, localToken));\n+    chainWrapper.init(interceptorChain, applicationAttemptId);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initializePipeline(\n      ApplicationAttemptId applicationAttemptId, String user,\n      Token\u003cAMRMTokenIdentifier\u003e amrmToken,\n      Token\u003cAMRMTokenIdentifier\u003e localToken) {\n    RequestInterceptorChainWrapper chainWrapper \u003d null;\n    synchronized (applPipelineMap) {\n      if (applPipelineMap.containsKey(applicationAttemptId.getApplicationId())) {\n        LOG.warn(\"Request to start an already existing appId was received. \"\n            + \" This can happen if an application failed and a new attempt \"\n            + \"was created on this machine.  ApplicationId: \"\n            + applicationAttemptId.toString());\n        return;\n      }\n\n      chainWrapper \u003d new RequestInterceptorChainWrapper();\n      this.applPipelineMap.put(applicationAttemptId.getApplicationId(),\n          chainWrapper);\n    }\n\n    // We register the pipeline instance in the map first and then initialize it\n    // later because chain initialization can be expensive and we would like to\n    // release the lock as soon as possible to prevent other applications from\n    // blocking when one application\u0027s chain is initializing\n    LOG.info(\"Initializing request processing pipeline for application. \"\n        + \" ApplicationId:\" + applicationAttemptId + \" for the user: \"\n        + user);\n\n    RequestInterceptor interceptorChain \u003d\n        this.createRequestInterceptorChain();\n    interceptorChain.init(createApplicationMasterContext(\n        applicationAttemptId, user, amrmToken, localToken));\n    chainWrapper.init(interceptorChain, applicationAttemptId);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/AMRMProxyService.java"
    }
  }
}