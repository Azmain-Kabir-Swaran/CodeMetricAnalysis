{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Client.java",
  "functionName": "receiveRpcResponse",
  "functionId": "receiveRpcResponse",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
  "functionStartLine": 1184,
  "functionEndLine": 1237,
  "numCommitsSeen": 184,
  "timeTaken": 6339,
  "changeHistory": [
    "e880660a204b6fd0e5a0799393a4d36359765a54",
    "c9d73437e881296282abe46a6b3196befc8cef72",
    "d4d076876a8d0002bd3a73491d8459d11cb4896c",
    "23abb09c1f979d8c18ece81e32630a35ed569399",
    "1898810cda83e6d273a2963b56ed499c0fb91118",
    "d4a2830b63f0819979b592f4ea6ea3abd5885b71",
    "0e0271b5fdf55c55b825e85c56639a4ae7277a39",
    "9ff01d626118a97ea4bf2fd72f022e11e69ee17d",
    "725623534ce7ab20c28af6e0cdf57bd7278551dd",
    "357472001725e786f28b27560bac8aca54c3c983",
    "a4c20088b5d35e6f986ece0db3c5e438dd9c3df1",
    "aa4fe26a01d2ca881cb458d49032ce419351bed1",
    "45fafc2b8fc1aab0a082600b0d50ad693491ea70",
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3",
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "97ce72a97efb57a5dbfb759ac8144c0890583068",
    "34d1b39c7525898b43e44a7c5cbd86768714baf0",
    "d6f4cf3dfec03867f02bf71aa900a77676651c2a",
    "3ef40e13449b4321c3bc5a34eaddb6dc1ac0ceed",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "e880660a204b6fd0e5a0799393a4d36359765a54": "Ybodychange",
    "c9d73437e881296282abe46a6b3196befc8cef72": "Ybodychange",
    "d4d076876a8d0002bd3a73491d8459d11cb4896c": "Ybodychange",
    "23abb09c1f979d8c18ece81e32630a35ed569399": "Ybodychange",
    "1898810cda83e6d273a2963b56ed499c0fb91118": "Ybodychange",
    "d4a2830b63f0819979b592f4ea6ea3abd5885b71": "Ybodychange",
    "0e0271b5fdf55c55b825e85c56639a4ae7277a39": "Ybodychange",
    "9ff01d626118a97ea4bf2fd72f022e11e69ee17d": "Ybodychange",
    "725623534ce7ab20c28af6e0cdf57bd7278551dd": "Ybodychange",
    "357472001725e786f28b27560bac8aca54c3c983": "Ybodychange",
    "a4c20088b5d35e6f986ece0db3c5e438dd9c3df1": "Ybodychange",
    "aa4fe26a01d2ca881cb458d49032ce419351bed1": "Yrename",
    "45fafc2b8fc1aab0a082600b0d50ad693491ea70": "Ybodychange",
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3": "Ybodychange",
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "97ce72a97efb57a5dbfb759ac8144c0890583068": "Ybodychange",
    "34d1b39c7525898b43e44a7c5cbd86768714baf0": "Ybodychange",
    "d6f4cf3dfec03867f02bf71aa900a77676651c2a": "Ybodychange",
    "3ef40e13449b4321c3bc5a34eaddb6dc1ac0ceed": "Ybodychange",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e880660a204b6fd0e5a0799393a4d36359765a54": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13399. [SBN read] Make Client field AlignmentContext non-static. Contributed by Plamen Jeliazkov.",
      "commitDate": "24/12/18 9:33 AM",
      "commitName": "e880660a204b6fd0e5a0799393a4d36359765a54",
      "commitAuthor": "Plamen Jeliazkov",
      "commitDateOld": "24/12/18 9:33 AM",
      "commitNameOld": "9bf0696c7348879678693176da0071628ca42566",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n     private void receiveRpcResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         ByteBuffer bb \u003d ipcStreams.readResponse();\n         RpcWritable.Buffer packet \u003d RpcWritable.Buffer.wrap(bb);\n         RpcResponseHeaderProto header \u003d\n             packet.getValue(RpcResponseHeaderProto.getDefaultInstance());\n         checkResponse(header);\n \n         int callId \u003d header.getCallId();\n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + callId);\n \n         RpcStatusProto status \u003d header.getStatus();\n         if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n           Writable value \u003d packet.newInstance(valueClass, conf);\n           final Call call \u003d calls.remove(callId);\n           call.setRpcResponse(value);\n-        }\n-        if (alignmentContext !\u003d null) {\n-          alignmentContext.receiveResponseState(header);\n+          if (call.alignmentContext !\u003d null) {\n+            call.alignmentContext.receiveResponseState(header);\n+          }\n         }\n         // verify that packet length was correct\n         if (packet.remaining() \u003e 0) {\n           throw new RpcClientException(\"RPC response length mismatch\");\n         }\n         if (status !\u003d RpcStatusProto.SUCCESS) { // Rpc Request failed\n           final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                 header.getExceptionClassName() : \n                   \"ServerDidNotSetExceptionClassName\";\n           final String errorMsg \u003d header.hasErrorMsg() ? \n                 header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n           final RpcErrorCodeProto erCode \u003d \n                     (header.hasErrorDetail() ? header.getErrorDetail() : null);\n           if (erCode \u003d\u003d null) {\n              LOG.warn(\"Detailed error code not set by server on rpc error\");\n           }\n           RemoteException re \u003d new RemoteException(exceptionClassName, errorMsg, erCode);\n           if (status \u003d\u003d RpcStatusProto.ERROR) {\n             final Call call \u003d calls.remove(callId);\n             call.setException(re);\n           } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n             // Close the connection\n             markClosed(re);\n           }\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveRpcResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        ByteBuffer bb \u003d ipcStreams.readResponse();\n        RpcWritable.Buffer packet \u003d RpcWritable.Buffer.wrap(bb);\n        RpcResponseHeaderProto header \u003d\n            packet.getValue(RpcResponseHeaderProto.getDefaultInstance());\n        checkResponse(header);\n\n        int callId \u003d header.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        RpcStatusProto status \u003d header.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d packet.newInstance(valueClass, conf);\n          final Call call \u003d calls.remove(callId);\n          call.setRpcResponse(value);\n          if (call.alignmentContext !\u003d null) {\n            call.alignmentContext.receiveResponseState(header);\n          }\n        }\n        // verify that packet length was correct\n        if (packet.remaining() \u003e 0) {\n          throw new RpcClientException(\"RPC response length mismatch\");\n        }\n        if (status !\u003d RpcStatusProto.SUCCESS) { // Rpc Request failed\n          final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                header.getExceptionClassName() : \n                  \"ServerDidNotSetExceptionClassName\";\n          final String errorMsg \u003d header.hasErrorMsg() ? \n                header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n          final RpcErrorCodeProto erCode \u003d \n                    (header.hasErrorDetail() ? header.getErrorDetail() : null);\n          if (erCode \u003d\u003d null) {\n             LOG.warn(\"Detailed error code not set by server on rpc error\");\n          }\n          RemoteException re \u003d new RemoteException(exceptionClassName, errorMsg, erCode);\n          if (status \u003d\u003d RpcStatusProto.ERROR) {\n            final Call call \u003d calls.remove(callId);\n            call.setException(re);\n          } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n            // Close the connection\n            markClosed(re);\n          }\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "c9d73437e881296282abe46a6b3196befc8cef72": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12977. [SBN read] Add stateId to RPC headers. Contributed by Plamen Jeliazkov.",
      "commitDate": "24/12/18 9:33 AM",
      "commitName": "c9d73437e881296282abe46a6b3196befc8cef72",
      "commitAuthor": "Plamen Jeliazkov",
      "commitDateOld": "10/10/18 9:51 PM",
      "commitNameOld": "7b57f2f71fbaa5af4897309597cca70a95b04edd",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 74.53,
      "commitsBetweenForRepo": 562,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,54 @@\n     private void receiveRpcResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         ByteBuffer bb \u003d ipcStreams.readResponse();\n         RpcWritable.Buffer packet \u003d RpcWritable.Buffer.wrap(bb);\n         RpcResponseHeaderProto header \u003d\n             packet.getValue(RpcResponseHeaderProto.getDefaultInstance());\n         checkResponse(header);\n \n         int callId \u003d header.getCallId();\n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + callId);\n \n         RpcStatusProto status \u003d header.getStatus();\n         if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n           Writable value \u003d packet.newInstance(valueClass, conf);\n           final Call call \u003d calls.remove(callId);\n           call.setRpcResponse(value);\n         }\n+        if (alignmentContext !\u003d null) {\n+          alignmentContext.receiveResponseState(header);\n+        }\n         // verify that packet length was correct\n         if (packet.remaining() \u003e 0) {\n           throw new RpcClientException(\"RPC response length mismatch\");\n         }\n         if (status !\u003d RpcStatusProto.SUCCESS) { // Rpc Request failed\n           final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                 header.getExceptionClassName() : \n                   \"ServerDidNotSetExceptionClassName\";\n           final String errorMsg \u003d header.hasErrorMsg() ? \n                 header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n           final RpcErrorCodeProto erCode \u003d \n                     (header.hasErrorDetail() ? header.getErrorDetail() : null);\n           if (erCode \u003d\u003d null) {\n              LOG.warn(\"Detailed error code not set by server on rpc error\");\n           }\n           RemoteException re \u003d new RemoteException(exceptionClassName, errorMsg, erCode);\n           if (status \u003d\u003d RpcStatusProto.ERROR) {\n             final Call call \u003d calls.remove(callId);\n             call.setException(re);\n           } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n             // Close the connection\n             markClosed(re);\n           }\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveRpcResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        ByteBuffer bb \u003d ipcStreams.readResponse();\n        RpcWritable.Buffer packet \u003d RpcWritable.Buffer.wrap(bb);\n        RpcResponseHeaderProto header \u003d\n            packet.getValue(RpcResponseHeaderProto.getDefaultInstance());\n        checkResponse(header);\n\n        int callId \u003d header.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        RpcStatusProto status \u003d header.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d packet.newInstance(valueClass, conf);\n          final Call call \u003d calls.remove(callId);\n          call.setRpcResponse(value);\n        }\n        if (alignmentContext !\u003d null) {\n          alignmentContext.receiveResponseState(header);\n        }\n        // verify that packet length was correct\n        if (packet.remaining() \u003e 0) {\n          throw new RpcClientException(\"RPC response length mismatch\");\n        }\n        if (status !\u003d RpcStatusProto.SUCCESS) { // Rpc Request failed\n          final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                header.getExceptionClassName() : \n                  \"ServerDidNotSetExceptionClassName\";\n          final String errorMsg \u003d header.hasErrorMsg() ? \n                header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n          final RpcErrorCodeProto erCode \u003d \n                    (header.hasErrorDetail() ? header.getErrorDetail() : null);\n          if (erCode \u003d\u003d null) {\n             LOG.warn(\"Detailed error code not set by server on rpc error\");\n          }\n          RemoteException re \u003d new RemoteException(exceptionClassName, errorMsg, erCode);\n          if (status \u003d\u003d RpcStatusProto.ERROR) {\n            final Call call \u003d calls.remove(callId);\n            call.setException(re);\n          } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n            // Close the connection\n            markClosed(re);\n          }\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "d4d076876a8d0002bd3a73491d8459d11cb4896c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10940. RPC client does no bounds checking of responses. Contributed by Daryn Sharp.\n",
      "commitDate": "09/09/16 8:39 AM",
      "commitName": "d4d076876a8d0002bd3a73491d8459d11cb4896c",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "02/09/16 9:03 AM",
      "commitNameOld": "23abb09c1f979d8c18ece81e32630a35ed569399",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 6.98,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,51 @@\n     private void receiveRpcResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n-        int totalLen \u003d in.readInt();\n-        ByteBuffer bb \u003d ByteBuffer.allocate(totalLen);\n-        in.readFully(bb.array());\n-\n+        ByteBuffer bb \u003d ipcStreams.readResponse();\n         RpcWritable.Buffer packet \u003d RpcWritable.Buffer.wrap(bb);\n         RpcResponseHeaderProto header \u003d\n             packet.getValue(RpcResponseHeaderProto.getDefaultInstance());\n         checkResponse(header);\n \n         int callId \u003d header.getCallId();\n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + callId);\n \n         RpcStatusProto status \u003d header.getStatus();\n         if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n           Writable value \u003d packet.newInstance(valueClass, conf);\n           final Call call \u003d calls.remove(callId);\n           call.setRpcResponse(value);\n         }\n         // verify that packet length was correct\n         if (packet.remaining() \u003e 0) {\n           throw new RpcClientException(\"RPC response length mismatch\");\n         }\n         if (status !\u003d RpcStatusProto.SUCCESS) { // Rpc Request failed\n           final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                 header.getExceptionClassName() : \n                   \"ServerDidNotSetExceptionClassName\";\n           final String errorMsg \u003d header.hasErrorMsg() ? \n                 header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n           final RpcErrorCodeProto erCode \u003d \n                     (header.hasErrorDetail() ? header.getErrorDetail() : null);\n           if (erCode \u003d\u003d null) {\n              LOG.warn(\"Detailed error code not set by server on rpc error\");\n           }\n           RemoteException re \u003d new RemoteException(exceptionClassName, errorMsg, erCode);\n           if (status \u003d\u003d RpcStatusProto.ERROR) {\n             final Call call \u003d calls.remove(callId);\n             call.setException(re);\n           } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n             // Close the connection\n             markClosed(re);\n           }\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveRpcResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        ByteBuffer bb \u003d ipcStreams.readResponse();\n        RpcWritable.Buffer packet \u003d RpcWritable.Buffer.wrap(bb);\n        RpcResponseHeaderProto header \u003d\n            packet.getValue(RpcResponseHeaderProto.getDefaultInstance());\n        checkResponse(header);\n\n        int callId \u003d header.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        RpcStatusProto status \u003d header.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d packet.newInstance(valueClass, conf);\n          final Call call \u003d calls.remove(callId);\n          call.setRpcResponse(value);\n        }\n        // verify that packet length was correct\n        if (packet.remaining() \u003e 0) {\n          throw new RpcClientException(\"RPC response length mismatch\");\n        }\n        if (status !\u003d RpcStatusProto.SUCCESS) { // Rpc Request failed\n          final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                header.getExceptionClassName() : \n                  \"ServerDidNotSetExceptionClassName\";\n          final String errorMsg \u003d header.hasErrorMsg() ? \n                header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n          final RpcErrorCodeProto erCode \u003d \n                    (header.hasErrorDetail() ? header.getErrorDetail() : null);\n          if (erCode \u003d\u003d null) {\n             LOG.warn(\"Detailed error code not set by server on rpc error\");\n          }\n          RemoteException re \u003d new RemoteException(exceptionClassName, errorMsg, erCode);\n          if (status \u003d\u003d RpcStatusProto.ERROR) {\n            final Call call \u003d calls.remove(callId);\n            call.setException(re);\n          } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n            // Close the connection\n            markClosed(re);\n          }\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "23abb09c1f979d8c18ece81e32630a35ed569399": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13547. Optimize IPC client protobuf decoding. Contributed by Daryn Sharp.\n",
      "commitDate": "02/09/16 9:03 AM",
      "commitName": "23abb09c1f979d8c18ece81e32630a35ed569399",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "25/06/16 12:45 AM",
      "commitNameOld": "d328e667067743f723e332d92154da8e84e65742",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 69.35,
      "commitsBetweenForRepo": 554,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,54 @@\n     private void receiveRpcResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         int totalLen \u003d in.readInt();\n-        RpcResponseHeaderProto header \u003d \n-            RpcResponseHeaderProto.parseDelimitedFrom(in);\n-        checkResponse(header);\n+        ByteBuffer bb \u003d ByteBuffer.allocate(totalLen);\n+        in.readFully(bb.array());\n \n-        int headerLen \u003d header.getSerializedSize();\n-        headerLen +\u003d CodedOutputStream.computeRawVarint32Size(headerLen);\n+        RpcWritable.Buffer packet \u003d RpcWritable.Buffer.wrap(bb);\n+        RpcResponseHeaderProto header \u003d\n+            packet.getValue(RpcResponseHeaderProto.getDefaultInstance());\n+        checkResponse(header);\n \n         int callId \u003d header.getCallId();\n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + callId);\n \n         RpcStatusProto status \u003d header.getStatus();\n         if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n-          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n-          value.readFields(in);                 // read value\n+          Writable value \u003d packet.newInstance(valueClass, conf);\n           final Call call \u003d calls.remove(callId);\n           call.setRpcResponse(value);\n-          \n-          // verify that length was correct\n-          // only for ProtobufEngine where len can be verified easily\n-          if (call.getRpcResponse() instanceof ProtobufRpcEngine.RpcWrapper) {\n-            ProtobufRpcEngine.RpcWrapper resWrapper \u003d \n-                (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();\n-            if (totalLen !\u003d headerLen + resWrapper.getLength()) { \n-              throw new RpcClientException(\n-                  \"RPC response length mismatch on rpc success\");\n-            }\n-          }\n-        } else { // Rpc Request failed\n-          // Verify that length was correct\n-          if (totalLen !\u003d headerLen) {\n-            throw new RpcClientException(\n-                \"RPC response length mismatch on rpc error\");\n-          }\n-          \n+        }\n+        // verify that packet length was correct\n+        if (packet.remaining() \u003e 0) {\n+          throw new RpcClientException(\"RPC response length mismatch\");\n+        }\n+        if (status !\u003d RpcStatusProto.SUCCESS) { // Rpc Request failed\n           final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                 header.getExceptionClassName() : \n                   \"ServerDidNotSetExceptionClassName\";\n           final String errorMsg \u003d header.hasErrorMsg() ? \n                 header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n           final RpcErrorCodeProto erCode \u003d \n                     (header.hasErrorDetail() ? header.getErrorDetail() : null);\n           if (erCode \u003d\u003d null) {\n              LOG.warn(\"Detailed error code not set by server on rpc error\");\n           }\n           RemoteException re \u003d new RemoteException(exceptionClassName, errorMsg, erCode);\n           if (status \u003d\u003d RpcStatusProto.ERROR) {\n             final Call call \u003d calls.remove(callId);\n             call.setException(re);\n           } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n             // Close the connection\n             markClosed(re);\n           }\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveRpcResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int totalLen \u003d in.readInt();\n        ByteBuffer bb \u003d ByteBuffer.allocate(totalLen);\n        in.readFully(bb.array());\n\n        RpcWritable.Buffer packet \u003d RpcWritable.Buffer.wrap(bb);\n        RpcResponseHeaderProto header \u003d\n            packet.getValue(RpcResponseHeaderProto.getDefaultInstance());\n        checkResponse(header);\n\n        int callId \u003d header.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        RpcStatusProto status \u003d header.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d packet.newInstance(valueClass, conf);\n          final Call call \u003d calls.remove(callId);\n          call.setRpcResponse(value);\n        }\n        // verify that packet length was correct\n        if (packet.remaining() \u003e 0) {\n          throw new RpcClientException(\"RPC response length mismatch\");\n        }\n        if (status !\u003d RpcStatusProto.SUCCESS) { // Rpc Request failed\n          final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                header.getExceptionClassName() : \n                  \"ServerDidNotSetExceptionClassName\";\n          final String errorMsg \u003d header.hasErrorMsg() ? \n                header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n          final RpcErrorCodeProto erCode \u003d \n                    (header.hasErrorDetail() ? header.getErrorDetail() : null);\n          if (erCode \u003d\u003d null) {\n             LOG.warn(\"Detailed error code not set by server on rpc error\");\n          }\n          RemoteException re \u003d new RemoteException(exceptionClassName, errorMsg, erCode);\n          if (status \u003d\u003d RpcStatusProto.ERROR) {\n            final Call call \u003d calls.remove(callId);\n            call.setException(re);\n          } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n            // Close the connection\n            markClosed(re);\n          }\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "1898810cda83e6d273a2963b56ed499c0fb91118": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12923. Move the test code in ipc.Client to test.\n",
      "commitDate": "14/03/16 3:48 PM",
      "commitName": "1898810cda83e6d273a2963b56ed499c0fb91118",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "11/03/16 9:00 AM",
      "commitNameOld": "754299695b778b9b602e46836c35a3ac9474d7f8",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 3.24,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,66 @@\n     private void receiveRpcResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         int totalLen \u003d in.readInt();\n         RpcResponseHeaderProto header \u003d \n             RpcResponseHeaderProto.parseDelimitedFrom(in);\n         checkResponse(header);\n \n         int headerLen \u003d header.getSerializedSize();\n         headerLen +\u003d CodedOutputStream.computeRawVarint32Size(headerLen);\n \n         int callId \u003d header.getCallId();\n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + callId);\n \n-        Call call \u003d calls.get(callId);\n         RpcStatusProto status \u003d header.getStatus();\n         if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n-          calls.remove(callId);\n+          final Call call \u003d calls.remove(callId);\n           call.setRpcResponse(value);\n           \n           // verify that length was correct\n           // only for ProtobufEngine where len can be verified easily\n           if (call.getRpcResponse() instanceof ProtobufRpcEngine.RpcWrapper) {\n             ProtobufRpcEngine.RpcWrapper resWrapper \u003d \n                 (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();\n             if (totalLen !\u003d headerLen + resWrapper.getLength()) { \n               throw new RpcClientException(\n                   \"RPC response length mismatch on rpc success\");\n             }\n           }\n         } else { // Rpc Request failed\n           // Verify that length was correct\n           if (totalLen !\u003d headerLen) {\n             throw new RpcClientException(\n                 \"RPC response length mismatch on rpc error\");\n           }\n           \n           final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                 header.getExceptionClassName() : \n                   \"ServerDidNotSetExceptionClassName\";\n           final String errorMsg \u003d header.hasErrorMsg() ? \n                 header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n           final RpcErrorCodeProto erCode \u003d \n                     (header.hasErrorDetail() ? header.getErrorDetail() : null);\n           if (erCode \u003d\u003d null) {\n              LOG.warn(\"Detailed error code not set by server on rpc error\");\n           }\n           RemoteException re \u003d new RemoteException(exceptionClassName, errorMsg, erCode);\n           if (status \u003d\u003d RpcStatusProto.ERROR) {\n-            calls.remove(callId);\n+            final Call call \u003d calls.remove(callId);\n             call.setException(re);\n           } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n             // Close the connection\n             markClosed(re);\n           }\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveRpcResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int totalLen \u003d in.readInt();\n        RpcResponseHeaderProto header \u003d \n            RpcResponseHeaderProto.parseDelimitedFrom(in);\n        checkResponse(header);\n\n        int headerLen \u003d header.getSerializedSize();\n        headerLen +\u003d CodedOutputStream.computeRawVarint32Size(headerLen);\n\n        int callId \u003d header.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        RpcStatusProto status \u003d header.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          final Call call \u003d calls.remove(callId);\n          call.setRpcResponse(value);\n          \n          // verify that length was correct\n          // only for ProtobufEngine where len can be verified easily\n          if (call.getRpcResponse() instanceof ProtobufRpcEngine.RpcWrapper) {\n            ProtobufRpcEngine.RpcWrapper resWrapper \u003d \n                (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();\n            if (totalLen !\u003d headerLen + resWrapper.getLength()) { \n              throw new RpcClientException(\n                  \"RPC response length mismatch on rpc success\");\n            }\n          }\n        } else { // Rpc Request failed\n          // Verify that length was correct\n          if (totalLen !\u003d headerLen) {\n            throw new RpcClientException(\n                \"RPC response length mismatch on rpc error\");\n          }\n          \n          final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                header.getExceptionClassName() : \n                  \"ServerDidNotSetExceptionClassName\";\n          final String errorMsg \u003d header.hasErrorMsg() ? \n                header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n          final RpcErrorCodeProto erCode \u003d \n                    (header.hasErrorDetail() ? header.getErrorDetail() : null);\n          if (erCode \u003d\u003d null) {\n             LOG.warn(\"Detailed error code not set by server on rpc error\");\n          }\n          RemoteException re \u003d new RemoteException(exceptionClassName, errorMsg, erCode);\n          if (status \u003d\u003d RpcStatusProto.ERROR) {\n            final Call call \u003d calls.remove(callId);\n            call.setException(re);\n          } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n            // Close the connection\n            markClosed(re);\n          }\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "d4a2830b63f0819979b592f4ea6ea3abd5885b71": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11103. Clean up RemoteException (Contributed by Sean Busbey)\n",
      "commitDate": "19/05/15 2:11 AM",
      "commitName": "d4a2830b63f0819979b592f4ea6ea3abd5885b71",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "09/03/15 9:08 PM",
      "commitNameOld": "54639c7d7a34f4a46e8df50d57c79bab34b1ac07",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 70.21,
      "commitsBetweenForRepo": 695,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,67 @@\n     private void receiveRpcResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         int totalLen \u003d in.readInt();\n         RpcResponseHeaderProto header \u003d \n             RpcResponseHeaderProto.parseDelimitedFrom(in);\n         checkResponse(header);\n \n         int headerLen \u003d header.getSerializedSize();\n         headerLen +\u003d CodedOutputStream.computeRawVarint32Size(headerLen);\n \n         int callId \u003d header.getCallId();\n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + callId);\n \n         Call call \u003d calls.get(callId);\n         RpcStatusProto status \u003d header.getStatus();\n         if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n           calls.remove(callId);\n           call.setRpcResponse(value);\n           \n           // verify that length was correct\n           // only for ProtobufEngine where len can be verified easily\n           if (call.getRpcResponse() instanceof ProtobufRpcEngine.RpcWrapper) {\n             ProtobufRpcEngine.RpcWrapper resWrapper \u003d \n                 (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();\n             if (totalLen !\u003d headerLen + resWrapper.getLength()) { \n               throw new RpcClientException(\n                   \"RPC response length mismatch on rpc success\");\n             }\n           }\n         } else { // Rpc Request failed\n           // Verify that length was correct\n           if (totalLen !\u003d headerLen) {\n             throw new RpcClientException(\n                 \"RPC response length mismatch on rpc error\");\n           }\n           \n           final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                 header.getExceptionClassName() : \n                   \"ServerDidNotSetExceptionClassName\";\n           final String errorMsg \u003d header.hasErrorMsg() ? \n                 header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n           final RpcErrorCodeProto erCode \u003d \n                     (header.hasErrorDetail() ? header.getErrorDetail() : null);\n           if (erCode \u003d\u003d null) {\n              LOG.warn(\"Detailed error code not set by server on rpc error\");\n           }\n-          RemoteException re \u003d \n-              ( (erCode \u003d\u003d null) ? \n-                  new RemoteException(exceptionClassName, errorMsg) :\n-              new RemoteException(exceptionClassName, errorMsg, erCode));\n+          RemoteException re \u003d new RemoteException(exceptionClassName, errorMsg, erCode);\n           if (status \u003d\u003d RpcStatusProto.ERROR) {\n             calls.remove(callId);\n             call.setException(re);\n           } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n             // Close the connection\n             markClosed(re);\n           }\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveRpcResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int totalLen \u003d in.readInt();\n        RpcResponseHeaderProto header \u003d \n            RpcResponseHeaderProto.parseDelimitedFrom(in);\n        checkResponse(header);\n\n        int headerLen \u003d header.getSerializedSize();\n        headerLen +\u003d CodedOutputStream.computeRawVarint32Size(headerLen);\n\n        int callId \u003d header.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        Call call \u003d calls.get(callId);\n        RpcStatusProto status \u003d header.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          calls.remove(callId);\n          call.setRpcResponse(value);\n          \n          // verify that length was correct\n          // only for ProtobufEngine where len can be verified easily\n          if (call.getRpcResponse() instanceof ProtobufRpcEngine.RpcWrapper) {\n            ProtobufRpcEngine.RpcWrapper resWrapper \u003d \n                (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();\n            if (totalLen !\u003d headerLen + resWrapper.getLength()) { \n              throw new RpcClientException(\n                  \"RPC response length mismatch on rpc success\");\n            }\n          }\n        } else { // Rpc Request failed\n          // Verify that length was correct\n          if (totalLen !\u003d headerLen) {\n            throw new RpcClientException(\n                \"RPC response length mismatch on rpc error\");\n          }\n          \n          final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                header.getExceptionClassName() : \n                  \"ServerDidNotSetExceptionClassName\";\n          final String errorMsg \u003d header.hasErrorMsg() ? \n                header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n          final RpcErrorCodeProto erCode \u003d \n                    (header.hasErrorDetail() ? header.getErrorDetail() : null);\n          if (erCode \u003d\u003d null) {\n             LOG.warn(\"Detailed error code not set by server on rpc error\");\n          }\n          RemoteException re \u003d new RemoteException(exceptionClassName, errorMsg, erCode);\n          if (status \u003d\u003d RpcStatusProto.ERROR) {\n            calls.remove(callId);\n            call.setException(re);\n          } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n            // Close the connection\n            markClosed(re);\n          }\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "0e0271b5fdf55c55b825e85c56639a4ae7277a39": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9916. Fix race in ipc.Client retry. (Binglin Chang via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1519973 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/13 3:34 AM",
      "commitName": "0e0271b5fdf55c55b825e85c56639a4ae7277a39",
      "commitAuthor": "Luke Lu",
      "commitDateOld": "08/08/13 4:02 PM",
      "commitNameOld": "c03c8fe199429a43c6aa944016566738abd9b193",
      "commitAuthorOld": "Jitendra Nath Pandey",
      "daysBetweenCommits": 26.48,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n     private void receiveRpcResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         int totalLen \u003d in.readInt();\n         RpcResponseHeaderProto header \u003d \n             RpcResponseHeaderProto.parseDelimitedFrom(in);\n         checkResponse(header);\n \n         int headerLen \u003d header.getSerializedSize();\n         headerLen +\u003d CodedOutputStream.computeRawVarint32Size(headerLen);\n \n         int callId \u003d header.getCallId();\n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + callId);\n \n         Call call \u003d calls.get(callId);\n         RpcStatusProto status \u003d header.getStatus();\n         if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n-          call.setRpcResponse(value);\n           calls.remove(callId);\n+          call.setRpcResponse(value);\n           \n           // verify that length was correct\n           // only for ProtobufEngine where len can be verified easily\n           if (call.getRpcResponse() instanceof ProtobufRpcEngine.RpcWrapper) {\n             ProtobufRpcEngine.RpcWrapper resWrapper \u003d \n                 (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();\n             if (totalLen !\u003d headerLen + resWrapper.getLength()) { \n               throw new RpcClientException(\n                   \"RPC response length mismatch on rpc success\");\n             }\n           }\n         } else { // Rpc Request failed\n           // Verify that length was correct\n           if (totalLen !\u003d headerLen) {\n             throw new RpcClientException(\n                 \"RPC response length mismatch on rpc error\");\n           }\n           \n           final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                 header.getExceptionClassName() : \n                   \"ServerDidNotSetExceptionClassName\";\n           final String errorMsg \u003d header.hasErrorMsg() ? \n                 header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n           final RpcErrorCodeProto erCode \u003d \n                     (header.hasErrorDetail() ? header.getErrorDetail() : null);\n           if (erCode \u003d\u003d null) {\n              LOG.warn(\"Detailed error code not set by server on rpc error\");\n           }\n           RemoteException re \u003d \n               ( (erCode \u003d\u003d null) ? \n                   new RemoteException(exceptionClassName, errorMsg) :\n               new RemoteException(exceptionClassName, errorMsg, erCode));\n           if (status \u003d\u003d RpcStatusProto.ERROR) {\n-            call.setException(re);\n             calls.remove(callId);\n+            call.setException(re);\n           } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n             // Close the connection\n             markClosed(re);\n           }\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveRpcResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int totalLen \u003d in.readInt();\n        RpcResponseHeaderProto header \u003d \n            RpcResponseHeaderProto.parseDelimitedFrom(in);\n        checkResponse(header);\n\n        int headerLen \u003d header.getSerializedSize();\n        headerLen +\u003d CodedOutputStream.computeRawVarint32Size(headerLen);\n\n        int callId \u003d header.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        Call call \u003d calls.get(callId);\n        RpcStatusProto status \u003d header.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          calls.remove(callId);\n          call.setRpcResponse(value);\n          \n          // verify that length was correct\n          // only for ProtobufEngine where len can be verified easily\n          if (call.getRpcResponse() instanceof ProtobufRpcEngine.RpcWrapper) {\n            ProtobufRpcEngine.RpcWrapper resWrapper \u003d \n                (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();\n            if (totalLen !\u003d headerLen + resWrapper.getLength()) { \n              throw new RpcClientException(\n                  \"RPC response length mismatch on rpc success\");\n            }\n          }\n        } else { // Rpc Request failed\n          // Verify that length was correct\n          if (totalLen !\u003d headerLen) {\n            throw new RpcClientException(\n                \"RPC response length mismatch on rpc error\");\n          }\n          \n          final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                header.getExceptionClassName() : \n                  \"ServerDidNotSetExceptionClassName\";\n          final String errorMsg \u003d header.hasErrorMsg() ? \n                header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n          final RpcErrorCodeProto erCode \u003d \n                    (header.hasErrorDetail() ? header.getErrorDetail() : null);\n          if (erCode \u003d\u003d null) {\n             LOG.warn(\"Detailed error code not set by server on rpc error\");\n          }\n          RemoteException re \u003d \n              ( (erCode \u003d\u003d null) ? \n                  new RemoteException(exceptionClassName, errorMsg) :\n              new RemoteException(exceptionClassName, errorMsg, erCode));\n          if (status \u003d\u003d RpcStatusProto.ERROR) {\n            calls.remove(callId);\n            call.setException(re);\n          } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n            // Close the connection\n            markClosed(re);\n          }\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "9ff01d626118a97ea4bf2fd72f022e11e69ee17d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9751. Add clientId and retryCount to RpcResponseHeaderProto.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505036 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/07/13 2:49 PM",
      "commitName": "9ff01d626118a97ea4bf2fd72f022e11e69ee17d",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "18/07/13 4:44 PM",
      "commitNameOld": "8724ceb2359af66c800043e665c17a2a30981c7d",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.92,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,70 @@\n     private void receiveRpcResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         int totalLen \u003d in.readInt();\n         RpcResponseHeaderProto header \u003d \n             RpcResponseHeaderProto.parseDelimitedFrom(in);\n-        if (header \u003d\u003d null) {\n-          throw new IOException(\"Response is null.\");\n-        }\n+        checkResponse(header);\n+\n         int headerLen \u003d header.getSerializedSize();\n         headerLen +\u003d CodedOutputStream.computeRawVarint32Size(headerLen);\n \n         int callId \u003d header.getCallId();\n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + callId);\n \n         Call call \u003d calls.get(callId);\n         RpcStatusProto status \u003d header.getStatus();\n         if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n           call.setRpcResponse(value);\n           calls.remove(callId);\n           \n           // verify that length was correct\n           // only for ProtobufEngine where len can be verified easily\n           if (call.getRpcResponse() instanceof ProtobufRpcEngine.RpcWrapper) {\n             ProtobufRpcEngine.RpcWrapper resWrapper \u003d \n                 (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();\n             if (totalLen !\u003d headerLen + resWrapper.getLength()) { \n               throw new RpcClientException(\n                   \"RPC response length mismatch on rpc success\");\n             }\n           }\n         } else { // Rpc Request failed\n           // Verify that length was correct\n           if (totalLen !\u003d headerLen) {\n             throw new RpcClientException(\n                 \"RPC response length mismatch on rpc error\");\n           }\n           \n           final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                 header.getExceptionClassName() : \n                   \"ServerDidNotSetExceptionClassName\";\n           final String errorMsg \u003d header.hasErrorMsg() ? \n                 header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n           final RpcErrorCodeProto erCode \u003d \n                     (header.hasErrorDetail() ? header.getErrorDetail() : null);\n           if (erCode \u003d\u003d null) {\n              LOG.warn(\"Detailed error code not set by server on rpc error\");\n           }\n           RemoteException re \u003d \n               ( (erCode \u003d\u003d null) ? \n                   new RemoteException(exceptionClassName, errorMsg) :\n               new RemoteException(exceptionClassName, errorMsg, erCode));\n           if (status \u003d\u003d RpcStatusProto.ERROR) {\n             call.setException(re);\n             calls.remove(callId);\n           } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n             // Close the connection\n             markClosed(re);\n           }\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveRpcResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int totalLen \u003d in.readInt();\n        RpcResponseHeaderProto header \u003d \n            RpcResponseHeaderProto.parseDelimitedFrom(in);\n        checkResponse(header);\n\n        int headerLen \u003d header.getSerializedSize();\n        headerLen +\u003d CodedOutputStream.computeRawVarint32Size(headerLen);\n\n        int callId \u003d header.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        Call call \u003d calls.get(callId);\n        RpcStatusProto status \u003d header.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setRpcResponse(value);\n          calls.remove(callId);\n          \n          // verify that length was correct\n          // only for ProtobufEngine where len can be verified easily\n          if (call.getRpcResponse() instanceof ProtobufRpcEngine.RpcWrapper) {\n            ProtobufRpcEngine.RpcWrapper resWrapper \u003d \n                (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();\n            if (totalLen !\u003d headerLen + resWrapper.getLength()) { \n              throw new RpcClientException(\n                  \"RPC response length mismatch on rpc success\");\n            }\n          }\n        } else { // Rpc Request failed\n          // Verify that length was correct\n          if (totalLen !\u003d headerLen) {\n            throw new RpcClientException(\n                \"RPC response length mismatch on rpc error\");\n          }\n          \n          final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                header.getExceptionClassName() : \n                  \"ServerDidNotSetExceptionClassName\";\n          final String errorMsg \u003d header.hasErrorMsg() ? \n                header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n          final RpcErrorCodeProto erCode \u003d \n                    (header.hasErrorDetail() ? header.getErrorDetail() : null);\n          if (erCode \u003d\u003d null) {\n             LOG.warn(\"Detailed error code not set by server on rpc error\");\n          }\n          RemoteException re \u003d \n              ( (erCode \u003d\u003d null) ? \n                  new RemoteException(exceptionClassName, errorMsg) :\n              new RemoteException(exceptionClassName, errorMsg, erCode));\n          if (status \u003d\u003d RpcStatusProto.ERROR) {\n            call.setException(re);\n            calls.remove(callId);\n          } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n            // Close the connection\n            markClosed(re);\n          }\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "725623534ce7ab20c28af6e0cdf57bd7278551dd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9425 Add error codes to rpc-response (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/05/13 10:51 AM",
      "commitName": "725623534ce7ab20c28af6e0cdf57bd7278551dd",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "25/04/13 2:07 PM",
      "commitNameOld": "e9c83b20f61b52a9595885e59673a09367b92866",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 8.86,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,71 @@\n     private void receiveRpcResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         int totalLen \u003d in.readInt();\n         RpcResponseHeaderProto header \u003d \n             RpcResponseHeaderProto.parseDelimitedFrom(in);\n         if (header \u003d\u003d null) {\n           throw new IOException(\"Response is null.\");\n         }\n         int headerLen \u003d header.getSerializedSize();\n         headerLen +\u003d CodedOutputStream.computeRawVarint32Size(headerLen);\n \n         int callId \u003d header.getCallId();\n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + callId);\n \n         Call call \u003d calls.get(callId);\n         RpcStatusProto status \u003d header.getStatus();\n         if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n           call.setRpcResponse(value);\n           calls.remove(callId);\n           \n           // verify that length was correct\n           // only for ProtobufEngine where len can be verified easily\n           if (call.getRpcResponse() instanceof ProtobufRpcEngine.RpcWrapper) {\n             ProtobufRpcEngine.RpcWrapper resWrapper \u003d \n                 (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();\n             if (totalLen !\u003d headerLen + resWrapper.getLength()) { \n               throw new RpcClientException(\n                   \"RPC response length mismatch on rpc success\");\n             }\n           }\n         } else { // Rpc Request failed\n           // Verify that length was correct\n           if (totalLen !\u003d headerLen) {\n             throw new RpcClientException(\n                 \"RPC response length mismatch on rpc error\");\n           }\n           \n           final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                 header.getExceptionClassName() : \n                   \"ServerDidNotSetExceptionClassName\";\n           final String errorMsg \u003d header.hasErrorMsg() ? \n                 header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n+          final RpcErrorCodeProto erCode \u003d \n+                    (header.hasErrorDetail() ? header.getErrorDetail() : null);\n+          if (erCode \u003d\u003d null) {\n+             LOG.warn(\"Detailed error code not set by server on rpc error\");\n+          }\n           RemoteException re \u003d \n-              new RemoteException(exceptionClassName, errorMsg);\n+              ( (erCode \u003d\u003d null) ? \n+                  new RemoteException(exceptionClassName, errorMsg) :\n+              new RemoteException(exceptionClassName, errorMsg, erCode));\n           if (status \u003d\u003d RpcStatusProto.ERROR) {\n             call.setException(re);\n             calls.remove(callId);\n           } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n             // Close the connection\n             markClosed(re);\n           }\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveRpcResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int totalLen \u003d in.readInt();\n        RpcResponseHeaderProto header \u003d \n            RpcResponseHeaderProto.parseDelimitedFrom(in);\n        if (header \u003d\u003d null) {\n          throw new IOException(\"Response is null.\");\n        }\n        int headerLen \u003d header.getSerializedSize();\n        headerLen +\u003d CodedOutputStream.computeRawVarint32Size(headerLen);\n\n        int callId \u003d header.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        Call call \u003d calls.get(callId);\n        RpcStatusProto status \u003d header.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setRpcResponse(value);\n          calls.remove(callId);\n          \n          // verify that length was correct\n          // only for ProtobufEngine where len can be verified easily\n          if (call.getRpcResponse() instanceof ProtobufRpcEngine.RpcWrapper) {\n            ProtobufRpcEngine.RpcWrapper resWrapper \u003d \n                (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();\n            if (totalLen !\u003d headerLen + resWrapper.getLength()) { \n              throw new RpcClientException(\n                  \"RPC response length mismatch on rpc success\");\n            }\n          }\n        } else { // Rpc Request failed\n          // Verify that length was correct\n          if (totalLen !\u003d headerLen) {\n            throw new RpcClientException(\n                \"RPC response length mismatch on rpc error\");\n          }\n          \n          final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                header.getExceptionClassName() : \n                  \"ServerDidNotSetExceptionClassName\";\n          final String errorMsg \u003d header.hasErrorMsg() ? \n                header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n          final RpcErrorCodeProto erCode \u003d \n                    (header.hasErrorDetail() ? header.getErrorDetail() : null);\n          if (erCode \u003d\u003d null) {\n             LOG.warn(\"Detailed error code not set by server on rpc error\");\n          }\n          RemoteException re \u003d \n              ( (erCode \u003d\u003d null) ? \n                  new RemoteException(exceptionClassName, errorMsg) :\n              new RemoteException(exceptionClassName, errorMsg, erCode));\n          if (status \u003d\u003d RpcStatusProto.ERROR) {\n            call.setException(re);\n            calls.remove(callId);\n          } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n            // Close the connection\n            markClosed(re);\n          }\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "357472001725e786f28b27560bac8aca54c3c983": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9380 Add totalLength to rpc response  (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1459392 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/13 9:41 AM",
      "commitName": "357472001725e786f28b27560bac8aca54c3c983",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "08/03/13 1:47 PM",
      "commitNameOld": "a4c20088b5d35e6f986ece0db3c5e438dd9c3df1",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 12.79,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,64 @@\n     private void receiveRpcResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n+        int totalLen \u003d in.readInt();\n         RpcResponseHeaderProto header \u003d \n             RpcResponseHeaderProto.parseDelimitedFrom(in);\n         if (header \u003d\u003d null) {\n           throw new IOException(\"Response is null.\");\n         }\n+        int headerLen \u003d header.getSerializedSize();\n+        headerLen +\u003d CodedOutputStream.computeRawVarint32Size(headerLen);\n \n         int callId \u003d header.getCallId();\n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + callId);\n \n         Call call \u003d calls.get(callId);\n         RpcStatusProto status \u003d header.getStatus();\n         if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n           call.setRpcResponse(value);\n           calls.remove(callId);\n+          \n+          // verify that length was correct\n+          // only for ProtobufEngine where len can be verified easily\n+          if (call.getRpcResponse() instanceof ProtobufRpcEngine.RpcWrapper) {\n+            ProtobufRpcEngine.RpcWrapper resWrapper \u003d \n+                (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();\n+            if (totalLen !\u003d headerLen + resWrapper.getLength()) { \n+              throw new RpcClientException(\n+                  \"RPC response length mismatch on rpc success\");\n+            }\n+          }\n         } else { // Rpc Request failed\n-            final String exceptionClassName \u003d header.hasExceptionClassName() ?\n+          // Verify that length was correct\n+          if (totalLen !\u003d headerLen) {\n+            throw new RpcClientException(\n+                \"RPC response length mismatch on rpc error\");\n+          }\n+          \n+          final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                 header.getExceptionClassName() : \n                   \"ServerDidNotSetExceptionClassName\";\n-            final String errorMsg \u003d header.hasErrorMsg() ? \n+          final String errorMsg \u003d header.hasErrorMsg() ? \n                 header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n           RemoteException re \u003d \n               new RemoteException(exceptionClassName, errorMsg);\n           if (status \u003d\u003d RpcStatusProto.ERROR) {\n             call.setException(re);\n             calls.remove(callId);\n           } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n             // Close the connection\n             markClosed(re);\n           }\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveRpcResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int totalLen \u003d in.readInt();\n        RpcResponseHeaderProto header \u003d \n            RpcResponseHeaderProto.parseDelimitedFrom(in);\n        if (header \u003d\u003d null) {\n          throw new IOException(\"Response is null.\");\n        }\n        int headerLen \u003d header.getSerializedSize();\n        headerLen +\u003d CodedOutputStream.computeRawVarint32Size(headerLen);\n\n        int callId \u003d header.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        Call call \u003d calls.get(callId);\n        RpcStatusProto status \u003d header.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setRpcResponse(value);\n          calls.remove(callId);\n          \n          // verify that length was correct\n          // only for ProtobufEngine where len can be verified easily\n          if (call.getRpcResponse() instanceof ProtobufRpcEngine.RpcWrapper) {\n            ProtobufRpcEngine.RpcWrapper resWrapper \u003d \n                (ProtobufRpcEngine.RpcWrapper) call.getRpcResponse();\n            if (totalLen !\u003d headerLen + resWrapper.getLength()) { \n              throw new RpcClientException(\n                  \"RPC response length mismatch on rpc success\");\n            }\n          }\n        } else { // Rpc Request failed\n          // Verify that length was correct\n          if (totalLen !\u003d headerLen) {\n            throw new RpcClientException(\n                \"RPC response length mismatch on rpc error\");\n          }\n          \n          final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                header.getExceptionClassName() : \n                  \"ServerDidNotSetExceptionClassName\";\n          final String errorMsg \u003d header.hasErrorMsg() ? \n                header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n          RemoteException re \u003d \n              new RemoteException(exceptionClassName, errorMsg);\n          if (status \u003d\u003d RpcStatusProto.ERROR) {\n            call.setException(re);\n            calls.remove(callId);\n          } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n            // Close the connection\n            markClosed(re);\n          }\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "a4c20088b5d35e6f986ece0db3c5e438dd9c3df1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9151 Include RPC error info in RpcResponseHeader instead of sending it separately (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1454593 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/03/13 1:47 PM",
      "commitName": "a4c20088b5d35e6f986ece0db3c5e438dd9c3df1",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "04/02/13 7:18 PM",
      "commitNameOld": "5a0b74663951475f668c7c68b9902c2bb54dc861",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 31.77,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,44 @@\n     private void receiveRpcResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n-        RpcResponseHeaderProto response \u003d \n+        RpcResponseHeaderProto header \u003d \n             RpcResponseHeaderProto.parseDelimitedFrom(in);\n-        if (response \u003d\u003d null) {\n+        if (header \u003d\u003d null) {\n           throw new IOException(\"Response is null.\");\n         }\n \n-        int callId \u003d response.getCallId();\n+        int callId \u003d header.getCallId();\n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + callId);\n \n         Call call \u003d calls.get(callId);\n-        RpcStatusProto status \u003d response.getStatus();\n+        RpcStatusProto status \u003d header.getStatus();\n         if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n           call.setRpcResponse(value);\n           calls.remove(callId);\n-        } else if (status \u003d\u003d RpcStatusProto.ERROR) {\n-          call.setException(new RemoteException(WritableUtils.readString(in),\n-                                                WritableUtils.readString(in)));\n-          calls.remove(callId);\n-        } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n-          // Close the connection\n-          markClosed(new RemoteException(WritableUtils.readString(in), \n-                                         WritableUtils.readString(in)));\n+        } else { // Rpc Request failed\n+            final String exceptionClassName \u003d header.hasExceptionClassName() ?\n+                header.getExceptionClassName() : \n+                  \"ServerDidNotSetExceptionClassName\";\n+            final String errorMsg \u003d header.hasErrorMsg() ? \n+                header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n+          RemoteException re \u003d \n+              new RemoteException(exceptionClassName, errorMsg);\n+          if (status \u003d\u003d RpcStatusProto.ERROR) {\n+            call.setException(re);\n+            calls.remove(callId);\n+          } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n+            // Close the connection\n+            markClosed(re);\n+          }\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveRpcResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        RpcResponseHeaderProto header \u003d \n            RpcResponseHeaderProto.parseDelimitedFrom(in);\n        if (header \u003d\u003d null) {\n          throw new IOException(\"Response is null.\");\n        }\n\n        int callId \u003d header.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        Call call \u003d calls.get(callId);\n        RpcStatusProto status \u003d header.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setRpcResponse(value);\n          calls.remove(callId);\n        } else { // Rpc Request failed\n            final String exceptionClassName \u003d header.hasExceptionClassName() ?\n                header.getExceptionClassName() : \n                  \"ServerDidNotSetExceptionClassName\";\n            final String errorMsg \u003d header.hasErrorMsg() ? \n                header.getErrorMsg() : \"ServerDidNotSetErrorMsg\" ;\n          RemoteException re \u003d \n              new RemoteException(exceptionClassName, errorMsg);\n          if (status \u003d\u003d RpcStatusProto.ERROR) {\n            call.setException(re);\n            calls.remove(callId);\n          } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n            // Close the connection\n            markClosed(re);\n          }\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "aa4fe26a01d2ca881cb458d49032ce419351bed1": {
      "type": "Yrename",
      "commitMessage": "HADOOP-9140 Cleanup rpc PB protos (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1423189 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/12/12 2:16 PM",
      "commitName": "aa4fe26a01d2ca881cb458d49032ce419351bed1",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "10/12/12 1:25 PM",
      "commitNameOld": "7ba12a628ad8de8c3e00afb45228b3e9d82c129b",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 7.04,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n-    private void receiveResponse() {\n+    private void receiveRpcResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         RpcResponseHeaderProto response \u003d \n             RpcResponseHeaderProto.parseDelimitedFrom(in);\n         if (response \u003d\u003d null) {\n           throw new IOException(\"Response is null.\");\n         }\n \n         int callId \u003d response.getCallId();\n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + callId);\n \n         Call call \u003d calls.get(callId);\n         RpcStatusProto status \u003d response.getStatus();\n         if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n           call.setRpcResponse(value);\n           calls.remove(callId);\n         } else if (status \u003d\u003d RpcStatusProto.ERROR) {\n           call.setException(new RemoteException(WritableUtils.readString(in),\n                                                 WritableUtils.readString(in)));\n           calls.remove(callId);\n         } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n           // Close the connection\n           markClosed(new RemoteException(WritableUtils.readString(in), \n                                          WritableUtils.readString(in)));\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveRpcResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        RpcResponseHeaderProto response \u003d \n            RpcResponseHeaderProto.parseDelimitedFrom(in);\n        if (response \u003d\u003d null) {\n          throw new IOException(\"Response is null.\");\n        }\n\n        int callId \u003d response.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        Call call \u003d calls.get(callId);\n        RpcStatusProto status \u003d response.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setRpcResponse(value);\n          calls.remove(callId);\n        } else if (status \u003d\u003d RpcStatusProto.ERROR) {\n          call.setException(new RemoteException(WritableUtils.readString(in),\n                                                WritableUtils.readString(in)));\n          calls.remove(callId);\n        } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n          // Close the connection\n          markClosed(new RemoteException(WritableUtils.readString(in), \n                                         WritableUtils.readString(in)));\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {
        "oldValue": "receiveResponse",
        "newValue": "receiveRpcResponse"
      }
    },
    "45fafc2b8fc1aab0a082600b0d50ad693491ea70": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3504. Support configurable retry policy in DFSClient for RPC connections and RPC calls, and add MultipleLinearRandomRetry, a new retry policy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1349124 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/06/12 10:27 PM",
      "commitName": "45fafc2b8fc1aab0a082600b0d50ad693491ea70",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "11/05/12 9:56 AM",
      "commitNameOld": "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 31.52,
      "commitsBetweenForRepo": 149,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,37 @@\n     private void receiveResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         RpcResponseHeaderProto response \u003d \n             RpcResponseHeaderProto.parseDelimitedFrom(in);\n+        if (response \u003d\u003d null) {\n+          throw new IOException(\"Response is null.\");\n+        }\n+\n         int callId \u003d response.getCallId();\n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + callId);\n \n         Call call \u003d calls.get(callId);\n         RpcStatusProto status \u003d response.getStatus();\n         if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n           call.setRpcResponse(value);\n           calls.remove(callId);\n         } else if (status \u003d\u003d RpcStatusProto.ERROR) {\n           call.setException(new RemoteException(WritableUtils.readString(in),\n                                                 WritableUtils.readString(in)));\n           calls.remove(callId);\n         } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n           // Close the connection\n           markClosed(new RemoteException(WritableUtils.readString(in), \n                                          WritableUtils.readString(in)));\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        RpcResponseHeaderProto response \u003d \n            RpcResponseHeaderProto.parseDelimitedFrom(in);\n        if (response \u003d\u003d null) {\n          throw new IOException(\"Response is null.\");\n        }\n\n        int callId \u003d response.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        Call call \u003d calls.get(callId);\n        RpcStatusProto status \u003d response.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setRpcResponse(value);\n          calls.remove(callId);\n        } else if (status \u003d\u003d RpcStatusProto.ERROR) {\n          call.setException(new RemoteException(WritableUtils.readString(in),\n                                                WritableUtils.readString(in)));\n          calls.remove(callId);\n        } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n          // Close the connection\n          markClosed(new RemoteException(WritableUtils.readString(in), \n                                         WritableUtils.readString(in)));\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-8366 Use ProtoBuf for RpcResponseHeader (sanjay radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1337283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/05/12 9:56 AM",
      "commitName": "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "23/04/12 9:34 AM",
      "commitNameOld": "589c68ae09effd6c4f26505d61636f779c22e99f",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 18.02,
      "commitsBetweenForRepo": 128,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n     private void receiveResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n-        int id \u003d in.readInt();                    // try to read an id\n-\n+        RpcResponseHeaderProto response \u003d \n+            RpcResponseHeaderProto.parseDelimitedFrom(in);\n+        int callId \u003d response.getCallId();\n         if (LOG.isDebugEnabled())\n-          LOG.debug(getName() + \" got value #\" + id);\n+          LOG.debug(getName() + \" got value #\" + callId);\n \n-        Call call \u003d calls.get(id);\n-\n-        int state \u003d in.readInt();     // read call status\n-        if (state \u003d\u003d Status.SUCCESS.state) {\n+        Call call \u003d calls.get(callId);\n+        RpcStatusProto status \u003d response.getStatus();\n+        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n           call.setRpcResponse(value);\n-          calls.remove(id);\n-        } else if (state \u003d\u003d Status.ERROR.state) {\n+          calls.remove(callId);\n+        } else if (status \u003d\u003d RpcStatusProto.ERROR) {\n           call.setException(new RemoteException(WritableUtils.readString(in),\n                                                 WritableUtils.readString(in)));\n-          calls.remove(id);\n-        } else if (state \u003d\u003d Status.FATAL.state) {\n+          calls.remove(callId);\n+        } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n           // Close the connection\n           markClosed(new RemoteException(WritableUtils.readString(in), \n                                          WritableUtils.readString(in)));\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        RpcResponseHeaderProto response \u003d \n            RpcResponseHeaderProto.parseDelimitedFrom(in);\n        int callId \u003d response.getCallId();\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + callId);\n\n        Call call \u003d calls.get(callId);\n        RpcStatusProto status \u003d response.getStatus();\n        if (status \u003d\u003d RpcStatusProto.SUCCESS) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setRpcResponse(value);\n          calls.remove(callId);\n        } else if (status \u003d\u003d RpcStatusProto.ERROR) {\n          call.setException(new RemoteException(WritableUtils.readString(in),\n                                                WritableUtils.readString(in)));\n          calls.remove(callId);\n        } else if (status \u003d\u003d RpcStatusProto.FATAL) {\n          // Close the connection\n          markClosed(new RemoteException(WritableUtils.readString(in), \n                                         WritableUtils.readString(in)));\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9": {
      "type": "Ybodychange",
      "commitMessage": "\t\tHADOOP-7776 Make the Ipc-Header in a RPC-Payload an explicit header (sanjay)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1197885 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/11/11 10:06 PM",
      "commitName": "072bdd85d16509d2c0cc32b5cfae3739521a29e9",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "30/09/11 6:22 AM",
      "commitNameOld": "ebdc7f800a6c161696adb161b623a80ebaa743d7",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 35.66,
      "commitsBetweenForRepo": 324,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n     private void receiveResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         int id \u003d in.readInt();                    // try to read an id\n \n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + id);\n \n         Call call \u003d calls.get(id);\n \n         int state \u003d in.readInt();     // read call status\n         if (state \u003d\u003d Status.SUCCESS.state) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n-          call.setValue(value);\n+          call.setRpcResponse(value);\n           calls.remove(id);\n         } else if (state \u003d\u003d Status.ERROR.state) {\n           call.setException(new RemoteException(WritableUtils.readString(in),\n                                                 WritableUtils.readString(in)));\n           calls.remove(id);\n         } else if (state \u003d\u003d Status.FATAL.state) {\n           // Close the connection\n           markClosed(new RemoteException(WritableUtils.readString(in), \n                                          WritableUtils.readString(in)));\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int id \u003d in.readInt();                    // try to read an id\n\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + id);\n\n        Call call \u003d calls.get(id);\n\n        int state \u003d in.readInt();     // read call status\n        if (state \u003d\u003d Status.SUCCESS.state) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setRpcResponse(value);\n          calls.remove(id);\n        } else if (state \u003d\u003d Status.ERROR.state) {\n          call.setException(new RemoteException(WritableUtils.readString(in),\n                                                WritableUtils.readString(in)));\n          calls.remove(id);\n        } else if (state \u003d\u003d Status.FATAL.state) {\n          // Close the connection\n          markClosed(new RemoteException(WritableUtils.readString(in), \n                                         WritableUtils.readString(in)));\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void receiveResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int id \u003d in.readInt();                    // try to read an id\n\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + id);\n\n        Call call \u003d calls.get(id);\n\n        int state \u003d in.readInt();     // read call status\n        if (state \u003d\u003d Status.SUCCESS.state) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setValue(value);\n          calls.remove(id);\n        } else if (state \u003d\u003d Status.ERROR.state) {\n          call.setException(new RemoteException(WritableUtils.readString(in),\n                                                WritableUtils.readString(in)));\n          calls.remove(id);\n        } else if (state \u003d\u003d Status.FATAL.state) {\n          // Close the connection\n          markClosed(new RemoteException(WritableUtils.readString(in), \n                                         WritableUtils.readString(in)));\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void receiveResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int id \u003d in.readInt();                    // try to read an id\n\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + id);\n\n        Call call \u003d calls.get(id);\n\n        int state \u003d in.readInt();     // read call status\n        if (state \u003d\u003d Status.SUCCESS.state) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setValue(value);\n          calls.remove(id);\n        } else if (state \u003d\u003d Status.ERROR.state) {\n          call.setException(new RemoteException(WritableUtils.readString(in),\n                                                WritableUtils.readString(in)));\n          calls.remove(id);\n        } else if (state \u003d\u003d Status.FATAL.state) {\n          // Close the connection\n          markClosed(new RemoteException(WritableUtils.readString(in), \n                                         WritableUtils.readString(in)));\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/ipc/Client.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void receiveResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int id \u003d in.readInt();                    // try to read an id\n\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + id);\n\n        Call call \u003d calls.get(id);\n\n        int state \u003d in.readInt();     // read call status\n        if (state \u003d\u003d Status.SUCCESS.state) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setValue(value);\n          calls.remove(id);\n        } else if (state \u003d\u003d Status.ERROR.state) {\n          call.setException(new RemoteException(WritableUtils.readString(in),\n                                                WritableUtils.readString(in)));\n          calls.remove(id);\n        } else if (state \u003d\u003d Status.FATAL.state) {\n          // Close the connection\n          markClosed(new RemoteException(WritableUtils.readString(in), \n                                         WritableUtils.readString(in)));\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "common/src/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/ipc/Client.java",
        "newPath": "common/src/java/org/apache/hadoop/ipc/Client.java"
      }
    },
    "97ce72a97efb57a5dbfb759ac8144c0890583068": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6833. IPC leaks call parameters when exceptions thrown. Contributed by Todd Lipcon.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@989999 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/08/10 7:53 PM",
      "commitName": "97ce72a97efb57a5dbfb759ac8144c0890583068",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "18/08/10 2:50 PM",
      "commitNameOld": "76e22cc8bfca9a91145869b204158113db329ab9",
      "commitAuthorOld": "Jakob Homan",
      "daysBetweenCommits": 8.21,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,33 @@\n     private void receiveResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         int id \u003d in.readInt();                    // try to read an id\n \n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + id);\n \n         Call call \u003d calls.get(id);\n \n         int state \u003d in.readInt();     // read call status\n         if (state \u003d\u003d Status.SUCCESS.state) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n           call.setValue(value);\n           calls.remove(id);\n         } else if (state \u003d\u003d Status.ERROR.state) {\n           call.setException(new RemoteException(WritableUtils.readString(in),\n                                                 WritableUtils.readString(in)));\n+          calls.remove(id);\n         } else if (state \u003d\u003d Status.FATAL.state) {\n           // Close the connection\n           markClosed(new RemoteException(WritableUtils.readString(in), \n                                          WritableUtils.readString(in)));\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int id \u003d in.readInt();                    // try to read an id\n\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + id);\n\n        Call call \u003d calls.get(id);\n\n        int state \u003d in.readInt();     // read call status\n        if (state \u003d\u003d Status.SUCCESS.state) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setValue(value);\n          calls.remove(id);\n        } else if (state \u003d\u003d Status.ERROR.state) {\n          call.setException(new RemoteException(WritableUtils.readString(in),\n                                                WritableUtils.readString(in)));\n          calls.remove(id);\n        } else if (state \u003d\u003d Status.FATAL.state) {\n          // Close the connection\n          markClosed(new RemoteException(WritableUtils.readString(in), \n                                         WritableUtils.readString(in)));\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "34d1b39c7525898b43e44a7c5cbd86768714baf0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6498. IPC client bug may cause rpc call hang. Contributed by Ruyue Ma and Hairong Kuang.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@903471 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/01/10 2:55 PM",
      "commitName": "34d1b39c7525898b43e44a7c5cbd86768714baf0",
      "commitAuthor": "Hairong Kuang",
      "commitDateOld": "26/01/10 2:52 PM",
      "commitNameOld": "d6f4cf3dfec03867f02bf71aa900a77676651c2a",
      "commitAuthorOld": "Hairong Kuang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,32 @@\n     private void receiveResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         int id \u003d in.readInt();                    // try to read an id\n \n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + id);\n \n-        Call call \u003d calls.remove(id);\n+        Call call \u003d calls.get(id);\n \n         int state \u003d in.readInt();     // read call status\n         if (state \u003d\u003d Status.SUCCESS.state) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n           call.setValue(value);\n+          calls.remove(id);\n         } else if (state \u003d\u003d Status.ERROR.state) {\n           call.setException(new RemoteException(WritableUtils.readString(in),\n                                                 WritableUtils.readString(in)));\n         } else if (state \u003d\u003d Status.FATAL.state) {\n           // Close the connection\n           markClosed(new RemoteException(WritableUtils.readString(in), \n                                          WritableUtils.readString(in)));\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int id \u003d in.readInt();                    // try to read an id\n\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + id);\n\n        Call call \u003d calls.get(id);\n\n        int state \u003d in.readInt();     // read call status\n        if (state \u003d\u003d Status.SUCCESS.state) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setValue(value);\n          calls.remove(id);\n        } else if (state \u003d\u003d Status.ERROR.state) {\n          call.setException(new RemoteException(WritableUtils.readString(in),\n                                                WritableUtils.readString(in)));\n        } else if (state \u003d\u003d Status.FATAL.state) {\n          // Close the connection\n          markClosed(new RemoteException(WritableUtils.readString(in), \n                                         WritableUtils.readString(in)));\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "d6f4cf3dfec03867f02bf71aa900a77676651c2a": {
      "type": "Ybodychange",
      "commitMessage": "Revert commit 903015 because it was tagged with the wrong jira number HADOOP-6459.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@903468 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/01/10 2:52 PM",
      "commitName": "d6f4cf3dfec03867f02bf71aa900a77676651c2a",
      "commitAuthor": "Hairong Kuang",
      "commitDateOld": "25/01/10 3:51 PM",
      "commitNameOld": "3ef40e13449b4321c3bc5a34eaddb6dc1ac0ceed",
      "commitAuthorOld": "Hairong Kuang",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,31 @@\n     private void receiveResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         int id \u003d in.readInt();                    // try to read an id\n \n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + id);\n \n-        Call call \u003d calls.get(id);\n+        Call call \u003d calls.remove(id);\n \n         int state \u003d in.readInt();     // read call status\n         if (state \u003d\u003d Status.SUCCESS.state) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n           call.setValue(value);\n-          calls.remove(id);\n         } else if (state \u003d\u003d Status.ERROR.state) {\n           call.setException(new RemoteException(WritableUtils.readString(in),\n                                                 WritableUtils.readString(in)));\n         } else if (state \u003d\u003d Status.FATAL.state) {\n           // Close the connection\n           markClosed(new RemoteException(WritableUtils.readString(in), \n                                          WritableUtils.readString(in)));\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int id \u003d in.readInt();                    // try to read an id\n\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + id);\n\n        Call call \u003d calls.remove(id);\n\n        int state \u003d in.readInt();     // read call status\n        if (state \u003d\u003d Status.SUCCESS.state) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setValue(value);\n        } else if (state \u003d\u003d Status.ERROR.state) {\n          call.setException(new RemoteException(WritableUtils.readString(in),\n                                                WritableUtils.readString(in)));\n        } else if (state \u003d\u003d Status.FATAL.state) {\n          // Close the connection\n          markClosed(new RemoteException(WritableUtils.readString(in), \n                                         WritableUtils.readString(in)));\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "3ef40e13449b4321c3bc5a34eaddb6dc1ac0ceed": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6459. IPC client bug may cause rpc call hang. Contributed by Hairong Kuang.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@903015 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/10 3:51 PM",
      "commitName": "3ef40e13449b4321c3bc5a34eaddb6dc1ac0ceed",
      "commitAuthor": "Hairong Kuang",
      "commitDateOld": "09/07/09 11:17 PM",
      "commitNameOld": "c38c5a43ffc2b12a1acb3afd1fa7685775bdeda1",
      "commitAuthorOld": "Dhruba Borthakur",
      "daysBetweenCommits": 199.73,
      "commitsBetweenForRepo": 181,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,32 @@\n     private void receiveResponse() {\n       if (shouldCloseConnection.get()) {\n         return;\n       }\n       touch();\n       \n       try {\n         int id \u003d in.readInt();                    // try to read an id\n \n         if (LOG.isDebugEnabled())\n           LOG.debug(getName() + \" got value #\" + id);\n \n-        Call call \u003d calls.remove(id);\n+        Call call \u003d calls.get(id);\n \n         int state \u003d in.readInt();     // read call status\n         if (state \u003d\u003d Status.SUCCESS.state) {\n           Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n           value.readFields(in);                 // read value\n           call.setValue(value);\n+          calls.remove(id);\n         } else if (state \u003d\u003d Status.ERROR.state) {\n           call.setException(new RemoteException(WritableUtils.readString(in),\n                                                 WritableUtils.readString(in)));\n         } else if (state \u003d\u003d Status.FATAL.state) {\n           // Close the connection\n           markClosed(new RemoteException(WritableUtils.readString(in), \n                                          WritableUtils.readString(in)));\n         }\n       } catch (IOException e) {\n         markClosed(e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int id \u003d in.readInt();                    // try to read an id\n\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + id);\n\n        Call call \u003d calls.get(id);\n\n        int state \u003d in.readInt();     // read call status\n        if (state \u003d\u003d Status.SUCCESS.state) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setValue(value);\n          calls.remove(id);\n        } else if (state \u003d\u003d Status.ERROR.state) {\n          call.setException(new RemoteException(WritableUtils.readString(in),\n                                                WritableUtils.readString(in)));\n        } else if (state \u003d\u003d Status.FATAL.state) {\n          // Close the connection\n          markClosed(new RemoteException(WritableUtils.readString(in), \n                                         WritableUtils.readString(in)));\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,31 @@\n+    private void receiveResponse() {\n+      if (shouldCloseConnection.get()) {\n+        return;\n+      }\n+      touch();\n+      \n+      try {\n+        int id \u003d in.readInt();                    // try to read an id\n+\n+        if (LOG.isDebugEnabled())\n+          LOG.debug(getName() + \" got value #\" + id);\n+\n+        Call call \u003d calls.remove(id);\n+\n+        int state \u003d in.readInt();     // read call status\n+        if (state \u003d\u003d Status.SUCCESS.state) {\n+          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n+          value.readFields(in);                 // read value\n+          call.setValue(value);\n+        } else if (state \u003d\u003d Status.ERROR.state) {\n+          call.setException(new RemoteException(WritableUtils.readString(in),\n+                                                WritableUtils.readString(in)));\n+        } else if (state \u003d\u003d Status.FATAL.state) {\n+          // Close the connection\n+          markClosed(new RemoteException(WritableUtils.readString(in), \n+                                         WritableUtils.readString(in)));\n+        }\n+      } catch (IOException e) {\n+        markClosed(e);\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void receiveResponse() {\n      if (shouldCloseConnection.get()) {\n        return;\n      }\n      touch();\n      \n      try {\n        int id \u003d in.readInt();                    // try to read an id\n\n        if (LOG.isDebugEnabled())\n          LOG.debug(getName() + \" got value #\" + id);\n\n        Call call \u003d calls.remove(id);\n\n        int state \u003d in.readInt();     // read call status\n        if (state \u003d\u003d Status.SUCCESS.state) {\n          Writable value \u003d ReflectionUtils.newInstance(valueClass, conf);\n          value.readFields(in);                 // read value\n          call.setValue(value);\n        } else if (state \u003d\u003d Status.ERROR.state) {\n          call.setException(new RemoteException(WritableUtils.readString(in),\n                                                WritableUtils.readString(in)));\n        } else if (state \u003d\u003d Status.FATAL.state) {\n          // Close the connection\n          markClosed(new RemoteException(WritableUtils.readString(in), \n                                         WritableUtils.readString(in)));\n        }\n      } catch (IOException e) {\n        markClosed(e);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Client.java"
    }
  }
}