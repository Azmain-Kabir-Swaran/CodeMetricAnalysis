{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMNodeImpl.java",
  "functionName": "handleContainerStatus",
  "functionId": "handleContainerStatus___containerStatuses-List__ContainerStatus__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java",
  "functionStartLine": 1392,
  "functionEndLine": 1486,
  "numCommitsSeen": 92,
  "timeTaken": 6723,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
    "85d81ae58ec4361a944c84753a900460a0888b9b",
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6",
    "352cbaa7a54a94bad2bed131d6a250c5b21a7701",
    "74f4bae45597f4794e99e33309130ddff647b21f",
    "e0f4620cc7db3db4b781e6042ab7dd754af28f18",
    "f45bc5a83ed2f2292ecf1f4c990b7153d8051fc9",
    "d16b17b4d299b4d58f879a2a15708bacd0938685",
    "ab80e277039a586f6d6259b2511ac413e29ea4f8",
    "08244264c0583472b9c4e16591cfde72c6db62a2",
    "a64dd3d24bfcb9af21eb63869924f6482b147fd3"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "f82922dcfae0b7e3e68ce970c441d8b7edc59acf": "Ybodychange",
    "85d81ae58ec4361a944c84753a900460a0888b9b": "Ybodychange",
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6": "Ybodychange",
    "352cbaa7a54a94bad2bed131d6a250c5b21a7701": "Ybodychange",
    "74f4bae45597f4794e99e33309130ddff647b21f": "Ybodychange",
    "e0f4620cc7db3db4b781e6042ab7dd754af28f18": "Ybodychange",
    "f45bc5a83ed2f2292ecf1f4c990b7153d8051fc9": "Ybodychange",
    "d16b17b4d299b4d58f879a2a15708bacd0938685": "Ybodychange",
    "ab80e277039a586f6d6259b2511ac413e29ea4f8": "Ybodychange",
    "08244264c0583472b9c4e16591cfde72c6db62a2": "Ybodychange",
    "a64dd3d24bfcb9af21eb63869924f6482b147fd3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "07/03/19 1:47 PM",
      "commitNameOld": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 8.06,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,95 @@\n   private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n     // Filter the map to only obtain just launched containers and finished\n     // containers.\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e newlyCompletedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     List\u003cMap.Entry\u003cApplicationId, ContainerStatus\u003e\u003e needUpdateContainers \u003d\n         new ArrayList\u003cMap.Entry\u003cApplicationId, ContainerStatus\u003e\u003e();\n     int numRemoteRunningContainers \u003d 0;\n     for (ContainerStatus remoteContainer : containerStatuses) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n \n       // Don\u0027t bother with containers already scheduled for cleanup, or for\n       // applications already killed. The scheduler doens\u0027t need to know any\n       // more about this container\n       if (containersToClean.contains(containerId)) {\n         LOG.info(\"Container \" + containerId + \" already scheduled for \"\n             + \"cleanup, no further processing\");\n         continue;\n       }\n \n       ApplicationId containerAppId \u003d\n           containerId.getApplicationAttemptId().getApplicationId();\n \n       if (finishedApplications.contains(containerAppId)) {\n         LOG.info(\"Container \" + containerId\n             + \" belongs to an application that is already killed,\"\n             + \" no further processing\");\n         continue;\n       } else if (!runningApplications.contains(containerAppId)) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Container \" + containerId\n-              + \" is the first container get launched for application \"\n-              + containerAppId);\n-        }\n+        LOG.debug(\"Container {} is the first container get launched for\"\n+            + \" application {}\", containerId, containerAppId);\n         handleRunningAppOnNode(this, context, containerAppId, nodeId);\n       }\n \n       // Process running containers\n       if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n         ++numRemoteRunningContainers;\n         if (!launchedContainers.contains(containerId)) {\n           // Just launched container. RM knows about it the first time.\n           launchedContainers.add(containerId);\n           newlyLaunchedContainers.add(remoteContainer);\n           // Unregister from containerAllocationExpirer.\n           containerAllocationExpirer\n               .unregister(new AllocationExpirationInfo(containerId));\n         }\n \n         // Check if you need to update the exist container status\n         boolean needUpdate \u003d false;\n         if (!updatedExistContainers.containsKey(containerId)) {\n           needUpdate \u003d true;\n         } else {\n           ContainerStatus pContainer \u003d updatedExistContainers.get(containerId);\n           if (null !\u003d pContainer) {\n             String preExposedPorts \u003d pContainer.getExposedPorts();\n             if (null !\u003d preExposedPorts \u0026\u0026\n                 !preExposedPorts.equals(remoteContainer.getExposedPorts())) {\n               needUpdate \u003d true;\n             }\n           }\n         }\n         if (needUpdate) {\n           updatedExistContainers.put(containerId, remoteContainer);\n           needUpdateContainers.add(new DefaultMapEntry(containerAppId,\n               remoteContainer));\n         }\n       } else {\n         // A finished container\n         launchedContainers.remove(containerId);\n         if (completedContainers.add(containerId)) {\n           newlyCompletedContainers.add(remoteContainer);\n         }\n         // Unregister from containerAllocationExpirer.\n         containerAllocationExpirer\n             .unregister(new AllocationExpirationInfo(containerId));\n       }\n     }\n \n     List\u003cContainerStatus\u003e lostContainers \u003d\n         findLostContainers(numRemoteRunningContainers, containerStatuses);\n     for (ContainerStatus remoteContainer : lostContainers) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n       if (completedContainers.add(containerId)) {\n         newlyCompletedContainers.add(remoteContainer);\n       }\n     }\n \n     if (newlyLaunchedContainers.size() !\u003d 0\n         || newlyCompletedContainers.size() !\u003d 0\n         || needUpdateContainers.size() !\u003d 0) {\n       nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n           newlyCompletedContainers, needUpdateContainers));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n    // Filter the map to only obtain just launched containers and finished\n    // containers.\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e newlyCompletedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cMap.Entry\u003cApplicationId, ContainerStatus\u003e\u003e needUpdateContainers \u003d\n        new ArrayList\u003cMap.Entry\u003cApplicationId, ContainerStatus\u003e\u003e();\n    int numRemoteRunningContainers \u003d 0;\n    for (ContainerStatus remoteContainer : containerStatuses) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n\n      // Don\u0027t bother with containers already scheduled for cleanup, or for\n      // applications already killed. The scheduler doens\u0027t need to know any\n      // more about this container\n      if (containersToClean.contains(containerId)) {\n        LOG.info(\"Container \" + containerId + \" already scheduled for \"\n            + \"cleanup, no further processing\");\n        continue;\n      }\n\n      ApplicationId containerAppId \u003d\n          containerId.getApplicationAttemptId().getApplicationId();\n\n      if (finishedApplications.contains(containerAppId)) {\n        LOG.info(\"Container \" + containerId\n            + \" belongs to an application that is already killed,\"\n            + \" no further processing\");\n        continue;\n      } else if (!runningApplications.contains(containerAppId)) {\n        LOG.debug(\"Container {} is the first container get launched for\"\n            + \" application {}\", containerId, containerAppId);\n        handleRunningAppOnNode(this, context, containerAppId, nodeId);\n      }\n\n      // Process running containers\n      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n        ++numRemoteRunningContainers;\n        if (!launchedContainers.contains(containerId)) {\n          // Just launched container. RM knows about it the first time.\n          launchedContainers.add(containerId);\n          newlyLaunchedContainers.add(remoteContainer);\n          // Unregister from containerAllocationExpirer.\n          containerAllocationExpirer\n              .unregister(new AllocationExpirationInfo(containerId));\n        }\n\n        // Check if you need to update the exist container status\n        boolean needUpdate \u003d false;\n        if (!updatedExistContainers.containsKey(containerId)) {\n          needUpdate \u003d true;\n        } else {\n          ContainerStatus pContainer \u003d updatedExistContainers.get(containerId);\n          if (null !\u003d pContainer) {\n            String preExposedPorts \u003d pContainer.getExposedPorts();\n            if (null !\u003d preExposedPorts \u0026\u0026\n                !preExposedPorts.equals(remoteContainer.getExposedPorts())) {\n              needUpdate \u003d true;\n            }\n          }\n        }\n        if (needUpdate) {\n          updatedExistContainers.put(containerId, remoteContainer);\n          needUpdateContainers.add(new DefaultMapEntry(containerAppId,\n              remoteContainer));\n        }\n      } else {\n        // A finished container\n        launchedContainers.remove(containerId);\n        if (completedContainers.add(containerId)) {\n          newlyCompletedContainers.add(remoteContainer);\n        }\n        // Unregister from containerAllocationExpirer.\n        containerAllocationExpirer\n            .unregister(new AllocationExpirationInfo(containerId));\n      }\n    }\n\n    List\u003cContainerStatus\u003e lostContainers \u003d\n        findLostContainers(numRemoteRunningContainers, containerStatuses);\n    for (ContainerStatus remoteContainer : lostContainers) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n      if (completedContainers.add(containerId)) {\n        newlyCompletedContainers.add(remoteContainer);\n      }\n    }\n\n    if (newlyLaunchedContainers.size() !\u003d 0\n        || newlyCompletedContainers.size() !\u003d 0\n        || needUpdateContainers.size() !\u003d 0) {\n      nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n          newlyCompletedContainers, needUpdateContainers));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java",
      "extendedDetails": {}
    },
    "f82922dcfae0b7e3e68ce970c441d8b7edc59acf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5168. Added exposed port information for Docker container.\n           Contributed by Xun Liu\n",
      "commitDate": "21/12/18 4:44 PM",
      "commitName": "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 100.59,
      "commitsBetweenForRepo": 850,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,98 @@\n   private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n     // Filter the map to only obtain just launched containers and finished\n     // containers.\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e newlyCompletedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n+    List\u003cMap.Entry\u003cApplicationId, ContainerStatus\u003e\u003e needUpdateContainers \u003d\n+        new ArrayList\u003cMap.Entry\u003cApplicationId, ContainerStatus\u003e\u003e();\n     int numRemoteRunningContainers \u003d 0;\n     for (ContainerStatus remoteContainer : containerStatuses) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n \n       // Don\u0027t bother with containers already scheduled for cleanup, or for\n       // applications already killed. The scheduler doens\u0027t need to know any\n       // more about this container\n       if (containersToClean.contains(containerId)) {\n         LOG.info(\"Container \" + containerId + \" already scheduled for \"\n             + \"cleanup, no further processing\");\n         continue;\n       }\n \n       ApplicationId containerAppId \u003d\n           containerId.getApplicationAttemptId().getApplicationId();\n \n       if (finishedApplications.contains(containerAppId)) {\n         LOG.info(\"Container \" + containerId\n             + \" belongs to an application that is already killed,\"\n             + \" no further processing\");\n         continue;\n       } else if (!runningApplications.contains(containerAppId)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Container \" + containerId\n               + \" is the first container get launched for application \"\n               + containerAppId);\n         }\n         handleRunningAppOnNode(this, context, containerAppId, nodeId);\n       }\n \n       // Process running containers\n       if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n         ++numRemoteRunningContainers;\n         if (!launchedContainers.contains(containerId)) {\n           // Just launched container. RM knows about it the first time.\n           launchedContainers.add(containerId);\n           newlyLaunchedContainers.add(remoteContainer);\n           // Unregister from containerAllocationExpirer.\n           containerAllocationExpirer\n               .unregister(new AllocationExpirationInfo(containerId));\n         }\n+\n+        // Check if you need to update the exist container status\n+        boolean needUpdate \u003d false;\n+        if (!updatedExistContainers.containsKey(containerId)) {\n+          needUpdate \u003d true;\n+        } else {\n+          ContainerStatus pContainer \u003d updatedExistContainers.get(containerId);\n+          if (null !\u003d pContainer) {\n+            String preExposedPorts \u003d pContainer.getExposedPorts();\n+            if (null !\u003d preExposedPorts \u0026\u0026\n+                !preExposedPorts.equals(remoteContainer.getExposedPorts())) {\n+              needUpdate \u003d true;\n+            }\n+          }\n+        }\n+        if (needUpdate) {\n+          updatedExistContainers.put(containerId, remoteContainer);\n+          needUpdateContainers.add(new DefaultMapEntry(containerAppId,\n+              remoteContainer));\n+        }\n       } else {\n         // A finished container\n         launchedContainers.remove(containerId);\n         if (completedContainers.add(containerId)) {\n           newlyCompletedContainers.add(remoteContainer);\n         }\n         // Unregister from containerAllocationExpirer.\n         containerAllocationExpirer\n             .unregister(new AllocationExpirationInfo(containerId));\n       }\n     }\n \n     List\u003cContainerStatus\u003e lostContainers \u003d\n         findLostContainers(numRemoteRunningContainers, containerStatuses);\n     for (ContainerStatus remoteContainer : lostContainers) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n       if (completedContainers.add(containerId)) {\n         newlyCompletedContainers.add(remoteContainer);\n       }\n     }\n \n     if (newlyLaunchedContainers.size() !\u003d 0\n-        || newlyCompletedContainers.size() !\u003d 0) {\n+        || newlyCompletedContainers.size() !\u003d 0\n+        || needUpdateContainers.size() !\u003d 0) {\n       nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n-          newlyCompletedContainers));\n+          newlyCompletedContainers, needUpdateContainers));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n    // Filter the map to only obtain just launched containers and finished\n    // containers.\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e newlyCompletedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cMap.Entry\u003cApplicationId, ContainerStatus\u003e\u003e needUpdateContainers \u003d\n        new ArrayList\u003cMap.Entry\u003cApplicationId, ContainerStatus\u003e\u003e();\n    int numRemoteRunningContainers \u003d 0;\n    for (ContainerStatus remoteContainer : containerStatuses) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n\n      // Don\u0027t bother with containers already scheduled for cleanup, or for\n      // applications already killed. The scheduler doens\u0027t need to know any\n      // more about this container\n      if (containersToClean.contains(containerId)) {\n        LOG.info(\"Container \" + containerId + \" already scheduled for \"\n            + \"cleanup, no further processing\");\n        continue;\n      }\n\n      ApplicationId containerAppId \u003d\n          containerId.getApplicationAttemptId().getApplicationId();\n\n      if (finishedApplications.contains(containerAppId)) {\n        LOG.info(\"Container \" + containerId\n            + \" belongs to an application that is already killed,\"\n            + \" no further processing\");\n        continue;\n      } else if (!runningApplications.contains(containerAppId)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Container \" + containerId\n              + \" is the first container get launched for application \"\n              + containerAppId);\n        }\n        handleRunningAppOnNode(this, context, containerAppId, nodeId);\n      }\n\n      // Process running containers\n      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n        ++numRemoteRunningContainers;\n        if (!launchedContainers.contains(containerId)) {\n          // Just launched container. RM knows about it the first time.\n          launchedContainers.add(containerId);\n          newlyLaunchedContainers.add(remoteContainer);\n          // Unregister from containerAllocationExpirer.\n          containerAllocationExpirer\n              .unregister(new AllocationExpirationInfo(containerId));\n        }\n\n        // Check if you need to update the exist container status\n        boolean needUpdate \u003d false;\n        if (!updatedExistContainers.containsKey(containerId)) {\n          needUpdate \u003d true;\n        } else {\n          ContainerStatus pContainer \u003d updatedExistContainers.get(containerId);\n          if (null !\u003d pContainer) {\n            String preExposedPorts \u003d pContainer.getExposedPorts();\n            if (null !\u003d preExposedPorts \u0026\u0026\n                !preExposedPorts.equals(remoteContainer.getExposedPorts())) {\n              needUpdate \u003d true;\n            }\n          }\n        }\n        if (needUpdate) {\n          updatedExistContainers.put(containerId, remoteContainer);\n          needUpdateContainers.add(new DefaultMapEntry(containerAppId,\n              remoteContainer));\n        }\n      } else {\n        // A finished container\n        launchedContainers.remove(containerId);\n        if (completedContainers.add(containerId)) {\n          newlyCompletedContainers.add(remoteContainer);\n        }\n        // Unregister from containerAllocationExpirer.\n        containerAllocationExpirer\n            .unregister(new AllocationExpirationInfo(containerId));\n      }\n    }\n\n    List\u003cContainerStatus\u003e lostContainers \u003d\n        findLostContainers(numRemoteRunningContainers, containerStatuses);\n    for (ContainerStatus remoteContainer : lostContainers) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n      if (completedContainers.add(containerId)) {\n        newlyCompletedContainers.add(remoteContainer);\n      }\n    }\n\n    if (newlyLaunchedContainers.size() !\u003d 0\n        || newlyCompletedContainers.size() !\u003d 0\n        || needUpdateContainers.size() !\u003d 0) {\n      nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n          newlyCompletedContainers, needUpdateContainers));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java",
      "extendedDetails": {}
    },
    "85d81ae58ec4361a944c84753a900460a0888b9b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7248. NM returns new SCHEDULED container status to older clients. Contributed by Arun Suresh\n",
      "commitDate": "28/09/17 12:10 PM",
      "commitName": "85d81ae58ec4361a944c84753a900460a0888b9b",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "11/09/17 8:52 PM",
      "commitNameOld": "e74d1be04be47969943b0501a4f335b0b5188287",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 16.64,
      "commitsBetweenForRepo": 180,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,75 @@\n   private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n     // Filter the map to only obtain just launched containers and finished\n     // containers.\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e newlyCompletedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     int numRemoteRunningContainers \u003d 0;\n     for (ContainerStatus remoteContainer : containerStatuses) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n \n       // Don\u0027t bother with containers already scheduled for cleanup, or for\n       // applications already killed. The scheduler doens\u0027t need to know any\n       // more about this container\n       if (containersToClean.contains(containerId)) {\n         LOG.info(\"Container \" + containerId + \" already scheduled for \"\n             + \"cleanup, no further processing\");\n         continue;\n       }\n \n       ApplicationId containerAppId \u003d\n           containerId.getApplicationAttemptId().getApplicationId();\n \n       if (finishedApplications.contains(containerAppId)) {\n         LOG.info(\"Container \" + containerId\n             + \" belongs to an application that is already killed,\"\n             + \" no further processing\");\n         continue;\n       } else if (!runningApplications.contains(containerAppId)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Container \" + containerId\n               + \" is the first container get launched for application \"\n               + containerAppId);\n         }\n         handleRunningAppOnNode(this, context, containerAppId, nodeId);\n       }\n \n       // Process running containers\n-      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING ||\n-          remoteContainer.getState() \u003d\u003d ContainerState.SCHEDULED) {\n+      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n         ++numRemoteRunningContainers;\n         if (!launchedContainers.contains(containerId)) {\n           // Just launched container. RM knows about it the first time.\n           launchedContainers.add(containerId);\n           newlyLaunchedContainers.add(remoteContainer);\n           // Unregister from containerAllocationExpirer.\n           containerAllocationExpirer\n               .unregister(new AllocationExpirationInfo(containerId));\n         }\n       } else {\n         // A finished container\n         launchedContainers.remove(containerId);\n         if (completedContainers.add(containerId)) {\n           newlyCompletedContainers.add(remoteContainer);\n         }\n         // Unregister from containerAllocationExpirer.\n         containerAllocationExpirer\n             .unregister(new AllocationExpirationInfo(containerId));\n       }\n     }\n \n     List\u003cContainerStatus\u003e lostContainers \u003d\n         findLostContainers(numRemoteRunningContainers, containerStatuses);\n     for (ContainerStatus remoteContainer : lostContainers) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n       if (completedContainers.add(containerId)) {\n         newlyCompletedContainers.add(remoteContainer);\n       }\n     }\n \n     if (newlyLaunchedContainers.size() !\u003d 0\n         || newlyCompletedContainers.size() !\u003d 0) {\n       nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n           newlyCompletedContainers));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n    // Filter the map to only obtain just launched containers and finished\n    // containers.\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e newlyCompletedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    int numRemoteRunningContainers \u003d 0;\n    for (ContainerStatus remoteContainer : containerStatuses) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n\n      // Don\u0027t bother with containers already scheduled for cleanup, or for\n      // applications already killed. The scheduler doens\u0027t need to know any\n      // more about this container\n      if (containersToClean.contains(containerId)) {\n        LOG.info(\"Container \" + containerId + \" already scheduled for \"\n            + \"cleanup, no further processing\");\n        continue;\n      }\n\n      ApplicationId containerAppId \u003d\n          containerId.getApplicationAttemptId().getApplicationId();\n\n      if (finishedApplications.contains(containerAppId)) {\n        LOG.info(\"Container \" + containerId\n            + \" belongs to an application that is already killed,\"\n            + \" no further processing\");\n        continue;\n      } else if (!runningApplications.contains(containerAppId)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Container \" + containerId\n              + \" is the first container get launched for application \"\n              + containerAppId);\n        }\n        handleRunningAppOnNode(this, context, containerAppId, nodeId);\n      }\n\n      // Process running containers\n      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n        ++numRemoteRunningContainers;\n        if (!launchedContainers.contains(containerId)) {\n          // Just launched container. RM knows about it the first time.\n          launchedContainers.add(containerId);\n          newlyLaunchedContainers.add(remoteContainer);\n          // Unregister from containerAllocationExpirer.\n          containerAllocationExpirer\n              .unregister(new AllocationExpirationInfo(containerId));\n        }\n      } else {\n        // A finished container\n        launchedContainers.remove(containerId);\n        if (completedContainers.add(containerId)) {\n          newlyCompletedContainers.add(remoteContainer);\n        }\n        // Unregister from containerAllocationExpirer.\n        containerAllocationExpirer\n            .unregister(new AllocationExpirationInfo(containerId));\n      }\n    }\n\n    List\u003cContainerStatus\u003e lostContainers \u003d\n        findLostContainers(numRemoteRunningContainers, containerStatuses);\n    for (ContainerStatus remoteContainer : lostContainers) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n      if (completedContainers.add(containerId)) {\n        newlyCompletedContainers.add(remoteContainer);\n      }\n    }\n\n    if (newlyLaunchedContainers.size() !\u003d 0\n        || newlyCompletedContainers.size() !\u003d 0) {\n      nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n          newlyCompletedContainers));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java",
      "extendedDetails": {}
    },
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4597. Introduce ContainerScheduler and a SCHEDULED state to NodeManager container lifecycle. (asuresh)\n",
      "commitDate": "15/11/16 7:56 AM",
      "commitName": "3219b7b4ac7d12aee343f6ab2980b3357fc618b6",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "08/11/16 2:01 PM",
      "commitNameOld": "3f93ac0733058238a2c8f23960c986c71dca0e02",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 6.75,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,76 @@\n   private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n     // Filter the map to only obtain just launched containers and finished\n     // containers.\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e newlyCompletedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     int numRemoteRunningContainers \u003d 0;\n     for (ContainerStatus remoteContainer : containerStatuses) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n \n       // Don\u0027t bother with containers already scheduled for cleanup, or for\n       // applications already killed. The scheduler doens\u0027t need to know any\n       // more about this container\n       if (containersToClean.contains(containerId)) {\n         LOG.info(\"Container \" + containerId + \" already scheduled for \"\n             + \"cleanup, no further processing\");\n         continue;\n       }\n \n       ApplicationId containerAppId \u003d\n           containerId.getApplicationAttemptId().getApplicationId();\n \n       if (finishedApplications.contains(containerAppId)) {\n         LOG.info(\"Container \" + containerId\n             + \" belongs to an application that is already killed,\"\n             + \" no further processing\");\n         continue;\n       } else if (!runningApplications.contains(containerAppId)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Container \" + containerId\n               + \" is the first container get launched for application \"\n               + containerAppId);\n         }\n         handleRunningAppOnNode(this, context, containerAppId, nodeId);\n       }\n \n       // Process running containers\n-      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n-        // Process only GUARANTEED containers in the RM.\n-        if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n-          ++numRemoteRunningContainers;\n-          if (!launchedContainers.contains(containerId)) {\n-            // Just launched container. RM knows about it the first time.\n-            launchedContainers.add(containerId);\n-            newlyLaunchedContainers.add(remoteContainer);\n-            // Unregister from containerAllocationExpirer.\n-            containerAllocationExpirer\n-                .unregister(new AllocationExpirationInfo(containerId));\n-          }\n-        }\n-      } else {\n-        if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n-          // A finished container\n-          launchedContainers.remove(containerId);\n+      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING ||\n+          remoteContainer.getState() \u003d\u003d ContainerState.SCHEDULED) {\n+        ++numRemoteRunningContainers;\n+        if (!launchedContainers.contains(containerId)) {\n+          // Just launched container. RM knows about it the first time.\n+          launchedContainers.add(containerId);\n+          newlyLaunchedContainers.add(remoteContainer);\n           // Unregister from containerAllocationExpirer.\n           containerAllocationExpirer\n               .unregister(new AllocationExpirationInfo(containerId));\n         }\n-        // Completed containers should also include the OPPORTUNISTIC containers\n-        // so that the AM gets properly notified.\n+      } else {\n+        // A finished container\n+        launchedContainers.remove(containerId);\n         if (completedContainers.add(containerId)) {\n           newlyCompletedContainers.add(remoteContainer);\n         }\n+        // Unregister from containerAllocationExpirer.\n+        containerAllocationExpirer\n+            .unregister(new AllocationExpirationInfo(containerId));\n       }\n     }\n \n     List\u003cContainerStatus\u003e lostContainers \u003d\n         findLostContainers(numRemoteRunningContainers, containerStatuses);\n     for (ContainerStatus remoteContainer : lostContainers) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n       if (completedContainers.add(containerId)) {\n         newlyCompletedContainers.add(remoteContainer);\n       }\n     }\n \n     if (newlyLaunchedContainers.size() !\u003d 0\n         || newlyCompletedContainers.size() !\u003d 0) {\n       nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n           newlyCompletedContainers));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n    // Filter the map to only obtain just launched containers and finished\n    // containers.\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e newlyCompletedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    int numRemoteRunningContainers \u003d 0;\n    for (ContainerStatus remoteContainer : containerStatuses) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n\n      // Don\u0027t bother with containers already scheduled for cleanup, or for\n      // applications already killed. The scheduler doens\u0027t need to know any\n      // more about this container\n      if (containersToClean.contains(containerId)) {\n        LOG.info(\"Container \" + containerId + \" already scheduled for \"\n            + \"cleanup, no further processing\");\n        continue;\n      }\n\n      ApplicationId containerAppId \u003d\n          containerId.getApplicationAttemptId().getApplicationId();\n\n      if (finishedApplications.contains(containerAppId)) {\n        LOG.info(\"Container \" + containerId\n            + \" belongs to an application that is already killed,\"\n            + \" no further processing\");\n        continue;\n      } else if (!runningApplications.contains(containerAppId)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Container \" + containerId\n              + \" is the first container get launched for application \"\n              + containerAppId);\n        }\n        handleRunningAppOnNode(this, context, containerAppId, nodeId);\n      }\n\n      // Process running containers\n      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING ||\n          remoteContainer.getState() \u003d\u003d ContainerState.SCHEDULED) {\n        ++numRemoteRunningContainers;\n        if (!launchedContainers.contains(containerId)) {\n          // Just launched container. RM knows about it the first time.\n          launchedContainers.add(containerId);\n          newlyLaunchedContainers.add(remoteContainer);\n          // Unregister from containerAllocationExpirer.\n          containerAllocationExpirer\n              .unregister(new AllocationExpirationInfo(containerId));\n        }\n      } else {\n        // A finished container\n        launchedContainers.remove(containerId);\n        if (completedContainers.add(containerId)) {\n          newlyCompletedContainers.add(remoteContainer);\n        }\n        // Unregister from containerAllocationExpirer.\n        containerAllocationExpirer\n            .unregister(new AllocationExpirationInfo(containerId));\n      }\n    }\n\n    List\u003cContainerStatus\u003e lostContainers \u003d\n        findLostContainers(numRemoteRunningContainers, containerStatuses);\n    for (ContainerStatus remoteContainer : lostContainers) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n      if (completedContainers.add(containerId)) {\n        newlyCompletedContainers.add(remoteContainer);\n      }\n    }\n\n    if (newlyLaunchedContainers.size() !\u003d 0\n        || newlyCompletedContainers.size() !\u003d 0) {\n      nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n          newlyCompletedContainers));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java",
      "extendedDetails": {}
    },
    "352cbaa7a54a94bad2bed131d6a250c5b21a7701": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4862. Handle duplicate completed containers in RMNodeImpl. Contributed by Rohith Sharma K S\n",
      "commitDate": "03/11/16 6:54 AM",
      "commitName": "352cbaa7a54a94bad2bed131d6a250c5b21a7701",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "01/09/16 2:44 PM",
      "commitNameOld": "74f4bae45597f4794e99e33309130ddff647b21f",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 62.67,
      "commitsBetweenForRepo": 463,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,82 @@\n   private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n     // Filter the map to only obtain just launched containers and finished\n     // containers.\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n-    List\u003cContainerStatus\u003e completedContainers \u003d\n+    List\u003cContainerStatus\u003e newlyCompletedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     int numRemoteRunningContainers \u003d 0;\n     for (ContainerStatus remoteContainer : containerStatuses) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n \n       // Don\u0027t bother with containers already scheduled for cleanup, or for\n       // applications already killed. The scheduler doens\u0027t need to know any\n       // more about this container\n       if (containersToClean.contains(containerId)) {\n         LOG.info(\"Container \" + containerId + \" already scheduled for \"\n             + \"cleanup, no further processing\");\n         continue;\n       }\n \n       ApplicationId containerAppId \u003d\n           containerId.getApplicationAttemptId().getApplicationId();\n \n       if (finishedApplications.contains(containerAppId)) {\n         LOG.info(\"Container \" + containerId\n             + \" belongs to an application that is already killed,\"\n             + \" no further processing\");\n         continue;\n       } else if (!runningApplications.contains(containerAppId)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Container \" + containerId\n               + \" is the first container get launched for application \"\n               + containerAppId);\n         }\n         handleRunningAppOnNode(this, context, containerAppId, nodeId);\n       }\n \n       // Process running containers\n       if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n         // Process only GUARANTEED containers in the RM.\n         if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n           ++numRemoteRunningContainers;\n           if (!launchedContainers.contains(containerId)) {\n             // Just launched container. RM knows about it the first time.\n             launchedContainers.add(containerId);\n             newlyLaunchedContainers.add(remoteContainer);\n             // Unregister from containerAllocationExpirer.\n             containerAllocationExpirer\n                 .unregister(new AllocationExpirationInfo(containerId));\n           }\n         }\n       } else {\n         if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n           // A finished container\n           launchedContainers.remove(containerId);\n           // Unregister from containerAllocationExpirer.\n           containerAllocationExpirer\n               .unregister(new AllocationExpirationInfo(containerId));\n         }\n         // Completed containers should also include the OPPORTUNISTIC containers\n         // so that the AM gets properly notified.\n-        completedContainers.add(remoteContainer);\n+        if (completedContainers.add(containerId)) {\n+          newlyCompletedContainers.add(remoteContainer);\n+        }\n       }\n     }\n-    completedContainers.addAll(findLostContainers(\n-          numRemoteRunningContainers, containerStatuses));\n \n-    if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n+    List\u003cContainerStatus\u003e lostContainers \u003d\n+        findLostContainers(numRemoteRunningContainers, containerStatuses);\n+    for (ContainerStatus remoteContainer : lostContainers) {\n+      ContainerId containerId \u003d remoteContainer.getContainerId();\n+      if (completedContainers.add(containerId)) {\n+        newlyCompletedContainers.add(remoteContainer);\n+      }\n+    }\n+\n+    if (newlyLaunchedContainers.size() !\u003d 0\n+        || newlyCompletedContainers.size() !\u003d 0) {\n       nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n-          completedContainers));\n+          newlyCompletedContainers));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n    // Filter the map to only obtain just launched containers and finished\n    // containers.\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e newlyCompletedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    int numRemoteRunningContainers \u003d 0;\n    for (ContainerStatus remoteContainer : containerStatuses) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n\n      // Don\u0027t bother with containers already scheduled for cleanup, or for\n      // applications already killed. The scheduler doens\u0027t need to know any\n      // more about this container\n      if (containersToClean.contains(containerId)) {\n        LOG.info(\"Container \" + containerId + \" already scheduled for \"\n            + \"cleanup, no further processing\");\n        continue;\n      }\n\n      ApplicationId containerAppId \u003d\n          containerId.getApplicationAttemptId().getApplicationId();\n\n      if (finishedApplications.contains(containerAppId)) {\n        LOG.info(\"Container \" + containerId\n            + \" belongs to an application that is already killed,\"\n            + \" no further processing\");\n        continue;\n      } else if (!runningApplications.contains(containerAppId)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Container \" + containerId\n              + \" is the first container get launched for application \"\n              + containerAppId);\n        }\n        handleRunningAppOnNode(this, context, containerAppId, nodeId);\n      }\n\n      // Process running containers\n      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n        // Process only GUARANTEED containers in the RM.\n        if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n          ++numRemoteRunningContainers;\n          if (!launchedContainers.contains(containerId)) {\n            // Just launched container. RM knows about it the first time.\n            launchedContainers.add(containerId);\n            newlyLaunchedContainers.add(remoteContainer);\n            // Unregister from containerAllocationExpirer.\n            containerAllocationExpirer\n                .unregister(new AllocationExpirationInfo(containerId));\n          }\n        }\n      } else {\n        if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n          // A finished container\n          launchedContainers.remove(containerId);\n          // Unregister from containerAllocationExpirer.\n          containerAllocationExpirer\n              .unregister(new AllocationExpirationInfo(containerId));\n        }\n        // Completed containers should also include the OPPORTUNISTIC containers\n        // so that the AM gets properly notified.\n        if (completedContainers.add(containerId)) {\n          newlyCompletedContainers.add(remoteContainer);\n        }\n      }\n    }\n\n    List\u003cContainerStatus\u003e lostContainers \u003d\n        findLostContainers(numRemoteRunningContainers, containerStatuses);\n    for (ContainerStatus remoteContainer : lostContainers) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n      if (completedContainers.add(containerId)) {\n        newlyCompletedContainers.add(remoteContainer);\n      }\n    }\n\n    if (newlyLaunchedContainers.size() !\u003d 0\n        || newlyCompletedContainers.size() !\u003d 0) {\n      nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n          newlyCompletedContainers));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java",
      "extendedDetails": {}
    },
    "74f4bae45597f4794e99e33309130ddff647b21f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5566. Client-side NM graceful decom is not triggered when jobs finish. (Robert Kanter via kasha)\n",
      "commitDate": "01/09/16 2:44 PM",
      "commitName": "74f4bae45597f4794e99e33309130ddff647b21f",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "18/08/16 7:27 AM",
      "commitNameOld": "0da69c324dee9baab0f0b9700db1cc5b623f8421",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 14.3,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n     // Filter the map to only obtain just launched containers and finished\n     // containers.\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     int numRemoteRunningContainers \u003d 0;\n     for (ContainerStatus remoteContainer : containerStatuses) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n \n       // Don\u0027t bother with containers already scheduled for cleanup, or for\n       // applications already killed. The scheduler doens\u0027t need to know any\n       // more about this container\n       if (containersToClean.contains(containerId)) {\n         LOG.info(\"Container \" + containerId + \" already scheduled for \"\n             + \"cleanup, no further processing\");\n         continue;\n       }\n \n       ApplicationId containerAppId \u003d\n           containerId.getApplicationAttemptId().getApplicationId();\n \n       if (finishedApplications.contains(containerAppId)) {\n         LOG.info(\"Container \" + containerId\n             + \" belongs to an application that is already killed,\"\n             + \" no further processing\");\n         continue;\n       } else if (!runningApplications.contains(containerAppId)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Container \" + containerId\n               + \" is the first container get launched for application \"\n               + containerAppId);\n         }\n-        runningApplications.add(containerAppId);\n+        handleRunningAppOnNode(this, context, containerAppId, nodeId);\n       }\n \n       // Process running containers\n       if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n         // Process only GUARANTEED containers in the RM.\n         if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n           ++numRemoteRunningContainers;\n           if (!launchedContainers.contains(containerId)) {\n             // Just launched container. RM knows about it the first time.\n             launchedContainers.add(containerId);\n             newlyLaunchedContainers.add(remoteContainer);\n             // Unregister from containerAllocationExpirer.\n             containerAllocationExpirer\n                 .unregister(new AllocationExpirationInfo(containerId));\n           }\n         }\n       } else {\n         if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n           // A finished container\n           launchedContainers.remove(containerId);\n           // Unregister from containerAllocationExpirer.\n           containerAllocationExpirer\n               .unregister(new AllocationExpirationInfo(containerId));\n         }\n         // Completed containers should also include the OPPORTUNISTIC containers\n         // so that the AM gets properly notified.\n         completedContainers.add(remoteContainer);\n       }\n     }\n     completedContainers.addAll(findLostContainers(\n           numRemoteRunningContainers, containerStatuses));\n \n     if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n       nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n           completedContainers));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n    // Filter the map to only obtain just launched containers and finished\n    // containers.\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    int numRemoteRunningContainers \u003d 0;\n    for (ContainerStatus remoteContainer : containerStatuses) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n\n      // Don\u0027t bother with containers already scheduled for cleanup, or for\n      // applications already killed. The scheduler doens\u0027t need to know any\n      // more about this container\n      if (containersToClean.contains(containerId)) {\n        LOG.info(\"Container \" + containerId + \" already scheduled for \"\n            + \"cleanup, no further processing\");\n        continue;\n      }\n\n      ApplicationId containerAppId \u003d\n          containerId.getApplicationAttemptId().getApplicationId();\n\n      if (finishedApplications.contains(containerAppId)) {\n        LOG.info(\"Container \" + containerId\n            + \" belongs to an application that is already killed,\"\n            + \" no further processing\");\n        continue;\n      } else if (!runningApplications.contains(containerAppId)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Container \" + containerId\n              + \" is the first container get launched for application \"\n              + containerAppId);\n        }\n        handleRunningAppOnNode(this, context, containerAppId, nodeId);\n      }\n\n      // Process running containers\n      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n        // Process only GUARANTEED containers in the RM.\n        if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n          ++numRemoteRunningContainers;\n          if (!launchedContainers.contains(containerId)) {\n            // Just launched container. RM knows about it the first time.\n            launchedContainers.add(containerId);\n            newlyLaunchedContainers.add(remoteContainer);\n            // Unregister from containerAllocationExpirer.\n            containerAllocationExpirer\n                .unregister(new AllocationExpirationInfo(containerId));\n          }\n        }\n      } else {\n        if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n          // A finished container\n          launchedContainers.remove(containerId);\n          // Unregister from containerAllocationExpirer.\n          containerAllocationExpirer\n              .unregister(new AllocationExpirationInfo(containerId));\n        }\n        // Completed containers should also include the OPPORTUNISTIC containers\n        // so that the AM gets properly notified.\n        completedContainers.add(remoteContainer);\n      }\n    }\n    completedContainers.addAll(findLostContainers(\n          numRemoteRunningContainers, containerStatuses));\n\n    if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n      nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n          completedContainers));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java",
      "extendedDetails": {}
    },
    "e0f4620cc7db3db4b781e6042ab7dd754af28f18": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5197. RM leaks containers if running container disappears from node update. Contributed by Jason Lowe.\n",
      "commitDate": "10/06/16 9:52 PM",
      "commitName": "e0f4620cc7db3db4b781e6042ab7dd754af28f18",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "15/05/16 5:54 PM",
      "commitNameOld": "f45bc5a83ed2f2292ecf1f4c990b7153d8051fc9",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 26.17,
      "commitsBetweenForRepo": 197,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,72 @@\n   private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n     // Filter the map to only obtain just launched containers and finished\n     // containers.\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n+    int numRemoteRunningContainers \u003d 0;\n     for (ContainerStatus remoteContainer : containerStatuses) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n \n       // Don\u0027t bother with containers already scheduled for cleanup, or for\n       // applications already killed. The scheduler doens\u0027t need to know any\n       // more about this container\n       if (containersToClean.contains(containerId)) {\n         LOG.info(\"Container \" + containerId + \" already scheduled for \"\n             + \"cleanup, no further processing\");\n         continue;\n       }\n \n       ApplicationId containerAppId \u003d\n           containerId.getApplicationAttemptId().getApplicationId();\n \n       if (finishedApplications.contains(containerAppId)) {\n         LOG.info(\"Container \" + containerId\n             + \" belongs to an application that is already killed,\"\n             + \" no further processing\");\n         continue;\n       } else if (!runningApplications.contains(containerAppId)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Container \" + containerId\n               + \" is the first container get launched for application \"\n               + containerAppId);\n         }\n         runningApplications.add(containerAppId);\n       }\n \n       // Process running containers\n       if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n         // Process only GUARANTEED containers in the RM.\n         if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n+          ++numRemoteRunningContainers;\n           if (!launchedContainers.contains(containerId)) {\n             // Just launched container. RM knows about it the first time.\n             launchedContainers.add(containerId);\n             newlyLaunchedContainers.add(remoteContainer);\n             // Unregister from containerAllocationExpirer.\n             containerAllocationExpirer\n                 .unregister(new AllocationExpirationInfo(containerId));\n           }\n         }\n       } else {\n         if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n           // A finished container\n           launchedContainers.remove(containerId);\n           // Unregister from containerAllocationExpirer.\n           containerAllocationExpirer\n               .unregister(new AllocationExpirationInfo(containerId));\n         }\n         // Completed containers should also include the OPPORTUNISTIC containers\n         // so that the AM gets properly notified.\n         completedContainers.add(remoteContainer);\n       }\n     }\n+    completedContainers.addAll(findLostContainers(\n+          numRemoteRunningContainers, containerStatuses));\n+\n     if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n       nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n           completedContainers));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n    // Filter the map to only obtain just launched containers and finished\n    // containers.\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    int numRemoteRunningContainers \u003d 0;\n    for (ContainerStatus remoteContainer : containerStatuses) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n\n      // Don\u0027t bother with containers already scheduled for cleanup, or for\n      // applications already killed. The scheduler doens\u0027t need to know any\n      // more about this container\n      if (containersToClean.contains(containerId)) {\n        LOG.info(\"Container \" + containerId + \" already scheduled for \"\n            + \"cleanup, no further processing\");\n        continue;\n      }\n\n      ApplicationId containerAppId \u003d\n          containerId.getApplicationAttemptId().getApplicationId();\n\n      if (finishedApplications.contains(containerAppId)) {\n        LOG.info(\"Container \" + containerId\n            + \" belongs to an application that is already killed,\"\n            + \" no further processing\");\n        continue;\n      } else if (!runningApplications.contains(containerAppId)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Container \" + containerId\n              + \" is the first container get launched for application \"\n              + containerAppId);\n        }\n        runningApplications.add(containerAppId);\n      }\n\n      // Process running containers\n      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n        // Process only GUARANTEED containers in the RM.\n        if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n          ++numRemoteRunningContainers;\n          if (!launchedContainers.contains(containerId)) {\n            // Just launched container. RM knows about it the first time.\n            launchedContainers.add(containerId);\n            newlyLaunchedContainers.add(remoteContainer);\n            // Unregister from containerAllocationExpirer.\n            containerAllocationExpirer\n                .unregister(new AllocationExpirationInfo(containerId));\n          }\n        }\n      } else {\n        if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n          // A finished container\n          launchedContainers.remove(containerId);\n          // Unregister from containerAllocationExpirer.\n          containerAllocationExpirer\n              .unregister(new AllocationExpirationInfo(containerId));\n        }\n        // Completed containers should also include the OPPORTUNISTIC containers\n        // so that the AM gets properly notified.\n        completedContainers.add(remoteContainer);\n      }\n    }\n    completedContainers.addAll(findLostContainers(\n          numRemoteRunningContainers, containerStatuses));\n\n    if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n      nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n          completedContainers));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java",
      "extendedDetails": {}
    },
    "f45bc5a83ed2f2292ecf1f4c990b7153d8051fc9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4738. Notify the RM about the status of OPPORTUNISTIC containers (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "15/05/16 5:54 PM",
      "commitName": "f45bc5a83ed2f2292ecf1f4c990b7153d8051fc9",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "05/05/16 7:07 AM",
      "commitNameOld": "d0da13229cf692579c8c9db47a93f6c6255392c8",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 10.45,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,67 @@\n   private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n     // Filter the map to only obtain just launched containers and finished\n     // containers.\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     for (ContainerStatus remoteContainer : containerStatuses) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n \n       // Don\u0027t bother with containers already scheduled for cleanup, or for\n       // applications already killed. The scheduler doens\u0027t need to know any\n       // more about this container\n       if (containersToClean.contains(containerId)) {\n         LOG.info(\"Container \" + containerId + \" already scheduled for \"\n             + \"cleanup, no further processing\");\n         continue;\n       }\n \n       ApplicationId containerAppId \u003d\n           containerId.getApplicationAttemptId().getApplicationId();\n \n       if (finishedApplications.contains(containerAppId)) {\n         LOG.info(\"Container \" + containerId\n             + \" belongs to an application that is already killed,\"\n             + \" no further processing\");\n         continue;\n       } else if (!runningApplications.contains(containerAppId)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Container \" + containerId\n               + \" is the first container get launched for application \"\n               + containerAppId);\n         }\n         runningApplications.add(containerAppId);\n       }\n \n       // Process running containers\n       if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n-        if (!launchedContainers.contains(containerId)) {\n-          // Just launched container. RM knows about it the first time.\n-          launchedContainers.add(containerId);\n-          newlyLaunchedContainers.add(remoteContainer);\n-          // Unregister from containerAllocationExpirer.\n-          containerAllocationExpirer.unregister(\n-              new AllocationExpirationInfo(containerId));\n+        // Process only GUARANTEED containers in the RM.\n+        if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n+          if (!launchedContainers.contains(containerId)) {\n+            // Just launched container. RM knows about it the first time.\n+            launchedContainers.add(containerId);\n+            newlyLaunchedContainers.add(remoteContainer);\n+            // Unregister from containerAllocationExpirer.\n+            containerAllocationExpirer\n+                .unregister(new AllocationExpirationInfo(containerId));\n+          }\n         }\n       } else {\n-        // A finished container\n-        launchedContainers.remove(containerId);\n+        if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n+          // A finished container\n+          launchedContainers.remove(containerId);\n+          // Unregister from containerAllocationExpirer.\n+          containerAllocationExpirer\n+              .unregister(new AllocationExpirationInfo(containerId));\n+        }\n+        // Completed containers should also include the OPPORTUNISTIC containers\n+        // so that the AM gets properly notified.\n         completedContainers.add(remoteContainer);\n-        // Unregister from containerAllocationExpirer.\n-        containerAllocationExpirer.unregister(\n-            new AllocationExpirationInfo(containerId));\n       }\n     }\n     if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n       nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n           completedContainers));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n    // Filter the map to only obtain just launched containers and finished\n    // containers.\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    for (ContainerStatus remoteContainer : containerStatuses) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n\n      // Don\u0027t bother with containers already scheduled for cleanup, or for\n      // applications already killed. The scheduler doens\u0027t need to know any\n      // more about this container\n      if (containersToClean.contains(containerId)) {\n        LOG.info(\"Container \" + containerId + \" already scheduled for \"\n            + \"cleanup, no further processing\");\n        continue;\n      }\n\n      ApplicationId containerAppId \u003d\n          containerId.getApplicationAttemptId().getApplicationId();\n\n      if (finishedApplications.contains(containerAppId)) {\n        LOG.info(\"Container \" + containerId\n            + \" belongs to an application that is already killed,\"\n            + \" no further processing\");\n        continue;\n      } else if (!runningApplications.contains(containerAppId)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Container \" + containerId\n              + \" is the first container get launched for application \"\n              + containerAppId);\n        }\n        runningApplications.add(containerAppId);\n      }\n\n      // Process running containers\n      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n        // Process only GUARANTEED containers in the RM.\n        if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n          if (!launchedContainers.contains(containerId)) {\n            // Just launched container. RM knows about it the first time.\n            launchedContainers.add(containerId);\n            newlyLaunchedContainers.add(remoteContainer);\n            // Unregister from containerAllocationExpirer.\n            containerAllocationExpirer\n                .unregister(new AllocationExpirationInfo(containerId));\n          }\n        }\n      } else {\n        if (remoteContainer.getExecutionType() \u003d\u003d ExecutionType.GUARANTEED) {\n          // A finished container\n          launchedContainers.remove(containerId);\n          // Unregister from containerAllocationExpirer.\n          containerAllocationExpirer\n              .unregister(new AllocationExpirationInfo(containerId));\n        }\n        // Completed containers should also include the OPPORTUNISTIC containers\n        // so that the AM gets properly notified.\n        completedContainers.add(remoteContainer);\n      }\n    }\n    if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n      nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n          completedContainers));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java",
      "extendedDetails": {}
    },
    "d16b17b4d299b4d58f879a2a15708bacd0938685": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4138. Roll back container resource allocation after resource increase token expires. Contributed by Meng Ding\n",
      "commitDate": "10/02/16 6:06 PM",
      "commitName": "d16b17b4d299b4d58f879a2a15708bacd0938685",
      "commitAuthor": "Jian He",
      "commitDateOld": "01/02/16 3:15 PM",
      "commitNameOld": "ed55950164a66e08fa34e30dba1030c5a986d1f1",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 9.12,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,60 @@\n   private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n     // Filter the map to only obtain just launched containers and finished\n     // containers.\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     for (ContainerStatus remoteContainer : containerStatuses) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n \n       // Don\u0027t bother with containers already scheduled for cleanup, or for\n       // applications already killed. The scheduler doens\u0027t need to know any\n       // more about this container\n       if (containersToClean.contains(containerId)) {\n         LOG.info(\"Container \" + containerId + \" already scheduled for \"\n             + \"cleanup, no further processing\");\n         continue;\n       }\n \n       ApplicationId containerAppId \u003d\n           containerId.getApplicationAttemptId().getApplicationId();\n \n       if (finishedApplications.contains(containerAppId)) {\n         LOG.info(\"Container \" + containerId\n             + \" belongs to an application that is already killed,\"\n             + \" no further processing\");\n         continue;\n       } else if (!runningApplications.contains(containerAppId)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Container \" + containerId\n               + \" is the first container get launched for application \"\n               + containerAppId);\n         }\n         runningApplications.add(containerAppId);\n       }\n \n       // Process running containers\n       if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n         if (!launchedContainers.contains(containerId)) {\n           // Just launched container. RM knows about it the first time.\n           launchedContainers.add(containerId);\n           newlyLaunchedContainers.add(remoteContainer);\n           // Unregister from containerAllocationExpirer.\n-          containerAllocationExpirer.unregister(containerId);\n+          containerAllocationExpirer.unregister(\n+              new AllocationExpirationInfo(containerId));\n         }\n       } else {\n         // A finished container\n         launchedContainers.remove(containerId);\n         completedContainers.add(remoteContainer);\n         // Unregister from containerAllocationExpirer.\n-        containerAllocationExpirer.unregister(containerId);\n+        containerAllocationExpirer.unregister(\n+            new AllocationExpirationInfo(containerId));\n       }\n     }\n     if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n       nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n           completedContainers));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n    // Filter the map to only obtain just launched containers and finished\n    // containers.\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    for (ContainerStatus remoteContainer : containerStatuses) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n\n      // Don\u0027t bother with containers already scheduled for cleanup, or for\n      // applications already killed. The scheduler doens\u0027t need to know any\n      // more about this container\n      if (containersToClean.contains(containerId)) {\n        LOG.info(\"Container \" + containerId + \" already scheduled for \"\n            + \"cleanup, no further processing\");\n        continue;\n      }\n\n      ApplicationId containerAppId \u003d\n          containerId.getApplicationAttemptId().getApplicationId();\n\n      if (finishedApplications.contains(containerAppId)) {\n        LOG.info(\"Container \" + containerId\n            + \" belongs to an application that is already killed,\"\n            + \" no further processing\");\n        continue;\n      } else if (!runningApplications.contains(containerAppId)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Container \" + containerId\n              + \" is the first container get launched for application \"\n              + containerAppId);\n        }\n        runningApplications.add(containerAppId);\n      }\n\n      // Process running containers\n      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n        if (!launchedContainers.contains(containerId)) {\n          // Just launched container. RM knows about it the first time.\n          launchedContainers.add(containerId);\n          newlyLaunchedContainers.add(remoteContainer);\n          // Unregister from containerAllocationExpirer.\n          containerAllocationExpirer.unregister(\n              new AllocationExpirationInfo(containerId));\n        }\n      } else {\n        // A finished container\n        launchedContainers.remove(containerId);\n        completedContainers.add(remoteContainer);\n        // Unregister from containerAllocationExpirer.\n        containerAllocationExpirer.unregister(\n            new AllocationExpirationInfo(containerId));\n      }\n    }\n    if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n      nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n          completedContainers));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java",
      "extendedDetails": {}
    },
    "ab80e277039a586f6d6259b2511ac413e29ea4f8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-433. When RM is catching up with node updates then it should not expire acquired containers. Contributed by Xuan Gong\n",
      "commitDate": "30/07/15 9:57 PM",
      "commitName": "ab80e277039a586f6d6259b2511ac413e29ea4f8",
      "commitAuthor": "Zhihai Xu",
      "commitDateOld": "13/07/15 1:52 AM",
      "commitNameOld": "19295b36d90e26616accee73b1f7743aab5df692",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 17.84,
      "commitsBetweenForRepo": 113,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,58 @@\n   private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n     // Filter the map to only obtain just launched containers and finished\n     // containers.\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     for (ContainerStatus remoteContainer : containerStatuses) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n \n       // Don\u0027t bother with containers already scheduled for cleanup, or for\n       // applications already killed. The scheduler doens\u0027t need to know any\n       // more about this container\n       if (containersToClean.contains(containerId)) {\n         LOG.info(\"Container \" + containerId + \" already scheduled for \"\n             + \"cleanup, no further processing\");\n         continue;\n       }\n \n       ApplicationId containerAppId \u003d\n           containerId.getApplicationAttemptId().getApplicationId();\n \n       if (finishedApplications.contains(containerAppId)) {\n         LOG.info(\"Container \" + containerId\n             + \" belongs to an application that is already killed,\"\n             + \" no further processing\");\n         continue;\n       } else if (!runningApplications.contains(containerAppId)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Container \" + containerId\n               + \" is the first container get launched for application \"\n               + containerAppId);\n         }\n         runningApplications.add(containerAppId);\n       }\n \n       // Process running containers\n       if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n         if (!launchedContainers.contains(containerId)) {\n           // Just launched container. RM knows about it the first time.\n           launchedContainers.add(containerId);\n           newlyLaunchedContainers.add(remoteContainer);\n+          // Unregister from containerAllocationExpirer.\n+          containerAllocationExpirer.unregister(containerId);\n         }\n       } else {\n         // A finished container\n         launchedContainers.remove(containerId);\n         completedContainers.add(remoteContainer);\n+        // Unregister from containerAllocationExpirer.\n+        containerAllocationExpirer.unregister(containerId);\n       }\n     }\n     if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n       nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n           completedContainers));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n    // Filter the map to only obtain just launched containers and finished\n    // containers.\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    for (ContainerStatus remoteContainer : containerStatuses) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n\n      // Don\u0027t bother with containers already scheduled for cleanup, or for\n      // applications already killed. The scheduler doens\u0027t need to know any\n      // more about this container\n      if (containersToClean.contains(containerId)) {\n        LOG.info(\"Container \" + containerId + \" already scheduled for \"\n            + \"cleanup, no further processing\");\n        continue;\n      }\n\n      ApplicationId containerAppId \u003d\n          containerId.getApplicationAttemptId().getApplicationId();\n\n      if (finishedApplications.contains(containerAppId)) {\n        LOG.info(\"Container \" + containerId\n            + \" belongs to an application that is already killed,\"\n            + \" no further processing\");\n        continue;\n      } else if (!runningApplications.contains(containerAppId)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Container \" + containerId\n              + \" is the first container get launched for application \"\n              + containerAppId);\n        }\n        runningApplications.add(containerAppId);\n      }\n\n      // Process running containers\n      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n        if (!launchedContainers.contains(containerId)) {\n          // Just launched container. RM knows about it the first time.\n          launchedContainers.add(containerId);\n          newlyLaunchedContainers.add(remoteContainer);\n          // Unregister from containerAllocationExpirer.\n          containerAllocationExpirer.unregister(containerId);\n        }\n      } else {\n        // A finished container\n        launchedContainers.remove(containerId);\n        completedContainers.add(remoteContainer);\n        // Unregister from containerAllocationExpirer.\n        containerAllocationExpirer.unregister(containerId);\n      }\n    }\n    if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n      nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n          completedContainers));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java",
      "extendedDetails": {}
    },
    "08244264c0583472b9c4e16591cfde72c6db62a2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3445. Cache runningApps in RMNode for getting running apps on given NodeId. (Junping Du via mingma)\n",
      "commitDate": "10/07/15 8:30 AM",
      "commitName": "08244264c0583472b9c4e16591cfde72c6db62a2",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "18/06/15 2:37 PM",
      "commitNameOld": "5b5bb8dcdc888ba1ebc7e4eba0fa0e7e79edda9a",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 21.74,
      "commitsBetweenForRepo": 145,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,54 @@\n   private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n     // Filter the map to only obtain just launched containers and finished\n     // containers.\n     List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     List\u003cContainerStatus\u003e completedContainers \u003d\n         new ArrayList\u003cContainerStatus\u003e();\n     for (ContainerStatus remoteContainer : containerStatuses) {\n       ContainerId containerId \u003d remoteContainer.getContainerId();\n \n       // Don\u0027t bother with containers already scheduled for cleanup, or for\n       // applications already killed. The scheduler doens\u0027t need to know any\n       // more about this container\n       if (containersToClean.contains(containerId)) {\n         LOG.info(\"Container \" + containerId + \" already scheduled for \"\n             + \"cleanup, no further processing\");\n         continue;\n       }\n-      if (finishedApplications.contains(containerId.getApplicationAttemptId()\n-          .getApplicationId())) {\n+\n+      ApplicationId containerAppId \u003d\n+          containerId.getApplicationAttemptId().getApplicationId();\n+\n+      if (finishedApplications.contains(containerAppId)) {\n         LOG.info(\"Container \" + containerId\n             + \" belongs to an application that is already killed,\"\n             + \" no further processing\");\n         continue;\n+      } else if (!runningApplications.contains(containerAppId)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Container \" + containerId\n+              + \" is the first container get launched for application \"\n+              + containerAppId);\n+        }\n+        runningApplications.add(containerAppId);\n       }\n \n       // Process running containers\n       if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n         if (!launchedContainers.contains(containerId)) {\n           // Just launched container. RM knows about it the first time.\n           launchedContainers.add(containerId);\n           newlyLaunchedContainers.add(remoteContainer);\n         }\n       } else {\n         // A finished container\n         launchedContainers.remove(containerId);\n         completedContainers.add(remoteContainer);\n       }\n     }\n     if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n       nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n           completedContainers));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n    // Filter the map to only obtain just launched containers and finished\n    // containers.\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    for (ContainerStatus remoteContainer : containerStatuses) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n\n      // Don\u0027t bother with containers already scheduled for cleanup, or for\n      // applications already killed. The scheduler doens\u0027t need to know any\n      // more about this container\n      if (containersToClean.contains(containerId)) {\n        LOG.info(\"Container \" + containerId + \" already scheduled for \"\n            + \"cleanup, no further processing\");\n        continue;\n      }\n\n      ApplicationId containerAppId \u003d\n          containerId.getApplicationAttemptId().getApplicationId();\n\n      if (finishedApplications.contains(containerAppId)) {\n        LOG.info(\"Container \" + containerId\n            + \" belongs to an application that is already killed,\"\n            + \" no further processing\");\n        continue;\n      } else if (!runningApplications.contains(containerAppId)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Container \" + containerId\n              + \" is the first container get launched for application \"\n              + containerAppId);\n        }\n        runningApplications.add(containerAppId);\n      }\n\n      // Process running containers\n      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n        if (!launchedContainers.contains(containerId)) {\n          // Just launched container. RM knows about it the first time.\n          launchedContainers.add(containerId);\n          newlyLaunchedContainers.add(remoteContainer);\n        }\n      } else {\n        // A finished container\n        launchedContainers.remove(containerId);\n        completedContainers.add(remoteContainer);\n      }\n    }\n    if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n      nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n          completedContainers));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java",
      "extendedDetails": {}
    },
    "a64dd3d24bfcb9af21eb63869924f6482b147fd3": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3194. RM should handle NMContainerStatuses sent by NM while registering if NM is Reconnected node. Contributed by Rohith\n",
      "commitDate": "20/02/15 7:10 AM",
      "commitName": "a64dd3d24bfcb9af21eb63869924f6482b147fd3",
      "commitAuthor": "Jason Lowe",
      "diff": "@@ -0,0 +1,44 @@\n+  private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n+    // Filter the map to only obtain just launched containers and finished\n+    // containers.\n+    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n+        new ArrayList\u003cContainerStatus\u003e();\n+    List\u003cContainerStatus\u003e completedContainers \u003d\n+        new ArrayList\u003cContainerStatus\u003e();\n+    for (ContainerStatus remoteContainer : containerStatuses) {\n+      ContainerId containerId \u003d remoteContainer.getContainerId();\n+\n+      // Don\u0027t bother with containers already scheduled for cleanup, or for\n+      // applications already killed. The scheduler doens\u0027t need to know any\n+      // more about this container\n+      if (containersToClean.contains(containerId)) {\n+        LOG.info(\"Container \" + containerId + \" already scheduled for \"\n+            + \"cleanup, no further processing\");\n+        continue;\n+      }\n+      if (finishedApplications.contains(containerId.getApplicationAttemptId()\n+          .getApplicationId())) {\n+        LOG.info(\"Container \" + containerId\n+            + \" belongs to an application that is already killed,\"\n+            + \" no further processing\");\n+        continue;\n+      }\n+\n+      // Process running containers\n+      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n+        if (!launchedContainers.contains(containerId)) {\n+          // Just launched container. RM knows about it the first time.\n+          launchedContainers.add(containerId);\n+          newlyLaunchedContainers.add(remoteContainer);\n+        }\n+      } else {\n+        // A finished container\n+        launchedContainers.remove(containerId);\n+        completedContainers.add(remoteContainer);\n+      }\n+    }\n+    if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n+      nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n+          completedContainers));\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleContainerStatus(List\u003cContainerStatus\u003e containerStatuses) {\n    // Filter the map to only obtain just launched containers and finished\n    // containers.\n    List\u003cContainerStatus\u003e newlyLaunchedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    List\u003cContainerStatus\u003e completedContainers \u003d\n        new ArrayList\u003cContainerStatus\u003e();\n    for (ContainerStatus remoteContainer : containerStatuses) {\n      ContainerId containerId \u003d remoteContainer.getContainerId();\n\n      // Don\u0027t bother with containers already scheduled for cleanup, or for\n      // applications already killed. The scheduler doens\u0027t need to know any\n      // more about this container\n      if (containersToClean.contains(containerId)) {\n        LOG.info(\"Container \" + containerId + \" already scheduled for \"\n            + \"cleanup, no further processing\");\n        continue;\n      }\n      if (finishedApplications.contains(containerId.getApplicationAttemptId()\n          .getApplicationId())) {\n        LOG.info(\"Container \" + containerId\n            + \" belongs to an application that is already killed,\"\n            + \" no further processing\");\n        continue;\n      }\n\n      // Process running containers\n      if (remoteContainer.getState() \u003d\u003d ContainerState.RUNNING) {\n        if (!launchedContainers.contains(containerId)) {\n          // Just launched container. RM knows about it the first time.\n          launchedContainers.add(containerId);\n          newlyLaunchedContainers.add(remoteContainer);\n        }\n      } else {\n        // A finished container\n        launchedContainers.remove(containerId);\n        completedContainers.add(remoteContainer);\n      }\n    }\n    if (newlyLaunchedContainers.size() !\u003d 0 || completedContainers.size() !\u003d 0) {\n      nodeUpdateQueue.add(new UpdatedContainerInfo(newlyLaunchedContainers,\n          completedContainers));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java"
    }
  }
}