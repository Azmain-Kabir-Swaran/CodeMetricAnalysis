{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AuditLogDirectParser.java",
  "functionName": "parse",
  "functionId": "parse___inputLine-Text__relativeToAbsolute-Function__Long,Long__",
  "sourceFilePath": "hadoop-tools/hadoop-dynamometer/hadoop-dynamometer-workload/src/main/java/org/apache/hadoop/tools/dynamometer/workloadgenerator/audit/AuditLogDirectParser.java",
  "functionStartLine": 115,
  "functionEndLine": 156,
  "numCommitsSeen": 4,
  "timeTaken": 1325,
  "changeHistory": [
    "c210cede5ce143a0c12646d82d657863f0ec96b6",
    "ae42c8cb61edcf69d0d6a9cf20ee9f936b0722fb",
    "ab0b180ddb5d0775a2452d5eeb7badd252aadb91"
  ],
  "changeHistoryShort": {
    "c210cede5ce143a0c12646d82d657863f0ec96b6": "Ybodychange",
    "ae42c8cb61edcf69d0d6a9cf20ee9f936b0722fb": "Ybodychange",
    "ab0b180ddb5d0775a2452d5eeb7badd252aadb91": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c210cede5ce143a0c12646d82d657863f0ec96b6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15044. [Dynamometer] Show the line of audit log when parsing it unsuccessfully. (#1749)\n\n",
      "commitDate": "12/12/19 7:48 AM",
      "commitName": "c210cede5ce143a0c12646d82d657863f0ec96b6",
      "commitAuthor": "Takanobu Asanuma",
      "commitDateOld": "06/09/19 10:13 AM",
      "commitNameOld": "ae42c8cb61edcf69d0d6a9cf20ee9f936b0722fb",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 96.94,
      "commitsBetweenForRepo": 535,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,42 @@\n   public AuditReplayCommand parse(Text inputLine,\n       Function\u003cLong, Long\u003e relativeToAbsolute) throws IOException {\n     Matcher m \u003d logLineParseRegex.matcher(inputLine.toString());\n     if (!m.find()) {\n       throw new IOException(\n           \"Unable to find valid message pattern from audit log line: `\"\n               + inputLine + \"` using regex `\" + logLineParseRegex + \"`\");\n     }\n     long relativeTimestamp;\n     try {\n       relativeTimestamp \u003d dateFormat.parse(m.group(\"timestamp\")).getTime()\n           - startTimestamp;\n     } catch (ParseException p) {\n-      throw new IOException(\"Exception while parsing timestamp from audit log\",\n-          p);\n+      throw new IOException(\n+          \"Exception while parsing timestamp from audit log line: `\"\n+          + inputLine + \"`\", p);\n     }\n     // Sanitize the \u003d in the rename options field into a : so we can split on \u003d\n     String auditMessageSanitized \u003d\n         m.group(\"message\").replace(\"(options\u003d\", \"(options:\");\n \n     Map\u003cString, String\u003e parameterMap \u003d new HashMap\u003cString, String\u003e();\n     String[] auditMessageSanitizedList \u003d auditMessageSanitized.split(\"\\t\");\n \n     for (String auditMessage : auditMessageSanitizedList) {\n       String[] splitMessage \u003d auditMessage.split(\"\u003d\", 2);\n       try {\n         parameterMap.put(splitMessage[0], splitMessage[1]);\n       } catch (ArrayIndexOutOfBoundsException e) {\n         throw new IOException(\n-            \"Exception while parsing a message from audit log\", e);\n+            \"Exception while parsing a message from audit log line: `\"\n+            + inputLine + \"`\", e);\n       }\n     }\n \n     return new AuditReplayCommand(relativeToAbsolute.apply(relativeTimestamp),\n         // Split the UGI on space to remove the auth and proxy portions of it\n         SPACE_SPLITTER.split(parameterMap.get(\"ugi\")).iterator().next(),\n         parameterMap.get(\"cmd\").replace(\"(options:\", \"(options\u003d\"),\n         parameterMap.get(\"src\"), parameterMap.get(\"dst\"),\n         parameterMap.get(\"ip\"));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AuditReplayCommand parse(Text inputLine,\n      Function\u003cLong, Long\u003e relativeToAbsolute) throws IOException {\n    Matcher m \u003d logLineParseRegex.matcher(inputLine.toString());\n    if (!m.find()) {\n      throw new IOException(\n          \"Unable to find valid message pattern from audit log line: `\"\n              + inputLine + \"` using regex `\" + logLineParseRegex + \"`\");\n    }\n    long relativeTimestamp;\n    try {\n      relativeTimestamp \u003d dateFormat.parse(m.group(\"timestamp\")).getTime()\n          - startTimestamp;\n    } catch (ParseException p) {\n      throw new IOException(\n          \"Exception while parsing timestamp from audit log line: `\"\n          + inputLine + \"`\", p);\n    }\n    // Sanitize the \u003d in the rename options field into a : so we can split on \u003d\n    String auditMessageSanitized \u003d\n        m.group(\"message\").replace(\"(options\u003d\", \"(options:\");\n\n    Map\u003cString, String\u003e parameterMap \u003d new HashMap\u003cString, String\u003e();\n    String[] auditMessageSanitizedList \u003d auditMessageSanitized.split(\"\\t\");\n\n    for (String auditMessage : auditMessageSanitizedList) {\n      String[] splitMessage \u003d auditMessage.split(\"\u003d\", 2);\n      try {\n        parameterMap.put(splitMessage[0], splitMessage[1]);\n      } catch (ArrayIndexOutOfBoundsException e) {\n        throw new IOException(\n            \"Exception while parsing a message from audit log line: `\"\n            + inputLine + \"`\", e);\n      }\n    }\n\n    return new AuditReplayCommand(relativeToAbsolute.apply(relativeTimestamp),\n        // Split the UGI on space to remove the auth and proxy portions of it\n        SPACE_SPLITTER.split(parameterMap.get(\"ugi\")).iterator().next(),\n        parameterMap.get(\"cmd\").replace(\"(options:\", \"(options\u003d\"),\n        parameterMap.get(\"src\"), parameterMap.get(\"dst\"),\n        parameterMap.get(\"ip\"));\n  }",
      "path": "hadoop-tools/hadoop-dynamometer/hadoop-dynamometer-workload/src/main/java/org/apache/hadoop/tools/dynamometer/workloadgenerator/audit/AuditLogDirectParser.java",
      "extendedDetails": {}
    },
    "ae42c8cb61edcf69d0d6a9cf20ee9f936b0722fb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4819. [Dynamometer] Fix parsing of audit logs which contain \u003d in path names. Contributed by Soya Miyoshi.\n",
      "commitDate": "06/09/19 10:13 AM",
      "commitName": "ae42c8cb61edcf69d0d6a9cf20ee9f936b0722fb",
      "commitAuthor": "Erik Krogen",
      "commitDateOld": "08/07/19 5:44 PM",
      "commitNameOld": "738c09349eb6178065797fc9cd624bf5e2285069",
      "commitAuthorOld": "Masatake Iwasaki",
      "daysBetweenCommits": 59.69,
      "commitsBetweenForRepo": 542,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,40 @@\n   public AuditReplayCommand parse(Text inputLine,\n       Function\u003cLong, Long\u003e relativeToAbsolute) throws IOException {\n     Matcher m \u003d logLineParseRegex.matcher(inputLine.toString());\n     if (!m.find()) {\n       throw new IOException(\n           \"Unable to find valid message pattern from audit log line: `\"\n               + inputLine + \"` using regex `\" + logLineParseRegex + \"`\");\n     }\n     long relativeTimestamp;\n     try {\n       relativeTimestamp \u003d dateFormat.parse(m.group(\"timestamp\")).getTime()\n           - startTimestamp;\n     } catch (ParseException p) {\n       throw new IOException(\"Exception while parsing timestamp from audit log\",\n           p);\n     }\n     // Sanitize the \u003d in the rename options field into a : so we can split on \u003d\n     String auditMessageSanitized \u003d\n         m.group(\"message\").replace(\"(options\u003d\", \"(options:\");\n-    Map\u003cString, String\u003e parameterMap \u003d AUDIT_SPLITTER\n-        .split(auditMessageSanitized);\n+\n+    Map\u003cString, String\u003e parameterMap \u003d new HashMap\u003cString, String\u003e();\n+    String[] auditMessageSanitizedList \u003d auditMessageSanitized.split(\"\\t\");\n+\n+    for (String auditMessage : auditMessageSanitizedList) {\n+      String[] splitMessage \u003d auditMessage.split(\"\u003d\", 2);\n+      try {\n+        parameterMap.put(splitMessage[0], splitMessage[1]);\n+      } catch (ArrayIndexOutOfBoundsException e) {\n+        throw new IOException(\n+            \"Exception while parsing a message from audit log\", e);\n+      }\n+    }\n+\n     return new AuditReplayCommand(relativeToAbsolute.apply(relativeTimestamp),\n         // Split the UGI on space to remove the auth and proxy portions of it\n         SPACE_SPLITTER.split(parameterMap.get(\"ugi\")).iterator().next(),\n         parameterMap.get(\"cmd\").replace(\"(options:\", \"(options\u003d\"),\n         parameterMap.get(\"src\"), parameterMap.get(\"dst\"),\n         parameterMap.get(\"ip\"));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AuditReplayCommand parse(Text inputLine,\n      Function\u003cLong, Long\u003e relativeToAbsolute) throws IOException {\n    Matcher m \u003d logLineParseRegex.matcher(inputLine.toString());\n    if (!m.find()) {\n      throw new IOException(\n          \"Unable to find valid message pattern from audit log line: `\"\n              + inputLine + \"` using regex `\" + logLineParseRegex + \"`\");\n    }\n    long relativeTimestamp;\n    try {\n      relativeTimestamp \u003d dateFormat.parse(m.group(\"timestamp\")).getTime()\n          - startTimestamp;\n    } catch (ParseException p) {\n      throw new IOException(\"Exception while parsing timestamp from audit log\",\n          p);\n    }\n    // Sanitize the \u003d in the rename options field into a : so we can split on \u003d\n    String auditMessageSanitized \u003d\n        m.group(\"message\").replace(\"(options\u003d\", \"(options:\");\n\n    Map\u003cString, String\u003e parameterMap \u003d new HashMap\u003cString, String\u003e();\n    String[] auditMessageSanitizedList \u003d auditMessageSanitized.split(\"\\t\");\n\n    for (String auditMessage : auditMessageSanitizedList) {\n      String[] splitMessage \u003d auditMessage.split(\"\u003d\", 2);\n      try {\n        parameterMap.put(splitMessage[0], splitMessage[1]);\n      } catch (ArrayIndexOutOfBoundsException e) {\n        throw new IOException(\n            \"Exception while parsing a message from audit log\", e);\n      }\n    }\n\n    return new AuditReplayCommand(relativeToAbsolute.apply(relativeTimestamp),\n        // Split the UGI on space to remove the auth and proxy portions of it\n        SPACE_SPLITTER.split(parameterMap.get(\"ugi\")).iterator().next(),\n        parameterMap.get(\"cmd\").replace(\"(options:\", \"(options\u003d\"),\n        parameterMap.get(\"src\"), parameterMap.get(\"dst\"),\n        parameterMap.get(\"ip\"));\n  }",
      "path": "hadoop-tools/hadoop-dynamometer/hadoop-dynamometer-workload/src/main/java/org/apache/hadoop/tools/dynamometer/workloadgenerator/audit/AuditLogDirectParser.java",
      "extendedDetails": {}
    },
    "ab0b180ddb5d0775a2452d5eeb7badd252aadb91": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-12345 Add Dynamometer to hadoop-tools, a tool for scale testing the HDFS NameNode with real metadata and workloads. Contributed by Erik Krogen.\n",
      "commitDate": "25/06/19 8:07 AM",
      "commitName": "ab0b180ddb5d0775a2452d5eeb7badd252aadb91",
      "commitAuthor": "Erik Krogen",
      "diff": "@@ -0,0 +1,28 @@\n+  public AuditReplayCommand parse(Text inputLine,\n+      Function\u003cLong, Long\u003e relativeToAbsolute) throws IOException {\n+    Matcher m \u003d logLineParseRegex.matcher(inputLine.toString());\n+    if (!m.find()) {\n+      throw new IOException(\n+          \"Unable to find valid message pattern from audit log line: `\"\n+              + inputLine + \"` using regex `\" + logLineParseRegex + \"`\");\n+    }\n+    long relativeTimestamp;\n+    try {\n+      relativeTimestamp \u003d dateFormat.parse(m.group(\"timestamp\")).getTime()\n+          - startTimestamp;\n+    } catch (ParseException p) {\n+      throw new IOException(\"Exception while parsing timestamp from audit log\",\n+          p);\n+    }\n+    // Sanitize the \u003d in the rename options field into a : so we can split on \u003d\n+    String auditMessageSanitized \u003d\n+        m.group(\"message\").replace(\"(options\u003d\", \"(options:\");\n+    Map\u003cString, String\u003e parameterMap \u003d AUDIT_SPLITTER\n+        .split(auditMessageSanitized);\n+    return new AuditReplayCommand(relativeToAbsolute.apply(relativeTimestamp),\n+        // Split the UGI on space to remove the auth and proxy portions of it\n+        SPACE_SPLITTER.split(parameterMap.get(\"ugi\")).iterator().next(),\n+        parameterMap.get(\"cmd\").replace(\"(options:\", \"(options\u003d\"),\n+        parameterMap.get(\"src\"), parameterMap.get(\"dst\"),\n+        parameterMap.get(\"ip\"));\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public AuditReplayCommand parse(Text inputLine,\n      Function\u003cLong, Long\u003e relativeToAbsolute) throws IOException {\n    Matcher m \u003d logLineParseRegex.matcher(inputLine.toString());\n    if (!m.find()) {\n      throw new IOException(\n          \"Unable to find valid message pattern from audit log line: `\"\n              + inputLine + \"` using regex `\" + logLineParseRegex + \"`\");\n    }\n    long relativeTimestamp;\n    try {\n      relativeTimestamp \u003d dateFormat.parse(m.group(\"timestamp\")).getTime()\n          - startTimestamp;\n    } catch (ParseException p) {\n      throw new IOException(\"Exception while parsing timestamp from audit log\",\n          p);\n    }\n    // Sanitize the \u003d in the rename options field into a : so we can split on \u003d\n    String auditMessageSanitized \u003d\n        m.group(\"message\").replace(\"(options\u003d\", \"(options:\");\n    Map\u003cString, String\u003e parameterMap \u003d AUDIT_SPLITTER\n        .split(auditMessageSanitized);\n    return new AuditReplayCommand(relativeToAbsolute.apply(relativeTimestamp),\n        // Split the UGI on space to remove the auth and proxy portions of it\n        SPACE_SPLITTER.split(parameterMap.get(\"ugi\")).iterator().next(),\n        parameterMap.get(\"cmd\").replace(\"(options:\", \"(options\u003d\"),\n        parameterMap.get(\"src\"), parameterMap.get(\"dst\"),\n        parameterMap.get(\"ip\"));\n  }",
      "path": "hadoop-tools/hadoop-dynamometer/hadoop-dynamometer-workload/src/main/java/org/apache/hadoop/tools/dynamometer/workloadgenerator/audit/AuditLogDirectParser.java"
    }
  }
}