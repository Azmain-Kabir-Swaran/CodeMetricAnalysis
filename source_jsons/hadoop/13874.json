{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockManager.java",
  "functionName": "processMisReplicatedBlock",
  "functionId": "processMisReplicatedBlock___block-BlockInfo",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
  "functionStartLine": 3794,
  "functionEndLine": 3834,
  "numCommitsSeen": 868,
  "timeTaken": 20731,
  "changeHistory": [
    "b61fb267b92b2736920b4bd0c673d31e7632ebb9",
    "8c84a2a93c22a93b4ff46dd917f6efb995675fbd",
    "32d043d9c5f4615058ea4f65a58ba271ba47fcb5",
    "f2ba7da4f0df6cf0fc245093aeb4500158e6ee0b",
    "47b92f2b6f2dafc129a41b247f35e77c8e47ffba",
    "5411dc559d5f73e4153e76fdff94a26869c17a37",
    "745d04be59accf80feda0ad38efcc74ba362f2ca",
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "b008348dbf9bdd5070930be5d182116c5d370f6b",
    "ba9371492036983a9899398907ab41fe548f29b3",
    "6d5da9484185ca9f585195d6da069b9cd5be4044",
    "997408eaaceef20b053ee7344468e28cb9a1379b",
    "f8f5887209a7d8e53c0a77abef275cbcaf1f7a5b",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
    "ad06a087131d69d173d8e03dce5c97650a530f2e",
    "7e8e983620f3ae3462d115972707c72b7d9cbabd",
    "f0f9a3631fe4950f5cf548f192226836925d0f05"
  ],
  "changeHistoryShort": {
    "b61fb267b92b2736920b4bd0c673d31e7632ebb9": "Ybodychange",
    "8c84a2a93c22a93b4ff46dd917f6efb995675fbd": "Ybodychange",
    "32d043d9c5f4615058ea4f65a58ba271ba47fcb5": "Ybodychange",
    "f2ba7da4f0df6cf0fc245093aeb4500158e6ee0b": "Ybodychange",
    "47b92f2b6f2dafc129a41b247f35e77c8e47ffba": "Ybodychange",
    "5411dc559d5f73e4153e76fdff94a26869c17a37": "Ybodychange",
    "745d04be59accf80feda0ad38efcc74ba362f2ca": "Ybodychange",
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046": "Ybodychange",
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5": "Ybodychange",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Yparameterchange",
    "b008348dbf9bdd5070930be5d182116c5d370f6b": "Ybodychange",
    "ba9371492036983a9899398907ab41fe548f29b3": "Yparameterchange",
    "6d5da9484185ca9f585195d6da069b9cd5be4044": "Ybodychange",
    "997408eaaceef20b053ee7344468e28cb9a1379b": "Ybodychange",
    "f8f5887209a7d8e53c0a77abef275cbcaf1f7a5b": "Ybodychange",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": "Yparameterchange",
    "ad06a087131d69d173d8e03dce5c97650a530f2e": "Ybodychange",
    "7e8e983620f3ae3462d115972707c72b7d9cbabd": "Ybodychange",
    "f0f9a3631fe4950f5cf548f192226836925d0f05": "Ybodychange"
  },
  "changeHistoryDetails": {
    "b61fb267b92b2736920b4bd0c673d31e7632ebb9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9390. Block management for maintenance states.\n",
      "commitDate": "17/10/16 5:45 PM",
      "commitName": "b61fb267b92b2736920b4bd0c673d31e7632ebb9",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "14/10/16 6:13 PM",
      "commitNameOld": "391ce535a739dc92cb90017d759217265a4fd969",
      "commitAuthorOld": "Vinitha Reddy Gankidi",
      "daysBetweenCommits": 2.98,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n     if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current redundancy\n     short expectedRedundancy \u003d getExpectedRedundancyNum(block);\n     NumberReplicas num \u003d countNodes(block);\n     final int numCurrentReplica \u003d num.liveReplicas();\n     // add to low redundancy queue if need to be\n-    if (isNeededReconstruction(block, numCurrentReplica)) {\n+    if (isNeededReconstruction(block, num)) {\n       if (neededReconstruction.add(block, numCurrentReplica,\n-          num.readOnlyReplicas(), num.decommissionedAndDecommissioning(),\n+          num.readOnlyReplicas(), num.outOfServiceReplicas(),\n           expectedRedundancy)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (shouldProcessExtraRedundancy(num, expectedRedundancy)) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // extra redundancy block\n       processExtraRedundancyBlock(block, expectedRedundancy, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current redundancy\n    short expectedRedundancy \u003d getExpectedRedundancyNum(block);\n    NumberReplicas num \u003d countNodes(block);\n    final int numCurrentReplica \u003d num.liveReplicas();\n    // add to low redundancy queue if need to be\n    if (isNeededReconstruction(block, num)) {\n      if (neededReconstruction.add(block, numCurrentReplica,\n          num.readOnlyReplicas(), num.outOfServiceReplicas(),\n          expectedRedundancy)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (shouldProcessExtraRedundancy(num, expectedRedundancy)) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // extra redundancy block\n      processExtraRedundancyBlock(block, expectedRedundancy, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "8c84a2a93c22a93b4ff46dd917f6efb995675fbd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10236. Erasure Coding: Rename replication-based names in BlockManager to more generic [part-3]. Contributed by Rakesh R.\n",
      "commitDate": "26/05/16 4:50 PM",
      "commitName": "8c84a2a93c22a93b4ff46dd917f6efb995675fbd",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "28/04/16 10:44 AM",
      "commitNameOld": "6243eabb48390fffada2418ade5adf9e0766afbe",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 28.25,
      "commitsBetweenForRepo": 196,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n     if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n-    // calculate current replication\n-    short expectedReplication \u003d getExpectedReplicaNum(block);\n+    // calculate current redundancy\n+    short expectedRedundancy \u003d getExpectedRedundancyNum(block);\n     NumberReplicas num \u003d countNodes(block);\n     final int numCurrentReplica \u003d num.liveReplicas();\n     // add to low redundancy queue if need to be\n     if (isNeededReconstruction(block, numCurrentReplica)) {\n       if (neededReconstruction.add(block, numCurrentReplica,\n           num.readOnlyReplicas(), num.decommissionedAndDecommissioning(),\n-          expectedReplication)) {\n+          expectedRedundancy)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n-    if (shouldProcessExtraRedundancy(num, expectedReplication)) {\n+    if (shouldProcessExtraRedundancy(num, expectedRedundancy)) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // extra redundancy block\n-      processExtraRedundancyBlock(block, expectedReplication, null, null);\n+      processExtraRedundancyBlock(block, expectedRedundancy, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current redundancy\n    short expectedRedundancy \u003d getExpectedRedundancyNum(block);\n    NumberReplicas num \u003d countNodes(block);\n    final int numCurrentReplica \u003d num.liveReplicas();\n    // add to low redundancy queue if need to be\n    if (isNeededReconstruction(block, numCurrentReplica)) {\n      if (neededReconstruction.add(block, numCurrentReplica,\n          num.readOnlyReplicas(), num.decommissionedAndDecommissioning(),\n          expectedRedundancy)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (shouldProcessExtraRedundancy(num, expectedRedundancy)) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // extra redundancy block\n      processExtraRedundancyBlock(block, expectedRedundancy, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "32d043d9c5f4615058ea4f65a58ba271ba47fcb5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9857. Erasure Coding: Rename replication-based names in BlockManager to more generic [part-1]. Contributed by Rakesh R.\n",
      "commitDate": "16/03/16 4:53 PM",
      "commitName": "32d043d9c5f4615058ea4f65a58ba271ba47fcb5",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "10/03/16 7:03 PM",
      "commitNameOld": "e01c6ea688e62f25c4310e771a0cd85b53a5fb87",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 5.87,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,41 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n     if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n     short expectedReplication \u003d getExpectedReplicaNum(block);\n     NumberReplicas num \u003d countNodes(block);\n     final int numCurrentReplica \u003d num.liveReplicas();\n-    // add to under-replicated queue if need to be\n-    if (isNeededReplication(block, numCurrentReplica)) {\n-      if (neededReplications.add(block, numCurrentReplica, num.readOnlyReplicas(),\n-          num.decommissionedAndDecommissioning(), expectedReplication)) {\n+    // add to low redundancy queue if need to be\n+    if (isNeededReconstruction(block, numCurrentReplica)) {\n+      if (neededReconstruction.add(block, numCurrentReplica,\n+          num.readOnlyReplicas(), num.decommissionedAndDecommissioning(),\n+          expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n-    if (shouldProcessOverReplicated(num, expectedReplication)) {\n+    if (shouldProcessExtraRedundancy(num, expectedReplication)) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n-      // over-replicated block\n-      processOverReplicatedBlock(block, expectedReplication, null, null);\n+      // extra redundancy block\n+      processExtraRedundancyBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d getExpectedReplicaNum(block);\n    NumberReplicas num \u003d countNodes(block);\n    final int numCurrentReplica \u003d num.liveReplicas();\n    // add to low redundancy queue if need to be\n    if (isNeededReconstruction(block, numCurrentReplica)) {\n      if (neededReconstruction.add(block, numCurrentReplica,\n          num.readOnlyReplicas(), num.decommissionedAndDecommissioning(),\n          expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (shouldProcessExtraRedundancy(num, expectedReplication)) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // extra redundancy block\n      processExtraRedundancyBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "f2ba7da4f0df6cf0fc245093aeb4500158e6ee0b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9876. shouldProcessOverReplicated should not count number of pending replicas. Contributed by Jing Zhao.\n",
      "commitDate": "01/03/16 6:41 PM",
      "commitName": "f2ba7da4f0df6cf0fc245093aeb4500158e6ee0b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "28/02/16 2:54 PM",
      "commitNameOld": "408f2c807bbaaaa37ce1b69a5dfa9d76ed427d6e",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.16,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n     if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n     short expectedReplication \u003d getExpectedReplicaNum(block);\n     NumberReplicas num \u003d countNodes(block);\n     final int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num.readOnlyReplicas(),\n           num.decommissionedAndDecommissioning(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n-    if (shouldProcessOverReplicated(num, 0, expectedReplication)) {\n+    if (shouldProcessOverReplicated(num, expectedReplication)) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d getExpectedReplicaNum(block);\n    NumberReplicas num \u003d countNodes(block);\n    final int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num.readOnlyReplicas(),\n          num.decommissionedAndDecommissioning(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (shouldProcessOverReplicated(num, expectedReplication)) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "47b92f2b6f2dafc129a41b247f35e77c8e47ffba": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9837. BlockManager#countNodes should be able to detect duplicated internal blocks. Contributed by Jing Zhao.\n",
      "commitDate": "24/02/16 3:13 PM",
      "commitName": "47b92f2b6f2dafc129a41b247f35e77c8e47ffba",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "20/02/16 11:19 PM",
      "commitNameOld": "d5abd293a890a8a1da48a166a291ae1c5644ad57",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 3.66,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n     if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n     short expectedReplication \u003d getExpectedReplicaNum(block);\n     NumberReplicas num \u003d countNodes(block);\n-    int numCurrentReplica \u003d num.liveReplicas();\n+    final int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num.readOnlyReplicas(),\n           num.decommissionedAndDecommissioning(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n-    if (numCurrentReplica \u003e expectedReplication) {\n+    if (shouldProcessOverReplicated(num, 0, expectedReplication)) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d getExpectedReplicaNum(block);\n    NumberReplicas num \u003d countNodes(block);\n    final int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num.readOnlyReplicas(),\n          num.decommissionedAndDecommissioning(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (shouldProcessOverReplicated(num, 0, expectedReplication)) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "5411dc559d5f73e4153e76fdff94a26869c17a37": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9205. Do not schedule corrupt blocks for replication.  (szetszwo)\n",
      "commitDate": "15/10/15 3:07 AM",
      "commitName": "5411dc559d5f73e4153e76fdff94a26869c17a37",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "14/10/15 4:17 PM",
      "commitNameOld": "be7a0add8b6561d3c566237cc0370b06e7f32bb4",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n     if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n     short expectedReplication \u003d getExpectedReplicaNum(block);\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, numCurrentReplica)) {\n-      if (neededReplications.add(block, numCurrentReplica, num\n-          .decommissionedAndDecommissioning(), expectedReplication)) {\n+      if (neededReplications.add(block, numCurrentReplica, num.readOnlyReplicas(),\n+          num.decommissionedAndDecommissioning(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d getExpectedReplicaNum(block);\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num.readOnlyReplicas(),\n          num.decommissionedAndDecommissioning(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "745d04be59accf80feda0ad38efcc74ba362f2ca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8823. Move replication factor into individual blocks. Contributed by Haohui Mai.\n",
      "commitDate": "22/08/15 12:09 AM",
      "commitName": "745d04be59accf80feda0ad38efcc74ba362f2ca",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "19/08/15 3:11 PM",
      "commitNameOld": "4e14f7982a6e57bf08deb3b266806c2b779a157d",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.37,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,40 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n     if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n-    short expectedReplication \u003d\n-        block.getBlockCollection().getPreferredBlockReplication();\n+    short expectedReplication \u003d getExpectedReplicaNum(block);\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n-    if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n+    if (isNeededReplication(block, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num\n           .decommissionedAndDecommissioning(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d getExpectedReplicaNum(block);\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num\n          .decommissionedAndDecommissioning(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8623. Refactor NameNode handling of invalid, corrupt, and under-recovery blocks. Contributed by Zhe Zhang.\"\n\nThis reverts commit de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5.\n",
      "commitDate": "06/08/15 10:21 AM",
      "commitName": "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "31/07/15 4:15 PM",
      "commitNameOld": "d311a38a6b32bbb210bd8748cfb65463e9c0740e",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 5.75,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n     if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n     short expectedReplication \u003d\n-        getExpectedReplicaNum(block.getBlockCollection(), block);\n+        block.getBlockCollection().getPreferredBlockReplication();\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num\n           .decommissionedAndDecommissioning(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d\n        block.getBlockCollection().getPreferredBlockReplication();\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num\n          .decommissionedAndDecommissioning(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8623. Refactor NameNode handling of invalid, corrupt, and under-recovery blocks. Contributed by Zhe Zhang.\n",
      "commitDate": "26/06/15 10:49 AM",
      "commitName": "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "24/06/15 2:42 PM",
      "commitNameOld": "afe9ea3c12e1f5a71922400eadb642960bc87ca1",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n     if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n     short expectedReplication \u003d\n-        block.getBlockCollection().getPreferredBlockReplication();\n+        getExpectedReplicaNum(block.getBlockCollection(), block);\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num\n           .decommissionedAndDecommissioning(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d\n        getExpectedReplicaNum(block.getBlockCollection(), block);\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num\n          .decommissionedAndDecommissioning(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Yparameterchange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "19/05/15 11:05 AM",
      "commitNameOld": "8860e352c394372e4eb3ebdf82ea899567f34e4e",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 8.19,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n-  private MisReplicationResult processMisReplicatedBlock(BlockInfoContiguous block) {\n+  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n     if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n     short expectedReplication \u003d\n         block.getBlockCollection().getPreferredBlockReplication();\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num\n           .decommissionedAndDecommissioning(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d\n        block.getBlockCollection().getPreferredBlockReplication();\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num\n          .decommissionedAndDecommissioning(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {
        "oldValue": "[block-BlockInfoContiguous]",
        "newValue": "[block-BlockInfo]"
      }
    },
    "b008348dbf9bdd5070930be5d182116c5d370f6b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8418. Fix the isNeededReplication calculation for Striped block in NN. Contributed by Yi Liu.\n",
      "commitDate": "26/05/15 12:02 PM",
      "commitName": "b008348dbf9bdd5070930be5d182116c5d370f6b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 12:02 PM",
      "commitNameOld": "d8ea443af0b1c8289a1dd738945831ff8be0e9c1",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n     if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n     short expectedReplication \u003d\n-        block.getBlockCollection().getPreferredBlockReplication();\n+        getExpectedReplicaNum(block.getBlockCollection(), block);\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num\n           .decommissionedAndDecommissioning(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d\n        getExpectedReplicaNum(block.getBlockCollection(), block);\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num\n          .decommissionedAndDecommissioning(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "ba9371492036983a9899398907ab41fe548f29b3": {
      "type": "Yparameterchange",
      "commitMessage": "HDFS-7716. Erasure Coding: extend BlockInfo to handle EC info. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:07 AM",
      "commitName": "ba9371492036983a9899398907ab41fe548f29b3",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:03 AM",
      "commitNameOld": "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n-  private MisReplicationResult processMisReplicatedBlock(BlockInfoContiguous block) {\n+  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n     if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n     short expectedReplication \u003d\n         block.getBlockCollection().getPreferredBlockReplication();\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num\n           .decommissionedAndDecommissioning(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d\n        block.getBlockCollection().getPreferredBlockReplication();\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num\n          .decommissionedAndDecommissioning(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {
        "oldValue": "[block-BlockInfoContiguous]",
        "newValue": "[block-BlockInfo]"
      }
    },
    "6d5da9484185ca9f585195d6da069b9cd5be4044": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8255. Rename getBlockReplication to getPreferredBlockReplication. (Contributed by Zhe Zhang)\n",
      "commitDate": "12/05/15 6:29 AM",
      "commitName": "6d5da9484185ca9f585195d6da069b9cd5be4044",
      "commitAuthor": "yliu",
      "commitDateOld": "08/05/15 2:36 PM",
      "commitNameOld": "2d4ae3d18bc530fa9f81ee616db8af3395705fb9",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 3.66,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfoContiguous block) {\n     if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n     short expectedReplication \u003d\n-        block.getBlockCollection().getBlockReplication();\n+        block.getBlockCollection().getPreferredBlockReplication();\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num\n           .decommissionedAndDecommissioning(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfoContiguous block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d\n        block.getBlockCollection().getPreferredBlockReplication();\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num\n          .decommissionedAndDecommissioning(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "997408eaaceef20b053ee7344468e28cb9a1379b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8133. Improve readability of deleted block check (Daryn Sharp via Colin P. McCabe)\n",
      "commitDate": "21/04/15 11:43 AM",
      "commitName": "997408eaaceef20b053ee7344468e28cb9a1379b",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "20/04/15 12:36 AM",
      "commitNameOld": "5c97db07fb306842f49d73a67a90cecec19a7833",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.46,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfoContiguous block) {\n-    BlockCollection bc \u003d block.getBlockCollection();\n-    if (bc \u003d\u003d null) {\n+    if (block.isDeleted()) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n-    short expectedReplication \u003d bc.getBlockReplication();\n+    short expectedReplication \u003d\n+        block.getBlockCollection().getBlockReplication();\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num\n           .decommissionedAndDecommissioning(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfoContiguous block) {\n    if (block.isDeleted()) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d\n        block.getBlockCollection().getBlockReplication();\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num\n          .decommissionedAndDecommissioning(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "f8f5887209a7d8e53c0a77abef275cbcaf1f7a5b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7933. fsck should also report decommissioning replicas. Contributed by Xiaoyu Yao.\n",
      "commitDate": "11/04/15 1:23 PM",
      "commitName": "f8f5887209a7d8e53c0a77abef275cbcaf1f7a5b",
      "commitAuthor": "cnauroth",
      "commitDateOld": "10/04/15 4:36 PM",
      "commitNameOld": "36e4cd3be6f7fec8db82d3d1bcb258af470ece2e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfoContiguous block) {\n     BlockCollection bc \u003d block.getBlockCollection();\n     if (bc \u003d\u003d null) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n     short expectedReplication \u003d bc.getBlockReplication();\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num\n-          .decommissionedReplicas(), expectedReplication)) {\n+          .decommissionedAndDecommissioning(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfoContiguous block) {\n    BlockCollection bc \u003d block.getBlockCollection();\n    if (bc \u003d\u003d null) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d bc.getBlockReplication();\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num\n          .decommissionedAndDecommissioning(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": {
      "type": "Yparameterchange",
      "commitMessage": "HDFS-7743. Code cleanup of BlockInfo and rename BlockInfo to BlockInfoContiguous. Contributed by Jing Zhao.\n",
      "commitDate": "08/02/15 11:51 AM",
      "commitName": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "04/02/15 11:31 AM",
      "commitNameOld": "9175105eeaecf0a1d60b57989b73ce45cee4689b",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.01,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n-  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n+  private MisReplicationResult processMisReplicatedBlock(BlockInfoContiguous block) {\n     BlockCollection bc \u003d block.getBlockCollection();\n     if (bc \u003d\u003d null) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n     short expectedReplication \u003d bc.getBlockReplication();\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num\n           .decommissionedReplicas(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfoContiguous block) {\n    BlockCollection bc \u003d block.getBlockCollection();\n    if (bc \u003d\u003d null) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d bc.getBlockReplication();\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num\n          .decommissionedReplicas(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {
        "oldValue": "[block-BlockInfo]",
        "newValue": "[block-BlockInfoContiguous]"
      }
    },
    "ad06a087131d69d173d8e03dce5c97650a530f2e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4037. Rename the getReplication() method in BlockCollection to getBlockReplication(). \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1398288 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/10/12 6:48 AM",
      "commitName": "ad06a087131d69d173d8e03dce5c97650a530f2e",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "11/09/12 9:10 PM",
      "commitNameOld": "414abe69183a39b38c8f8936785dce3e4774f4ca",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 33.4,
      "commitsBetweenForRepo": 170,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n     BlockCollection bc \u003d block.getBlockCollection();\n     if (bc \u003d\u003d null) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n-    short expectedReplication \u003d bc.getReplication();\n+    short expectedReplication \u003d bc.getBlockReplication();\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num\n           .decommissionedReplicas(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    BlockCollection bc \u003d block.getBlockCollection();\n    if (bc \u003d\u003d null) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d bc.getBlockReplication();\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num\n          .decommissionedReplicas(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "7e8e983620f3ae3462d115972707c72b7d9cbabd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3369. Rename {get|set|add}INode(..) methods in BlockManager and BlocksMap to {get|set|add}BlockCollection(..).  Contributed by John George\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1336909 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/05/12 2:41 PM",
      "commitName": "7e8e983620f3ae3462d115972707c72b7d9cbabd",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "10/05/12 2:59 AM",
      "commitNameOld": "f1ff05bf47a7dfb670bc63e4e6e58d74f6b5b4a7",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.49,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n-    BlockCollection fileINode \u003d block.getINode();\n-    if (fileINode \u003d\u003d null) {\n+    BlockCollection bc \u003d block.getBlockCollection();\n+    if (bc \u003d\u003d null) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n-    short expectedReplication \u003d fileINode.getReplication();\n+    short expectedReplication \u003d bc.getReplication();\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num\n           .decommissionedReplicas(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    BlockCollection bc \u003d block.getBlockCollection();\n    if (bc \u003d\u003d null) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d bc.getReplication();\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num\n          .decommissionedReplicas(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "f0f9a3631fe4950f5cf548f192226836925d0f05": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3363. Define BlockCollection and MutableBlockCollection interfaces so that INodeFile and INodeFileUnderConstruction do not have to be used in block management.  Contributed by John George\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1335304 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/05/12 5:06 PM",
      "commitName": "f0f9a3631fe4950f5cf548f192226836925d0f05",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "01/05/12 4:02 PM",
      "commitNameOld": "8620a99d1eea163b7505cde0a57e849b1b2a3a6f",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 6.04,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n-    INodeFile fileINode \u003d block.getINode();\n+    BlockCollection fileINode \u003d block.getINode();\n     if (fileINode \u003d\u003d null) {\n       // block does not belong to any file\n       addToInvalidates(block);\n       return MisReplicationResult.INVALID;\n     }\n     if (!block.isComplete()) {\n       // Incomplete blocks are never considered mis-replicated --\n       // they\u0027ll be reached when they are completed or recovered.\n       return MisReplicationResult.UNDER_CONSTRUCTION;\n     }\n     // calculate current replication\n     short expectedReplication \u003d fileINode.getReplication();\n     NumberReplicas num \u003d countNodes(block);\n     int numCurrentReplica \u003d num.liveReplicas();\n     // add to under-replicated queue if need to be\n     if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n       if (neededReplications.add(block, numCurrentReplica, num\n           .decommissionedReplicas(), expectedReplication)) {\n         return MisReplicationResult.UNDER_REPLICATED;\n       }\n     }\n \n     if (numCurrentReplica \u003e expectedReplication) {\n       if (num.replicasOnStaleNodes() \u003e 0) {\n         // If any of the replicas of this block are on nodes that are\n         // considered \"stale\", then these replicas may in fact have\n         // already been deleted. So, we cannot safely act on the\n         // over-replication until a later point in time, when\n         // the \"stale\" nodes have block reported.\n         return MisReplicationResult.POSTPONE;\n       }\n       \n       // over-replicated block\n       processOverReplicatedBlock(block, expectedReplication, null, null);\n       return MisReplicationResult.OVER_REPLICATED;\n     }\n     \n     return MisReplicationResult.OK;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private MisReplicationResult processMisReplicatedBlock(BlockInfo block) {\n    BlockCollection fileINode \u003d block.getINode();\n    if (fileINode \u003d\u003d null) {\n      // block does not belong to any file\n      addToInvalidates(block);\n      return MisReplicationResult.INVALID;\n    }\n    if (!block.isComplete()) {\n      // Incomplete blocks are never considered mis-replicated --\n      // they\u0027ll be reached when they are completed or recovered.\n      return MisReplicationResult.UNDER_CONSTRUCTION;\n    }\n    // calculate current replication\n    short expectedReplication \u003d fileINode.getReplication();\n    NumberReplicas num \u003d countNodes(block);\n    int numCurrentReplica \u003d num.liveReplicas();\n    // add to under-replicated queue if need to be\n    if (isNeededReplication(block, expectedReplication, numCurrentReplica)) {\n      if (neededReplications.add(block, numCurrentReplica, num\n          .decommissionedReplicas(), expectedReplication)) {\n        return MisReplicationResult.UNDER_REPLICATED;\n      }\n    }\n\n    if (numCurrentReplica \u003e expectedReplication) {\n      if (num.replicasOnStaleNodes() \u003e 0) {\n        // If any of the replicas of this block are on nodes that are\n        // considered \"stale\", then these replicas may in fact have\n        // already been deleted. So, we cannot safely act on the\n        // over-replication until a later point in time, when\n        // the \"stale\" nodes have block reported.\n        return MisReplicationResult.POSTPONE;\n      }\n      \n      // over-replicated block\n      processOverReplicatedBlock(block, expectedReplication, null, null);\n      return MisReplicationResult.OVER_REPLICATED;\n    }\n    \n    return MisReplicationResult.OK;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    }
  }
}