{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "OfflineImageReconstructor.java",
  "functionName": "processFileDiffEntry",
  "functionId": "processFileDiffEntry",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java",
  "functionStartLine": 1528,
  "functionEndLine": 1592,
  "numCommitsSeen": 15,
  "timeTaken": 1991,
  "changeHistory": [
    "05391c1845639d4f01da8e5df966e2dc2682f2ca",
    "680716f31e120f4d3ee70b095e4db46c05b891d9",
    "700b0e4019cf483f7532609711812150b8c44742"
  ],
  "changeHistoryShort": {
    "05391c1845639d4f01da8e5df966e2dc2682f2ca": "Ybodychange",
    "680716f31e120f4d3ee70b095e4db46c05b891d9": "Ybodychange",
    "700b0e4019cf483f7532609711812150b8c44742": "Yintroduced"
  },
  "changeHistoryDetails": {
    "05391c1845639d4f01da8e5df966e2dc2682f2ca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10506. OIV\u0027s ReverseXML processor cannot reconstruct some snapshot details. Contributed by Akira Ajisaka.\n",
      "commitDate": "25/02/17 2:38 PM",
      "commitName": "05391c1845639d4f01da8e5df966e2dc2682f2ca",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "18/01/17 1:31 PM",
      "commitNameOld": "a2a5d7b5bca715835d92816e7b267b59f7270708",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 38.05,
      "commitsBetweenForRepo": 195,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,65 @@\n     private void processFileDiffEntry() throws IOException {\n       LOG.debug(\"Processing fileDiffEntry\");\n       DiffEntry.Builder headerBld \u003d DiffEntry.newBuilder();\n       headerBld.setType(DiffEntry.Type.FILEDIFF);\n       Node fileDiffHeader \u003d new Node();\n       loadNodeChildren(fileDiffHeader, \"fileDiffEntry fields\", \"fileDiff\");\n       Long inodeId \u003d fileDiffHeader.removeChildLong(\n           SNAPSHOT_DIFF_SECTION_INODE_ID);\n       if (inodeId \u003d\u003d null) {\n         throw new IOException(\"\u003cfileDiffEntry\u003e contained no \u003cinodeid\u003e entry.\");\n       }\n       headerBld.setInodeId(inodeId);\n       Integer expectedDiffs \u003d fileDiffHeader.removeChildInt(\n           SNAPSHOT_DIFF_SECTION_COUNT);\n       if (expectedDiffs \u003d\u003d null) {\n         throw new IOException(\"\u003cfileDiffEntry\u003e contained no \u003ccount\u003e entry.\");\n       }\n       headerBld.setNumOfDiff(expectedDiffs);\n       fileDiffHeader.verifyNoRemainingKeys(\"fileDiffEntry\");\n       headerBld.build().writeDelimitedTo(out);\n       for (int actualDiffs \u003d 0; actualDiffs \u003c expectedDiffs; actualDiffs++) {\n         try {\n           expectTag(SNAPSHOT_DIFF_SECTION_FILE_DIFF, false);\n         } catch (IOException e) {\n           throw new IOException(\"Only read \" + (actualDiffs + 1) +\n               \" diffs out of \" + expectedDiffs, e);\n         }\n         Node fileDiff \u003d new Node();\n         loadNodeChildren(fileDiff, \"fileDiff fields\");\n         FsImageProto.SnapshotDiffSection.FileDiff.Builder bld \u003d\n             FsImageProto.SnapshotDiffSection.FileDiff.newBuilder();\n         Integer snapshotId \u003d fileDiff.removeChildInt(\n             SNAPSHOT_DIFF_SECTION_SNAPSHOT_ID);\n         if (snapshotId !\u003d null) {\n           bld.setSnapshotId(snapshotId);\n         }\n         Long size \u003d fileDiff.removeChildLong(\n             SNAPSHOT_DIFF_SECTION_SIZE);\n         if (size !\u003d null) {\n           bld.setFileSize(size);\n         }\n         String name \u003d fileDiff.removeChildStr(SECTION_NAME);\n         if (name !\u003d null) {\n           bld.setName(ByteString.copyFrom(name, \"UTF8\"));\n         }\n-        // TODO: missing snapshotCopy\n-        // TODO: missing blocks\n+        Node snapshotCopy \u003d fileDiff.removeChild(\n+            SNAPSHOT_DIFF_SECTION_SNAPSHOT_COPY);\n+        if (snapshotCopy !\u003d null) {\n+          bld.setSnapshotCopy(createINodeFileBuilder(snapshotCopy));\n+        }\n+        Node blocks \u003d fileDiff.removeChild(INODE_SECTION_BLOCKS);\n+        if (blocks !\u003d null) {\n+          while (true) {\n+            Node block \u003d blocks.removeChild(INODE_SECTION_BLOCK);\n+            if (block \u003d\u003d null) {\n+              break;\n+            }\n+            bld.addBlocks(createBlockBuilder(block));\n+          }\n+        }\n         fileDiff.verifyNoRemainingKeys(\"fileDiff\");\n         bld.build().writeDelimitedTo(out);\n       }\n       expectTagEnd(SNAPSHOT_DIFF_SECTION_FILE_DIFF_ENTRY);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processFileDiffEntry() throws IOException {\n      LOG.debug(\"Processing fileDiffEntry\");\n      DiffEntry.Builder headerBld \u003d DiffEntry.newBuilder();\n      headerBld.setType(DiffEntry.Type.FILEDIFF);\n      Node fileDiffHeader \u003d new Node();\n      loadNodeChildren(fileDiffHeader, \"fileDiffEntry fields\", \"fileDiff\");\n      Long inodeId \u003d fileDiffHeader.removeChildLong(\n          SNAPSHOT_DIFF_SECTION_INODE_ID);\n      if (inodeId \u003d\u003d null) {\n        throw new IOException(\"\u003cfileDiffEntry\u003e contained no \u003cinodeid\u003e entry.\");\n      }\n      headerBld.setInodeId(inodeId);\n      Integer expectedDiffs \u003d fileDiffHeader.removeChildInt(\n          SNAPSHOT_DIFF_SECTION_COUNT);\n      if (expectedDiffs \u003d\u003d null) {\n        throw new IOException(\"\u003cfileDiffEntry\u003e contained no \u003ccount\u003e entry.\");\n      }\n      headerBld.setNumOfDiff(expectedDiffs);\n      fileDiffHeader.verifyNoRemainingKeys(\"fileDiffEntry\");\n      headerBld.build().writeDelimitedTo(out);\n      for (int actualDiffs \u003d 0; actualDiffs \u003c expectedDiffs; actualDiffs++) {\n        try {\n          expectTag(SNAPSHOT_DIFF_SECTION_FILE_DIFF, false);\n        } catch (IOException e) {\n          throw new IOException(\"Only read \" + (actualDiffs + 1) +\n              \" diffs out of \" + expectedDiffs, e);\n        }\n        Node fileDiff \u003d new Node();\n        loadNodeChildren(fileDiff, \"fileDiff fields\");\n        FsImageProto.SnapshotDiffSection.FileDiff.Builder bld \u003d\n            FsImageProto.SnapshotDiffSection.FileDiff.newBuilder();\n        Integer snapshotId \u003d fileDiff.removeChildInt(\n            SNAPSHOT_DIFF_SECTION_SNAPSHOT_ID);\n        if (snapshotId !\u003d null) {\n          bld.setSnapshotId(snapshotId);\n        }\n        Long size \u003d fileDiff.removeChildLong(\n            SNAPSHOT_DIFF_SECTION_SIZE);\n        if (size !\u003d null) {\n          bld.setFileSize(size);\n        }\n        String name \u003d fileDiff.removeChildStr(SECTION_NAME);\n        if (name !\u003d null) {\n          bld.setName(ByteString.copyFrom(name, \"UTF8\"));\n        }\n        Node snapshotCopy \u003d fileDiff.removeChild(\n            SNAPSHOT_DIFF_SECTION_SNAPSHOT_COPY);\n        if (snapshotCopy !\u003d null) {\n          bld.setSnapshotCopy(createINodeFileBuilder(snapshotCopy));\n        }\n        Node blocks \u003d fileDiff.removeChild(INODE_SECTION_BLOCKS);\n        if (blocks !\u003d null) {\n          while (true) {\n            Node block \u003d blocks.removeChild(INODE_SECTION_BLOCK);\n            if (block \u003d\u003d null) {\n              break;\n            }\n            bld.addBlocks(createBlockBuilder(block));\n          }\n        }\n        fileDiff.verifyNoRemainingKeys(\"fileDiff\");\n        bld.build().writeDelimitedTo(out);\n      }\n      expectTagEnd(SNAPSHOT_DIFF_SECTION_FILE_DIFF_ENTRY);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java",
      "extendedDetails": {}
    },
    "680716f31e120f4d3ee70b095e4db46c05b891d9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9951. Use string constants for XML tags in OfflineImageReconstructor (Lin Yiqun via cmccabe)\n",
      "commitDate": "21/03/16 11:40 AM",
      "commitName": "680716f31e120f4d3ee70b095e4db46c05b891d9",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "10/03/16 1:41 PM",
      "commitNameOld": "bd49354c6d6387620b0de2219eab1714ec2d64f8",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 10.87,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,52 @@\n     private void processFileDiffEntry() throws IOException {\n       LOG.debug(\"Processing fileDiffEntry\");\n       DiffEntry.Builder headerBld \u003d DiffEntry.newBuilder();\n       headerBld.setType(DiffEntry.Type.FILEDIFF);\n       Node fileDiffHeader \u003d new Node();\n       loadNodeChildren(fileDiffHeader, \"fileDiffEntry fields\", \"fileDiff\");\n-      Long inodeId \u003d fileDiffHeader.removeChildLong(\"inodeid\");\n+      Long inodeId \u003d fileDiffHeader.removeChildLong(\n+          SNAPSHOT_DIFF_SECTION_INODE_ID);\n       if (inodeId \u003d\u003d null) {\n         throw new IOException(\"\u003cfileDiffEntry\u003e contained no \u003cinodeid\u003e entry.\");\n       }\n       headerBld.setInodeId(inodeId);\n-      Integer expectedDiffs \u003d fileDiffHeader.removeChildInt(\"count\");\n+      Integer expectedDiffs \u003d fileDiffHeader.removeChildInt(\n+          SNAPSHOT_DIFF_SECTION_COUNT);\n       if (expectedDiffs \u003d\u003d null) {\n         throw new IOException(\"\u003cfileDiffEntry\u003e contained no \u003ccount\u003e entry.\");\n       }\n       headerBld.setNumOfDiff(expectedDiffs);\n       fileDiffHeader.verifyNoRemainingKeys(\"fileDiffEntry\");\n       headerBld.build().writeDelimitedTo(out);\n       for (int actualDiffs \u003d 0; actualDiffs \u003c expectedDiffs; actualDiffs++) {\n         try {\n-          expectTag(\"fileDiff\", false);\n+          expectTag(SNAPSHOT_DIFF_SECTION_FILE_DIFF, false);\n         } catch (IOException e) {\n           throw new IOException(\"Only read \" + (actualDiffs + 1) +\n               \" diffs out of \" + expectedDiffs, e);\n         }\n         Node fileDiff \u003d new Node();\n         loadNodeChildren(fileDiff, \"fileDiff fields\");\n         FsImageProto.SnapshotDiffSection.FileDiff.Builder bld \u003d\n             FsImageProto.SnapshotDiffSection.FileDiff.newBuilder();\n-        Integer snapshotId \u003d fileDiff.removeChildInt(\"snapshotId\");\n+        Integer snapshotId \u003d fileDiff.removeChildInt(\n+            SNAPSHOT_DIFF_SECTION_SNAPSHOT_ID);\n         if (snapshotId !\u003d null) {\n           bld.setSnapshotId(snapshotId);\n         }\n-        Long size \u003d fileDiff.removeChildLong(\"size\");\n+        Long size \u003d fileDiff.removeChildLong(\n+            SNAPSHOT_DIFF_SECTION_SIZE);\n         if (size !\u003d null) {\n           bld.setFileSize(size);\n         }\n-        String name \u003d fileDiff.removeChildStr(\"name\");\n+        String name \u003d fileDiff.removeChildStr(SECTION_NAME);\n         if (name !\u003d null) {\n           bld.setName(ByteString.copyFrom(name, \"UTF8\"));\n         }\n         // TODO: missing snapshotCopy\n         // TODO: missing blocks\n         fileDiff.verifyNoRemainingKeys(\"fileDiff\");\n         bld.build().writeDelimitedTo(out);\n       }\n-      expectTagEnd(\"fileDiffEntry\");\n+      expectTagEnd(SNAPSHOT_DIFF_SECTION_FILE_DIFF_ENTRY);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processFileDiffEntry() throws IOException {\n      LOG.debug(\"Processing fileDiffEntry\");\n      DiffEntry.Builder headerBld \u003d DiffEntry.newBuilder();\n      headerBld.setType(DiffEntry.Type.FILEDIFF);\n      Node fileDiffHeader \u003d new Node();\n      loadNodeChildren(fileDiffHeader, \"fileDiffEntry fields\", \"fileDiff\");\n      Long inodeId \u003d fileDiffHeader.removeChildLong(\n          SNAPSHOT_DIFF_SECTION_INODE_ID);\n      if (inodeId \u003d\u003d null) {\n        throw new IOException(\"\u003cfileDiffEntry\u003e contained no \u003cinodeid\u003e entry.\");\n      }\n      headerBld.setInodeId(inodeId);\n      Integer expectedDiffs \u003d fileDiffHeader.removeChildInt(\n          SNAPSHOT_DIFF_SECTION_COUNT);\n      if (expectedDiffs \u003d\u003d null) {\n        throw new IOException(\"\u003cfileDiffEntry\u003e contained no \u003ccount\u003e entry.\");\n      }\n      headerBld.setNumOfDiff(expectedDiffs);\n      fileDiffHeader.verifyNoRemainingKeys(\"fileDiffEntry\");\n      headerBld.build().writeDelimitedTo(out);\n      for (int actualDiffs \u003d 0; actualDiffs \u003c expectedDiffs; actualDiffs++) {\n        try {\n          expectTag(SNAPSHOT_DIFF_SECTION_FILE_DIFF, false);\n        } catch (IOException e) {\n          throw new IOException(\"Only read \" + (actualDiffs + 1) +\n              \" diffs out of \" + expectedDiffs, e);\n        }\n        Node fileDiff \u003d new Node();\n        loadNodeChildren(fileDiff, \"fileDiff fields\");\n        FsImageProto.SnapshotDiffSection.FileDiff.Builder bld \u003d\n            FsImageProto.SnapshotDiffSection.FileDiff.newBuilder();\n        Integer snapshotId \u003d fileDiff.removeChildInt(\n            SNAPSHOT_DIFF_SECTION_SNAPSHOT_ID);\n        if (snapshotId !\u003d null) {\n          bld.setSnapshotId(snapshotId);\n        }\n        Long size \u003d fileDiff.removeChildLong(\n            SNAPSHOT_DIFF_SECTION_SIZE);\n        if (size !\u003d null) {\n          bld.setFileSize(size);\n        }\n        String name \u003d fileDiff.removeChildStr(SECTION_NAME);\n        if (name !\u003d null) {\n          bld.setName(ByteString.copyFrom(name, \"UTF8\"));\n        }\n        // TODO: missing snapshotCopy\n        // TODO: missing blocks\n        fileDiff.verifyNoRemainingKeys(\"fileDiff\");\n        bld.build().writeDelimitedTo(out);\n      }\n      expectTagEnd(SNAPSHOT_DIFF_SECTION_FILE_DIFF_ENTRY);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java",
      "extendedDetails": {}
    },
    "700b0e4019cf483f7532609711812150b8c44742": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-9835. OIV: add ReverseXML processor which reconstructs an fsimage from an XML file (cmccabe)\n",
      "commitDate": "02/03/16 5:56 PM",
      "commitName": "700b0e4019cf483f7532609711812150b8c44742",
      "commitAuthor": "Colin Patrick Mccabe",
      "diff": "@@ -0,0 +1,48 @@\n+    private void processFileDiffEntry() throws IOException {\n+      LOG.debug(\"Processing fileDiffEntry\");\n+      DiffEntry.Builder headerBld \u003d DiffEntry.newBuilder();\n+      headerBld.setType(DiffEntry.Type.FILEDIFF);\n+      Node fileDiffHeader \u003d new Node();\n+      loadNodeChildren(fileDiffHeader, \"fileDiffEntry fields\", \"fileDiff\");\n+      Long inodeId \u003d fileDiffHeader.removeChildLong(\"inodeid\");\n+      if (inodeId \u003d\u003d null) {\n+        throw new IOException(\"\u003cfileDiffEntry\u003e contained no \u003cinodeid\u003e entry.\");\n+      }\n+      headerBld.setInodeId(inodeId);\n+      Integer expectedDiffs \u003d fileDiffHeader.removeChildInt(\"count\");\n+      if (expectedDiffs \u003d\u003d null) {\n+        throw new IOException(\"\u003cfileDiffEntry\u003e contained no \u003ccount\u003e entry.\");\n+      }\n+      headerBld.setNumOfDiff(expectedDiffs);\n+      fileDiffHeader.verifyNoRemainingKeys(\"fileDiffEntry\");\n+      headerBld.build().writeDelimitedTo(out);\n+      for (int actualDiffs \u003d 0; actualDiffs \u003c expectedDiffs; actualDiffs++) {\n+        try {\n+          expectTag(\"fileDiff\", false);\n+        } catch (IOException e) {\n+          throw new IOException(\"Only read \" + (actualDiffs + 1) +\n+              \" diffs out of \" + expectedDiffs, e);\n+        }\n+        Node fileDiff \u003d new Node();\n+        loadNodeChildren(fileDiff, \"fileDiff fields\");\n+        FsImageProto.SnapshotDiffSection.FileDiff.Builder bld \u003d\n+            FsImageProto.SnapshotDiffSection.FileDiff.newBuilder();\n+        Integer snapshotId \u003d fileDiff.removeChildInt(\"snapshotId\");\n+        if (snapshotId !\u003d null) {\n+          bld.setSnapshotId(snapshotId);\n+        }\n+        Long size \u003d fileDiff.removeChildLong(\"size\");\n+        if (size !\u003d null) {\n+          bld.setFileSize(size);\n+        }\n+        String name \u003d fileDiff.removeChildStr(\"name\");\n+        if (name !\u003d null) {\n+          bld.setName(ByteString.copyFrom(name, \"UTF8\"));\n+        }\n+        // TODO: missing snapshotCopy\n+        // TODO: missing blocks\n+        fileDiff.verifyNoRemainingKeys(\"fileDiff\");\n+        bld.build().writeDelimitedTo(out);\n+      }\n+      expectTagEnd(\"fileDiffEntry\");\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void processFileDiffEntry() throws IOException {\n      LOG.debug(\"Processing fileDiffEntry\");\n      DiffEntry.Builder headerBld \u003d DiffEntry.newBuilder();\n      headerBld.setType(DiffEntry.Type.FILEDIFF);\n      Node fileDiffHeader \u003d new Node();\n      loadNodeChildren(fileDiffHeader, \"fileDiffEntry fields\", \"fileDiff\");\n      Long inodeId \u003d fileDiffHeader.removeChildLong(\"inodeid\");\n      if (inodeId \u003d\u003d null) {\n        throw new IOException(\"\u003cfileDiffEntry\u003e contained no \u003cinodeid\u003e entry.\");\n      }\n      headerBld.setInodeId(inodeId);\n      Integer expectedDiffs \u003d fileDiffHeader.removeChildInt(\"count\");\n      if (expectedDiffs \u003d\u003d null) {\n        throw new IOException(\"\u003cfileDiffEntry\u003e contained no \u003ccount\u003e entry.\");\n      }\n      headerBld.setNumOfDiff(expectedDiffs);\n      fileDiffHeader.verifyNoRemainingKeys(\"fileDiffEntry\");\n      headerBld.build().writeDelimitedTo(out);\n      for (int actualDiffs \u003d 0; actualDiffs \u003c expectedDiffs; actualDiffs++) {\n        try {\n          expectTag(\"fileDiff\", false);\n        } catch (IOException e) {\n          throw new IOException(\"Only read \" + (actualDiffs + 1) +\n              \" diffs out of \" + expectedDiffs, e);\n        }\n        Node fileDiff \u003d new Node();\n        loadNodeChildren(fileDiff, \"fileDiff fields\");\n        FsImageProto.SnapshotDiffSection.FileDiff.Builder bld \u003d\n            FsImageProto.SnapshotDiffSection.FileDiff.newBuilder();\n        Integer snapshotId \u003d fileDiff.removeChildInt(\"snapshotId\");\n        if (snapshotId !\u003d null) {\n          bld.setSnapshotId(snapshotId);\n        }\n        Long size \u003d fileDiff.removeChildLong(\"size\");\n        if (size !\u003d null) {\n          bld.setFileSize(size);\n        }\n        String name \u003d fileDiff.removeChildStr(\"name\");\n        if (name !\u003d null) {\n          bld.setName(ByteString.copyFrom(name, \"UTF8\"));\n        }\n        // TODO: missing snapshotCopy\n        // TODO: missing blocks\n        fileDiff.verifyNoRemainingKeys(\"fileDiff\");\n        bld.build().writeDelimitedTo(out);\n      }\n      expectTagEnd(\"fileDiffEntry\");\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java"
    }
  }
}