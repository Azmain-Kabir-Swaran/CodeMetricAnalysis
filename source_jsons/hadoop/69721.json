{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbfsInputStream.java",
  "functionName": "readInternal",
  "functionId": "readInternal___position-long(modifiers-final)__b-byte[](modifiers-final)__offset-int(modifiers-final)__length-int(modifiers-final)__bypassReadAhead-boolean(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsInputStream.java",
  "functionStartLine": 190,
  "functionEndLine": 223,
  "numCommitsSeen": 13,
  "timeTaken": 1915,
  "changeHistory": [
    "c734d247b1ea16b7028de3a37ff556cb1ef8b7d6",
    "28afdce00955a51bbea9bf46aa0f784764ec1329",
    "e2c7ac71b5ee47bb40294acd10c0c21dd6ee430f",
    "f044deedbbfee0812316d587139cb828f27172e9"
  ],
  "changeHistoryShort": {
    "c734d247b1ea16b7028de3a37ff556cb1ef8b7d6": "Ybodychange",
    "28afdce00955a51bbea9bf46aa0f784764ec1329": "Ybodychange",
    "e2c7ac71b5ee47bb40294acd10c0c21dd6ee430f": "Ybodychange",
    "f044deedbbfee0812316d587139cb828f27172e9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c734d247b1ea16b7028de3a37ff556cb1ef8b7d6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16910 : ABFS Streams to update FileSystem.Statistics counters on IO. (#1918). Contributed by Mehakmeet Singh.\n\n",
      "commitDate": "31/03/20 5:49 AM",
      "commitName": "c734d247b1ea16b7028de3a37ff556cb1ef8b7d6",
      "commitAuthor": "Mehakmeet Singh",
      "commitDateOld": "24/03/20 5:11 AM",
      "commitNameOld": "28afdce00955a51bbea9bf46aa0f784764ec1329",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 7.03,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,34 @@\n   private int readInternal(final long position, final byte[] b, final int offset, final int length,\n                            final boolean bypassReadAhead) throws IOException {\n     if (readAheadEnabled \u0026\u0026 !bypassReadAhead) {\n       // try reading from read-ahead\n       if (offset !\u003d 0) {\n         throw new IllegalArgumentException(\"readahead buffers cannot have non-zero buffer offsets\");\n       }\n       int receivedBytes;\n \n       // queue read-aheads\n       int numReadAheads \u003d this.readAheadQueueDepth;\n       long nextSize;\n       long nextOffset \u003d position;\n       while (numReadAheads \u003e 0 \u0026\u0026 nextOffset \u003c contentLength) {\n         nextSize \u003d Math.min((long) bufferSize, contentLength - nextOffset);\n         ReadBufferManager.getBufferManager().queueReadAhead(this, nextOffset, (int) nextSize);\n         nextOffset \u003d nextOffset + nextSize;\n         numReadAheads--;\n       }\n \n       // try reading from buffers first\n       receivedBytes \u003d ReadBufferManager.getBufferManager().getBlock(this, position, length, b);\n       if (receivedBytes \u003e 0) {\n+        incrementReadOps();\n         return receivedBytes;\n       }\n \n       // got nothing from read-ahead, do our own read now\n       receivedBytes \u003d readRemote(position, b, offset, length);\n       return receivedBytes;\n     } else {\n       return readRemote(position, b, offset, length);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int readInternal(final long position, final byte[] b, final int offset, final int length,\n                           final boolean bypassReadAhead) throws IOException {\n    if (readAheadEnabled \u0026\u0026 !bypassReadAhead) {\n      // try reading from read-ahead\n      if (offset !\u003d 0) {\n        throw new IllegalArgumentException(\"readahead buffers cannot have non-zero buffer offsets\");\n      }\n      int receivedBytes;\n\n      // queue read-aheads\n      int numReadAheads \u003d this.readAheadQueueDepth;\n      long nextSize;\n      long nextOffset \u003d position;\n      while (numReadAheads \u003e 0 \u0026\u0026 nextOffset \u003c contentLength) {\n        nextSize \u003d Math.min((long) bufferSize, contentLength - nextOffset);\n        ReadBufferManager.getBufferManager().queueReadAhead(this, nextOffset, (int) nextSize);\n        nextOffset \u003d nextOffset + nextSize;\n        numReadAheads--;\n      }\n\n      // try reading from buffers first\n      receivedBytes \u003d ReadBufferManager.getBufferManager().getBlock(this, position, length, b);\n      if (receivedBytes \u003e 0) {\n        incrementReadOps();\n        return receivedBytes;\n      }\n\n      // got nothing from read-ahead, do our own read now\n      receivedBytes \u003d readRemote(position, b, offset, length);\n      return receivedBytes;\n    } else {\n      return readRemote(position, b, offset, length);\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsInputStream.java",
      "extendedDetails": {}
    },
    "28afdce00955a51bbea9bf46aa0f784764ec1329": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"\"HADOOP-16910. ABFS Streams to update FileSystem.Statistics counters on IO.\"\n\nThis reverts commit e2c7ac71b5ee47bb40294acd10c0c21dd6ee430f.\n\nChange-Id: I5b5a93f5a36cdb0c3d56d1b3f747c318f089de20\n",
      "commitDate": "24/03/20 5:11 AM",
      "commitName": "28afdce00955a51bbea9bf46aa0f784764ec1329",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "23/03/20 6:50 AM",
      "commitNameOld": "e2c7ac71b5ee47bb40294acd10c0c21dd6ee430f",
      "commitAuthorOld": "Mehakmeet Singh",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,33 @@\n   private int readInternal(final long position, final byte[] b, final int offset, final int length,\n                            final boolean bypassReadAhead) throws IOException {\n     if (readAheadEnabled \u0026\u0026 !bypassReadAhead) {\n       // try reading from read-ahead\n       if (offset !\u003d 0) {\n         throw new IllegalArgumentException(\"readahead buffers cannot have non-zero buffer offsets\");\n       }\n       int receivedBytes;\n \n       // queue read-aheads\n       int numReadAheads \u003d this.readAheadQueueDepth;\n       long nextSize;\n       long nextOffset \u003d position;\n       while (numReadAheads \u003e 0 \u0026\u0026 nextOffset \u003c contentLength) {\n         nextSize \u003d Math.min((long) bufferSize, contentLength - nextOffset);\n         ReadBufferManager.getBufferManager().queueReadAhead(this, nextOffset, (int) nextSize);\n         nextOffset \u003d nextOffset + nextSize;\n         numReadAheads--;\n       }\n \n       // try reading from buffers first\n       receivedBytes \u003d ReadBufferManager.getBufferManager().getBlock(this, position, length, b);\n       if (receivedBytes \u003e 0) {\n-        incrementReadOps();\n         return receivedBytes;\n       }\n \n       // got nothing from read-ahead, do our own read now\n       receivedBytes \u003d readRemote(position, b, offset, length);\n       return receivedBytes;\n     } else {\n       return readRemote(position, b, offset, length);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int readInternal(final long position, final byte[] b, final int offset, final int length,\n                           final boolean bypassReadAhead) throws IOException {\n    if (readAheadEnabled \u0026\u0026 !bypassReadAhead) {\n      // try reading from read-ahead\n      if (offset !\u003d 0) {\n        throw new IllegalArgumentException(\"readahead buffers cannot have non-zero buffer offsets\");\n      }\n      int receivedBytes;\n\n      // queue read-aheads\n      int numReadAheads \u003d this.readAheadQueueDepth;\n      long nextSize;\n      long nextOffset \u003d position;\n      while (numReadAheads \u003e 0 \u0026\u0026 nextOffset \u003c contentLength) {\n        nextSize \u003d Math.min((long) bufferSize, contentLength - nextOffset);\n        ReadBufferManager.getBufferManager().queueReadAhead(this, nextOffset, (int) nextSize);\n        nextOffset \u003d nextOffset + nextSize;\n        numReadAheads--;\n      }\n\n      // try reading from buffers first\n      receivedBytes \u003d ReadBufferManager.getBufferManager().getBlock(this, position, length, b);\n      if (receivedBytes \u003e 0) {\n        return receivedBytes;\n      }\n\n      // got nothing from read-ahead, do our own read now\n      receivedBytes \u003d readRemote(position, b, offset, length);\n      return receivedBytes;\n    } else {\n      return readRemote(position, b, offset, length);\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsInputStream.java",
      "extendedDetails": {}
    },
    "e2c7ac71b5ee47bb40294acd10c0c21dd6ee430f": {
      "type": "Ybodychange",
      "commitMessage": "ABFS Streams to update FileSystem.Statistics counters on IO.\n\n\r\nContributed by Mehakmeet Singh",
      "commitDate": "23/03/20 6:50 AM",
      "commitName": "e2c7ac71b5ee47bb40294acd10c0c21dd6ee430f",
      "commitAuthor": "Mehakmeet Singh",
      "commitDateOld": "24/02/20 8:28 AM",
      "commitNameOld": "42dfd270a11419adcb189e8f3a6ddb8f19358088",
      "commitAuthorOld": "Sahil Takiar",
      "daysBetweenCommits": 27.89,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,34 @@\n   private int readInternal(final long position, final byte[] b, final int offset, final int length,\n                            final boolean bypassReadAhead) throws IOException {\n     if (readAheadEnabled \u0026\u0026 !bypassReadAhead) {\n       // try reading from read-ahead\n       if (offset !\u003d 0) {\n         throw new IllegalArgumentException(\"readahead buffers cannot have non-zero buffer offsets\");\n       }\n       int receivedBytes;\n \n       // queue read-aheads\n       int numReadAheads \u003d this.readAheadQueueDepth;\n       long nextSize;\n       long nextOffset \u003d position;\n       while (numReadAheads \u003e 0 \u0026\u0026 nextOffset \u003c contentLength) {\n         nextSize \u003d Math.min((long) bufferSize, contentLength - nextOffset);\n         ReadBufferManager.getBufferManager().queueReadAhead(this, nextOffset, (int) nextSize);\n         nextOffset \u003d nextOffset + nextSize;\n         numReadAheads--;\n       }\n \n       // try reading from buffers first\n       receivedBytes \u003d ReadBufferManager.getBufferManager().getBlock(this, position, length, b);\n       if (receivedBytes \u003e 0) {\n+        incrementReadOps();\n         return receivedBytes;\n       }\n \n       // got nothing from read-ahead, do our own read now\n       receivedBytes \u003d readRemote(position, b, offset, length);\n       return receivedBytes;\n     } else {\n       return readRemote(position, b, offset, length);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int readInternal(final long position, final byte[] b, final int offset, final int length,\n                           final boolean bypassReadAhead) throws IOException {\n    if (readAheadEnabled \u0026\u0026 !bypassReadAhead) {\n      // try reading from read-ahead\n      if (offset !\u003d 0) {\n        throw new IllegalArgumentException(\"readahead buffers cannot have non-zero buffer offsets\");\n      }\n      int receivedBytes;\n\n      // queue read-aheads\n      int numReadAheads \u003d this.readAheadQueueDepth;\n      long nextSize;\n      long nextOffset \u003d position;\n      while (numReadAheads \u003e 0 \u0026\u0026 nextOffset \u003c contentLength) {\n        nextSize \u003d Math.min((long) bufferSize, contentLength - nextOffset);\n        ReadBufferManager.getBufferManager().queueReadAhead(this, nextOffset, (int) nextSize);\n        nextOffset \u003d nextOffset + nextSize;\n        numReadAheads--;\n      }\n\n      // try reading from buffers first\n      receivedBytes \u003d ReadBufferManager.getBufferManager().getBlock(this, position, length, b);\n      if (receivedBytes \u003e 0) {\n        incrementReadOps();\n        return receivedBytes;\n      }\n\n      // got nothing from read-ahead, do our own read now\n      receivedBytes \u003d readRemote(position, b, offset, length);\n      return receivedBytes;\n    } else {\n      return readRemote(position, b, offset, length);\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsInputStream.java",
      "extendedDetails": {}
    },
    "f044deedbbfee0812316d587139cb828f27172e9": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15407. HADOOP-15540. Support Windows Azure Storage - Blob file system \"ABFS\" in Hadoop: Core Commit.\n\nContributed by Shane Mainali, Thomas Marquardt, Zichen Sun, Georgi Chalakov, Esfandiar Manii, Amit Singh, Dana Kaban, Da Zhou, Junhua Gu, Saher Ahwal, Saurabh Pant, James Baker, Shaoyu Zhang, Lawrence Chen, Kevin Chen and Steve Loughran\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "f044deedbbfee0812316d587139cb828f27172e9",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,33 @@\n+  private int readInternal(final long position, final byte[] b, final int offset, final int length,\n+                           final boolean bypassReadAhead) throws IOException {\n+    if (readAheadEnabled \u0026\u0026 !bypassReadAhead) {\n+      // try reading from read-ahead\n+      if (offset !\u003d 0) {\n+        throw new IllegalArgumentException(\"readahead buffers cannot have non-zero buffer offsets\");\n+      }\n+      int receivedBytes;\n+\n+      // queue read-aheads\n+      int numReadAheads \u003d this.readAheadQueueDepth;\n+      long nextSize;\n+      long nextOffset \u003d position;\n+      while (numReadAheads \u003e 0 \u0026\u0026 nextOffset \u003c contentLength) {\n+        nextSize \u003d Math.min((long) bufferSize, contentLength - nextOffset);\n+        ReadBufferManager.getBufferManager().queueReadAhead(this, nextOffset, (int) nextSize);\n+        nextOffset \u003d nextOffset + nextSize;\n+        numReadAheads--;\n+      }\n+\n+      // try reading from buffers first\n+      receivedBytes \u003d ReadBufferManager.getBufferManager().getBlock(this, position, length, b);\n+      if (receivedBytes \u003e 0) {\n+        return receivedBytes;\n+      }\n+\n+      // got nothing from read-ahead, do our own read now\n+      receivedBytes \u003d readRemote(position, b, offset, length);\n+      return receivedBytes;\n+    } else {\n+      return readRemote(position, b, offset, length);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private int readInternal(final long position, final byte[] b, final int offset, final int length,\n                           final boolean bypassReadAhead) throws IOException {\n    if (readAheadEnabled \u0026\u0026 !bypassReadAhead) {\n      // try reading from read-ahead\n      if (offset !\u003d 0) {\n        throw new IllegalArgumentException(\"readahead buffers cannot have non-zero buffer offsets\");\n      }\n      int receivedBytes;\n\n      // queue read-aheads\n      int numReadAheads \u003d this.readAheadQueueDepth;\n      long nextSize;\n      long nextOffset \u003d position;\n      while (numReadAheads \u003e 0 \u0026\u0026 nextOffset \u003c contentLength) {\n        nextSize \u003d Math.min((long) bufferSize, contentLength - nextOffset);\n        ReadBufferManager.getBufferManager().queueReadAhead(this, nextOffset, (int) nextSize);\n        nextOffset \u003d nextOffset + nextSize;\n        numReadAheads--;\n      }\n\n      // try reading from buffers first\n      receivedBytes \u003d ReadBufferManager.getBufferManager().getBlock(this, position, length, b);\n      if (receivedBytes \u003e 0) {\n        return receivedBytes;\n      }\n\n      // got nothing from read-ahead, do our own read now\n      receivedBytes \u003d readRemote(position, b, offset, length);\n      return receivedBytes;\n    } else {\n      return readRemote(position, b, offset, length);\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsInputStream.java"
    }
  }
}