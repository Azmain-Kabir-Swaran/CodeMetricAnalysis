{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InMemoryPlan.java",
  "functionName": "decrementAllocation",
  "functionId": "decrementAllocation___reservation-ReservationAllocation",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
  "functionStartLine": 247,
  "functionEndLine": 304,
  "numCommitsSeen": 19,
  "timeTaken": 2890,
  "changeHistory": [
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
    "e3345e985bff93c6c74a76747e45376c6027f42c",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
    "742632e346604fd2b263bd42367165638fcf2416",
    "0e602fa3a1529134214452fba10a90307d9c2072",
    "a2986234be4e02f9ccb589f9ff5f7ffb28bc6400",
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168"
  ],
  "changeHistoryShort": {
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": "Ybodychange",
    "e3345e985bff93c6c74a76747e45376c6027f42c": "Ybodychange",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": "Ybodychange",
    "742632e346604fd2b263bd42367165638fcf2416": "Ybodychange",
    "0e602fa3a1529134214452fba10a90307d9c2072": "Ybodychange",
    "a2986234be4e02f9ccb589f9ff5f7ffb28bc6400": "Ybodychange",
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5328. Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "06/09/17 4:46 PM",
      "commitName": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "06/09/17 4:39 PM",
      "commitNameOld": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,58 @@\n   private void decrementAllocation(ReservationAllocation reservation) {\n     assert (readWriteLock.isWriteLockedByCurrentThread());\n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         reservation.getAllocationRequests();\n     String user \u003d reservation.getUser();\n-    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n+    long period \u003d reservation.getPeriodicity();\n+    RLESparseResourceAllocation resAlloc \u003d\n+        getUserRLEResourceAllocation(user, period);\n \n     long earliestActive \u003d Long.MAX_VALUE;\n     long latestActive \u003d Long.MIN_VALUE;\n     for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n         .entrySet()) {\n-      resAlloc.removeInterval(r.getKey(), r.getValue());\n-      rleSparseVector.removeInterval(r.getKey(), r.getValue());\n-      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n-          ZERO_RESOURCE)) {\n-        earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n-        latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n+      if (period \u003e 0L) {\n+        for (int i \u003d 0; i \u003c periodicRle.getTimePeriod() / period; i++) {\n+\n+          long rStart \u003d r.getKey().getStartTime() + i * period;\n+          long rEnd \u003d r.getKey().getEndTime() + i * period;\n+\n+          // handle wrap-around\n+          if (rEnd \u003e periodicRle.getTimePeriod()) {\n+            long diff \u003d rEnd - periodicRle.getTimePeriod();\n+            rEnd \u003d periodicRle.getTimePeriod();\n+            ReservationInterval newInterval \u003d new ReservationInterval(0, diff);\n+            periodicRle.removeInterval(newInterval, r.getValue());\n+            resAlloc.removeInterval(newInterval, r.getValue());\n+          }\n+\n+          ReservationInterval newInterval \u003d\n+              new ReservationInterval(rStart, rEnd);\n+          periodicRle.removeInterval(newInterval, r.getValue());\n+          resAlloc.removeInterval(newInterval, r.getValue());\n+        }\n+      } else {\n+        rleSparseVector.removeInterval(r.getKey(), r.getValue());\n+        resAlloc.removeInterval(r.getKey(), r.getValue());\n+        if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n+            ZERO_RESOURCE)) {\n+          earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n+          latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n+        }\n       }\n     }\n-    if (resAlloc.isEmpty()) {\n-      userResourceAlloc.remove(user);\n-    }\n+    gcUserRLEResourceAllocation(user, period);\n \n     RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n-    resCount.removeInterval(new ReservationInterval(earliestActive,\n-        latestActive), Resource.newInstance(1, 1));\n+    // periodic reservations are active from start time and good till cancelled\n+    if (period \u003e 0L) {\n+      earliestActive \u003d reservation.getStartTime();\n+      latestActive \u003d Long.MAX_VALUE;\n+    }\n+    resCount.removeInterval(\n+        new ReservationInterval(earliestActive, latestActive),\n+        Resource.newInstance(1, 1));\n     if (resCount.isEmpty()) {\n       userActiveReservationCount.remove(user);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void decrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    String user \u003d reservation.getUser();\n    long period \u003d reservation.getPeriodicity();\n    RLESparseResourceAllocation resAlloc \u003d\n        getUserRLEResourceAllocation(user, period);\n\n    long earliestActive \u003d Long.MAX_VALUE;\n    long latestActive \u003d Long.MIN_VALUE;\n    for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n        .entrySet()) {\n      if (period \u003e 0L) {\n        for (int i \u003d 0; i \u003c periodicRle.getTimePeriod() / period; i++) {\n\n          long rStart \u003d r.getKey().getStartTime() + i * period;\n          long rEnd \u003d r.getKey().getEndTime() + i * period;\n\n          // handle wrap-around\n          if (rEnd \u003e periodicRle.getTimePeriod()) {\n            long diff \u003d rEnd - periodicRle.getTimePeriod();\n            rEnd \u003d periodicRle.getTimePeriod();\n            ReservationInterval newInterval \u003d new ReservationInterval(0, diff);\n            periodicRle.removeInterval(newInterval, r.getValue());\n            resAlloc.removeInterval(newInterval, r.getValue());\n          }\n\n          ReservationInterval newInterval \u003d\n              new ReservationInterval(rStart, rEnd);\n          periodicRle.removeInterval(newInterval, r.getValue());\n          resAlloc.removeInterval(newInterval, r.getValue());\n        }\n      } else {\n        rleSparseVector.removeInterval(r.getKey(), r.getValue());\n        resAlloc.removeInterval(r.getKey(), r.getValue());\n        if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n            ZERO_RESOURCE)) {\n          earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n          latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n        }\n      }\n    }\n    gcUserRLEResourceAllocation(user, period);\n\n    RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n    // periodic reservations are active from start time and good till cancelled\n    if (period \u003e 0L) {\n      earliestActive \u003d reservation.getStartTime();\n      latestActive \u003d Long.MAX_VALUE;\n    }\n    resCount.removeInterval(\n        new ReservationInterval(earliestActive, latestActive),\n        Resource.newInstance(1, 1));\n    if (resCount.isEmpty()) {\n      userActiveReservationCount.remove(user);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "e3345e985bff93c6c74a76747e45376c6027f42c": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\"\n\nThis reverts commit 7996eca7dcfaa1bdf970e32022274f2699bef8a1.\n",
      "commitDate": "06/09/17 4:39 PM",
      "commitName": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/09/17 3:16 PM",
      "commitNameOld": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 5.06,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,30 @@\n   private void decrementAllocation(ReservationAllocation reservation) {\n     assert (readWriteLock.isWriteLockedByCurrentThread());\n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         reservation.getAllocationRequests();\n     String user \u003d reservation.getUser();\n-    long period \u003d reservation.getPeriodicity();\n-    RLESparseResourceAllocation resAlloc \u003d\n-        getUserRLEResourceAllocation(user, period);\n+    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n \n     long earliestActive \u003d Long.MAX_VALUE;\n     long latestActive \u003d Long.MIN_VALUE;\n     for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n         .entrySet()) {\n-      if (period \u003e 0L) {\n-        for (int i \u003d 0; i \u003c periodicRle.getTimePeriod() / period; i++) {\n-\n-          long rStart \u003d r.getKey().getStartTime() + i * period;\n-          long rEnd \u003d r.getKey().getEndTime() + i * period;\n-\n-          // handle wrap-around\n-          if (rEnd \u003e periodicRle.getTimePeriod()) {\n-            long diff \u003d rEnd - periodicRle.getTimePeriod();\n-            rEnd \u003d periodicRle.getTimePeriod();\n-            ReservationInterval newInterval \u003d new ReservationInterval(0, diff);\n-            periodicRle.removeInterval(newInterval, r.getValue());\n-            resAlloc.removeInterval(newInterval, r.getValue());\n-          }\n-\n-          ReservationInterval newInterval \u003d\n-              new ReservationInterval(rStart, rEnd);\n-          periodicRle.removeInterval(newInterval, r.getValue());\n-          resAlloc.removeInterval(newInterval, r.getValue());\n-        }\n-      } else {\n-        rleSparseVector.removeInterval(r.getKey(), r.getValue());\n-        resAlloc.removeInterval(r.getKey(), r.getValue());\n-        if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n-            ZERO_RESOURCE)) {\n-          earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n-          latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n-        }\n+      resAlloc.removeInterval(r.getKey(), r.getValue());\n+      rleSparseVector.removeInterval(r.getKey(), r.getValue());\n+      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n+          ZERO_RESOURCE)) {\n+        earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n+        latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n       }\n     }\n-    gcUserRLEResourceAllocation(user, period);\n+    if (resAlloc.isEmpty()) {\n+      userResourceAlloc.remove(user);\n+    }\n \n     RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n-    // periodic reservations are active from start time and good till cancelled\n-    if (period \u003e 0L) {\n-      earliestActive \u003d reservation.getStartTime();\n-      latestActive \u003d Long.MAX_VALUE;\n-    }\n-    resCount.removeInterval(\n-        new ReservationInterval(earliestActive, latestActive),\n-        Resource.newInstance(1, 1));\n+    resCount.removeInterval(new ReservationInterval(earliestActive,\n+        latestActive), Resource.newInstance(1, 1));\n     if (resCount.isEmpty()) {\n       userActiveReservationCount.remove(user);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void decrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    String user \u003d reservation.getUser();\n    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n\n    long earliestActive \u003d Long.MAX_VALUE;\n    long latestActive \u003d Long.MIN_VALUE;\n    for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n        .entrySet()) {\n      resAlloc.removeInterval(r.getKey(), r.getValue());\n      rleSparseVector.removeInterval(r.getKey(), r.getValue());\n      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n          ZERO_RESOURCE)) {\n        earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n        latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n      }\n    }\n    if (resAlloc.isEmpty()) {\n      userResourceAlloc.remove(user);\n    }\n\n    RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n    resCount.removeInterval(new ReservationInterval(earliestActive,\n        latestActive), Resource.newInstance(1, 1));\n    if (resCount.isEmpty()) {\n      userActiveReservationCount.remove(user);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": {
      "type": "Ybodychange",
      "commitMessage": "Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "01/09/17 3:16 PM",
      "commitName": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/05/17 4:01 PM",
      "commitNameOld": "a3a615eeab8c14ccdc548311097e62a916963dc5",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 122.97,
      "commitsBetweenForRepo": 775,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,58 @@\n   private void decrementAllocation(ReservationAllocation reservation) {\n     assert (readWriteLock.isWriteLockedByCurrentThread());\n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         reservation.getAllocationRequests();\n     String user \u003d reservation.getUser();\n-    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n+    long period \u003d reservation.getPeriodicity();\n+    RLESparseResourceAllocation resAlloc \u003d\n+        getUserRLEResourceAllocation(user, period);\n \n     long earliestActive \u003d Long.MAX_VALUE;\n     long latestActive \u003d Long.MIN_VALUE;\n     for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n         .entrySet()) {\n-      resAlloc.removeInterval(r.getKey(), r.getValue());\n-      rleSparseVector.removeInterval(r.getKey(), r.getValue());\n-      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n-          ZERO_RESOURCE)) {\n-        earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n-        latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n+      if (period \u003e 0L) {\n+        for (int i \u003d 0; i \u003c periodicRle.getTimePeriod() / period; i++) {\n+\n+          long rStart \u003d r.getKey().getStartTime() + i * period;\n+          long rEnd \u003d r.getKey().getEndTime() + i * period;\n+\n+          // handle wrap-around\n+          if (rEnd \u003e periodicRle.getTimePeriod()) {\n+            long diff \u003d rEnd - periodicRle.getTimePeriod();\n+            rEnd \u003d periodicRle.getTimePeriod();\n+            ReservationInterval newInterval \u003d new ReservationInterval(0, diff);\n+            periodicRle.removeInterval(newInterval, r.getValue());\n+            resAlloc.removeInterval(newInterval, r.getValue());\n+          }\n+\n+          ReservationInterval newInterval \u003d\n+              new ReservationInterval(rStart, rEnd);\n+          periodicRle.removeInterval(newInterval, r.getValue());\n+          resAlloc.removeInterval(newInterval, r.getValue());\n+        }\n+      } else {\n+        rleSparseVector.removeInterval(r.getKey(), r.getValue());\n+        resAlloc.removeInterval(r.getKey(), r.getValue());\n+        if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n+            ZERO_RESOURCE)) {\n+          earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n+          latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n+        }\n       }\n     }\n-    if (resAlloc.isEmpty()) {\n-      userResourceAlloc.remove(user);\n-    }\n+    gcUserRLEResourceAllocation(user, period);\n \n     RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n-    resCount.removeInterval(new ReservationInterval(earliestActive,\n-        latestActive), Resource.newInstance(1, 1));\n+    // periodic reservations are active from start time and good till cancelled\n+    if (period \u003e 0L) {\n+      earliestActive \u003d reservation.getStartTime();\n+      latestActive \u003d Long.MAX_VALUE;\n+    }\n+    resCount.removeInterval(\n+        new ReservationInterval(earliestActive, latestActive),\n+        Resource.newInstance(1, 1));\n     if (resCount.isEmpty()) {\n       userActiveReservationCount.remove(user);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void decrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    String user \u003d reservation.getUser();\n    long period \u003d reservation.getPeriodicity();\n    RLESparseResourceAllocation resAlloc \u003d\n        getUserRLEResourceAllocation(user, period);\n\n    long earliestActive \u003d Long.MAX_VALUE;\n    long latestActive \u003d Long.MIN_VALUE;\n    for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n        .entrySet()) {\n      if (period \u003e 0L) {\n        for (int i \u003d 0; i \u003c periodicRle.getTimePeriod() / period; i++) {\n\n          long rStart \u003d r.getKey().getStartTime() + i * period;\n          long rEnd \u003d r.getKey().getEndTime() + i * period;\n\n          // handle wrap-around\n          if (rEnd \u003e periodicRle.getTimePeriod()) {\n            long diff \u003d rEnd - periodicRle.getTimePeriod();\n            rEnd \u003d periodicRle.getTimePeriod();\n            ReservationInterval newInterval \u003d new ReservationInterval(0, diff);\n            periodicRle.removeInterval(newInterval, r.getValue());\n            resAlloc.removeInterval(newInterval, r.getValue());\n          }\n\n          ReservationInterval newInterval \u003d\n              new ReservationInterval(rStart, rEnd);\n          periodicRle.removeInterval(newInterval, r.getValue());\n          resAlloc.removeInterval(newInterval, r.getValue());\n        }\n      } else {\n        rleSparseVector.removeInterval(r.getKey(), r.getValue());\n        resAlloc.removeInterval(r.getKey(), r.getValue());\n        if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n            ZERO_RESOURCE)) {\n          earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n          latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n        }\n      }\n    }\n    gcUserRLEResourceAllocation(user, period);\n\n    RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n    // periodic reservations are active from start time and good till cancelled\n    if (period \u003e 0L) {\n      earliestActive \u003d reservation.getStartTime();\n      latestActive \u003d Long.MAX_VALUE;\n    }\n    resCount.removeInterval(\n        new ReservationInterval(earliestActive, latestActive),\n        Resource.newInstance(1, 1));\n    if (resCount.isEmpty()) {\n      userActiveReservationCount.remove(user);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "742632e346604fd2b263bd42367165638fcf2416": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
      "commitDate": "05/12/15 9:26 PM",
      "commitName": "742632e346604fd2b263bd42367165638fcf2416",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "21/11/15 9:59 AM",
      "commitNameOld": "da1016365aba1cee9c06771ab142d077379f27af",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 14.48,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,30 @@\n   private void decrementAllocation(ReservationAllocation reservation) {\n     assert (readWriteLock.isWriteLockedByCurrentThread());\n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         reservation.getAllocationRequests();\n     String user \u003d reservation.getUser();\n     RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n+\n+    long earliestActive \u003d Long.MAX_VALUE;\n+    long latestActive \u003d Long.MIN_VALUE;\n     for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n         .entrySet()) {\n       resAlloc.removeInterval(r.getKey(), r.getValue());\n       rleSparseVector.removeInterval(r.getKey(), r.getValue());\n+      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n+          ZERO_RESOURCE)) {\n+        earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n+        latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n+      }\n     }\n     if (resAlloc.isEmpty()) {\n       userResourceAlloc.remove(user);\n     }\n+\n+    RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n+    resCount.removeInterval(new ReservationInterval(earliestActive,\n+        latestActive), Resource.newInstance(1, 1));\n+    if (resCount.isEmpty()) {\n+      userActiveReservationCount.remove(user);\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void decrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    String user \u003d reservation.getUser();\n    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n\n    long earliestActive \u003d Long.MAX_VALUE;\n    long latestActive \u003d Long.MIN_VALUE;\n    for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n        .entrySet()) {\n      resAlloc.removeInterval(r.getKey(), r.getValue());\n      rleSparseVector.removeInterval(r.getKey(), r.getValue());\n      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n          ZERO_RESOURCE)) {\n        earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n        latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n      }\n    }\n    if (resAlloc.isEmpty()) {\n      userResourceAlloc.remove(user);\n    }\n\n    RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n    resCount.removeInterval(new ReservationInterval(earliestActive,\n        latestActive), Resource.newInstance(1, 1));\n    if (resCount.isEmpty()) {\n      userActiveReservationCount.remove(user);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "0e602fa3a1529134214452fba10a90307d9c2072": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3800. Reduce storage footprint for ReservationAllocation. Contributed by Anubhav Dhoot.\n",
      "commitDate": "09/07/15 4:51 PM",
      "commitName": "0e602fa3a1529134214452fba10a90307d9c2072",
      "commitAuthor": "carlo curino",
      "commitDateOld": "03/10/14 3:43 PM",
      "commitNameOld": "a2986234be4e02f9ccb589f9ff5f7ffb28bc6400",
      "commitAuthorOld": "subru",
      "daysBetweenCommits": 279.05,
      "commitsBetweenForRepo": 2291,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,15 @@\n   private void decrementAllocation(ReservationAllocation reservation) {\n     assert (readWriteLock.isWriteLockedByCurrentThread());\n-    Map\u003cReservationInterval, ReservationRequest\u003e allocationRequests \u003d\n+    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         reservation.getAllocationRequests();\n     String user \u003d reservation.getUser();\n     RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n-    for (Map.Entry\u003cReservationInterval, ReservationRequest\u003e r : allocationRequests\n+    for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n         .entrySet()) {\n       resAlloc.removeInterval(r.getKey(), r.getValue());\n       rleSparseVector.removeInterval(r.getKey(), r.getValue());\n     }\n     if (resAlloc.isEmpty()) {\n       userResourceAlloc.remove(user);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void decrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    String user \u003d reservation.getUser();\n    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n    for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n        .entrySet()) {\n      resAlloc.removeInterval(r.getKey(), r.getValue());\n      rleSparseVector.removeInterval(r.getKey(), r.getValue());\n    }\n    if (resAlloc.isEmpty()) {\n      userResourceAlloc.remove(user);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "a2986234be4e02f9ccb589f9ff5f7ffb28bc6400": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2611. Fixing jenkins findbugs warning and TestRMWebServicesCapacitySched for branch YARN-1051. Contributed by Subru Krishnan and Carlo Curino.\n(cherry picked from commit c47464aba407d1dafe10be23fe454f0489cc4367)\n",
      "commitDate": "03/10/14 3:43 PM",
      "commitName": "a2986234be4e02f9ccb589f9ff5f7ffb28bc6400",
      "commitAuthor": "subru",
      "commitDateOld": "03/10/14 3:43 PM",
      "commitNameOld": "5e10a13bb4759984494c6a870c7f08fb6693c9c0",
      "commitAuthorOld": "subru",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,15 @@\n   private void decrementAllocation(ReservationAllocation reservation) {\n     assert (readWriteLock.isWriteLockedByCurrentThread());\n     Map\u003cReservationInterval, ReservationRequest\u003e allocationRequests \u003d\n         reservation.getAllocationRequests();\n     String user \u003d reservation.getUser();\n     RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n     for (Map.Entry\u003cReservationInterval, ReservationRequest\u003e r : allocationRequests\n         .entrySet()) {\n       resAlloc.removeInterval(r.getKey(), r.getValue());\n       rleSparseVector.removeInterval(r.getKey(), r.getValue());\n     }\n     if (resAlloc.isEmpty()) {\n-      userResourceAlloc.remove(resAlloc);\n+      userResourceAlloc.remove(user);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void decrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, ReservationRequest\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    String user \u003d reservation.getUser();\n    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n    for (Map.Entry\u003cReservationInterval, ReservationRequest\u003e r : allocationRequests\n        .entrySet()) {\n      resAlloc.removeInterval(r.getKey(), r.getValue());\n      rleSparseVector.removeInterval(r.getKey(), r.getValue());\n    }\n    if (resAlloc.isEmpty()) {\n      userResourceAlloc.remove(user);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1709. In-memory data structures used to track resources over time to enable reservations.\n(cherry picked from commit 0d8b2cd88b958b1e602fd4ea4078ef8d4742a7c3)\n",
      "commitDate": "03/10/14 3:41 PM",
      "commitName": "cf4b34282aafee9f6b09d3433c4de1ae4b359168",
      "commitAuthor": "subru",
      "diff": "@@ -0,0 +1,15 @@\n+  private void decrementAllocation(ReservationAllocation reservation) {\n+    assert (readWriteLock.isWriteLockedByCurrentThread());\n+    Map\u003cReservationInterval, ReservationRequest\u003e allocationRequests \u003d\n+        reservation.getAllocationRequests();\n+    String user \u003d reservation.getUser();\n+    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n+    for (Map.Entry\u003cReservationInterval, ReservationRequest\u003e r : allocationRequests\n+        .entrySet()) {\n+      resAlloc.removeInterval(r.getKey(), r.getValue());\n+      rleSparseVector.removeInterval(r.getKey(), r.getValue());\n+    }\n+    if (resAlloc.isEmpty()) {\n+      userResourceAlloc.remove(resAlloc);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void decrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, ReservationRequest\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    String user \u003d reservation.getUser();\n    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n    for (Map.Entry\u003cReservationInterval, ReservationRequest\u003e r : allocationRequests\n        .entrySet()) {\n      resAlloc.removeInterval(r.getKey(), r.getValue());\n      rleSparseVector.removeInterval(r.getKey(), r.getValue());\n    }\n    if (resAlloc.isEmpty()) {\n      userResourceAlloc.remove(resAlloc);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java"
    }
  }
}