{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "UnmanagedAMLauncher.java",
  "functionName": "launchAM",
  "functionId": "launchAM___attemptId-ApplicationAttemptId",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
  "functionStartLine": 179,
  "functionEndLine": 303,
  "numCommitsSeen": 24,
  "timeTaken": 2407,
  "changeHistory": [
    "9262797e86453fc04b7ca3710b73b21fcdf9e6b4",
    "d468c9aaf15e977f12e6214b47996412c907e069",
    "856b46cf47d3d17d3db2ca23106cb472aa8dd488",
    "ca3381de61ff53604d9389694049a1a4dedc7571",
    "43cd07b408c6613d2c9aa89203cfa3110d830538",
    "ef9634bf796807501e3c1937a8ea8a70205cb990",
    "817a6543465a3228cdb28a2eeb8e4f96a2d0f9e6",
    "f179afc68d863ea35f3ce5c06f1690fb7a4e8f02",
    "39f019f41392d9e46ea1dc86ddd5563aabbeda1e",
    "27e8c86999bc6a972a99216060b11ef35b7de858",
    "2aed48a67f408c290e90c83af9f76165d695f91a",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "3ef19e9dbd5995634aac9b4011765e1d889ea6f5"
  ],
  "changeHistoryShort": {
    "9262797e86453fc04b7ca3710b73b21fcdf9e6b4": "Ybodychange",
    "d468c9aaf15e977f12e6214b47996412c907e069": "Ybodychange",
    "856b46cf47d3d17d3db2ca23106cb472aa8dd488": "Ybodychange",
    "ca3381de61ff53604d9389694049a1a4dedc7571": "Ybodychange",
    "43cd07b408c6613d2c9aa89203cfa3110d830538": "Ybodychange",
    "ef9634bf796807501e3c1937a8ea8a70205cb990": "Ybodychange",
    "817a6543465a3228cdb28a2eeb8e4f96a2d0f9e6": "Ybodychange",
    "f179afc68d863ea35f3ce5c06f1690fb7a4e8f02": "Ymultichange(Yexceptionschange,Ybodychange)",
    "39f019f41392d9e46ea1dc86ddd5563aabbeda1e": "Ybodychange",
    "27e8c86999bc6a972a99216060b11ef35b7de858": "Ybodychange",
    "2aed48a67f408c290e90c83af9f76165d695f91a": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "3ef19e9dbd5995634aac9b4011765e1d889ea6f5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9262797e86453fc04b7ca3710b73b21fcdf9e6b4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5257. Fix unreleased resources and null dereferences (yufeigu via rkanter)\n",
      "commitDate": "27/12/16 2:14 PM",
      "commitName": "9262797e86453fc04b7ca3710b73b21fcdf9e6b4",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "23/12/14 8:04 PM",
      "commitNameOld": "d468c9aaf15e977f12e6214b47996412c907e069",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 734.76,
      "commitsBetweenForRepo": 5509,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   public void launchAM(ApplicationAttemptId attemptId) \n     throws IOException, YarnException {\n     Credentials credentials \u003d new Credentials();\n     Token\u003cAMRMTokenIdentifier\u003e token \u003d \n         rmClient.getAMRMToken(attemptId.getApplicationId());\n     // Service will be empty but that\u0027s okay, we are just passing down only\n     // AMRMToken down to the real AM which eventually sets the correct\n     // service-address.\n     credentials.addToken(token.getService(), token);\n     File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n         new File(System.getProperty(\"user.dir\")));\n     try {\n       FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n     } catch (InterruptedException ex) {\n       throw new RuntimeException(ex);\n     }\n     tokenFile.deleteOnExit();\n-    DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n-        true));\n-    credentials.writeTokenStorageToStream(os);\n-    os.close();\n-    \n+    try (DataOutputStream os \u003d new DataOutputStream(\n+        new FileOutputStream(tokenFile, true))) {\n+      credentials.writeTokenStorageToStream(os);\n+    }\n+\n     Map\u003cString, String\u003e env \u003d System.getenv();\n     ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n     boolean setClasspath \u003d false;\n     for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n       String key \u003d entry.getKey();\n       String value \u003d entry.getValue();\n       if(key.equals(\"CLASSPATH\")) {\n         setClasspath \u003d true;\n         if(classpath !\u003d null) {\n           value \u003d value + File.pathSeparator + classpath;\n         }\n       }\n       envAMList.add(key + \"\u003d\" + value);\n     }\n     \n     if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n       envAMList.add(\"CLASSPATH\u003d\"+classpath);\n     }\n     ContainerId containerId \u003d ContainerId.newContainerId(attemptId, 0);\n \n     String hostname \u003d InetAddress.getLocalHost().getHostName();\n     envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n     envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n     envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n     envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n         + System.currentTimeMillis());\n \n     envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n       tokenFile.getAbsolutePath());\n     \n     String[] envAM \u003d new String[envAMList.size()];\n     Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n \n     final BufferedReader errReader \u003d \n         new BufferedReader(new InputStreamReader(\n             amProc.getErrorStream(), Charset.forName(\"UTF-8\")));\n     final BufferedReader inReader \u003d \n         new BufferedReader(new InputStreamReader(\n             amProc.getInputStream(), Charset.forName(\"UTF-8\")));\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.err.println(line);\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     Thread outThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d inReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.out.println(line);\n             line \u003d inReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the out stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n       outThread.start();\n     } catch (IllegalStateException ise) { }\n \n     // wait for the process to finish and check the exit code\n     try {\n       int exitCode \u003d amProc.waitFor();\n       LOG.info(\"AM process exited with value: \" + exitCode);\n     } catch (InterruptedException e) {\n       e.printStackTrace();\n     } finally {\n       amCompleted \u003d true;\n     }\n     \n     try {\n       // make sure that the error thread exits\n       // on Windows these threads sometimes get stuck and hang the execution\n       // timeout and join later after destroying the process.\n       errThread.join();\n       outThread.join();\n       errReader.close();\n       inReader.close();\n     } catch (InterruptedException ie) {\n       LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n           ie);\n     } catch (IOException ioe) {\n       LOG.warn(\"Error while closing the error/out stream\", ioe);\n     }\n     amProc.destroy();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) \n    throws IOException, YarnException {\n    Credentials credentials \u003d new Credentials();\n    Token\u003cAMRMTokenIdentifier\u003e token \u003d \n        rmClient.getAMRMToken(attemptId.getApplicationId());\n    // Service will be empty but that\u0027s okay, we are just passing down only\n    // AMRMToken down to the real AM which eventually sets the correct\n    // service-address.\n    credentials.addToken(token.getService(), token);\n    File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n        new File(System.getProperty(\"user.dir\")));\n    try {\n      FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n    } catch (InterruptedException ex) {\n      throw new RuntimeException(ex);\n    }\n    tokenFile.deleteOnExit();\n    try (DataOutputStream os \u003d new DataOutputStream(\n        new FileOutputStream(tokenFile, true))) {\n      credentials.writeTokenStorageToStream(os);\n    }\n\n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n    ContainerId containerId \u003d ContainerId.newContainerId(attemptId, 0);\n\n    String hostname \u003d InetAddress.getLocalHost().getHostName();\n    envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n    envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n    envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n    envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n        + System.currentTimeMillis());\n\n    envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n      tokenFile.getAbsolutePath());\n    \n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(\n            amProc.getErrorStream(), Charset.forName(\"UTF-8\")));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(\n            amProc.getInputStream(), Charset.forName(\"UTF-8\")));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    } finally {\n      amCompleted \u003d true;\n    }\n    \n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "d468c9aaf15e977f12e6214b47996412c907e069": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2940. Fix new findbugs warnings in rest of the hadoop-yarn components. (Contributed by Li Lu)\n",
      "commitDate": "23/12/14 8:04 PM",
      "commitName": "d468c9aaf15e977f12e6214b47996412c907e069",
      "commitAuthor": "Junping Du",
      "commitDateOld": "23/12/14 8:02 PM",
      "commitNameOld": "856b46cf47d3d17d3db2ca23106cb472aa8dd488",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   public void launchAM(ApplicationAttemptId attemptId) \n     throws IOException, YarnException {\n     Credentials credentials \u003d new Credentials();\n     Token\u003cAMRMTokenIdentifier\u003e token \u003d \n         rmClient.getAMRMToken(attemptId.getApplicationId());\n     // Service will be empty but that\u0027s okay, we are just passing down only\n     // AMRMToken down to the real AM which eventually sets the correct\n     // service-address.\n     credentials.addToken(token.getService(), token);\n     File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n         new File(System.getProperty(\"user.dir\")));\n     try {\n       FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n     } catch (InterruptedException ex) {\n       throw new RuntimeException(ex);\n     }\n     tokenFile.deleteOnExit();\n     DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n         true));\n     credentials.writeTokenStorageToStream(os);\n     os.close();\n     \n     Map\u003cString, String\u003e env \u003d System.getenv();\n     ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n     boolean setClasspath \u003d false;\n     for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n       String key \u003d entry.getKey();\n       String value \u003d entry.getValue();\n       if(key.equals(\"CLASSPATH\")) {\n         setClasspath \u003d true;\n         if(classpath !\u003d null) {\n           value \u003d value + File.pathSeparator + classpath;\n         }\n       }\n       envAMList.add(key + \"\u003d\" + value);\n     }\n     \n     if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n       envAMList.add(\"CLASSPATH\u003d\"+classpath);\n     }\n     ContainerId containerId \u003d ContainerId.newContainerId(attemptId, 0);\n \n     String hostname \u003d InetAddress.getLocalHost().getHostName();\n     envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n     envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n     envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n     envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n         + System.currentTimeMillis());\n \n     envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n       tokenFile.getAbsolutePath());\n     \n     String[] envAM \u003d new String[envAMList.size()];\n     Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n \n     final BufferedReader errReader \u003d \n-        new BufferedReader(new InputStreamReader(amProc\n-                                                 .getErrorStream()));\n+        new BufferedReader(new InputStreamReader(\n+            amProc.getErrorStream(), Charset.forName(\"UTF-8\")));\n     final BufferedReader inReader \u003d \n-        new BufferedReader(new InputStreamReader(amProc\n-                                                 .getInputStream()));\n+        new BufferedReader(new InputStreamReader(\n+            amProc.getInputStream(), Charset.forName(\"UTF-8\")));\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.err.println(line);\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     Thread outThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d inReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.out.println(line);\n             line \u003d inReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the out stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n       outThread.start();\n     } catch (IllegalStateException ise) { }\n \n     // wait for the process to finish and check the exit code\n     try {\n       int exitCode \u003d amProc.waitFor();\n       LOG.info(\"AM process exited with value: \" + exitCode);\n     } catch (InterruptedException e) {\n       e.printStackTrace();\n     } finally {\n       amCompleted \u003d true;\n     }\n     \n     try {\n       // make sure that the error thread exits\n       // on Windows these threads sometimes get stuck and hang the execution\n       // timeout and join later after destroying the process.\n       errThread.join();\n       outThread.join();\n       errReader.close();\n       inReader.close();\n     } catch (InterruptedException ie) {\n       LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n           ie);\n     } catch (IOException ioe) {\n       LOG.warn(\"Error while closing the error/out stream\", ioe);\n     }\n     amProc.destroy();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) \n    throws IOException, YarnException {\n    Credentials credentials \u003d new Credentials();\n    Token\u003cAMRMTokenIdentifier\u003e token \u003d \n        rmClient.getAMRMToken(attemptId.getApplicationId());\n    // Service will be empty but that\u0027s okay, we are just passing down only\n    // AMRMToken down to the real AM which eventually sets the correct\n    // service-address.\n    credentials.addToken(token.getService(), token);\n    File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n        new File(System.getProperty(\"user.dir\")));\n    try {\n      FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n    } catch (InterruptedException ex) {\n      throw new RuntimeException(ex);\n    }\n    tokenFile.deleteOnExit();\n    DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n        true));\n    credentials.writeTokenStorageToStream(os);\n    os.close();\n    \n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n    ContainerId containerId \u003d ContainerId.newContainerId(attemptId, 0);\n\n    String hostname \u003d InetAddress.getLocalHost().getHostName();\n    envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n    envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n    envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n    envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n        + System.currentTimeMillis());\n\n    envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n      tokenFile.getAbsolutePath());\n    \n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(\n            amProc.getErrorStream(), Charset.forName(\"UTF-8\")));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(\n            amProc.getInputStream(), Charset.forName(\"UTF-8\")));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    } finally {\n      amCompleted \u003d true;\n    }\n    \n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "856b46cf47d3d17d3db2ca23106cb472aa8dd488": {
      "type": "Ybodychange",
      "commitMessage": "Revert ca3381de61ff53604d9389694049a1a4dedc7571 and 20674255ad891bb693ecb2faa5bdb37477073dac as missing JIRA number in commit message\n",
      "commitDate": "23/12/14 8:02 PM",
      "commitName": "856b46cf47d3d17d3db2ca23106cb472aa8dd488",
      "commitAuthor": "Junping Du",
      "commitDateOld": "23/12/14 6:57 PM",
      "commitNameOld": "ca3381de61ff53604d9389694049a1a4dedc7571",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   public void launchAM(ApplicationAttemptId attemptId) \n     throws IOException, YarnException {\n     Credentials credentials \u003d new Credentials();\n     Token\u003cAMRMTokenIdentifier\u003e token \u003d \n         rmClient.getAMRMToken(attemptId.getApplicationId());\n     // Service will be empty but that\u0027s okay, we are just passing down only\n     // AMRMToken down to the real AM which eventually sets the correct\n     // service-address.\n     credentials.addToken(token.getService(), token);\n     File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n         new File(System.getProperty(\"user.dir\")));\n     try {\n       FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n     } catch (InterruptedException ex) {\n       throw new RuntimeException(ex);\n     }\n     tokenFile.deleteOnExit();\n     DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n         true));\n     credentials.writeTokenStorageToStream(os);\n     os.close();\n     \n     Map\u003cString, String\u003e env \u003d System.getenv();\n     ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n     boolean setClasspath \u003d false;\n     for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n       String key \u003d entry.getKey();\n       String value \u003d entry.getValue();\n       if(key.equals(\"CLASSPATH\")) {\n         setClasspath \u003d true;\n         if(classpath !\u003d null) {\n           value \u003d value + File.pathSeparator + classpath;\n         }\n       }\n       envAMList.add(key + \"\u003d\" + value);\n     }\n     \n     if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n       envAMList.add(\"CLASSPATH\u003d\"+classpath);\n     }\n     ContainerId containerId \u003d ContainerId.newContainerId(attemptId, 0);\n \n     String hostname \u003d InetAddress.getLocalHost().getHostName();\n     envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n     envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n     envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n     envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n         + System.currentTimeMillis());\n \n     envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n       tokenFile.getAbsolutePath());\n     \n     String[] envAM \u003d new String[envAMList.size()];\n     Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n \n     final BufferedReader errReader \u003d \n-        new BufferedReader(new InputStreamReader(\n-            amProc.getErrorStream(), Charset.forName(\"UTF-8\")));\n+        new BufferedReader(new InputStreamReader(amProc\n+                                                 .getErrorStream()));\n     final BufferedReader inReader \u003d \n-        new BufferedReader(new InputStreamReader(\n-            amProc.getInputStream(), Charset.forName(\"UTF-8\")));\n+        new BufferedReader(new InputStreamReader(amProc\n+                                                 .getInputStream()));\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.err.println(line);\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     Thread outThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d inReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.out.println(line);\n             line \u003d inReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the out stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n       outThread.start();\n     } catch (IllegalStateException ise) { }\n \n     // wait for the process to finish and check the exit code\n     try {\n       int exitCode \u003d amProc.waitFor();\n       LOG.info(\"AM process exited with value: \" + exitCode);\n     } catch (InterruptedException e) {\n       e.printStackTrace();\n     } finally {\n       amCompleted \u003d true;\n     }\n     \n     try {\n       // make sure that the error thread exits\n       // on Windows these threads sometimes get stuck and hang the execution\n       // timeout and join later after destroying the process.\n       errThread.join();\n       outThread.join();\n       errReader.close();\n       inReader.close();\n     } catch (InterruptedException ie) {\n       LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n           ie);\n     } catch (IOException ioe) {\n       LOG.warn(\"Error while closing the error/out stream\", ioe);\n     }\n     amProc.destroy();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) \n    throws IOException, YarnException {\n    Credentials credentials \u003d new Credentials();\n    Token\u003cAMRMTokenIdentifier\u003e token \u003d \n        rmClient.getAMRMToken(attemptId.getApplicationId());\n    // Service will be empty but that\u0027s okay, we are just passing down only\n    // AMRMToken down to the real AM which eventually sets the correct\n    // service-address.\n    credentials.addToken(token.getService(), token);\n    File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n        new File(System.getProperty(\"user.dir\")));\n    try {\n      FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n    } catch (InterruptedException ex) {\n      throw new RuntimeException(ex);\n    }\n    tokenFile.deleteOnExit();\n    DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n        true));\n    credentials.writeTokenStorageToStream(os);\n    os.close();\n    \n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n    ContainerId containerId \u003d ContainerId.newContainerId(attemptId, 0);\n\n    String hostname \u003d InetAddress.getLocalHost().getHostName();\n    envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n    envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n    envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n    envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n        + System.currentTimeMillis());\n\n    envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n      tokenFile.getAbsolutePath());\n    \n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getErrorStream()));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getInputStream()));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    } finally {\n      amCompleted \u003d true;\n    }\n    \n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "ca3381de61ff53604d9389694049a1a4dedc7571": {
      "type": "Ybodychange",
      "commitMessage": "Fix new findbugs warnings in rest of the hadoop-yarn components. (Contributed by Li Lu)\n",
      "commitDate": "23/12/14 6:57 PM",
      "commitName": "ca3381de61ff53604d9389694049a1a4dedc7571",
      "commitAuthor": "Junping Du",
      "commitDateOld": "09/11/14 2:57 PM",
      "commitNameOld": "43cd07b408c6613d2c9aa89203cfa3110d830538",
      "commitAuthorOld": "Arun C. Murthy",
      "daysBetweenCommits": 44.17,
      "commitsBetweenForRepo": 318,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   public void launchAM(ApplicationAttemptId attemptId) \n     throws IOException, YarnException {\n     Credentials credentials \u003d new Credentials();\n     Token\u003cAMRMTokenIdentifier\u003e token \u003d \n         rmClient.getAMRMToken(attemptId.getApplicationId());\n     // Service will be empty but that\u0027s okay, we are just passing down only\n     // AMRMToken down to the real AM which eventually sets the correct\n     // service-address.\n     credentials.addToken(token.getService(), token);\n     File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n         new File(System.getProperty(\"user.dir\")));\n     try {\n       FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n     } catch (InterruptedException ex) {\n       throw new RuntimeException(ex);\n     }\n     tokenFile.deleteOnExit();\n     DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n         true));\n     credentials.writeTokenStorageToStream(os);\n     os.close();\n     \n     Map\u003cString, String\u003e env \u003d System.getenv();\n     ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n     boolean setClasspath \u003d false;\n     for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n       String key \u003d entry.getKey();\n       String value \u003d entry.getValue();\n       if(key.equals(\"CLASSPATH\")) {\n         setClasspath \u003d true;\n         if(classpath !\u003d null) {\n           value \u003d value + File.pathSeparator + classpath;\n         }\n       }\n       envAMList.add(key + \"\u003d\" + value);\n     }\n     \n     if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n       envAMList.add(\"CLASSPATH\u003d\"+classpath);\n     }\n     ContainerId containerId \u003d ContainerId.newContainerId(attemptId, 0);\n \n     String hostname \u003d InetAddress.getLocalHost().getHostName();\n     envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n     envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n     envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n     envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n         + System.currentTimeMillis());\n \n     envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n       tokenFile.getAbsolutePath());\n     \n     String[] envAM \u003d new String[envAMList.size()];\n     Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n \n     final BufferedReader errReader \u003d \n-        new BufferedReader(new InputStreamReader(amProc\n-                                                 .getErrorStream()));\n+        new BufferedReader(new InputStreamReader(\n+            amProc.getErrorStream(), Charset.forName(\"UTF-8\")));\n     final BufferedReader inReader \u003d \n-        new BufferedReader(new InputStreamReader(amProc\n-                                                 .getInputStream()));\n+        new BufferedReader(new InputStreamReader(\n+            amProc.getInputStream(), Charset.forName(\"UTF-8\")));\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.err.println(line);\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     Thread outThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d inReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.out.println(line);\n             line \u003d inReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the out stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n       outThread.start();\n     } catch (IllegalStateException ise) { }\n \n     // wait for the process to finish and check the exit code\n     try {\n       int exitCode \u003d amProc.waitFor();\n       LOG.info(\"AM process exited with value: \" + exitCode);\n     } catch (InterruptedException e) {\n       e.printStackTrace();\n     } finally {\n       amCompleted \u003d true;\n     }\n     \n     try {\n       // make sure that the error thread exits\n       // on Windows these threads sometimes get stuck and hang the execution\n       // timeout and join later after destroying the process.\n       errThread.join();\n       outThread.join();\n       errReader.close();\n       inReader.close();\n     } catch (InterruptedException ie) {\n       LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n           ie);\n     } catch (IOException ioe) {\n       LOG.warn(\"Error while closing the error/out stream\", ioe);\n     }\n     amProc.destroy();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) \n    throws IOException, YarnException {\n    Credentials credentials \u003d new Credentials();\n    Token\u003cAMRMTokenIdentifier\u003e token \u003d \n        rmClient.getAMRMToken(attemptId.getApplicationId());\n    // Service will be empty but that\u0027s okay, we are just passing down only\n    // AMRMToken down to the real AM which eventually sets the correct\n    // service-address.\n    credentials.addToken(token.getService(), token);\n    File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n        new File(System.getProperty(\"user.dir\")));\n    try {\n      FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n    } catch (InterruptedException ex) {\n      throw new RuntimeException(ex);\n    }\n    tokenFile.deleteOnExit();\n    DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n        true));\n    credentials.writeTokenStorageToStream(os);\n    os.close();\n    \n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n    ContainerId containerId \u003d ContainerId.newContainerId(attemptId, 0);\n\n    String hostname \u003d InetAddress.getLocalHost().getHostName();\n    envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n    envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n    envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n    envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n        + System.currentTimeMillis());\n\n    envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n      tokenFile.getAbsolutePath());\n    \n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(\n            amProc.getErrorStream(), Charset.forName(\"UTF-8\")));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(\n            amProc.getInputStream(), Charset.forName(\"UTF-8\")));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    } finally {\n      amCompleted \u003d true;\n    }\n    \n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "43cd07b408c6613d2c9aa89203cfa3110d830538": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2830. Add backwords compatible ContainerId.newInstance constructor. Contributed by Jonathan Eagles.\n",
      "commitDate": "09/11/14 2:57 PM",
      "commitName": "43cd07b408c6613d2c9aa89203cfa3110d830538",
      "commitAuthor": "Arun C. Murthy",
      "commitDateOld": "21/03/14 9:35 PM",
      "commitNameOld": "ef9634bf796807501e3c1937a8ea8a70205cb990",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 232.77,
      "commitsBetweenForRepo": 1900,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   public void launchAM(ApplicationAttemptId attemptId) \n     throws IOException, YarnException {\n     Credentials credentials \u003d new Credentials();\n     Token\u003cAMRMTokenIdentifier\u003e token \u003d \n         rmClient.getAMRMToken(attemptId.getApplicationId());\n     // Service will be empty but that\u0027s okay, we are just passing down only\n     // AMRMToken down to the real AM which eventually sets the correct\n     // service-address.\n     credentials.addToken(token.getService(), token);\n     File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n         new File(System.getProperty(\"user.dir\")));\n     try {\n       FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n     } catch (InterruptedException ex) {\n       throw new RuntimeException(ex);\n     }\n     tokenFile.deleteOnExit();\n     DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n         true));\n     credentials.writeTokenStorageToStream(os);\n     os.close();\n     \n     Map\u003cString, String\u003e env \u003d System.getenv();\n     ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n     boolean setClasspath \u003d false;\n     for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n       String key \u003d entry.getKey();\n       String value \u003d entry.getValue();\n       if(key.equals(\"CLASSPATH\")) {\n         setClasspath \u003d true;\n         if(classpath !\u003d null) {\n           value \u003d value + File.pathSeparator + classpath;\n         }\n       }\n       envAMList.add(key + \"\u003d\" + value);\n     }\n     \n     if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n       envAMList.add(\"CLASSPATH\u003d\"+classpath);\n     }\n-    ContainerId containerId \u003d ContainerId.newInstance(attemptId, 0);\n+    ContainerId containerId \u003d ContainerId.newContainerId(attemptId, 0);\n \n     String hostname \u003d InetAddress.getLocalHost().getHostName();\n     envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n     envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n     envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n     envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n         + System.currentTimeMillis());\n \n     envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n       tokenFile.getAbsolutePath());\n     \n     String[] envAM \u003d new String[envAMList.size()];\n     Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n \n     final BufferedReader errReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getErrorStream()));\n     final BufferedReader inReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getInputStream()));\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.err.println(line);\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     Thread outThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d inReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.out.println(line);\n             line \u003d inReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the out stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n       outThread.start();\n     } catch (IllegalStateException ise) { }\n \n     // wait for the process to finish and check the exit code\n     try {\n       int exitCode \u003d amProc.waitFor();\n       LOG.info(\"AM process exited with value: \" + exitCode);\n     } catch (InterruptedException e) {\n       e.printStackTrace();\n     } finally {\n       amCompleted \u003d true;\n     }\n     \n     try {\n       // make sure that the error thread exits\n       // on Windows these threads sometimes get stuck and hang the execution\n       // timeout and join later after destroying the process.\n       errThread.join();\n       outThread.join();\n       errReader.close();\n       inReader.close();\n     } catch (InterruptedException ie) {\n       LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n           ie);\n     } catch (IOException ioe) {\n       LOG.warn(\"Error while closing the error/out stream\", ioe);\n     }\n     amProc.destroy();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) \n    throws IOException, YarnException {\n    Credentials credentials \u003d new Credentials();\n    Token\u003cAMRMTokenIdentifier\u003e token \u003d \n        rmClient.getAMRMToken(attemptId.getApplicationId());\n    // Service will be empty but that\u0027s okay, we are just passing down only\n    // AMRMToken down to the real AM which eventually sets the correct\n    // service-address.\n    credentials.addToken(token.getService(), token);\n    File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n        new File(System.getProperty(\"user.dir\")));\n    try {\n      FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n    } catch (InterruptedException ex) {\n      throw new RuntimeException(ex);\n    }\n    tokenFile.deleteOnExit();\n    DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n        true));\n    credentials.writeTokenStorageToStream(os);\n    os.close();\n    \n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n    ContainerId containerId \u003d ContainerId.newContainerId(attemptId, 0);\n\n    String hostname \u003d InetAddress.getLocalHost().getHostName();\n    envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n    envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n    envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n    envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n        + System.currentTimeMillis());\n\n    envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n      tokenFile.getAbsolutePath());\n    \n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getErrorStream()));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getInputStream()));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    } finally {\n      amCompleted \u003d true;\n    }\n    \n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "ef9634bf796807501e3c1937a8ea8a70205cb990": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1577. Made UnmanagedAMLauncher do launchAM after the attempt reaches the LAUNCHED state. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580164 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/14 9:35 PM",
      "commitName": "ef9634bf796807501e3c1937a8ea8a70205cb990",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "29/07/13 4:17 PM",
      "commitNameOld": "817a6543465a3228cdb28a2eeb8e4f96a2d0f9e6",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 235.22,
      "commitsBetweenForRepo": 1630,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,125 @@\n   public void launchAM(ApplicationAttemptId attemptId) \n     throws IOException, YarnException {\n-    ApplicationReport report \u003d \n-      rmClient.getApplicationReport(attemptId.getApplicationId());\n-    if (report.getYarnApplicationState() !\u003d YarnApplicationState.ACCEPTED) {\n-      throw new YarnException(\n-          \"Umanaged AM must be in ACCEPTED state before launching\");\n-    }\n     Credentials credentials \u003d new Credentials();\n     Token\u003cAMRMTokenIdentifier\u003e token \u003d \n         rmClient.getAMRMToken(attemptId.getApplicationId());\n     // Service will be empty but that\u0027s okay, we are just passing down only\n     // AMRMToken down to the real AM which eventually sets the correct\n     // service-address.\n     credentials.addToken(token.getService(), token);\n     File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n         new File(System.getProperty(\"user.dir\")));\n     try {\n       FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n     } catch (InterruptedException ex) {\n       throw new RuntimeException(ex);\n     }\n     tokenFile.deleteOnExit();\n     DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n         true));\n     credentials.writeTokenStorageToStream(os);\n     os.close();\n     \n     Map\u003cString, String\u003e env \u003d System.getenv();\n     ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n     boolean setClasspath \u003d false;\n     for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n       String key \u003d entry.getKey();\n       String value \u003d entry.getValue();\n       if(key.equals(\"CLASSPATH\")) {\n         setClasspath \u003d true;\n         if(classpath !\u003d null) {\n           value \u003d value + File.pathSeparator + classpath;\n         }\n       }\n       envAMList.add(key + \"\u003d\" + value);\n     }\n     \n     if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n       envAMList.add(\"CLASSPATH\u003d\"+classpath);\n     }\n     ContainerId containerId \u003d ContainerId.newInstance(attemptId, 0);\n \n     String hostname \u003d InetAddress.getLocalHost().getHostName();\n     envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n     envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n     envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n     envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n         + System.currentTimeMillis());\n \n     envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n       tokenFile.getAbsolutePath());\n     \n     String[] envAM \u003d new String[envAMList.size()];\n     Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n \n     final BufferedReader errReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getErrorStream()));\n     final BufferedReader inReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getInputStream()));\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.err.println(line);\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     Thread outThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d inReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.out.println(line);\n             line \u003d inReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the out stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n       outThread.start();\n     } catch (IllegalStateException ise) { }\n \n     // wait for the process to finish and check the exit code\n     try {\n       int exitCode \u003d amProc.waitFor();\n       LOG.info(\"AM process exited with value: \" + exitCode);\n     } catch (InterruptedException e) {\n       e.printStackTrace();\n     } finally {\n       amCompleted \u003d true;\n     }\n     \n     try {\n       // make sure that the error thread exits\n       // on Windows these threads sometimes get stuck and hang the execution\n       // timeout and join later after destroying the process.\n       errThread.join();\n       outThread.join();\n       errReader.close();\n       inReader.close();\n     } catch (InterruptedException ie) {\n       LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n           ie);\n     } catch (IOException ioe) {\n       LOG.warn(\"Error while closing the error/out stream\", ioe);\n     }\n     amProc.destroy();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) \n    throws IOException, YarnException {\n    Credentials credentials \u003d new Credentials();\n    Token\u003cAMRMTokenIdentifier\u003e token \u003d \n        rmClient.getAMRMToken(attemptId.getApplicationId());\n    // Service will be empty but that\u0027s okay, we are just passing down only\n    // AMRMToken down to the real AM which eventually sets the correct\n    // service-address.\n    credentials.addToken(token.getService(), token);\n    File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n        new File(System.getProperty(\"user.dir\")));\n    try {\n      FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n    } catch (InterruptedException ex) {\n      throw new RuntimeException(ex);\n    }\n    tokenFile.deleteOnExit();\n    DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n        true));\n    credentials.writeTokenStorageToStream(os);\n    os.close();\n    \n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n    ContainerId containerId \u003d ContainerId.newInstance(attemptId, 0);\n\n    String hostname \u003d InetAddress.getLocalHost().getHostName();\n    envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n    envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n    envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n    envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n        + System.currentTimeMillis());\n\n    envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n      tokenFile.getAbsolutePath());\n    \n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getErrorStream()));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getInputStream()));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    } finally {\n      amCompleted \u003d true;\n    }\n    \n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "817a6543465a3228cdb28a2eeb8e4f96a2d0f9e6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-945. Removed setting of AMRMToken\u0027s service from ResourceManager and changed client libraries do it all the time and correctly. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508232 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 4:17 PM",
      "commitName": "817a6543465a3228cdb28a2eeb8e4f96a2d0f9e6",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/07/13 1:04 PM",
      "commitNameOld": "f179afc68d863ea35f3ce5c06f1690fb7a4e8f02",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 2.13,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,128 +1,131 @@\n   public void launchAM(ApplicationAttemptId attemptId) \n     throws IOException, YarnException {\n     ApplicationReport report \u003d \n       rmClient.getApplicationReport(attemptId.getApplicationId());\n     if (report.getYarnApplicationState() !\u003d YarnApplicationState.ACCEPTED) {\n       throw new YarnException(\n           \"Umanaged AM must be in ACCEPTED state before launching\");\n     }\n     Credentials credentials \u003d new Credentials();\n     Token\u003cAMRMTokenIdentifier\u003e token \u003d \n         rmClient.getAMRMToken(attemptId.getApplicationId());\n+    // Service will be empty but that\u0027s okay, we are just passing down only\n+    // AMRMToken down to the real AM which eventually sets the correct\n+    // service-address.\n     credentials.addToken(token.getService(), token);\n     File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n         new File(System.getProperty(\"user.dir\")));\n     try {\n       FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n     } catch (InterruptedException ex) {\n       throw new RuntimeException(ex);\n     }\n     tokenFile.deleteOnExit();\n     DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n         true));\n     credentials.writeTokenStorageToStream(os);\n     os.close();\n     \n     Map\u003cString, String\u003e env \u003d System.getenv();\n     ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n     boolean setClasspath \u003d false;\n     for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n       String key \u003d entry.getKey();\n       String value \u003d entry.getValue();\n       if(key.equals(\"CLASSPATH\")) {\n         setClasspath \u003d true;\n         if(classpath !\u003d null) {\n           value \u003d value + File.pathSeparator + classpath;\n         }\n       }\n       envAMList.add(key + \"\u003d\" + value);\n     }\n     \n     if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n       envAMList.add(\"CLASSPATH\u003d\"+classpath);\n     }\n     ContainerId containerId \u003d ContainerId.newInstance(attemptId, 0);\n \n     String hostname \u003d InetAddress.getLocalHost().getHostName();\n     envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n     envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n     envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n     envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n         + System.currentTimeMillis());\n \n     envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n       tokenFile.getAbsolutePath());\n     \n     String[] envAM \u003d new String[envAMList.size()];\n     Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n \n     final BufferedReader errReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getErrorStream()));\n     final BufferedReader inReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getInputStream()));\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.err.println(line);\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     Thread outThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d inReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.out.println(line);\n             line \u003d inReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the out stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n       outThread.start();\n     } catch (IllegalStateException ise) { }\n \n     // wait for the process to finish and check the exit code\n     try {\n       int exitCode \u003d amProc.waitFor();\n       LOG.info(\"AM process exited with value: \" + exitCode);\n     } catch (InterruptedException e) {\n       e.printStackTrace();\n     } finally {\n       amCompleted \u003d true;\n     }\n     \n     try {\n       // make sure that the error thread exits\n       // on Windows these threads sometimes get stuck and hang the execution\n       // timeout and join later after destroying the process.\n       errThread.join();\n       outThread.join();\n       errReader.close();\n       inReader.close();\n     } catch (InterruptedException ie) {\n       LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n           ie);\n     } catch (IOException ioe) {\n       LOG.warn(\"Error while closing the error/out stream\", ioe);\n     }\n     amProc.destroy();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) \n    throws IOException, YarnException {\n    ApplicationReport report \u003d \n      rmClient.getApplicationReport(attemptId.getApplicationId());\n    if (report.getYarnApplicationState() !\u003d YarnApplicationState.ACCEPTED) {\n      throw new YarnException(\n          \"Umanaged AM must be in ACCEPTED state before launching\");\n    }\n    Credentials credentials \u003d new Credentials();\n    Token\u003cAMRMTokenIdentifier\u003e token \u003d \n        rmClient.getAMRMToken(attemptId.getApplicationId());\n    // Service will be empty but that\u0027s okay, we are just passing down only\n    // AMRMToken down to the real AM which eventually sets the correct\n    // service-address.\n    credentials.addToken(token.getService(), token);\n    File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n        new File(System.getProperty(\"user.dir\")));\n    try {\n      FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n    } catch (InterruptedException ex) {\n      throw new RuntimeException(ex);\n    }\n    tokenFile.deleteOnExit();\n    DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n        true));\n    credentials.writeTokenStorageToStream(os);\n    os.close();\n    \n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n    ContainerId containerId \u003d ContainerId.newInstance(attemptId, 0);\n\n    String hostname \u003d InetAddress.getLocalHost().getHostName();\n    envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n    envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n    envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n    envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n        + System.currentTimeMillis());\n\n    envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n      tokenFile.getAbsolutePath());\n    \n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getErrorStream()));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getInputStream()));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    } finally {\n      amCompleted \u003d true;\n    }\n    \n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "f179afc68d863ea35f3ce5c06f1690fb7a4e8f02": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-937. Fix unmanaged AM in non-secure/secure setup post YARN-701. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1507706 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/07/13 1:04 PM",
      "commitName": "f179afc68d863ea35f3ce5c06f1690fb7a4e8f02",
      "commitAuthor": "Alejandro Abdelnur",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-937. Fix unmanaged AM in non-secure/secure setup post YARN-701. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1507706 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/07/13 1:04 PM",
          "commitName": "f179afc68d863ea35f3ce5c06f1690fb7a4e8f02",
          "commitAuthor": "Alejandro Abdelnur",
          "commitDateOld": "19/06/13 12:06 AM",
          "commitNameOld": "d3198dddc8c66139cbb57b3c3c061a3d0d2c6a5d",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 38.54,
          "commitsBetweenForRepo": 206,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,101 +1,128 @@\n-  public void launchAM(ApplicationAttemptId attemptId) throws IOException {\n+  public void launchAM(ApplicationAttemptId attemptId) \n+    throws IOException, YarnException {\n+    ApplicationReport report \u003d \n+      rmClient.getApplicationReport(attemptId.getApplicationId());\n+    if (report.getYarnApplicationState() !\u003d YarnApplicationState.ACCEPTED) {\n+      throw new YarnException(\n+          \"Umanaged AM must be in ACCEPTED state before launching\");\n+    }\n+    Credentials credentials \u003d new Credentials();\n+    Token\u003cAMRMTokenIdentifier\u003e token \u003d \n+        rmClient.getAMRMToken(attemptId.getApplicationId());\n+    credentials.addToken(token.getService(), token);\n+    File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n+        new File(System.getProperty(\"user.dir\")));\n+    try {\n+      FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n+    } catch (InterruptedException ex) {\n+      throw new RuntimeException(ex);\n+    }\n+    tokenFile.deleteOnExit();\n+    DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n+        true));\n+    credentials.writeTokenStorageToStream(os);\n+    os.close();\n+    \n     Map\u003cString, String\u003e env \u003d System.getenv();\n     ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n     boolean setClasspath \u003d false;\n     for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n       String key \u003d entry.getKey();\n       String value \u003d entry.getValue();\n       if(key.equals(\"CLASSPATH\")) {\n         setClasspath \u003d true;\n         if(classpath !\u003d null) {\n           value \u003d value + File.pathSeparator + classpath;\n         }\n       }\n       envAMList.add(key + \"\u003d\" + value);\n     }\n     \n     if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n       envAMList.add(\"CLASSPATH\u003d\"+classpath);\n     }\n     ContainerId containerId \u003d ContainerId.newInstance(attemptId, 0);\n \n     String hostname \u003d InetAddress.getLocalHost().getHostName();\n     envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n     envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n     envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n     envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n         + System.currentTimeMillis());\n \n+    envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n+      tokenFile.getAbsolutePath());\n+    \n     String[] envAM \u003d new String[envAMList.size()];\n     Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n \n     final BufferedReader errReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getErrorStream()));\n     final BufferedReader inReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getInputStream()));\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.err.println(line);\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     Thread outThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d inReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.out.println(line);\n             line \u003d inReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the out stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n       outThread.start();\n     } catch (IllegalStateException ise) { }\n \n     // wait for the process to finish and check the exit code\n     try {\n       int exitCode \u003d amProc.waitFor();\n       LOG.info(\"AM process exited with value: \" + exitCode);\n     } catch (InterruptedException e) {\n       e.printStackTrace();\n     } finally {\n       amCompleted \u003d true;\n     }\n     \n     try {\n       // make sure that the error thread exits\n       // on Windows these threads sometimes get stuck and hang the execution\n       // timeout and join later after destroying the process.\n       errThread.join();\n       outThread.join();\n       errReader.close();\n       inReader.close();\n     } catch (InterruptedException ie) {\n       LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n           ie);\n     } catch (IOException ioe) {\n       LOG.warn(\"Error while closing the error/out stream\", ioe);\n     }\n     amProc.destroy();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) \n    throws IOException, YarnException {\n    ApplicationReport report \u003d \n      rmClient.getApplicationReport(attemptId.getApplicationId());\n    if (report.getYarnApplicationState() !\u003d YarnApplicationState.ACCEPTED) {\n      throw new YarnException(\n          \"Umanaged AM must be in ACCEPTED state before launching\");\n    }\n    Credentials credentials \u003d new Credentials();\n    Token\u003cAMRMTokenIdentifier\u003e token \u003d \n        rmClient.getAMRMToken(attemptId.getApplicationId());\n    credentials.addToken(token.getService(), token);\n    File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n        new File(System.getProperty(\"user.dir\")));\n    try {\n      FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n    } catch (InterruptedException ex) {\n      throw new RuntimeException(ex);\n    }\n    tokenFile.deleteOnExit();\n    DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n        true));\n    credentials.writeTokenStorageToStream(os);\n    os.close();\n    \n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n    ContainerId containerId \u003d ContainerId.newInstance(attemptId, 0);\n\n    String hostname \u003d InetAddress.getLocalHost().getHostName();\n    envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n    envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n    envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n    envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n        + System.currentTimeMillis());\n\n    envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n      tokenFile.getAbsolutePath());\n    \n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getErrorStream()));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getInputStream()));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    } finally {\n      amCompleted \u003d true;\n    }\n    \n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[IOException, YarnException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-937. Fix unmanaged AM in non-secure/secure setup post YARN-701. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1507706 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/07/13 1:04 PM",
          "commitName": "f179afc68d863ea35f3ce5c06f1690fb7a4e8f02",
          "commitAuthor": "Alejandro Abdelnur",
          "commitDateOld": "19/06/13 12:06 AM",
          "commitNameOld": "d3198dddc8c66139cbb57b3c3c061a3d0d2c6a5d",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 38.54,
          "commitsBetweenForRepo": 206,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,101 +1,128 @@\n-  public void launchAM(ApplicationAttemptId attemptId) throws IOException {\n+  public void launchAM(ApplicationAttemptId attemptId) \n+    throws IOException, YarnException {\n+    ApplicationReport report \u003d \n+      rmClient.getApplicationReport(attemptId.getApplicationId());\n+    if (report.getYarnApplicationState() !\u003d YarnApplicationState.ACCEPTED) {\n+      throw new YarnException(\n+          \"Umanaged AM must be in ACCEPTED state before launching\");\n+    }\n+    Credentials credentials \u003d new Credentials();\n+    Token\u003cAMRMTokenIdentifier\u003e token \u003d \n+        rmClient.getAMRMToken(attemptId.getApplicationId());\n+    credentials.addToken(token.getService(), token);\n+    File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n+        new File(System.getProperty(\"user.dir\")));\n+    try {\n+      FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n+    } catch (InterruptedException ex) {\n+      throw new RuntimeException(ex);\n+    }\n+    tokenFile.deleteOnExit();\n+    DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n+        true));\n+    credentials.writeTokenStorageToStream(os);\n+    os.close();\n+    \n     Map\u003cString, String\u003e env \u003d System.getenv();\n     ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n     boolean setClasspath \u003d false;\n     for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n       String key \u003d entry.getKey();\n       String value \u003d entry.getValue();\n       if(key.equals(\"CLASSPATH\")) {\n         setClasspath \u003d true;\n         if(classpath !\u003d null) {\n           value \u003d value + File.pathSeparator + classpath;\n         }\n       }\n       envAMList.add(key + \"\u003d\" + value);\n     }\n     \n     if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n       envAMList.add(\"CLASSPATH\u003d\"+classpath);\n     }\n     ContainerId containerId \u003d ContainerId.newInstance(attemptId, 0);\n \n     String hostname \u003d InetAddress.getLocalHost().getHostName();\n     envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n     envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n     envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n     envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n         + System.currentTimeMillis());\n \n+    envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n+      tokenFile.getAbsolutePath());\n+    \n     String[] envAM \u003d new String[envAMList.size()];\n     Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n \n     final BufferedReader errReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getErrorStream()));\n     final BufferedReader inReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getInputStream()));\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.err.println(line);\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     Thread outThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d inReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.out.println(line);\n             line \u003d inReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the out stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n       outThread.start();\n     } catch (IllegalStateException ise) { }\n \n     // wait for the process to finish and check the exit code\n     try {\n       int exitCode \u003d amProc.waitFor();\n       LOG.info(\"AM process exited with value: \" + exitCode);\n     } catch (InterruptedException e) {\n       e.printStackTrace();\n     } finally {\n       amCompleted \u003d true;\n     }\n     \n     try {\n       // make sure that the error thread exits\n       // on Windows these threads sometimes get stuck and hang the execution\n       // timeout and join later after destroying the process.\n       errThread.join();\n       outThread.join();\n       errReader.close();\n       inReader.close();\n     } catch (InterruptedException ie) {\n       LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n           ie);\n     } catch (IOException ioe) {\n       LOG.warn(\"Error while closing the error/out stream\", ioe);\n     }\n     amProc.destroy();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) \n    throws IOException, YarnException {\n    ApplicationReport report \u003d \n      rmClient.getApplicationReport(attemptId.getApplicationId());\n    if (report.getYarnApplicationState() !\u003d YarnApplicationState.ACCEPTED) {\n      throw new YarnException(\n          \"Umanaged AM must be in ACCEPTED state before launching\");\n    }\n    Credentials credentials \u003d new Credentials();\n    Token\u003cAMRMTokenIdentifier\u003e token \u003d \n        rmClient.getAMRMToken(attemptId.getApplicationId());\n    credentials.addToken(token.getService(), token);\n    File tokenFile \u003d File.createTempFile(\"unmanagedAMRMToken\",\"\", \n        new File(System.getProperty(\"user.dir\")));\n    try {\n      FileUtil.chmod(tokenFile.getAbsolutePath(), \"600\");\n    } catch (InterruptedException ex) {\n      throw new RuntimeException(ex);\n    }\n    tokenFile.deleteOnExit();\n    DataOutputStream os \u003d new DataOutputStream(new FileOutputStream(tokenFile, \n        true));\n    credentials.writeTokenStorageToStream(os);\n    os.close();\n    \n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n    ContainerId containerId \u003d ContainerId.newInstance(attemptId, 0);\n\n    String hostname \u003d InetAddress.getLocalHost().getHostName();\n    envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n    envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n    envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n    envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n        + System.currentTimeMillis());\n\n    envAMList.add(ApplicationConstants.CONTAINER_TOKEN_FILE_ENV_NAME + \"\u003d\" + \n      tokenFile.getAbsolutePath());\n    \n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getErrorStream()));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getInputStream()));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    } finally {\n      amCompleted \u003d true;\n    }\n    \n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
          "extendedDetails": {}
        }
      ]
    },
    "39f019f41392d9e46ea1dc86ddd5563aabbeda1e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-735. Make ApplicationAttemptId, ContainerId and NodeId immutable. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488439 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/05/13 5:14 PM",
      "commitName": "39f019f41392d9e46ea1dc86ddd5563aabbeda1e",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "08/05/13 3:53 PM",
      "commitNameOld": "0727ecaf50481fa7a529398bc2a12ce18c9a6b43",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 23.06,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,101 @@\n   public void launchAM(ApplicationAttemptId attemptId) throws IOException {\n     Map\u003cString, String\u003e env \u003d System.getenv();\n     ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n     boolean setClasspath \u003d false;\n     for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n       String key \u003d entry.getKey();\n       String value \u003d entry.getValue();\n       if(key.equals(\"CLASSPATH\")) {\n         setClasspath \u003d true;\n         if(classpath !\u003d null) {\n           value \u003d value + File.pathSeparator + classpath;\n         }\n       }\n       envAMList.add(key + \"\u003d\" + value);\n     }\n     \n     if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n       envAMList.add(\"CLASSPATH\u003d\"+classpath);\n     }\n-\n-    ContainerId containerId \u003d Records.newRecord(ContainerId.class);\n-    containerId.setApplicationAttemptId(attemptId);\n-    containerId.setId(0);\n+    ContainerId containerId \u003d ContainerId.newInstance(attemptId, 0);\n \n     String hostname \u003d InetAddress.getLocalHost().getHostName();\n     envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n     envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n     envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n     envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n     envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n         + System.currentTimeMillis());\n \n     String[] envAM \u003d new String[envAMList.size()];\n     Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n \n     final BufferedReader errReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getErrorStream()));\n     final BufferedReader inReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getInputStream()));\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.err.println(line);\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     Thread outThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d inReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.out.println(line);\n             line \u003d inReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the out stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n       outThread.start();\n     } catch (IllegalStateException ise) { }\n \n     // wait for the process to finish and check the exit code\n     try {\n       int exitCode \u003d amProc.waitFor();\n       LOG.info(\"AM process exited with value: \" + exitCode);\n     } catch (InterruptedException e) {\n       e.printStackTrace();\n     } finally {\n       amCompleted \u003d true;\n     }\n     \n     try {\n       // make sure that the error thread exits\n       // on Windows these threads sometimes get stuck and hang the execution\n       // timeout and join later after destroying the process.\n       errThread.join();\n       outThread.join();\n       errReader.close();\n       inReader.close();\n     } catch (InterruptedException ie) {\n       LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n           ie);\n     } catch (IOException ioe) {\n       LOG.warn(\"Error while closing the error/out stream\", ioe);\n     }\n     amProc.destroy();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) throws IOException {\n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n    ContainerId containerId \u003d ContainerId.newInstance(attemptId, 0);\n\n    String hostname \u003d InetAddress.getLocalHost().getHostName();\n    envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n    envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n    envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n    envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n        + System.currentTimeMillis());\n\n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getErrorStream()));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getInputStream()));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    } finally {\n      amCompleted \u003d true;\n    }\n    \n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "27e8c86999bc6a972a99216060b11ef35b7de858": {
      "type": "Ybodychange",
      "commitMessage": "YARN-561. Modified NodeManager to set key information into the environment of every container that it launches. Contributed by Xuan Gong.\nMAPREDUCE-5175. Updated MR App to not set envs that will be set by NMs anyways after YARN-561. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1471156 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/13 2:39 PM",
      "commitName": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/03/13 12:17 PM",
      "commitNameOld": "aa634e0814e89ebdcd993b8db1447dd168241658",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 23.1,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,104 @@\n   public void launchAM(ApplicationAttemptId attemptId) throws IOException {\n     Map\u003cString, String\u003e env \u003d System.getenv();\n     ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n     boolean setClasspath \u003d false;\n     for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n       String key \u003d entry.getKey();\n       String value \u003d entry.getValue();\n       if(key.equals(\"CLASSPATH\")) {\n         setClasspath \u003d true;\n         if(classpath !\u003d null) {\n           value \u003d value + File.pathSeparator + classpath;\n         }\n       }\n       envAMList.add(key + \"\u003d\" + value);\n     }\n     \n     if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n       envAMList.add(\"CLASSPATH\u003d\"+classpath);\n     }\n \n     ContainerId containerId \u003d Records.newRecord(ContainerId.class);\n     containerId.setApplicationAttemptId(attemptId);\n     containerId.setId(0);\n \n     String hostname \u003d InetAddress.getLocalHost().getHostName();\n-    envAMList.add(ApplicationConstants.AM_CONTAINER_ID_ENV + \"\u003d\" + containerId);\n-    envAMList.add(ApplicationConstants.NM_HOST_ENV + \"\u003d\" + hostname);\n-    envAMList.add(ApplicationConstants.NM_HTTP_PORT_ENV + \"\u003d0\");\n-    envAMList.add(ApplicationConstants.NM_PORT_ENV + \"\u003d0\");\n+    envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n+    envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n+    envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n+    envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n+    envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n     envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n         + System.currentTimeMillis());\n \n     String[] envAM \u003d new String[envAMList.size()];\n     Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n \n     final BufferedReader errReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getErrorStream()));\n     final BufferedReader inReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getInputStream()));\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.err.println(line);\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     Thread outThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d inReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.out.println(line);\n             line \u003d inReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the out stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n       outThread.start();\n     } catch (IllegalStateException ise) { }\n \n     // wait for the process to finish and check the exit code\n     try {\n       int exitCode \u003d amProc.waitFor();\n       LOG.info(\"AM process exited with value: \" + exitCode);\n     } catch (InterruptedException e) {\n       e.printStackTrace();\n     } finally {\n       amCompleted \u003d true;\n     }\n     \n     try {\n       // make sure that the error thread exits\n       // on Windows these threads sometimes get stuck and hang the execution\n       // timeout and join later after destroying the process.\n       errThread.join();\n       outThread.join();\n       errReader.close();\n       inReader.close();\n     } catch (InterruptedException ie) {\n       LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n           ie);\n     } catch (IOException ioe) {\n       LOG.warn(\"Error while closing the error/out stream\", ioe);\n     }\n     amProc.destroy();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) throws IOException {\n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n\n    ContainerId containerId \u003d Records.newRecord(ContainerId.class);\n    containerId.setApplicationAttemptId(attemptId);\n    containerId.setId(0);\n\n    String hostname \u003d InetAddress.getLocalHost().getHostName();\n    envAMList.add(Environment.CONTAINER_ID.name() + \"\u003d\" + containerId);\n    envAMList.add(Environment.NM_HOST.name() + \"\u003d\" + hostname);\n    envAMList.add(Environment.NM_HTTP_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.NM_PORT.name() + \"\u003d0\");\n    envAMList.add(Environment.LOCAL_DIRS.name() + \"\u003d /tmp\");\n    envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n        + System.currentTimeMillis());\n\n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getErrorStream()));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getInputStream()));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    } finally {\n      amCompleted \u003d true;\n    }\n    \n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "2aed48a67f408c290e90c83af9f76165d695f91a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-498. Unmanaged AM launcher does not set various constants in env for an AM, also does not handle failed AMs properly (Hitesh Shah via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1460954 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/13 7:34 PM",
      "commitName": "2aed48a67f408c290e90c83af9f76165d695f91a",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "23/10/12 2:06 PM",
      "commitNameOld": "88d326f0a411442b75d1a95425f150621b51da59",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 153.23,
      "commitsBetweenForRepo": 693,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,103 @@\n   public void launchAM(ApplicationAttemptId attemptId) throws IOException {\n     Map\u003cString, String\u003e env \u003d System.getenv();\n     ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n     boolean setClasspath \u003d false;\n     for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n       String key \u003d entry.getKey();\n       String value \u003d entry.getValue();\n       if(key.equals(\"CLASSPATH\")) {\n         setClasspath \u003d true;\n         if(classpath !\u003d null) {\n           value \u003d value + File.pathSeparator + classpath;\n         }\n       }\n       envAMList.add(key + \"\u003d\" + value);\n     }\n     \n     if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n       envAMList.add(\"CLASSPATH\u003d\"+classpath);\n     }\n-        \n-    envAMList.add(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV + \"\u003d\" + attemptId);\n+\n+    ContainerId containerId \u003d Records.newRecord(ContainerId.class);\n+    containerId.setApplicationAttemptId(attemptId);\n+    containerId.setId(0);\n+\n+    String hostname \u003d InetAddress.getLocalHost().getHostName();\n+    envAMList.add(ApplicationConstants.AM_CONTAINER_ID_ENV + \"\u003d\" + containerId);\n+    envAMList.add(ApplicationConstants.NM_HOST_ENV + \"\u003d\" + hostname);\n+    envAMList.add(ApplicationConstants.NM_HTTP_PORT_ENV + \"\u003d0\");\n+    envAMList.add(ApplicationConstants.NM_PORT_ENV + \"\u003d0\");\n+    envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n+        + System.currentTimeMillis());\n \n     String[] envAM \u003d new String[envAMList.size()];\n     Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n \n     final BufferedReader errReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getErrorStream()));\n     final BufferedReader inReader \u003d \n         new BufferedReader(new InputStreamReader(amProc\n                                                  .getInputStream()));\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.err.println(line);\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     Thread outThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d inReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             System.out.println(line);\n             line \u003d inReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the out stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n       outThread.start();\n     } catch (IllegalStateException ise) { }\n \n     // wait for the process to finish and check the exit code\n     try {\n       int exitCode \u003d amProc.waitFor();\n       LOG.info(\"AM process exited with value: \" + exitCode);\n     } catch (InterruptedException e) {\n       e.printStackTrace();\n+    } finally {\n+      amCompleted \u003d true;\n     }\n-\n+    \n     try {\n       // make sure that the error thread exits\n       // on Windows these threads sometimes get stuck and hang the execution\n       // timeout and join later after destroying the process.\n       errThread.join();\n       outThread.join();\n       errReader.close();\n       inReader.close();\n     } catch (InterruptedException ie) {\n       LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n           ie);\n     } catch (IOException ioe) {\n       LOG.warn(\"Error while closing the error/out stream\", ioe);\n     }\n     amProc.destroy();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) throws IOException {\n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n\n    ContainerId containerId \u003d Records.newRecord(ContainerId.class);\n    containerId.setApplicationAttemptId(attemptId);\n    containerId.setId(0);\n\n    String hostname \u003d InetAddress.getLocalHost().getHostName();\n    envAMList.add(ApplicationConstants.AM_CONTAINER_ID_ENV + \"\u003d\" + containerId);\n    envAMList.add(ApplicationConstants.NM_HOST_ENV + \"\u003d\" + hostname);\n    envAMList.add(ApplicationConstants.NM_HTTP_PORT_ENV + \"\u003d0\");\n    envAMList.add(ApplicationConstants.NM_PORT_ENV + \"\u003d0\");\n    envAMList.add(ApplicationConstants.APP_SUBMIT_TIME_ENV + \"\u003d\"\n        + System.currentTimeMillis());\n\n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getErrorStream()));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getInputStream()));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    } finally {\n      amCompleted \u003d true;\n    }\n    \n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) throws IOException {\n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n        \n    envAMList.add(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV + \"\u003d\" + attemptId);\n\n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getErrorStream()));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getInputStream()));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n\n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java"
      }
    },
    "3ef19e9dbd5995634aac9b4011765e1d889ea6f5": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-4438. Add a simple, generic client to run \u0027easy\u0027 AMs in YARN. Contributed by Bikas Saha.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1365185 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/07/12 10:33 AM",
      "commitName": "3ef19e9dbd5995634aac9b4011765e1d889ea6f5",
      "commitAuthor": "Arun Murthy",
      "diff": "@@ -0,0 +1,91 @@\n+  public void launchAM(ApplicationAttemptId attemptId) throws IOException {\n+    Map\u003cString, String\u003e env \u003d System.getenv();\n+    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n+    boolean setClasspath \u003d false;\n+    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n+      String key \u003d entry.getKey();\n+      String value \u003d entry.getValue();\n+      if(key.equals(\"CLASSPATH\")) {\n+        setClasspath \u003d true;\n+        if(classpath !\u003d null) {\n+          value \u003d value + File.pathSeparator + classpath;\n+        }\n+      }\n+      envAMList.add(key + \"\u003d\" + value);\n+    }\n+    \n+    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n+      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n+    }\n+        \n+    envAMList.add(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV + \"\u003d\" + attemptId);\n+\n+    String[] envAM \u003d new String[envAMList.size()];\n+    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n+\n+    final BufferedReader errReader \u003d \n+        new BufferedReader(new InputStreamReader(amProc\n+                                                 .getErrorStream()));\n+    final BufferedReader inReader \u003d \n+        new BufferedReader(new InputStreamReader(amProc\n+                                                 .getInputStream()));\n+    \n+    // read error and input streams as this would free up the buffers\n+    // free the error stream buffer\n+    Thread errThread \u003d new Thread() {\n+      @Override\n+      public void run() {\n+        try {\n+          String line \u003d errReader.readLine();\n+          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n+            System.err.println(line);\n+            line \u003d errReader.readLine();\n+          }\n+        } catch(IOException ioe) {\n+          LOG.warn(\"Error reading the error stream\", ioe);\n+        }\n+      }\n+    };\n+    Thread outThread \u003d new Thread() {\n+      @Override\n+      public void run() {\n+        try {\n+          String line \u003d inReader.readLine();\n+          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n+            System.out.println(line);\n+            line \u003d inReader.readLine();\n+          }\n+        } catch(IOException ioe) {\n+          LOG.warn(\"Error reading the out stream\", ioe);\n+        }\n+      }\n+    };\n+    try {\n+      errThread.start();\n+      outThread.start();\n+    } catch (IllegalStateException ise) { }\n+\n+    // wait for the process to finish and check the exit code\n+    try {\n+      int exitCode \u003d amProc.waitFor();\n+      LOG.info(\"AM process exited with value: \" + exitCode);\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+\n+    try {\n+      // make sure that the error thread exits\n+      // on Windows these threads sometimes get stuck and hang the execution\n+      // timeout and join later after destroying the process.\n+      errThread.join();\n+      outThread.join();\n+      errReader.close();\n+      inReader.close();\n+    } catch (InterruptedException ie) {\n+      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n+          ie);\n+    } catch (IOException ioe) {\n+      LOG.warn(\"Error while closing the error/out stream\", ioe);\n+    }\n+    amProc.destroy();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchAM(ApplicationAttemptId attemptId) throws IOException {\n    Map\u003cString, String\u003e env \u003d System.getenv();\n    ArrayList\u003cString\u003e envAMList \u003d new ArrayList\u003cString\u003e();\n    boolean setClasspath \u003d false;\n    for (Map.Entry\u003cString, String\u003e entry : env.entrySet()) {\n      String key \u003d entry.getKey();\n      String value \u003d entry.getValue();\n      if(key.equals(\"CLASSPATH\")) {\n        setClasspath \u003d true;\n        if(classpath !\u003d null) {\n          value \u003d value + File.pathSeparator + classpath;\n        }\n      }\n      envAMList.add(key + \"\u003d\" + value);\n    }\n    \n    if(!setClasspath \u0026\u0026 classpath!\u003dnull) {\n      envAMList.add(\"CLASSPATH\u003d\"+classpath);\n    }\n        \n    envAMList.add(ApplicationConstants.AM_APP_ATTEMPT_ID_ENV + \"\u003d\" + attemptId);\n\n    String[] envAM \u003d new String[envAMList.size()];\n    Process amProc \u003d Runtime.getRuntime().exec(amCmd, envAMList.toArray(envAM));\n\n    final BufferedReader errReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getErrorStream()));\n    final BufferedReader inReader \u003d \n        new BufferedReader(new InputStreamReader(amProc\n                                                 .getInputStream()));\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.err.println(line);\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    Thread outThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d inReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            System.out.println(line);\n            line \u003d inReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the out stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n      outThread.start();\n    } catch (IllegalStateException ise) { }\n\n    // wait for the process to finish and check the exit code\n    try {\n      int exitCode \u003d amProc.waitFor();\n      LOG.info(\"AM process exited with value: \" + exitCode);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n\n    try {\n      // make sure that the error thread exits\n      // on Windows these threads sometimes get stuck and hang the execution\n      // timeout and join later after destroying the process.\n      errThread.join();\n      outThread.join();\n      errReader.close();\n      inReader.close();\n    } catch (InterruptedException ie) {\n      LOG.info(\"ShellExecutor: Interrupted while reading the error/out stream\",\n          ie);\n    } catch (IOException ioe) {\n      LOG.warn(\"Error while closing the error/out stream\", ioe);\n    }\n    amProc.destroy();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java"
    }
  }
}