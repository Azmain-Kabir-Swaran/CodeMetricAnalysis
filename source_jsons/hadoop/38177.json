{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FifoCandidatesSelector.java",
  "functionName": "preemptFrom",
  "functionId": "preemptFrom___app-FiCaSchedulerApp__clusterResource-Resource__resToObtainByPartition-Map__String,Resource____skippedAMContainerlist-List__RMContainer____skippedAMSize-Resource__selectedContainers-Map__ApplicationAttemptId,Set__RMContainer______curCandidates-Map__ApplicationAttemptId,Set__RMContainer______totalPreemptionAllowed-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
  "functionStartLine": 208,
  "functionEndLine": 278,
  "numCommitsSeen": 64,
  "timeTaken": 9211,
  "changeHistory": [
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
    "8d5509c68156faaa6641f4e747fc9ff80adccf88",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
    "60e4116bf1d00afed91010e57357fe54057e4e39",
    "ae14e5d07f1b6702a5160637438028bb03d9387e",
    "fa7a43529d529f0006c8033c2003f15b9b93f103",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff",
    "adf260a728df427eb729abe8fb9ad7248991ea54",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
    "0e4b06690ff51fbde3ab26f68fde8aeb32af69af",
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
    "0a2d3e717d9c42090a32ff177991a222a1e34132",
    "03a25d2cc1a2fb124d00edf874d67e329c65a5e6",
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61"
  ],
  "changeHistoryShort": {
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": "Ymultichange(Yparameterchange,Ybodychange)",
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": "Ybodychange",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": "Ybodychange",
    "60e4116bf1d00afed91010e57357fe54057e4e39": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
    "ae14e5d07f1b6702a5160637438028bb03d9387e": "Ybodychange",
    "fa7a43529d529f0006c8033c2003f15b9b93f103": "Ybodychange",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": "Ybodychange",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": "Ybodychange",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": "Ybodychange",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": "Ybodychange",
    "adf260a728df427eb729abe8fb9ad7248991ea54": "Ybodychange",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": "Ybodychange",
    "0e4b06690ff51fbde3ab26f68fde8aeb32af69af": "Ybodychange",
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "0a2d3e717d9c42090a32ff177991a222a1e34132": "Ybodychange",
    "03a25d2cc1a2fb124d00edf874d67e329c65a5e6": "Ymultichange(Yparameterchange,Ybodychange)",
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61": "Yintroduced"
  },
  "changeHistoryDetails": {
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
      "commitDate": "28/06/18 10:23 AM",
      "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
      "commitAuthor": "Sunil G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
          "commitDate": "28/06/18 10:23 AM",
          "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
          "commitAuthor": "Sunil G",
          "commitDateOld": "25/05/18 9:06 AM",
          "commitNameOld": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
          "commitAuthorOld": "Eric E Payne",
          "daysBetweenCommits": 34.05,
          "commitsBetweenForRepo": 228,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,71 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n       Resource totalPreemptionAllowed) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003c\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedContainers)) {\n         continue;\n       }\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n-      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n-          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n-          selectedContainers, totalPreemptionAllowed, false);\n+     CapacitySchedulerPreemptionUtils\n+          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n+              resToObtainByPartition, c, clusterResource, selectedContainers,\n+              curCandidates, totalPreemptionAllowed, false);\n \n       if (!preemptionContext.isObserveOnly()) {\n         preemptionContext.getRMContext().getDispatcher().getEventHandler()\n             .handle(new ContainerPreemptEvent(appId, c,\n                 SchedulerEventType.KILL_RESERVED_CONTAINER));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n     List\u003cRMContainer\u003e liveContainers \u003d\n         new ArrayList\u003c\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedContainers)) {\n         continue;\n       }\n \n       // Skip already marked to killable containers\n       if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n           .getKillableContainers().contains(c.getContainerId())) {\n         continue;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n       // Try to preempt this container\n-      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n-          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n-          selectedContainers, totalPreemptionAllowed, false);\n+      CapacitySchedulerPreemptionUtils\n+          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n+              resToObtainByPartition, c, clusterResource, selectedContainers,\n+              curCandidates, totalPreemptionAllowed, false);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003c\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n     CapacitySchedulerPreemptionUtils\n          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n              resToObtainByPartition, c, clusterResource, selectedContainers,\n              curCandidates, totalPreemptionAllowed, false);\n\n      if (!preemptionContext.isObserveOnly()) {\n        preemptionContext.getRMContext().getDispatcher().getEventHandler()\n            .handle(new ContainerPreemptEvent(appId, c,\n                SchedulerEventType.KILL_RESERVED_CONTAINER));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n        new ArrayList\u003c\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      CapacitySchedulerPreemptionUtils\n          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n              resToObtainByPartition, c, clusterResource, selectedContainers,\n              curCandidates, totalPreemptionAllowed, false);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
          "extendedDetails": {
            "oldValue": "[app-FiCaSchedulerApp, clusterResource-Resource, resToObtainByPartition-Map\u003cString,Resource\u003e, skippedAMContainerlist-List\u003cRMContainer\u003e, skippedAMSize-Resource, selectedContainers-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, totalPreemptionAllowed-Resource]",
            "newValue": "[app-FiCaSchedulerApp, clusterResource-Resource, resToObtainByPartition-Map\u003cString,Resource\u003e, skippedAMContainerlist-List\u003cRMContainer\u003e, skippedAMSize-Resource, selectedContainers-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, curCandidates-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, totalPreemptionAllowed-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
          "commitDate": "28/06/18 10:23 AM",
          "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
          "commitAuthor": "Sunil G",
          "commitDateOld": "25/05/18 9:06 AM",
          "commitNameOld": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
          "commitAuthorOld": "Eric E Payne",
          "daysBetweenCommits": 34.05,
          "commitsBetweenForRepo": 228,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,71 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n       Resource totalPreemptionAllowed) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003c\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedContainers)) {\n         continue;\n       }\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n-      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n-          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n-          selectedContainers, totalPreemptionAllowed, false);\n+     CapacitySchedulerPreemptionUtils\n+          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n+              resToObtainByPartition, c, clusterResource, selectedContainers,\n+              curCandidates, totalPreemptionAllowed, false);\n \n       if (!preemptionContext.isObserveOnly()) {\n         preemptionContext.getRMContext().getDispatcher().getEventHandler()\n             .handle(new ContainerPreemptEvent(appId, c,\n                 SchedulerEventType.KILL_RESERVED_CONTAINER));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n     List\u003cRMContainer\u003e liveContainers \u003d\n         new ArrayList\u003c\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedContainers)) {\n         continue;\n       }\n \n       // Skip already marked to killable containers\n       if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n           .getKillableContainers().contains(c.getContainerId())) {\n         continue;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n       // Try to preempt this container\n-      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n-          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n-          selectedContainers, totalPreemptionAllowed, false);\n+      CapacitySchedulerPreemptionUtils\n+          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n+              resToObtainByPartition, c, clusterResource, selectedContainers,\n+              curCandidates, totalPreemptionAllowed, false);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003c\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n     CapacitySchedulerPreemptionUtils\n          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n              resToObtainByPartition, c, clusterResource, selectedContainers,\n              curCandidates, totalPreemptionAllowed, false);\n\n      if (!preemptionContext.isObserveOnly()) {\n        preemptionContext.getRMContext().getDispatcher().getEventHandler()\n            .handle(new ContainerPreemptEvent(appId, c,\n                SchedulerEventType.KILL_RESERVED_CONTAINER));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n        new ArrayList\u003c\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      CapacitySchedulerPreemptionUtils\n          .tryPreemptContainerAndDeductResToObtain(rc, preemptionContext,\n              resToObtainByPartition, c, clusterResource, selectedContainers,\n              curCandidates, totalPreemptionAllowed, false);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
          "extendedDetails": {}
        }
      ]
    },
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8292: Fix the dominant resource preemption cannot happen when some of the resource vector becomes negative. Contributed by Wangda Tan.\n",
      "commitDate": "25/05/18 9:06 AM",
      "commitName": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
      "commitAuthor": "Eric E Payne",
      "commitDateOld": "07/12/17 6:56 PM",
      "commitNameOld": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 168.55,
      "commitsBetweenForRepo": 1747,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n       Resource totalPreemptionAllowed) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003c\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedContainers)) {\n         continue;\n       }\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n       CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n           rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n-          selectedContainers, totalPreemptionAllowed);\n+          selectedContainers, totalPreemptionAllowed, false);\n \n       if (!preemptionContext.isObserveOnly()) {\n         preemptionContext.getRMContext().getDispatcher().getEventHandler()\n             .handle(new ContainerPreemptEvent(appId, c,\n                 SchedulerEventType.KILL_RESERVED_CONTAINER));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n     List\u003cRMContainer\u003e liveContainers \u003d\n         new ArrayList\u003c\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedContainers)) {\n         continue;\n       }\n \n       // Skip already marked to killable containers\n       if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n           .getKillableContainers().contains(c.getContainerId())) {\n         continue;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n       // Try to preempt this container\n       CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n           rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n-          selectedContainers, totalPreemptionAllowed);\n+          selectedContainers, totalPreemptionAllowed, false);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003c\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n          selectedContainers, totalPreemptionAllowed, false);\n\n      if (!preemptionContext.isObserveOnly()) {\n        preemptionContext.getRMContext().getDispatcher().getEventHandler()\n            .handle(new ContainerPreemptEvent(appId, c,\n                SchedulerEventType.KILL_RESERVED_CONTAINER));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n        new ArrayList\u003c\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n          selectedContainers, totalPreemptionAllowed, false);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
      "extendedDetails": {}
    },
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
      "commitDate": "31/10/16 3:18 PM",
      "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/07/16 2:54 PM",
      "commitNameOld": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 97.02,
      "commitsBetweenForRepo": 698,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,68 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n       Resource totalPreemptionAllowed) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n-          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n-    }\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003c\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedContainers)) {\n         continue;\n       }\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n-      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n-          clusterResource, selectedContainers, totalPreemptionAllowed);\n+      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n+          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n+          selectedContainers, totalPreemptionAllowed);\n \n       if (!preemptionContext.isObserveOnly()) {\n         preemptionContext.getRMContext().getDispatcher().getEventHandler()\n             .handle(new ContainerPreemptEvent(appId, c,\n                 SchedulerEventType.KILL_RESERVED_CONTAINER));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n     List\u003cRMContainer\u003e liveContainers \u003d\n         new ArrayList\u003c\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n           selectedContainers)) {\n         continue;\n       }\n \n       // Skip already marked to killable containers\n       if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n           .getKillableContainers().contains(c.getContainerId())) {\n         continue;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n       // Try to preempt this container\n-      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n-          clusterResource, selectedContainers, totalPreemptionAllowed);\n+      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n+          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n+          selectedContainers, totalPreemptionAllowed);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003c\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n          selectedContainers, totalPreemptionAllowed);\n\n      if (!preemptionContext.isObserveOnly()) {\n        preemptionContext.getRMContext().getDispatcher().getEventHandler()\n            .handle(new ContainerPreemptEvent(appId, c,\n                SchedulerEventType.KILL_RESERVED_CONTAINER));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n        new ArrayList\u003c\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      CapacitySchedulerPreemptionUtils.tryPreemptContainerAndDeductResToObtain(\n          rc, preemptionContext, resToObtainByPartition, c, clusterResource,\n          selectedContainers, totalPreemptionAllowed);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
      "extendedDetails": {}
    },
    "60e4116bf1d00afed91010e57357fe54057e4e39": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
      "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
      "commitDate": "30/03/16 12:43 PM",
      "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
          "commitDate": "30/03/16 12:43 PM",
          "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
          "commitAuthor": "Jian He",
          "commitDateOld": "29/03/16 11:22 PM",
          "commitNameOld": "09d63d5a192b5d6b172f94ff6c94da348fd49ea6",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 0.56,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,70 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n-      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n+      Resource totalPreemptionAllowed) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n           + \" resourceToObtain\u003d\" + resToObtainByPartition);\n     }\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003c\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n+      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n+          selectedContainers)) {\n+        continue;\n+      }\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n-          clusterResource, preemptMap);\n+          clusterResource, selectedContainers, totalPreemptionAllowed);\n \n-      if (!observeOnly) {\n-        rmContext.getDispatcher().getEventHandler().handle(\n-            new ContainerPreemptEvent(\n-                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n+      if (!preemptionContext.isObserveOnly()) {\n+        preemptionContext.getRMContext().getDispatcher().getEventHandler()\n+            .handle(new ContainerPreemptEvent(appId, c,\n+                SchedulerEventType.KILL_RESERVED_CONTAINER));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n-    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n+    List\u003cRMContainer\u003e liveContainers \u003d\n+        new ArrayList\u003c\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n+      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n+          selectedContainers)) {\n+        continue;\n+      }\n+\n+      // Skip already marked to killable containers\n+      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n+          .getKillableContainers().contains(c.getContainerId())) {\n+        continue;\n+      }\n+\n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n-      // Skip already marked to killable containers\n-      if (killableContainers.contains(c.getContainerId())) {\n-        continue;\n-      }\n-\n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n-          clusterResource, preemptMap);\n+          clusterResource, selectedContainers, totalPreemptionAllowed);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003c\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, selectedContainers, totalPreemptionAllowed);\n\n      if (!preemptionContext.isObserveOnly()) {\n        preemptionContext.getRMContext().getDispatcher().getEventHandler()\n            .handle(new ContainerPreemptEvent(appId, c,\n                SchedulerEventType.KILL_RESERVED_CONTAINER));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n        new ArrayList\u003c\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, selectedContainers, totalPreemptionAllowed);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
            "oldMethodName": "preemptFrom",
            "newMethodName": "preemptFrom"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
          "commitDate": "30/03/16 12:43 PM",
          "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
          "commitAuthor": "Jian He",
          "commitDateOld": "29/03/16 11:22 PM",
          "commitNameOld": "09d63d5a192b5d6b172f94ff6c94da348fd49ea6",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 0.56,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,70 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n-      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n+      Resource totalPreemptionAllowed) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n           + \" resourceToObtain\u003d\" + resToObtainByPartition);\n     }\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003c\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n+      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n+          selectedContainers)) {\n+        continue;\n+      }\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n-          clusterResource, preemptMap);\n+          clusterResource, selectedContainers, totalPreemptionAllowed);\n \n-      if (!observeOnly) {\n-        rmContext.getDispatcher().getEventHandler().handle(\n-            new ContainerPreemptEvent(\n-                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n+      if (!preemptionContext.isObserveOnly()) {\n+        preemptionContext.getRMContext().getDispatcher().getEventHandler()\n+            .handle(new ContainerPreemptEvent(appId, c,\n+                SchedulerEventType.KILL_RESERVED_CONTAINER));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n-    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n+    List\u003cRMContainer\u003e liveContainers \u003d\n+        new ArrayList\u003c\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n+      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n+          selectedContainers)) {\n+        continue;\n+      }\n+\n+      // Skip already marked to killable containers\n+      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n+          .getKillableContainers().contains(c.getContainerId())) {\n+        continue;\n+      }\n+\n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n-      // Skip already marked to killable containers\n-      if (killableContainers.contains(c.getContainerId())) {\n-        continue;\n-      }\n-\n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n-          clusterResource, preemptMap);\n+          clusterResource, selectedContainers, totalPreemptionAllowed);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003c\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, selectedContainers, totalPreemptionAllowed);\n\n      if (!preemptionContext.isObserveOnly()) {\n        preemptionContext.getRMContext().getDispatcher().getEventHandler()\n            .handle(new ContainerPreemptEvent(appId, c,\n                SchedulerEventType.KILL_RESERVED_CONTAINER));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n        new ArrayList\u003c\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, selectedContainers, totalPreemptionAllowed);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
          "commitDate": "30/03/16 12:43 PM",
          "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
          "commitAuthor": "Jian He",
          "commitDateOld": "29/03/16 11:22 PM",
          "commitNameOld": "09d63d5a192b5d6b172f94ff6c94da348fd49ea6",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 0.56,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,70 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n-      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n+      Resource totalPreemptionAllowed) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n           + \" resourceToObtain\u003d\" + resToObtainByPartition);\n     }\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003c\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n+      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n+          selectedContainers)) {\n+        continue;\n+      }\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n-          clusterResource, preemptMap);\n+          clusterResource, selectedContainers, totalPreemptionAllowed);\n \n-      if (!observeOnly) {\n-        rmContext.getDispatcher().getEventHandler().handle(\n-            new ContainerPreemptEvent(\n-                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n+      if (!preemptionContext.isObserveOnly()) {\n+        preemptionContext.getRMContext().getDispatcher().getEventHandler()\n+            .handle(new ContainerPreemptEvent(appId, c,\n+                SchedulerEventType.KILL_RESERVED_CONTAINER));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n-    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n+    List\u003cRMContainer\u003e liveContainers \u003d\n+        new ArrayList\u003c\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n+      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n+          selectedContainers)) {\n+        continue;\n+      }\n+\n+      // Skip already marked to killable containers\n+      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n+          .getKillableContainers().contains(c.getContainerId())) {\n+        continue;\n+      }\n+\n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n-      // Skip already marked to killable containers\n-      if (killableContainers.contains(c.getContainerId())) {\n-        continue;\n-      }\n-\n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n-          clusterResource, preemptMap);\n+          clusterResource, selectedContainers, totalPreemptionAllowed);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedContainers,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003c\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, selectedContainers, totalPreemptionAllowed);\n\n      if (!preemptionContext.isObserveOnly()) {\n        preemptionContext.getRMContext().getDispatcher().getEventHandler()\n            .handle(new ContainerPreemptEvent(appId, c,\n                SchedulerEventType.KILL_RESERVED_CONTAINER));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n        new ArrayList\u003c\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n          selectedContainers)) {\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (null !\u003d preemptionContext.getKillableContainers() \u0026\u0026 preemptionContext\n          .getKillableContainers().contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, selectedContainers, totalPreemptionAllowed);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
          "extendedDetails": {
            "oldValue": "[app-FiCaSchedulerApp, clusterResource-Resource, resToObtainByPartition-Map\u003cString,Resource\u003e, skippedAMContainerlist-List\u003cRMContainer\u003e, skippedAMSize-Resource, preemptMap-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e]",
            "newValue": "[app-FiCaSchedulerApp, clusterResource-Resource, resToObtainByPartition-Map\u003cString,Resource\u003e, skippedAMContainerlist-List\u003cRMContainer\u003e, skippedAMSize-Resource, selectedContainers-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, totalPreemptionAllowed-Resource]"
          }
        }
      ]
    },
    "ae14e5d07f1b6702a5160637438028bb03d9387e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4108. CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n\n(cherry picked from commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913)\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "ae14e5d07f1b6702a5160637438028bb03d9387e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 5:02 PM",
      "commitNameOld": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,58 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n           + \" resourceToObtain\u003d\" + resToObtainByPartition);\n     }\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n-        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n+        new ArrayList\u003c\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n \n       if (!observeOnly) {\n         rmContext.getDispatcher().getEventHandler().handle(\n             new ContainerPreemptEvent(\n                 appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n-    List\u003cRMContainer\u003e liveContainers \u003d\n-      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n+    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n+      // Skip already marked to killable containers\n+      if (killableContainers.contains(c.getContainerId())) {\n+        continue;\n+      }\n+\n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003c\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n\n      if (!observeOnly) {\n        rmContext.getDispatcher().getEventHandler().handle(\n            new ContainerPreemptEvent(\n                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (killableContainers.contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "fa7a43529d529f0006c8033c2003f15b9b93f103": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\"\n\nThis reverts commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913.\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 4:59 PM",
      "commitNameOld": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,54 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n           + \" resourceToObtain\u003d\" + resToObtainByPartition);\n     }\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n-        new ArrayList\u003c\u003e(app.getReservedContainers());\n+        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n \n       if (!observeOnly) {\n         rmContext.getDispatcher().getEventHandler().handle(\n             new ContainerPreemptEvent(\n                 appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n-    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n+    List\u003cRMContainer\u003e liveContainers \u003d\n+      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n-      // Skip already marked to killable containers\n-      if (killableContainers.contains(c.getContainerId())) {\n-        continue;\n-      }\n-\n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n\n      if (!observeOnly) {\n        rmContext.getDispatcher().getEventHandler().handle(\n            new ContainerPreemptEvent(\n                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": {
      "type": "Ybodychange",
      "commitMessage": "CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n",
      "commitDate": "16/03/16 4:59 PM",
      "commitName": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 5:30 PM",
      "commitNameOld": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 57.94,
      "commitsBetweenForRepo": 394,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,58 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n           + \" resourceToObtain\u003d\" + resToObtainByPartition);\n     }\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n-        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n+        new ArrayList\u003c\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n \n       if (!observeOnly) {\n         rmContext.getDispatcher().getEventHandler().handle(\n             new ContainerPreemptEvent(\n                 appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n-    List\u003cRMContainer\u003e liveContainers \u003d\n-      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n+    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n+      // Skip already marked to killable containers\n+      if (killableContainers.contains(c.getContainerId())) {\n+        continue;\n+      }\n+\n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003c\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n\n      if (!observeOnly) {\n        rmContext.getDispatcher().getEventHandler().handle(\n            new ContainerPreemptEvent(\n                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d new ArrayList\u003c\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Skip already marked to killable containers\n      if (killableContainers.contains(c.getContainerId())) {\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "18/01/16 5:30 PM",
      "commitName": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 5:27 PM",
      "commitNameOld": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n           + \" resourceToObtain\u003d\" + resToObtainByPartition);\n     }\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n \n       if (!observeOnly) {\n         rmContext.getDispatcher().getEventHandler().handle(\n             new ContainerPreemptEvent(\n-                appId, c, SchedulerEventType.DROP_RESERVATION));\n+                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n     List\u003cRMContainer\u003e liveContainers \u003d\n       new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n\n      if (!observeOnly) {\n        rmContext.getDispatcher().getEventHandler().handle(\n            new ContainerPreemptEvent(\n                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 3fe57285635e8058c34aa40a103845b49ca7d6ff.\n\nConflicts:\n\thadoop-yarn-project/CHANGES.txt\n",
      "commitDate": "18/01/16 5:27 PM",
      "commitName": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 1:58 AM",
      "commitNameOld": "d40859fab1ad977636457a6cc96b6a4f9b903afc",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 0.65,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n           + \" resourceToObtain\u003d\" + resToObtainByPartition);\n     }\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n \n       if (!observeOnly) {\n         rmContext.getDispatcher().getEventHandler().handle(\n             new ContainerPreemptEvent(\n-                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n+                appId, c, SchedulerEventType.DROP_RESERVATION));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n     List\u003cRMContainer\u003e liveContainers \u003d\n       new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n\n      if (!observeOnly) {\n        rmContext.getDispatcher().getEventHandler().handle(\n            new ContainerPreemptEvent(\n                appId, c, SchedulerEventType.DROP_RESERVATION));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n\n(cherry picked from commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579)\n",
      "commitDate": "18/01/16 1:06 AM",
      "commitName": "3fe57285635e8058c34aa40a103845b49ca7d6ff",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 12:50 AM",
      "commitNameOld": "adf260a728df427eb729abe8fb9ad7248991ea54",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n           + \" resourceToObtain\u003d\" + resToObtainByPartition);\n     }\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n \n       if (!observeOnly) {\n         rmContext.getDispatcher().getEventHandler().handle(\n             new ContainerPreemptEvent(\n-                appId, c, SchedulerEventType.DROP_RESERVATION));\n+                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n     List\u003cRMContainer\u003e liveContainers \u003d\n       new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n\n      if (!observeOnly) {\n        rmContext.getDispatcher().getEventHandler().handle(\n            new ContainerPreemptEvent(\n                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "adf260a728df427eb729abe8fb9ad7248991ea54": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579.\n",
      "commitDate": "18/01/16 12:50 AM",
      "commitName": "adf260a728df427eb729abe8fb9ad7248991ea54",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/01/16 7:04 PM",
      "commitNameOld": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n           + \" resourceToObtain\u003d\" + resToObtainByPartition);\n     }\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n \n       if (!observeOnly) {\n         rmContext.getDispatcher().getEventHandler().handle(\n             new ContainerPreemptEvent(\n-                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n+                appId, c, SchedulerEventType.DROP_RESERVATION));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n     List\u003cRMContainer\u003e liveContainers \u003d\n       new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n\n      if (!observeOnly) {\n        rmContext.getDispatcher().getEventHandler().handle(\n            new ContainerPreemptEvent(\n                appId, c, SchedulerEventType.DROP_RESERVATION));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "17/01/16 7:04 PM",
      "commitName": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "20/11/15 3:55 PM",
      "commitNameOld": "2346fa3141bf28f25a90b6a426a1d3a3982e464f",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 58.13,
      "commitsBetweenForRepo": 350,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n           + \" resourceToObtain\u003d\" + resToObtainByPartition);\n     }\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n \n       if (!observeOnly) {\n         rmContext.getDispatcher().getEventHandler().handle(\n             new ContainerPreemptEvent(\n-                appId, c, SchedulerEventType.DROP_RESERVATION));\n+                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n     List\u003cRMContainer\u003e liveContainers \u003d\n       new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n\n      if (!observeOnly) {\n        rmContext.getDispatcher().getEventHandler().handle(\n            new ContainerPreemptEvent(\n                appId, c, SchedulerEventType.KILL_RESERVED_CONTAINER));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "0e4b06690ff51fbde3ab26f68fde8aeb32af69af": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3508. Prevent processing preemption events on the main RM dispatcher. (Varun Saxena via wangda)\n",
      "commitDate": "01/07/15 5:32 PM",
      "commitName": "0e4b06690ff51fbde3ab26f68fde8aeb32af69af",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "24/04/15 5:03 PM",
      "commitNameOld": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 68.02,
      "commitsBetweenForRepo": 597,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,54 @@\n   private void preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n           + \" resourceToObtain\u003d\" + resToObtainByPartition);\n     }\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n     for (RMContainer c : reservedContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n \n       if (!observeOnly) {\n-        dispatcher.handle(new ContainerPreemptEvent(appId, c,\n-            ContainerPreemptEventType.DROP_RESERVATION));\n+        rmContext.getDispatcher().getEventHandler().handle(\n+            new ContainerPreemptEvent(\n+                appId, c, SchedulerEventType.DROP_RESERVATION));\n       }\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n     List\u003cRMContainer\u003e liveContainers \u003d\n       new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n \n     sortContainers(liveContainers);\n \n     for (RMContainer c : liveContainers) {\n       if (resToObtainByPartition.isEmpty()) {\n         return;\n       }\n \n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n \n       // Try to preempt this container\n       tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n           clusterResource, preemptMap);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n\n      if (!observeOnly) {\n        rmContext.getDispatcher().getEventHandler().handle(\n            new ContainerPreemptEvent(\n                appId, c, SchedulerEventType.DROP_RESERVATION));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-2498. Respect labels in preemption policy of capacity scheduler for inter-queue preemption. Contributed by Wangda Tan\n",
      "commitDate": "24/04/15 5:03 PM",
      "commitName": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2498. Respect labels in preemption policy of capacity scheduler for inter-queue preemption. Contributed by Wangda Tan\n",
          "commitDate": "24/04/15 5:03 PM",
          "commitName": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
          "commitAuthor": "Jian He",
          "commitDateOld": "20/04/15 5:12 PM",
          "commitNameOld": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.99,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,53 @@\n-  private Set\u003cRMContainer\u003e preemptFrom(FiCaSchedulerApp app,\n-      Resource clusterResource, Resource rsrcPreempt,\n-      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize) {\n-    Set\u003cRMContainer\u003e ret \u003d new HashSet\u003cRMContainer\u003e();\n+  private void preemptFrom(FiCaSchedulerApp app,\n+      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n+      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n+          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n+    }\n \n     // first drop reserved containers towards rsrcPreempt\n-    List\u003cRMContainer\u003e reservations \u003d\n+    List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n-    for (RMContainer c : reservations) {\n-      if (Resources.lessThanOrEqual(rc, clusterResource,\n-          rsrcPreempt, Resources.none())) {\n-        return ret;\n+    for (RMContainer c : reservedContainers) {\n+      if (resToObtainByPartition.isEmpty()) {\n+        return;\n       }\n+\n+      // Try to preempt this container\n+      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n+          clusterResource, preemptMap);\n+\n       if (!observeOnly) {\n         dispatcher.handle(new ContainerPreemptEvent(appId, c,\n             ContainerPreemptEventType.DROP_RESERVATION));\n       }\n-      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n-    List\u003cRMContainer\u003e containers \u003d\n+    List\u003cRMContainer\u003e liveContainers \u003d\n       new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n \n-    sortContainers(containers);\n+    sortContainers(liveContainers);\n \n-    for (RMContainer c : containers) {\n-      if (Resources.lessThanOrEqual(rc, clusterResource,\n-            rsrcPreempt, Resources.none())) {\n-        return ret;\n+    for (RMContainer c : liveContainers) {\n+      if (resToObtainByPartition.isEmpty()) {\n+        return;\n       }\n+\n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n-        Resources.addTo(skippedAMSize, c.getContainer().getResource());\n+        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n-      // skip Labeled resource\n-      if(isLabeledContainer(c)){\n-        continue;\n-      }\n-      ret.add(c);\n-      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n-    }\n \n-    return ret;\n+      // Try to preempt this container\n+      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n+          clusterResource, preemptMap);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n\n      if (!observeOnly) {\n        dispatcher.handle(new ContainerPreemptEvent(appId, c,\n            ContainerPreemptEventType.DROP_RESERVATION));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {
            "oldValue": "[app-FiCaSchedulerApp, clusterResource-Resource, rsrcPreempt-Resource, skippedAMContainerlist-List\u003cRMContainer\u003e, skippedAMSize-Resource]",
            "newValue": "[app-FiCaSchedulerApp, clusterResource-Resource, resToObtainByPartition-Map\u003cString,Resource\u003e, skippedAMContainerlist-List\u003cRMContainer\u003e, skippedAMSize-Resource, preemptMap-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-2498. Respect labels in preemption policy of capacity scheduler for inter-queue preemption. Contributed by Wangda Tan\n",
          "commitDate": "24/04/15 5:03 PM",
          "commitName": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
          "commitAuthor": "Jian He",
          "commitDateOld": "20/04/15 5:12 PM",
          "commitNameOld": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.99,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,53 @@\n-  private Set\u003cRMContainer\u003e preemptFrom(FiCaSchedulerApp app,\n-      Resource clusterResource, Resource rsrcPreempt,\n-      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize) {\n-    Set\u003cRMContainer\u003e ret \u003d new HashSet\u003cRMContainer\u003e();\n+  private void preemptFrom(FiCaSchedulerApp app,\n+      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n+      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n+          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n+    }\n \n     // first drop reserved containers towards rsrcPreempt\n-    List\u003cRMContainer\u003e reservations \u003d\n+    List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n-    for (RMContainer c : reservations) {\n-      if (Resources.lessThanOrEqual(rc, clusterResource,\n-          rsrcPreempt, Resources.none())) {\n-        return ret;\n+    for (RMContainer c : reservedContainers) {\n+      if (resToObtainByPartition.isEmpty()) {\n+        return;\n       }\n+\n+      // Try to preempt this container\n+      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n+          clusterResource, preemptMap);\n+\n       if (!observeOnly) {\n         dispatcher.handle(new ContainerPreemptEvent(appId, c,\n             ContainerPreemptEventType.DROP_RESERVATION));\n       }\n-      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n-    List\u003cRMContainer\u003e containers \u003d\n+    List\u003cRMContainer\u003e liveContainers \u003d\n       new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n \n-    sortContainers(containers);\n+    sortContainers(liveContainers);\n \n-    for (RMContainer c : containers) {\n-      if (Resources.lessThanOrEqual(rc, clusterResource,\n-            rsrcPreempt, Resources.none())) {\n-        return ret;\n+    for (RMContainer c : liveContainers) {\n+      if (resToObtainByPartition.isEmpty()) {\n+        return;\n       }\n+\n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n-        Resources.addTo(skippedAMSize, c.getContainer().getResource());\n+        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n-      // skip Labeled resource\n-      if(isLabeledContainer(c)){\n-        continue;\n-      }\n-      ret.add(c);\n-      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n-    }\n \n-    return ret;\n+      // Try to preempt this container\n+      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n+          clusterResource, preemptMap);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n\n      if (!observeOnly) {\n        dispatcher.handle(new ContainerPreemptEvent(appId, c,\n            ContainerPreemptEventType.DROP_RESERVATION));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {
            "oldValue": "Set\u003cRMContainer\u003e",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2498. Respect labels in preemption policy of capacity scheduler for inter-queue preemption. Contributed by Wangda Tan\n",
          "commitDate": "24/04/15 5:03 PM",
          "commitName": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
          "commitAuthor": "Jian He",
          "commitDateOld": "20/04/15 5:12 PM",
          "commitNameOld": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.99,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,53 @@\n-  private Set\u003cRMContainer\u003e preemptFrom(FiCaSchedulerApp app,\n-      Resource clusterResource, Resource rsrcPreempt,\n-      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize) {\n-    Set\u003cRMContainer\u003e ret \u003d new HashSet\u003cRMContainer\u003e();\n+  private void preemptFrom(FiCaSchedulerApp app,\n+      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n+      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n+          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n+    }\n \n     // first drop reserved containers towards rsrcPreempt\n-    List\u003cRMContainer\u003e reservations \u003d\n+    List\u003cRMContainer\u003e reservedContainers \u003d\n         new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n-    for (RMContainer c : reservations) {\n-      if (Resources.lessThanOrEqual(rc, clusterResource,\n-          rsrcPreempt, Resources.none())) {\n-        return ret;\n+    for (RMContainer c : reservedContainers) {\n+      if (resToObtainByPartition.isEmpty()) {\n+        return;\n       }\n+\n+      // Try to preempt this container\n+      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n+          clusterResource, preemptMap);\n+\n       if (!observeOnly) {\n         dispatcher.handle(new ContainerPreemptEvent(appId, c,\n             ContainerPreemptEventType.DROP_RESERVATION));\n       }\n-      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n-    List\u003cRMContainer\u003e containers \u003d\n+    List\u003cRMContainer\u003e liveContainers \u003d\n       new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n \n-    sortContainers(containers);\n+    sortContainers(liveContainers);\n \n-    for (RMContainer c : containers) {\n-      if (Resources.lessThanOrEqual(rc, clusterResource,\n-            rsrcPreempt, Resources.none())) {\n-        return ret;\n+    for (RMContainer c : liveContainers) {\n+      if (resToObtainByPartition.isEmpty()) {\n+        return;\n       }\n+\n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n-        Resources.addTo(skippedAMSize, c.getContainer().getResource());\n+        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n         continue;\n       }\n-      // skip Labeled resource\n-      if(isLabeledContainer(c)){\n-        continue;\n-      }\n-      ret.add(c);\n-      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n-    }\n \n-    return ret;\n+      // Try to preempt this container\n+      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n+          clusterResource, preemptMap);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Map\u003cString, Resource\u003e resToObtainByPartition,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Looking at application\u003d\" + app.getApplicationAttemptId()\n          + \" resourceToObtain\u003d\" + resToObtainByPartition);\n    }\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservedContainers \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservedContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n\n      if (!observeOnly) {\n        dispatcher.handle(new ContainerPreemptEvent(appId, c,\n            ContainerPreemptEventType.DROP_RESERVATION));\n      }\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e liveContainers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(liveContainers);\n\n    for (RMContainer c : liveContainers) {\n      if (resToObtainByPartition.isEmpty()) {\n        return;\n      }\n\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getAllocatedResource());\n        continue;\n      }\n\n      // Try to preempt this container\n      tryPreemptContainerAndDeductResToObtain(resToObtainByPartition, c,\n          clusterResource, preemptMap);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "0a2d3e717d9c42090a32ff177991a222a1e34132": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2933. Capacity Scheduler preemption policy should only consider capacity without labels temporarily. Contributed by Mayank Bansal\n",
      "commitDate": "19/01/15 4:48 PM",
      "commitName": "0a2d3e717d9c42090a32ff177991a222a1e34132",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "05/12/14 1:06 PM",
      "commitNameOld": "4b130821995a3cfe20c71e38e0f63294085c0491",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 45.15,
      "commitsBetweenForRepo": 253,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,50 @@\n   private Set\u003cRMContainer\u003e preemptFrom(FiCaSchedulerApp app,\n       Resource clusterResource, Resource rsrcPreempt,\n       List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize) {\n     Set\u003cRMContainer\u003e ret \u003d new HashSet\u003cRMContainer\u003e();\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservations \u003d\n         new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n     for (RMContainer c : reservations) {\n       if (Resources.lessThanOrEqual(rc, clusterResource,\n           rsrcPreempt, Resources.none())) {\n         return ret;\n       }\n       if (!observeOnly) {\n         dispatcher.handle(new ContainerPreemptEvent(appId, c,\n             ContainerPreemptEventType.DROP_RESERVATION));\n       }\n       Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n     List\u003cRMContainer\u003e containers \u003d\n       new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n \n     sortContainers(containers);\n \n     for (RMContainer c : containers) {\n       if (Resources.lessThanOrEqual(rc, clusterResource,\n             rsrcPreempt, Resources.none())) {\n         return ret;\n       }\n       // Skip AM Container from preemption for now.\n       if (c.isAMContainer()) {\n         skippedAMContainerlist.add(c);\n         Resources.addTo(skippedAMSize, c.getContainer().getResource());\n         continue;\n       }\n+      // skip Labeled resource\n+      if(isLabeledContainer(c)){\n+        continue;\n+      }\n       ret.add(c);\n       Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n     }\n \n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Set\u003cRMContainer\u003e preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Resource rsrcPreempt,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize) {\n    Set\u003cRMContainer\u003e ret \u003d new HashSet\u003cRMContainer\u003e();\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservations \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservations) {\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n          rsrcPreempt, Resources.none())) {\n        return ret;\n      }\n      if (!observeOnly) {\n        dispatcher.handle(new ContainerPreemptEvent(appId, c,\n            ContainerPreemptEventType.DROP_RESERVATION));\n      }\n      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e containers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(containers);\n\n    for (RMContainer c : containers) {\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n            rsrcPreempt, Resources.none())) {\n        return ret;\n      }\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getContainer().getResource());\n        continue;\n      }\n      // skip Labeled resource\n      if(isLabeledContainer(c)){\n        continue;\n      }\n      ret.add(c);\n      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n    }\n\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "03a25d2cc1a2fb124d00edf874d67e329c65a5e6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2022 Preempting an Application Master container can be kept as least priority when multiple applications are marked for preemption by ProportionalCapacityPreemptionPolicy (Sunil G via mayank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1607227 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/07/14 6:54 PM",
      "commitName": "03a25d2cc1a2fb124d00edf874d67e329c65a5e6",
      "commitAuthor": "Mayank Bansal",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2022 Preempting an Application Master container can be kept as least priority when multiple applications are marked for preemption by ProportionalCapacityPreemptionPolicy (Sunil G via mayank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1607227 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "01/07/14 6:54 PM",
          "commitName": "03a25d2cc1a2fb124d00edf874d67e329c65a5e6",
          "commitAuthor": "Mayank Bansal",
          "commitDateOld": "11/06/14 11:31 AM",
          "commitNameOld": "c6e29a9f069f71bd77fcff2111def4a60676b4ba",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 20.31,
          "commitsBetweenForRepo": 140,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,46 @@\n-  private Set\u003cRMContainer\u003e preemptFrom(\n-      FiCaSchedulerApp app, Resource clusterResource, Resource rsrcPreempt) {\n+  private Set\u003cRMContainer\u003e preemptFrom(FiCaSchedulerApp app,\n+      Resource clusterResource, Resource rsrcPreempt,\n+      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize) {\n     Set\u003cRMContainer\u003e ret \u003d new HashSet\u003cRMContainer\u003e();\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservations \u003d\n         new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n     for (RMContainer c : reservations) {\n       if (Resources.lessThanOrEqual(rc, clusterResource,\n           rsrcPreempt, Resources.none())) {\n         return ret;\n       }\n       if (!observeOnly) {\n         dispatcher.handle(new ContainerPreemptEvent(appId, c,\n             ContainerPreemptEventType.DROP_RESERVATION));\n       }\n       Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n     List\u003cRMContainer\u003e containers \u003d\n       new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n \n     sortContainers(containers);\n \n     for (RMContainer c : containers) {\n       if (Resources.lessThanOrEqual(rc, clusterResource,\n             rsrcPreempt, Resources.none())) {\n         return ret;\n       }\n+      // Skip AM Container from preemption for now.\n+      if (c.isAMContainer()) {\n+        skippedAMContainerlist.add(c);\n+        Resources.addTo(skippedAMSize, c.getContainer().getResource());\n+        continue;\n+      }\n       ret.add(c);\n       Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n     }\n \n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Set\u003cRMContainer\u003e preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Resource rsrcPreempt,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize) {\n    Set\u003cRMContainer\u003e ret \u003d new HashSet\u003cRMContainer\u003e();\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservations \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservations) {\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n          rsrcPreempt, Resources.none())) {\n        return ret;\n      }\n      if (!observeOnly) {\n        dispatcher.handle(new ContainerPreemptEvent(appId, c,\n            ContainerPreemptEventType.DROP_RESERVATION));\n      }\n      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e containers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(containers);\n\n    for (RMContainer c : containers) {\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n            rsrcPreempt, Resources.none())) {\n        return ret;\n      }\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getContainer().getResource());\n        continue;\n      }\n      ret.add(c);\n      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n    }\n\n    return ret;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {
            "oldValue": "[app-FiCaSchedulerApp, clusterResource-Resource, rsrcPreempt-Resource]",
            "newValue": "[app-FiCaSchedulerApp, clusterResource-Resource, rsrcPreempt-Resource, skippedAMContainerlist-List\u003cRMContainer\u003e, skippedAMSize-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2022 Preempting an Application Master container can be kept as least priority when multiple applications are marked for preemption by ProportionalCapacityPreemptionPolicy (Sunil G via mayank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1607227 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "01/07/14 6:54 PM",
          "commitName": "03a25d2cc1a2fb124d00edf874d67e329c65a5e6",
          "commitAuthor": "Mayank Bansal",
          "commitDateOld": "11/06/14 11:31 AM",
          "commitNameOld": "c6e29a9f069f71bd77fcff2111def4a60676b4ba",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 20.31,
          "commitsBetweenForRepo": 140,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,46 @@\n-  private Set\u003cRMContainer\u003e preemptFrom(\n-      FiCaSchedulerApp app, Resource clusterResource, Resource rsrcPreempt) {\n+  private Set\u003cRMContainer\u003e preemptFrom(FiCaSchedulerApp app,\n+      Resource clusterResource, Resource rsrcPreempt,\n+      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize) {\n     Set\u003cRMContainer\u003e ret \u003d new HashSet\u003cRMContainer\u003e();\n     ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n \n     // first drop reserved containers towards rsrcPreempt\n     List\u003cRMContainer\u003e reservations \u003d\n         new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n     for (RMContainer c : reservations) {\n       if (Resources.lessThanOrEqual(rc, clusterResource,\n           rsrcPreempt, Resources.none())) {\n         return ret;\n       }\n       if (!observeOnly) {\n         dispatcher.handle(new ContainerPreemptEvent(appId, c,\n             ContainerPreemptEventType.DROP_RESERVATION));\n       }\n       Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n     }\n \n     // if more resources are to be freed go through all live containers in\n     // reverse priority and reverse allocation order and mark them for\n     // preemption\n     List\u003cRMContainer\u003e containers \u003d\n       new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n \n     sortContainers(containers);\n \n     for (RMContainer c : containers) {\n       if (Resources.lessThanOrEqual(rc, clusterResource,\n             rsrcPreempt, Resources.none())) {\n         return ret;\n       }\n+      // Skip AM Container from preemption for now.\n+      if (c.isAMContainer()) {\n+        skippedAMContainerlist.add(c);\n+        Resources.addTo(skippedAMSize, c.getContainer().getResource());\n+        continue;\n+      }\n       ret.add(c);\n       Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n     }\n \n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Set\u003cRMContainer\u003e preemptFrom(FiCaSchedulerApp app,\n      Resource clusterResource, Resource rsrcPreempt,\n      List\u003cRMContainer\u003e skippedAMContainerlist, Resource skippedAMSize) {\n    Set\u003cRMContainer\u003e ret \u003d new HashSet\u003cRMContainer\u003e();\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservations \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservations) {\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n          rsrcPreempt, Resources.none())) {\n        return ret;\n      }\n      if (!observeOnly) {\n        dispatcher.handle(new ContainerPreemptEvent(appId, c,\n            ContainerPreemptEventType.DROP_RESERVATION));\n      }\n      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e containers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(containers);\n\n    for (RMContainer c : containers) {\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n            rsrcPreempt, Resources.none())) {\n        return ret;\n      }\n      // Skip AM Container from preemption for now.\n      if (c.isAMContainer()) {\n        skippedAMContainerlist.add(c);\n        Resources.addTo(skippedAMSize, c.getContainer().getResource());\n        continue;\n      }\n      ret.add(c);\n      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n    }\n\n    return ret;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61": {
      "type": "Yintroduced",
      "commitMessage": "YARN-569. Add support for requesting and enforcing preemption requests via\na capacity monitor. Contributed by Carlo Curino, Chris Douglas\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502083 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/13 6:20 PM",
      "commitName": "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61",
      "commitAuthor": "Christopher Douglas",
      "diff": "@@ -0,0 +1,39 @@\n+  private Set\u003cRMContainer\u003e preemptFrom(\n+      FiCaSchedulerApp app, Resource clusterResource, Resource rsrcPreempt) {\n+    Set\u003cRMContainer\u003e ret \u003d new HashSet\u003cRMContainer\u003e();\n+    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n+\n+    // first drop reserved containers towards rsrcPreempt\n+    List\u003cRMContainer\u003e reservations \u003d\n+        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n+    for (RMContainer c : reservations) {\n+      if (Resources.lessThanOrEqual(rc, clusterResource,\n+          rsrcPreempt, Resources.none())) {\n+        return ret;\n+      }\n+      if (!observeOnly) {\n+        dispatcher.handle(new ContainerPreemptEvent(appId, c,\n+            ContainerPreemptEventType.DROP_RESERVATION));\n+      }\n+      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n+    }\n+\n+    // if more resources are to be freed go through all live containers in\n+    // reverse priority and reverse allocation order and mark them for\n+    // preemption\n+    List\u003cRMContainer\u003e containers \u003d\n+      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n+\n+    sortContainers(containers);\n+\n+    for (RMContainer c : containers) {\n+      if (Resources.lessThanOrEqual(rc, clusterResource,\n+            rsrcPreempt, Resources.none())) {\n+        return ret;\n+      }\n+      ret.add(c);\n+      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n+    }\n+\n+    return ret;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Set\u003cRMContainer\u003e preemptFrom(\n      FiCaSchedulerApp app, Resource clusterResource, Resource rsrcPreempt) {\n    Set\u003cRMContainer\u003e ret \u003d new HashSet\u003cRMContainer\u003e();\n    ApplicationAttemptId appId \u003d app.getApplicationAttemptId();\n\n    // first drop reserved containers towards rsrcPreempt\n    List\u003cRMContainer\u003e reservations \u003d\n        new ArrayList\u003cRMContainer\u003e(app.getReservedContainers());\n    for (RMContainer c : reservations) {\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n          rsrcPreempt, Resources.none())) {\n        return ret;\n      }\n      if (!observeOnly) {\n        dispatcher.handle(new ContainerPreemptEvent(appId, c,\n            ContainerPreemptEventType.DROP_RESERVATION));\n      }\n      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n    }\n\n    // if more resources are to be freed go through all live containers in\n    // reverse priority and reverse allocation order and mark them for\n    // preemption\n    List\u003cRMContainer\u003e containers \u003d\n      new ArrayList\u003cRMContainer\u003e(app.getLiveContainers());\n\n    sortContainers(containers);\n\n    for (RMContainer c : containers) {\n      if (Resources.lessThanOrEqual(rc, clusterResource,\n            rsrcPreempt, Resources.none())) {\n        return ret;\n      }\n      ret.add(c);\n      Resources.subtractFrom(rsrcPreempt, c.getContainer().getResource());\n    }\n\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java"
    }
  }
}