{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PlacementConstraintsUtil.java",
  "functionName": "canSatisfySingleConstraint",
  "functionId": "canSatisfySingleConstraint___applicationId-ApplicationId__singleConstraint-SingleConstraint__schedulerNode-SchedulerNode__tagsManager-AllocationTagsManager__dcOpt-Optional__DiagnosticsCollector__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/PlacementConstraintsUtil.java",
  "functionStartLine": 216,
  "functionEndLine": 251,
  "numCommitsSeen": 40,
  "timeTaken": 6302,
  "changeHistory": [
    "12b7059ddc8d8f67dd7131565f03a0e09cb92ca7",
    "52194351e7df33b8438569c3a032f73d696c534d",
    "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983",
    "38af23796971193fa529c3d08ffde8fcd6e607b6",
    "8779a35742085fadddccc21342b55d4f17fae5c2",
    "bdba01f73b58d2228e808c6f61377f101b6bac1c"
  ],
  "changeHistoryShort": {
    "12b7059ddc8d8f67dd7131565f03a0e09cb92ca7": "Ymultichange(Yparameterchange,Ybodychange)",
    "52194351e7df33b8438569c3a032f73d696c534d": "Ybodychange",
    "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983": "Ybodychange",
    "38af23796971193fa529c3d08ffde8fcd6e607b6": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
    "8779a35742085fadddccc21342b55d4f17fae5c2": "Ybodychange",
    "bdba01f73b58d2228e808c6f61377f101b6bac1c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "12b7059ddc8d8f67dd7131565f03a0e09cb92ca7": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-9440. Improve diagnostics for scheduler and app activities. Contributed by Tao Yang.\n",
      "commitDate": "06/05/19 5:00 AM",
      "commitName": "12b7059ddc8d8f67dd7131565f03a0e09cb92ca7",
      "commitAuthor": "Weiwei Yang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-9440. Improve diagnostics for scheduler and app activities. Contributed by Tao Yang.\n",
          "commitDate": "06/05/19 5:00 AM",
          "commitName": "12b7059ddc8d8f67dd7131565f03a0e09cb92ca7",
          "commitAuthor": "Weiwei Yang",
          "commitDateOld": "18/03/19 10:57 AM",
          "commitNameOld": "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 48.75,
          "commitsBetweenForRepo": 303,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,36 @@\n   private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n       SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n-      AllocationTagsManager tagsManager)\n+      AllocationTagsManager tagsManager,\n+      Optional\u003cDiagnosticsCollector\u003e dcOpt)\n       throws InvalidAllocationTagsQueryException {\n     // Iterate through TargetExpressions\n     Iterator\u003cTargetExpression\u003e expIt \u003d\n         singleConstraint.getTargetExpressions().iterator();\n     while (expIt.hasNext()) {\n       TargetExpression currentExp \u003d expIt.next();\n       // Supporting AllocationTag Expressions for now\n       if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n         // Check if conditions are met\n         if (!canSatisfySingleConstraintExpression(applicationId,\n             singleConstraint, currentExp, schedulerNode, tagsManager)) {\n+          if (dcOpt.isPresent()) {\n+            dcOpt.get().collectPlacementConstraintDiagnostics(\n+                singleConstraint.build(), TargetType.ALLOCATION_TAG);\n+          }\n           return false;\n         }\n       } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)) {\n         // This is a node attribute expression, check it.\n         if (!canSatisfyNodeConstraintExpression(singleConstraint, currentExp,\n             schedulerNode)) {\n+          if (dcOpt.isPresent()) {\n+            dcOpt.get().collectPlacementConstraintDiagnostics(\n+                singleConstraint.build(), TargetType.NODE_ATTRIBUTE);\n+          }\n           return false;\n         }\n       }\n     }\n     // return true if all targetExpressions are satisfied\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n      SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n      AllocationTagsManager tagsManager,\n      Optional\u003cDiagnosticsCollector\u003e dcOpt)\n      throws InvalidAllocationTagsQueryException {\n    // Iterate through TargetExpressions\n    Iterator\u003cTargetExpression\u003e expIt \u003d\n        singleConstraint.getTargetExpressions().iterator();\n    while (expIt.hasNext()) {\n      TargetExpression currentExp \u003d expIt.next();\n      // Supporting AllocationTag Expressions for now\n      if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n        // Check if conditions are met\n        if (!canSatisfySingleConstraintExpression(applicationId,\n            singleConstraint, currentExp, schedulerNode, tagsManager)) {\n          if (dcOpt.isPresent()) {\n            dcOpt.get().collectPlacementConstraintDiagnostics(\n                singleConstraint.build(), TargetType.ALLOCATION_TAG);\n          }\n          return false;\n        }\n      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)) {\n        // This is a node attribute expression, check it.\n        if (!canSatisfyNodeConstraintExpression(singleConstraint, currentExp,\n            schedulerNode)) {\n          if (dcOpt.isPresent()) {\n            dcOpt.get().collectPlacementConstraintDiagnostics(\n                singleConstraint.build(), TargetType.NODE_ATTRIBUTE);\n          }\n          return false;\n        }\n      }\n    }\n    // return true if all targetExpressions are satisfied\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/PlacementConstraintsUtil.java",
          "extendedDetails": {
            "oldValue": "[applicationId-ApplicationId, singleConstraint-SingleConstraint, schedulerNode-SchedulerNode, tagsManager-AllocationTagsManager]",
            "newValue": "[applicationId-ApplicationId, singleConstraint-SingleConstraint, schedulerNode-SchedulerNode, tagsManager-AllocationTagsManager, dcOpt-Optional\u003cDiagnosticsCollector\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9440. Improve diagnostics for scheduler and app activities. Contributed by Tao Yang.\n",
          "commitDate": "06/05/19 5:00 AM",
          "commitName": "12b7059ddc8d8f67dd7131565f03a0e09cb92ca7",
          "commitAuthor": "Weiwei Yang",
          "commitDateOld": "18/03/19 10:57 AM",
          "commitNameOld": "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 48.75,
          "commitsBetweenForRepo": 303,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,36 @@\n   private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n       SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n-      AllocationTagsManager tagsManager)\n+      AllocationTagsManager tagsManager,\n+      Optional\u003cDiagnosticsCollector\u003e dcOpt)\n       throws InvalidAllocationTagsQueryException {\n     // Iterate through TargetExpressions\n     Iterator\u003cTargetExpression\u003e expIt \u003d\n         singleConstraint.getTargetExpressions().iterator();\n     while (expIt.hasNext()) {\n       TargetExpression currentExp \u003d expIt.next();\n       // Supporting AllocationTag Expressions for now\n       if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n         // Check if conditions are met\n         if (!canSatisfySingleConstraintExpression(applicationId,\n             singleConstraint, currentExp, schedulerNode, tagsManager)) {\n+          if (dcOpt.isPresent()) {\n+            dcOpt.get().collectPlacementConstraintDiagnostics(\n+                singleConstraint.build(), TargetType.ALLOCATION_TAG);\n+          }\n           return false;\n         }\n       } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)) {\n         // This is a node attribute expression, check it.\n         if (!canSatisfyNodeConstraintExpression(singleConstraint, currentExp,\n             schedulerNode)) {\n+          if (dcOpt.isPresent()) {\n+            dcOpt.get().collectPlacementConstraintDiagnostics(\n+                singleConstraint.build(), TargetType.NODE_ATTRIBUTE);\n+          }\n           return false;\n         }\n       }\n     }\n     // return true if all targetExpressions are satisfied\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n      SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n      AllocationTagsManager tagsManager,\n      Optional\u003cDiagnosticsCollector\u003e dcOpt)\n      throws InvalidAllocationTagsQueryException {\n    // Iterate through TargetExpressions\n    Iterator\u003cTargetExpression\u003e expIt \u003d\n        singleConstraint.getTargetExpressions().iterator();\n    while (expIt.hasNext()) {\n      TargetExpression currentExp \u003d expIt.next();\n      // Supporting AllocationTag Expressions for now\n      if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n        // Check if conditions are met\n        if (!canSatisfySingleConstraintExpression(applicationId,\n            singleConstraint, currentExp, schedulerNode, tagsManager)) {\n          if (dcOpt.isPresent()) {\n            dcOpt.get().collectPlacementConstraintDiagnostics(\n                singleConstraint.build(), TargetType.ALLOCATION_TAG);\n          }\n          return false;\n        }\n      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)) {\n        // This is a node attribute expression, check it.\n        if (!canSatisfyNodeConstraintExpression(singleConstraint, currentExp,\n            schedulerNode)) {\n          if (dcOpt.isPresent()) {\n            dcOpt.get().collectPlacementConstraintDiagnostics(\n                singleConstraint.build(), TargetType.NODE_ATTRIBUTE);\n          }\n          return false;\n        }\n      }\n    }\n    // return true if all targetExpressions are satisfied\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/PlacementConstraintsUtil.java",
          "extendedDetails": {}
        }
      ]
    },
    "52194351e7df33b8438569c3a032f73d696c534d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8721. Relax NE node-attribute check when attribute doesn\u0027t exist on a node. Contributed by Sunil Govindan.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "52194351e7df33b8438569c3a032f73d696c534d",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n   private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n       SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n       AllocationTagsManager tagsManager)\n       throws InvalidAllocationTagsQueryException {\n     // Iterate through TargetExpressions\n     Iterator\u003cTargetExpression\u003e expIt \u003d\n         singleConstraint.getTargetExpressions().iterator();\n     while (expIt.hasNext()) {\n       TargetExpression currentExp \u003d expIt.next();\n       // Supporting AllocationTag Expressions for now\n       if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n         // Check if conditions are met\n         if (!canSatisfySingleConstraintExpression(applicationId,\n             singleConstraint, currentExp, schedulerNode, tagsManager)) {\n           return false;\n         }\n       } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)) {\n         // This is a node attribute expression, check it.\n-        if (!canSatisfyNodeConstraintExpresssion(singleConstraint, currentExp,\n+        if (!canSatisfyNodeConstraintExpression(singleConstraint, currentExp,\n             schedulerNode)) {\n           return false;\n         }\n       }\n     }\n     // return true if all targetExpressions are satisfied\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n      SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n      AllocationTagsManager tagsManager)\n      throws InvalidAllocationTagsQueryException {\n    // Iterate through TargetExpressions\n    Iterator\u003cTargetExpression\u003e expIt \u003d\n        singleConstraint.getTargetExpressions().iterator();\n    while (expIt.hasNext()) {\n      TargetExpression currentExp \u003d expIt.next();\n      // Supporting AllocationTag Expressions for now\n      if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n        // Check if conditions are met\n        if (!canSatisfySingleConstraintExpression(applicationId,\n            singleConstraint, currentExp, schedulerNode, tagsManager)) {\n          return false;\n        }\n      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)) {\n        // This is a node attribute expression, check it.\n        if (!canSatisfyNodeConstraintExpression(singleConstraint, currentExp,\n            schedulerNode)) {\n          return false;\n        }\n      }\n    }\n    // return true if all targetExpressions are satisfied\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/PlacementConstraintsUtil.java",
      "extendedDetails": {}
    },
    "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7863. Modify placement constraints to support node attributes. Contributed by Sunil Govindan.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "30/04/18 11:54 AM",
      "commitNameOld": "9b0955545174abe16fd81240db30f175145ee89b",
      "commitAuthorOld": "Konstantinos Karanasos",
      "daysBetweenCommits": 134.65,
      "commitsBetweenForRepo": 1013,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,27 @@\n   private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n       SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n       AllocationTagsManager tagsManager)\n       throws InvalidAllocationTagsQueryException {\n     // Iterate through TargetExpressions\n     Iterator\u003cTargetExpression\u003e expIt \u003d\n         singleConstraint.getTargetExpressions().iterator();\n     while (expIt.hasNext()) {\n       TargetExpression currentExp \u003d expIt.next();\n       // Supporting AllocationTag Expressions for now\n       if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n         // Check if conditions are met\n         if (!canSatisfySingleConstraintExpression(applicationId,\n             singleConstraint, currentExp, schedulerNode, tagsManager)) {\n           return false;\n         }\n-      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)\n-          \u0026\u0026 currentExp.getTargetKey().equals(NODE_PARTITION)) {\n-        // This is a node partition expression, check it.\n-        canSatisfyNodePartitionConstraintExpresssion(currentExp, schedulerNode);\n+      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)) {\n+        // This is a node attribute expression, check it.\n+        if (!canSatisfyNodeConstraintExpresssion(singleConstraint, currentExp,\n+            schedulerNode)) {\n+          return false;\n+        }\n       }\n     }\n     // return true if all targetExpressions are satisfied\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n      SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n      AllocationTagsManager tagsManager)\n      throws InvalidAllocationTagsQueryException {\n    // Iterate through TargetExpressions\n    Iterator\u003cTargetExpression\u003e expIt \u003d\n        singleConstraint.getTargetExpressions().iterator();\n    while (expIt.hasNext()) {\n      TargetExpression currentExp \u003d expIt.next();\n      // Supporting AllocationTag Expressions for now\n      if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n        // Check if conditions are met\n        if (!canSatisfySingleConstraintExpression(applicationId,\n            singleConstraint, currentExp, schedulerNode, tagsManager)) {\n          return false;\n        }\n      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)) {\n        // This is a node attribute expression, check it.\n        if (!canSatisfyNodeConstraintExpresssion(singleConstraint, currentExp,\n            schedulerNode)) {\n          return false;\n        }\n      }\n    }\n    // return true if all targetExpressions are satisfied\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/PlacementConstraintsUtil.java",
      "extendedDetails": {}
    },
    "38af23796971193fa529c3d08ffde8fcd6e607b6": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "8779a35742085fadddccc21342b55d4f17fae5c2",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,25 @@\n-  public static boolean canSatisfyConstraints(ApplicationId appId,\n-      Set\u003cString\u003e allocationTags, SchedulerNode node,\n-      PlacementConstraintManager pcm, AllocationTagsManager tagsManager)\n+  private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n+      SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n+      AllocationTagsManager tagsManager)\n       throws InvalidAllocationTagsQueryException {\n-    PlacementConstraint constraint \u003d pcm.getConstraint(appId, allocationTags);\n-    if (constraint \u003d\u003d null) {\n-      return true;\n-    }\n-    // Transform to SimpleConstraint\n-    SingleConstraintTransformer singleTransformer \u003d\n-        new SingleConstraintTransformer(constraint);\n-    constraint \u003d singleTransformer.transform();\n-    AbstractConstraint sConstraintExpr \u003d constraint.getConstraintExpr();\n-    SingleConstraint single \u003d (SingleConstraint) sConstraintExpr;\n     // Iterate through TargetExpressions\n-    Iterator\u003cTargetExpression\u003e expIt \u003d single.getTargetExpressions().iterator();\n+    Iterator\u003cTargetExpression\u003e expIt \u003d\n+        singleConstraint.getTargetExpressions().iterator();\n     while (expIt.hasNext()) {\n       TargetExpression currentExp \u003d expIt.next();\n       // Supporting AllocationTag Expressions for now\n       if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n-        // If source and tag allocation tags are the same, we do not enforce\n-        // constraints with minimum cardinality.\n-        if (currentExp.getTargetValues().equals(allocationTags)\n-            \u0026\u0026 single.getMinCardinality() \u003e 0) {\n-          return true;\n-        }\n         // Check if conditions are met\n-        if (!canSatisfySingleConstraintExpression(appId, single, currentExp,\n-            node, tagsManager)) {\n+        if (!canSatisfySingleConstraintExpression(applicationId,\n+            singleConstraint, currentExp, schedulerNode, tagsManager)) {\n           return false;\n         }\n+      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)\n+          \u0026\u0026 currentExp.getTargetKey().equals(NODE_PARTITION)) {\n+        // This is a node partition expression, check it.\n+        canSatisfyNodePartitionConstraintExpresssion(currentExp, schedulerNode);\n       }\n     }\n     // return true if all targetExpressions are satisfied\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n      SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n      AllocationTagsManager tagsManager)\n      throws InvalidAllocationTagsQueryException {\n    // Iterate through TargetExpressions\n    Iterator\u003cTargetExpression\u003e expIt \u003d\n        singleConstraint.getTargetExpressions().iterator();\n    while (expIt.hasNext()) {\n      TargetExpression currentExp \u003d expIt.next();\n      // Supporting AllocationTag Expressions for now\n      if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n        // Check if conditions are met\n        if (!canSatisfySingleConstraintExpression(applicationId,\n            singleConstraint, currentExp, schedulerNode, tagsManager)) {\n          return false;\n        }\n      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)\n          \u0026\u0026 currentExp.getTargetKey().equals(NODE_PARTITION)) {\n        // This is a node partition expression, check it.\n        canSatisfyNodePartitionConstraintExpresssion(currentExp, schedulerNode);\n      }\n    }\n    // return true if all targetExpressions are satisfied\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/PlacementConstraintsUtil.java",
          "extendedDetails": {
            "oldValue": "canSatisfyConstraints",
            "newValue": "canSatisfySingleConstraint"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "8779a35742085fadddccc21342b55d4f17fae5c2",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,25 @@\n-  public static boolean canSatisfyConstraints(ApplicationId appId,\n-      Set\u003cString\u003e allocationTags, SchedulerNode node,\n-      PlacementConstraintManager pcm, AllocationTagsManager tagsManager)\n+  private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n+      SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n+      AllocationTagsManager tagsManager)\n       throws InvalidAllocationTagsQueryException {\n-    PlacementConstraint constraint \u003d pcm.getConstraint(appId, allocationTags);\n-    if (constraint \u003d\u003d null) {\n-      return true;\n-    }\n-    // Transform to SimpleConstraint\n-    SingleConstraintTransformer singleTransformer \u003d\n-        new SingleConstraintTransformer(constraint);\n-    constraint \u003d singleTransformer.transform();\n-    AbstractConstraint sConstraintExpr \u003d constraint.getConstraintExpr();\n-    SingleConstraint single \u003d (SingleConstraint) sConstraintExpr;\n     // Iterate through TargetExpressions\n-    Iterator\u003cTargetExpression\u003e expIt \u003d single.getTargetExpressions().iterator();\n+    Iterator\u003cTargetExpression\u003e expIt \u003d\n+        singleConstraint.getTargetExpressions().iterator();\n     while (expIt.hasNext()) {\n       TargetExpression currentExp \u003d expIt.next();\n       // Supporting AllocationTag Expressions for now\n       if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n-        // If source and tag allocation tags are the same, we do not enforce\n-        // constraints with minimum cardinality.\n-        if (currentExp.getTargetValues().equals(allocationTags)\n-            \u0026\u0026 single.getMinCardinality() \u003e 0) {\n-          return true;\n-        }\n         // Check if conditions are met\n-        if (!canSatisfySingleConstraintExpression(appId, single, currentExp,\n-            node, tagsManager)) {\n+        if (!canSatisfySingleConstraintExpression(applicationId,\n+            singleConstraint, currentExp, schedulerNode, tagsManager)) {\n           return false;\n         }\n+      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)\n+          \u0026\u0026 currentExp.getTargetKey().equals(NODE_PARTITION)) {\n+        // This is a node partition expression, check it.\n+        canSatisfyNodePartitionConstraintExpresssion(currentExp, schedulerNode);\n       }\n     }\n     // return true if all targetExpressions are satisfied\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n      SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n      AllocationTagsManager tagsManager)\n      throws InvalidAllocationTagsQueryException {\n    // Iterate through TargetExpressions\n    Iterator\u003cTargetExpression\u003e expIt \u003d\n        singleConstraint.getTargetExpressions().iterator();\n    while (expIt.hasNext()) {\n      TargetExpression currentExp \u003d expIt.next();\n      // Supporting AllocationTag Expressions for now\n      if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n        // Check if conditions are met\n        if (!canSatisfySingleConstraintExpression(applicationId,\n            singleConstraint, currentExp, schedulerNode, tagsManager)) {\n          return false;\n        }\n      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)\n          \u0026\u0026 currentExp.getTargetKey().equals(NODE_PARTITION)) {\n        // This is a node partition expression, check it.\n        canSatisfyNodePartitionConstraintExpresssion(currentExp, schedulerNode);\n      }\n    }\n    // return true if all targetExpressions are satisfied\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/PlacementConstraintsUtil.java",
          "extendedDetails": {
            "oldValue": "[appId-ApplicationId, allocationTags-Set\u003cString\u003e, node-SchedulerNode, pcm-PlacementConstraintManager, tagsManager-AllocationTagsManager]",
            "newValue": "[applicationId-ApplicationId, singleConstraint-SingleConstraint, schedulerNode-SchedulerNode, tagsManager-AllocationTagsManager]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "8779a35742085fadddccc21342b55d4f17fae5c2",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,25 @@\n-  public static boolean canSatisfyConstraints(ApplicationId appId,\n-      Set\u003cString\u003e allocationTags, SchedulerNode node,\n-      PlacementConstraintManager pcm, AllocationTagsManager tagsManager)\n+  private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n+      SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n+      AllocationTagsManager tagsManager)\n       throws InvalidAllocationTagsQueryException {\n-    PlacementConstraint constraint \u003d pcm.getConstraint(appId, allocationTags);\n-    if (constraint \u003d\u003d null) {\n-      return true;\n-    }\n-    // Transform to SimpleConstraint\n-    SingleConstraintTransformer singleTransformer \u003d\n-        new SingleConstraintTransformer(constraint);\n-    constraint \u003d singleTransformer.transform();\n-    AbstractConstraint sConstraintExpr \u003d constraint.getConstraintExpr();\n-    SingleConstraint single \u003d (SingleConstraint) sConstraintExpr;\n     // Iterate through TargetExpressions\n-    Iterator\u003cTargetExpression\u003e expIt \u003d single.getTargetExpressions().iterator();\n+    Iterator\u003cTargetExpression\u003e expIt \u003d\n+        singleConstraint.getTargetExpressions().iterator();\n     while (expIt.hasNext()) {\n       TargetExpression currentExp \u003d expIt.next();\n       // Supporting AllocationTag Expressions for now\n       if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n-        // If source and tag allocation tags are the same, we do not enforce\n-        // constraints with minimum cardinality.\n-        if (currentExp.getTargetValues().equals(allocationTags)\n-            \u0026\u0026 single.getMinCardinality() \u003e 0) {\n-          return true;\n-        }\n         // Check if conditions are met\n-        if (!canSatisfySingleConstraintExpression(appId, single, currentExp,\n-            node, tagsManager)) {\n+        if (!canSatisfySingleConstraintExpression(applicationId,\n+            singleConstraint, currentExp, schedulerNode, tagsManager)) {\n           return false;\n         }\n+      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)\n+          \u0026\u0026 currentExp.getTargetKey().equals(NODE_PARTITION)) {\n+        // This is a node partition expression, check it.\n+        canSatisfyNodePartitionConstraintExpresssion(currentExp, schedulerNode);\n       }\n     }\n     // return true if all targetExpressions are satisfied\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n      SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n      AllocationTagsManager tagsManager)\n      throws InvalidAllocationTagsQueryException {\n    // Iterate through TargetExpressions\n    Iterator\u003cTargetExpression\u003e expIt \u003d\n        singleConstraint.getTargetExpressions().iterator();\n    while (expIt.hasNext()) {\n      TargetExpression currentExp \u003d expIt.next();\n      // Supporting AllocationTag Expressions for now\n      if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n        // Check if conditions are met\n        if (!canSatisfySingleConstraintExpression(applicationId,\n            singleConstraint, currentExp, schedulerNode, tagsManager)) {\n          return false;\n        }\n      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)\n          \u0026\u0026 currentExp.getTargetKey().equals(NODE_PARTITION)) {\n        // This is a node partition expression, check it.\n        canSatisfyNodePartitionConstraintExpresssion(currentExp, schedulerNode);\n      }\n    }\n    // return true if all targetExpressions are satisfied\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/PlacementConstraintsUtil.java",
          "extendedDetails": {
            "oldValue": "[public, static]",
            "newValue": "[private, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "8779a35742085fadddccc21342b55d4f17fae5c2",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,25 @@\n-  public static boolean canSatisfyConstraints(ApplicationId appId,\n-      Set\u003cString\u003e allocationTags, SchedulerNode node,\n-      PlacementConstraintManager pcm, AllocationTagsManager tagsManager)\n+  private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n+      SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n+      AllocationTagsManager tagsManager)\n       throws InvalidAllocationTagsQueryException {\n-    PlacementConstraint constraint \u003d pcm.getConstraint(appId, allocationTags);\n-    if (constraint \u003d\u003d null) {\n-      return true;\n-    }\n-    // Transform to SimpleConstraint\n-    SingleConstraintTransformer singleTransformer \u003d\n-        new SingleConstraintTransformer(constraint);\n-    constraint \u003d singleTransformer.transform();\n-    AbstractConstraint sConstraintExpr \u003d constraint.getConstraintExpr();\n-    SingleConstraint single \u003d (SingleConstraint) sConstraintExpr;\n     // Iterate through TargetExpressions\n-    Iterator\u003cTargetExpression\u003e expIt \u003d single.getTargetExpressions().iterator();\n+    Iterator\u003cTargetExpression\u003e expIt \u003d\n+        singleConstraint.getTargetExpressions().iterator();\n     while (expIt.hasNext()) {\n       TargetExpression currentExp \u003d expIt.next();\n       // Supporting AllocationTag Expressions for now\n       if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n-        // If source and tag allocation tags are the same, we do not enforce\n-        // constraints with minimum cardinality.\n-        if (currentExp.getTargetValues().equals(allocationTags)\n-            \u0026\u0026 single.getMinCardinality() \u003e 0) {\n-          return true;\n-        }\n         // Check if conditions are met\n-        if (!canSatisfySingleConstraintExpression(appId, single, currentExp,\n-            node, tagsManager)) {\n+        if (!canSatisfySingleConstraintExpression(applicationId,\n+            singleConstraint, currentExp, schedulerNode, tagsManager)) {\n           return false;\n         }\n+      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)\n+          \u0026\u0026 currentExp.getTargetKey().equals(NODE_PARTITION)) {\n+        // This is a node partition expression, check it.\n+        canSatisfyNodePartitionConstraintExpresssion(currentExp, schedulerNode);\n       }\n     }\n     // return true if all targetExpressions are satisfied\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean canSatisfySingleConstraint(ApplicationId applicationId,\n      SingleConstraint singleConstraint, SchedulerNode schedulerNode,\n      AllocationTagsManager tagsManager)\n      throws InvalidAllocationTagsQueryException {\n    // Iterate through TargetExpressions\n    Iterator\u003cTargetExpression\u003e expIt \u003d\n        singleConstraint.getTargetExpressions().iterator();\n    while (expIt.hasNext()) {\n      TargetExpression currentExp \u003d expIt.next();\n      // Supporting AllocationTag Expressions for now\n      if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n        // Check if conditions are met\n        if (!canSatisfySingleConstraintExpression(applicationId,\n            singleConstraint, currentExp, schedulerNode, tagsManager)) {\n          return false;\n        }\n      } else if (currentExp.getTargetType().equals(TargetType.NODE_ATTRIBUTE)\n          \u0026\u0026 currentExp.getTargetKey().equals(NODE_PARTITION)) {\n        // This is a node partition expression, check it.\n        canSatisfyNodePartitionConstraintExpresssion(currentExp, schedulerNode);\n      }\n    }\n    // return true if all targetExpressions are satisfied\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/PlacementConstraintsUtil.java",
          "extendedDetails": {}
        }
      ]
    },
    "8779a35742085fadddccc21342b55d4f17fae5c2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7709. Remove SELF from TargetExpression type. (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "8779a35742085fadddccc21342b55d4f17fae5c2",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "29d9e4d5814900d5c59d77fe05d32186d4ad9385",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,36 @@\n   public static boolean canSatisfyConstraints(ApplicationId appId,\n       Set\u003cString\u003e allocationTags, SchedulerNode node,\n       PlacementConstraintManager pcm, AllocationTagsManager tagsManager)\n       throws InvalidAllocationTagsQueryException {\n     PlacementConstraint constraint \u003d pcm.getConstraint(appId, allocationTags);\n     if (constraint \u003d\u003d null) {\n       return true;\n     }\n     // Transform to SimpleConstraint\n     SingleConstraintTransformer singleTransformer \u003d\n         new SingleConstraintTransformer(constraint);\n     constraint \u003d singleTransformer.transform();\n     AbstractConstraint sConstraintExpr \u003d constraint.getConstraintExpr();\n     SingleConstraint single \u003d (SingleConstraint) sConstraintExpr;\n     // Iterate through TargetExpressions\n     Iterator\u003cTargetExpression\u003e expIt \u003d single.getTargetExpressions().iterator();\n     while (expIt.hasNext()) {\n       TargetExpression currentExp \u003d expIt.next();\n       // Supporting AllocationTag Expressions for now\n       if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n+        // If source and tag allocation tags are the same, we do not enforce\n+        // constraints with minimum cardinality.\n+        if (currentExp.getTargetValues().equals(allocationTags)\n+            \u0026\u0026 single.getMinCardinality() \u003e 0) {\n+          return true;\n+        }\n         // Check if conditions are met\n         if (!canSatisfySingleConstraintExpression(appId, single, currentExp,\n             node, tagsManager)) {\n           return false;\n         }\n       }\n     }\n     // return true if all targetExpressions are satisfied\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static boolean canSatisfyConstraints(ApplicationId appId,\n      Set\u003cString\u003e allocationTags, SchedulerNode node,\n      PlacementConstraintManager pcm, AllocationTagsManager tagsManager)\n      throws InvalidAllocationTagsQueryException {\n    PlacementConstraint constraint \u003d pcm.getConstraint(appId, allocationTags);\n    if (constraint \u003d\u003d null) {\n      return true;\n    }\n    // Transform to SimpleConstraint\n    SingleConstraintTransformer singleTransformer \u003d\n        new SingleConstraintTransformer(constraint);\n    constraint \u003d singleTransformer.transform();\n    AbstractConstraint sConstraintExpr \u003d constraint.getConstraintExpr();\n    SingleConstraint single \u003d (SingleConstraint) sConstraintExpr;\n    // Iterate through TargetExpressions\n    Iterator\u003cTargetExpression\u003e expIt \u003d single.getTargetExpressions().iterator();\n    while (expIt.hasNext()) {\n      TargetExpression currentExp \u003d expIt.next();\n      // Supporting AllocationTag Expressions for now\n      if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n        // If source and tag allocation tags are the same, we do not enforce\n        // constraints with minimum cardinality.\n        if (currentExp.getTargetValues().equals(allocationTags)\n            \u0026\u0026 single.getMinCardinality() \u003e 0) {\n          return true;\n        }\n        // Check if conditions are met\n        if (!canSatisfySingleConstraintExpression(appId, single, currentExp,\n            node, tagsManager)) {\n          return false;\n        }\n      }\n    }\n    // return true if all targetExpressions are satisfied\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/PlacementConstraintsUtil.java",
      "extendedDetails": {}
    },
    "bdba01f73b58d2228e808c6f61377f101b6bac1c": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7682. Expose canSatisfyConstraints utility function to validate a placement against a constraint. (Panagiotis Garefalakis via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "bdba01f73b58d2228e808c6f61377f101b6bac1c",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,30 @@\n+  public static boolean canSatisfyConstraints(ApplicationId appId,\n+      Set\u003cString\u003e allocationTags, SchedulerNode node,\n+      PlacementConstraintManager pcm, AllocationTagsManager tagsManager)\n+      throws InvalidAllocationTagsQueryException {\n+    PlacementConstraint constraint \u003d pcm.getConstraint(appId, allocationTags);\n+    if (constraint \u003d\u003d null) {\n+      return true;\n+    }\n+    // Transform to SimpleConstraint\n+    SingleConstraintTransformer singleTransformer \u003d\n+        new SingleConstraintTransformer(constraint);\n+    constraint \u003d singleTransformer.transform();\n+    AbstractConstraint sConstraintExpr \u003d constraint.getConstraintExpr();\n+    SingleConstraint single \u003d (SingleConstraint) sConstraintExpr;\n+    // Iterate through TargetExpressions\n+    Iterator\u003cTargetExpression\u003e expIt \u003d single.getTargetExpressions().iterator();\n+    while (expIt.hasNext()) {\n+      TargetExpression currentExp \u003d expIt.next();\n+      // Supporting AllocationTag Expressions for now\n+      if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n+        // Check if conditions are met\n+        if (!canSatisfySingleConstraintExpression(appId, single, currentExp,\n+            node, tagsManager)) {\n+          return false;\n+        }\n+      }\n+    }\n+    // return true if all targetExpressions are satisfied\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static boolean canSatisfyConstraints(ApplicationId appId,\n      Set\u003cString\u003e allocationTags, SchedulerNode node,\n      PlacementConstraintManager pcm, AllocationTagsManager tagsManager)\n      throws InvalidAllocationTagsQueryException {\n    PlacementConstraint constraint \u003d pcm.getConstraint(appId, allocationTags);\n    if (constraint \u003d\u003d null) {\n      return true;\n    }\n    // Transform to SimpleConstraint\n    SingleConstraintTransformer singleTransformer \u003d\n        new SingleConstraintTransformer(constraint);\n    constraint \u003d singleTransformer.transform();\n    AbstractConstraint sConstraintExpr \u003d constraint.getConstraintExpr();\n    SingleConstraint single \u003d (SingleConstraint) sConstraintExpr;\n    // Iterate through TargetExpressions\n    Iterator\u003cTargetExpression\u003e expIt \u003d single.getTargetExpressions().iterator();\n    while (expIt.hasNext()) {\n      TargetExpression currentExp \u003d expIt.next();\n      // Supporting AllocationTag Expressions for now\n      if (currentExp.getTargetType().equals(TargetType.ALLOCATION_TAG)) {\n        // Check if conditions are met\n        if (!canSatisfySingleConstraintExpression(appId, single, currentExp,\n            node, tagsManager)) {\n          return false;\n        }\n      }\n    }\n    // return true if all targetExpressions are satisfied\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/PlacementConstraintsUtil.java"
    }
  }
}