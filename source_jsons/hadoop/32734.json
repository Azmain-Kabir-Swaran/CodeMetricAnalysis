{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NodeStatusUpdaterImpl.java",
  "functionName": "updateTimelineCollectorData",
  "functionId": "updateTimelineCollectorData___response-NodeHeartbeatResponse",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
  "functionStartLine": 1440,
  "functionEndLine": 1478,
  "numCommitsSeen": 213,
  "timeTaken": 4655,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "78b7e070d8009c78665a2baa64fe888788f53e69",
    "84c35ac6c4a76c31d9bf9c87b87ed29394564611",
    "0d02ab8729630ad3cfb4300702927333b1d349e3",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "5712b8f9fd1859fe046b482889239bd164ed7dab"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "78b7e070d8009c78665a2baa64fe888788f53e69": "Ymultichange(Yrename,Ybodychange)",
    "84c35ac6c4a76c31d9bf9c87b87ed29394564611": "Ybodychange",
    "0d02ab8729630ad3cfb4300702927333b1d349e3": "Ybodychange",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "5712b8f9fd1859fe046b482889239bd164ed7dab": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "22/02/19 7:31 AM",
      "commitNameOld": "ed13cf84068ad50a78e66211132c1f08238fb65b",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 21.33,
      "commitsBetweenForRepo": 206,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,39 @@\n     private void updateTimelineCollectorData(\n         NodeHeartbeatResponse response) {\n       Map\u003cApplicationId, AppCollectorData\u003e incomingCollectorsMap \u003d\n           response.getAppCollectors();\n       if (incomingCollectorsMap \u003d\u003d null) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"No collectors to update RM\");\n-        }\n+        LOG.debug(\"No collectors to update RM\");\n         return;\n       }\n       Map\u003cApplicationId, AppCollectorData\u003e knownCollectors \u003d\n           context.getKnownCollectors();\n       for (Map.Entry\u003cApplicationId, AppCollectorData\u003e entry\n           : incomingCollectorsMap.entrySet()) {\n         ApplicationId appId \u003d entry.getKey();\n         AppCollectorData collectorData \u003d entry.getValue();\n \n         // Only handle applications running on local node.\n         Application application \u003d context.getApplications().get(appId);\n         if (application !\u003d null) {\n           // Update collector data if the newly received data happens after\n           // the known data (updates the known data).\n           AppCollectorData existingData \u003d knownCollectors.get(appId);\n           if (AppCollectorData.happensBefore(existingData, collectorData)) {\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Sync a new collector address: \"\n-                  + collectorData.getCollectorAddr()\n-                  + \" for application: \" + appId + \" from RM.\");\n-            }\n+            LOG.debug(\"Sync a new collector address: {} for application: {}\"\n+                + \" from RM.\", collectorData.getCollectorAddr(), appId);\n             // Update information for clients.\n             NMTimelinePublisher nmTimelinePublisher \u003d\n                 context.getNMTimelinePublisher();\n             if (nmTimelinePublisher !\u003d null) {\n               nmTimelinePublisher.setTimelineServiceAddress(\n                   application.getAppId(), collectorData.getCollectorAddr());\n             }\n             // Update information for the node manager itself.\n             knownCollectors.put(appId, collectorData);\n           }\n         }\n         // Remove the registering collector data\n         context.getRegisteringCollectors().remove(entry.getKey());\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void updateTimelineCollectorData(\n        NodeHeartbeatResponse response) {\n      Map\u003cApplicationId, AppCollectorData\u003e incomingCollectorsMap \u003d\n          response.getAppCollectors();\n      if (incomingCollectorsMap \u003d\u003d null) {\n        LOG.debug(\"No collectors to update RM\");\n        return;\n      }\n      Map\u003cApplicationId, AppCollectorData\u003e knownCollectors \u003d\n          context.getKnownCollectors();\n      for (Map.Entry\u003cApplicationId, AppCollectorData\u003e entry\n          : incomingCollectorsMap.entrySet()) {\n        ApplicationId appId \u003d entry.getKey();\n        AppCollectorData collectorData \u003d entry.getValue();\n\n        // Only handle applications running on local node.\n        Application application \u003d context.getApplications().get(appId);\n        if (application !\u003d null) {\n          // Update collector data if the newly received data happens after\n          // the known data (updates the known data).\n          AppCollectorData existingData \u003d knownCollectors.get(appId);\n          if (AppCollectorData.happensBefore(existingData, collectorData)) {\n            LOG.debug(\"Sync a new collector address: {} for application: {}\"\n                + \" from RM.\", collectorData.getCollectorAddr(), appId);\n            // Update information for clients.\n            NMTimelinePublisher nmTimelinePublisher \u003d\n                context.getNMTimelinePublisher();\n            if (nmTimelinePublisher !\u003d null) {\n              nmTimelinePublisher.setTimelineServiceAddress(\n                  application.getAppId(), collectorData.getCollectorAddr());\n            }\n            // Update information for the node manager itself.\n            knownCollectors.put(appId, collectorData);\n          }\n        }\n        // Remove the registering collector data\n        context.getRegisteringCollectors().remove(entry.getKey());\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "78b7e070d8009c78665a2baa64fe888788f53e69": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "YARN-5638. Introduce a collector timestamp to uniquely identify collectors creation order in collector discovery. Contributed by Li Lu.\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "78b7e070d8009c78665a2baa64fe888788f53e69",
      "commitAuthor": "Sangjin Lee",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-5638. Introduce a collector timestamp to uniquely identify collectors creation order in collector discovery. Contributed by Li Lu.\n",
          "commitDate": "29/08/17 10:59 PM",
          "commitName": "78b7e070d8009c78665a2baa64fe888788f53e69",
          "commitAuthor": "Sangjin Lee",
          "commitDateOld": "22/08/17 1:14 AM",
          "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 7.91,
          "commitsBetweenForRepo": 51,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,44 @@\n-    private void updateTimelineClientsAddress(\n+    private void updateTimelineCollectorData(\n         NodeHeartbeatResponse response) {\n-      Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n-          response.getAppCollectorsMap();\n-      if (knownCollectorsMap \u003d\u003d null) {\n+      Map\u003cApplicationId, AppCollectorData\u003e incomingCollectorsMap \u003d\n+          response.getAppCollectors();\n+      if (incomingCollectorsMap \u003d\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"No collectors to update RM\");\n         }\n-      } else {\n-        Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n-            knownCollectorsMap.entrySet();\n-        for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n-          ApplicationId appId \u003d entry.getKey();\n-          String collectorAddr \u003d entry.getValue();\n+        return;\n+      }\n+      Map\u003cApplicationId, AppCollectorData\u003e knownCollectors \u003d\n+          context.getKnownCollectors();\n+      for (Map.Entry\u003cApplicationId, AppCollectorData\u003e entry\n+          : incomingCollectorsMap.entrySet()) {\n+        ApplicationId appId \u003d entry.getKey();\n+        AppCollectorData collectorData \u003d entry.getValue();\n \n-          // Only handle applications running on local node.\n-          // Not include apps with timeline collectors running in local\n-          Application application \u003d context.getApplications().get(appId);\n-          // TODO this logic could be problematic if the collector address\n-          // gets updated due to NM restart or collector service failure\n-          if (application !\u003d null \u0026\u0026\n-              !context.getRegisteredCollectors().containsKey(appId)) {\n+        // Only handle applications running on local node.\n+        Application application \u003d context.getApplications().get(appId);\n+        if (application !\u003d null) {\n+          // Update collector data if the newly received data happens after\n+          // the known data (updates the known data).\n+          AppCollectorData existingData \u003d knownCollectors.get(appId);\n+          if (AppCollectorData.happensBefore(existingData, collectorData)) {\n             if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n-                      \" for application: \" + appId + \" from RM.\");\n+              LOG.debug(\"Sync a new collector address: \"\n+                  + collectorData.getCollectorAddr()\n+                  + \" for application: \" + appId + \" from RM.\");\n             }\n+            // Update information for clients.\n             NMTimelinePublisher nmTimelinePublisher \u003d\n                 context.getNMTimelinePublisher();\n             if (nmTimelinePublisher !\u003d null) {\n               nmTimelinePublisher.setTimelineServiceAddress(\n-                  application.getAppId(), collectorAddr);\n+                  application.getAppId(), collectorData.getCollectorAddr());\n             }\n+            // Update information for the node manager itself.\n+            knownCollectors.put(appId, collectorData);\n           }\n         }\n+        // Remove the registering collector data\n+        context.getRegisteringCollectors().remove(entry.getKey());\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void updateTimelineCollectorData(\n        NodeHeartbeatResponse response) {\n      Map\u003cApplicationId, AppCollectorData\u003e incomingCollectorsMap \u003d\n          response.getAppCollectors();\n      if (incomingCollectorsMap \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"No collectors to update RM\");\n        }\n        return;\n      }\n      Map\u003cApplicationId, AppCollectorData\u003e knownCollectors \u003d\n          context.getKnownCollectors();\n      for (Map.Entry\u003cApplicationId, AppCollectorData\u003e entry\n          : incomingCollectorsMap.entrySet()) {\n        ApplicationId appId \u003d entry.getKey();\n        AppCollectorData collectorData \u003d entry.getValue();\n\n        // Only handle applications running on local node.\n        Application application \u003d context.getApplications().get(appId);\n        if (application !\u003d null) {\n          // Update collector data if the newly received data happens after\n          // the known data (updates the known data).\n          AppCollectorData existingData \u003d knownCollectors.get(appId);\n          if (AppCollectorData.happensBefore(existingData, collectorData)) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Sync a new collector address: \"\n                  + collectorData.getCollectorAddr()\n                  + \" for application: \" + appId + \" from RM.\");\n            }\n            // Update information for clients.\n            NMTimelinePublisher nmTimelinePublisher \u003d\n                context.getNMTimelinePublisher();\n            if (nmTimelinePublisher !\u003d null) {\n              nmTimelinePublisher.setTimelineServiceAddress(\n                  application.getAppId(), collectorData.getCollectorAddr());\n            }\n            // Update information for the node manager itself.\n            knownCollectors.put(appId, collectorData);\n          }\n        }\n        // Remove the registering collector data\n        context.getRegisteringCollectors().remove(entry.getKey());\n      }\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
          "extendedDetails": {
            "oldValue": "updateTimelineClientsAddress",
            "newValue": "updateTimelineCollectorData"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5638. Introduce a collector timestamp to uniquely identify collectors creation order in collector discovery. Contributed by Li Lu.\n",
          "commitDate": "29/08/17 10:59 PM",
          "commitName": "78b7e070d8009c78665a2baa64fe888788f53e69",
          "commitAuthor": "Sangjin Lee",
          "commitDateOld": "22/08/17 1:14 AM",
          "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 7.91,
          "commitsBetweenForRepo": 51,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,44 @@\n-    private void updateTimelineClientsAddress(\n+    private void updateTimelineCollectorData(\n         NodeHeartbeatResponse response) {\n-      Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n-          response.getAppCollectorsMap();\n-      if (knownCollectorsMap \u003d\u003d null) {\n+      Map\u003cApplicationId, AppCollectorData\u003e incomingCollectorsMap \u003d\n+          response.getAppCollectors();\n+      if (incomingCollectorsMap \u003d\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"No collectors to update RM\");\n         }\n-      } else {\n-        Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n-            knownCollectorsMap.entrySet();\n-        for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n-          ApplicationId appId \u003d entry.getKey();\n-          String collectorAddr \u003d entry.getValue();\n+        return;\n+      }\n+      Map\u003cApplicationId, AppCollectorData\u003e knownCollectors \u003d\n+          context.getKnownCollectors();\n+      for (Map.Entry\u003cApplicationId, AppCollectorData\u003e entry\n+          : incomingCollectorsMap.entrySet()) {\n+        ApplicationId appId \u003d entry.getKey();\n+        AppCollectorData collectorData \u003d entry.getValue();\n \n-          // Only handle applications running on local node.\n-          // Not include apps with timeline collectors running in local\n-          Application application \u003d context.getApplications().get(appId);\n-          // TODO this logic could be problematic if the collector address\n-          // gets updated due to NM restart or collector service failure\n-          if (application !\u003d null \u0026\u0026\n-              !context.getRegisteredCollectors().containsKey(appId)) {\n+        // Only handle applications running on local node.\n+        Application application \u003d context.getApplications().get(appId);\n+        if (application !\u003d null) {\n+          // Update collector data if the newly received data happens after\n+          // the known data (updates the known data).\n+          AppCollectorData existingData \u003d knownCollectors.get(appId);\n+          if (AppCollectorData.happensBefore(existingData, collectorData)) {\n             if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n-                      \" for application: \" + appId + \" from RM.\");\n+              LOG.debug(\"Sync a new collector address: \"\n+                  + collectorData.getCollectorAddr()\n+                  + \" for application: \" + appId + \" from RM.\");\n             }\n+            // Update information for clients.\n             NMTimelinePublisher nmTimelinePublisher \u003d\n                 context.getNMTimelinePublisher();\n             if (nmTimelinePublisher !\u003d null) {\n               nmTimelinePublisher.setTimelineServiceAddress(\n-                  application.getAppId(), collectorAddr);\n+                  application.getAppId(), collectorData.getCollectorAddr());\n             }\n+            // Update information for the node manager itself.\n+            knownCollectors.put(appId, collectorData);\n           }\n         }\n+        // Remove the registering collector data\n+        context.getRegisteringCollectors().remove(entry.getKey());\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void updateTimelineCollectorData(\n        NodeHeartbeatResponse response) {\n      Map\u003cApplicationId, AppCollectorData\u003e incomingCollectorsMap \u003d\n          response.getAppCollectors();\n      if (incomingCollectorsMap \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"No collectors to update RM\");\n        }\n        return;\n      }\n      Map\u003cApplicationId, AppCollectorData\u003e knownCollectors \u003d\n          context.getKnownCollectors();\n      for (Map.Entry\u003cApplicationId, AppCollectorData\u003e entry\n          : incomingCollectorsMap.entrySet()) {\n        ApplicationId appId \u003d entry.getKey();\n        AppCollectorData collectorData \u003d entry.getValue();\n\n        // Only handle applications running on local node.\n        Application application \u003d context.getApplications().get(appId);\n        if (application !\u003d null) {\n          // Update collector data if the newly received data happens after\n          // the known data (updates the known data).\n          AppCollectorData existingData \u003d knownCollectors.get(appId);\n          if (AppCollectorData.happensBefore(existingData, collectorData)) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Sync a new collector address: \"\n                  + collectorData.getCollectorAddr()\n                  + \" for application: \" + appId + \" from RM.\");\n            }\n            // Update information for clients.\n            NMTimelinePublisher nmTimelinePublisher \u003d\n                context.getNMTimelinePublisher();\n            if (nmTimelinePublisher !\u003d null) {\n              nmTimelinePublisher.setTimelineServiceAddress(\n                  application.getAppId(), collectorData.getCollectorAddr());\n            }\n            // Update information for the node manager itself.\n            knownCollectors.put(appId, collectorData);\n          }\n        }\n        // Remove the registering collector data\n        context.getRegisteringCollectors().remove(entry.getKey());\n      }\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "84c35ac6c4a76c31d9bf9c87b87ed29394564611": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4711. NM is going down with NPE\u0027s due to single thread processing of events by Timeline client (Naganarasimha G R via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "84c35ac6c4a76c31d9bf9c87b87ed29394564611",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "0d02ab8729630ad3cfb4300702927333b1d349e3",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,36 @@\n       private void updateTimelineClientsAddress(\n           NodeHeartbeatResponse response) {\n         Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n             response.getAppCollectorsMap();\n         if (knownCollectorsMap \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"No collectors to update RM\");\n           }\n         } else {\n           Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n               knownCollectorsMap.entrySet();\n           for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n             ApplicationId appId \u003d entry.getKey();\n             String collectorAddr \u003d entry.getValue();\n \n             // Only handle applications running on local node.\n             // Not include apps with timeline collectors running in local\n             Application application \u003d context.getApplications().get(appId);\n             // TODO this logic could be problematic if the collector address\n             // gets updated due to NM restart or collector service failure\n             if (application !\u003d null \u0026\u0026\n                 !context.getRegisteredCollectors().containsKey(appId)) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n                     \" for application: \" + appId + \" from RM.\");\n               }\n-              TimelineClient client \u003d application.getTimelineClient();\n-              if (client !\u003d null) {\n-                client.setTimelineServiceAddress(collectorAddr);\n+              NMTimelinePublisher nmTimelinePublisher \u003d\n+                  context.getNMTimelinePublisher();\n+              if (nmTimelinePublisher !\u003d null) {\n+                nmTimelinePublisher.setTimelineServiceAddress(\n+                    application.getAppId(), collectorAddr);\n               }\n             }\n           }\n         }\n       }\n\\ No newline at end of file\n",
      "actualSource": "      private void updateTimelineClientsAddress(\n          NodeHeartbeatResponse response) {\n        Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n            response.getAppCollectorsMap();\n        if (knownCollectorsMap \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"No collectors to update RM\");\n          }\n        } else {\n          Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n              knownCollectorsMap.entrySet();\n          for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n            ApplicationId appId \u003d entry.getKey();\n            String collectorAddr \u003d entry.getValue();\n\n            // Only handle applications running on local node.\n            // Not include apps with timeline collectors running in local\n            Application application \u003d context.getApplications().get(appId);\n            // TODO this logic could be problematic if the collector address\n            // gets updated due to NM restart or collector service failure\n            if (application !\u003d null \u0026\u0026\n                !context.getRegisteredCollectors().containsKey(appId)) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n                    \" for application: \" + appId + \" from RM.\");\n              }\n              NMTimelinePublisher nmTimelinePublisher \u003d\n                  context.getNMTimelinePublisher();\n              if (nmTimelinePublisher !\u003d null) {\n                nmTimelinePublisher.setTimelineServiceAddress(\n                    application.getAppId(), collectorAddr);\n              }\n            }\n          }\n        }\n      }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "0d02ab8729630ad3cfb4300702927333b1d349e3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3367. Replace starting a separate thread for post entity with event loop in TimelineClient (Naganarasimha G R via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "0d02ab8729630ad3cfb4300702927333b1d349e3",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,34 @@\n       private void updateTimelineClientsAddress(\n           NodeHeartbeatResponse response) {\n         Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n             response.getAppCollectorsMap();\n         if (knownCollectorsMap \u003d\u003d null) {\n-          LOG.warn(\"the collectors map is null\");\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"No collectors to update RM\");\n+          }\n         } else {\n           Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n               knownCollectorsMap.entrySet();\n           for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n             ApplicationId appId \u003d entry.getKey();\n             String collectorAddr \u003d entry.getValue();\n \n             // Only handle applications running on local node.\n             // Not include apps with timeline collectors running in local\n             Application application \u003d context.getApplications().get(appId);\n             // TODO this logic could be problematic if the collector address\n             // gets updated due to NM restart or collector service failure\n             if (application !\u003d null \u0026\u0026\n                 !context.getRegisteredCollectors().containsKey(appId)) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n                     \" for application: \" + appId + \" from RM.\");\n               }\n               TimelineClient client \u003d application.getTimelineClient();\n               if (client !\u003d null) {\n                 client.setTimelineServiceAddress(collectorAddr);\n               }\n             }\n           }\n         }\n       }\n\\ No newline at end of file\n",
      "actualSource": "      private void updateTimelineClientsAddress(\n          NodeHeartbeatResponse response) {\n        Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n            response.getAppCollectorsMap();\n        if (knownCollectorsMap \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"No collectors to update RM\");\n          }\n        } else {\n          Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n              knownCollectorsMap.entrySet();\n          for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n            ApplicationId appId \u003d entry.getKey();\n            String collectorAddr \u003d entry.getValue();\n\n            // Only handle applications running on local node.\n            // Not include apps with timeline collectors running in local\n            Application application \u003d context.getApplications().get(appId);\n            // TODO this logic could be problematic if the collector address\n            // gets updated due to NM restart or collector service failure\n            if (application !\u003d null \u0026\u0026\n                !context.getRegisteredCollectors().containsKey(appId)) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n                    \" for application: \" + appId + \" from RM.\");\n              }\n              TimelineClient client \u003d application.getTimelineClient();\n              if (client !\u003d null) {\n                client.setTimelineServiceAddress(collectorAddr);\n              }\n            }\n          }\n        }\n      }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "5712b8f9fd1859fe046b482889239bd164ed7dab",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,32 @@\n       private void updateTimelineClientsAddress(\n           NodeHeartbeatResponse response) {\n-        Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d \n-            response.getAppCollectorsMap().entrySet();\n-        for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n-          ApplicationId appId \u003d entry.getKey();\n-          String collectorAddr \u003d entry.getValue();\n+        Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n+            response.getAppCollectorsMap();\n+        if (knownCollectorsMap \u003d\u003d null) {\n+          LOG.warn(\"the collectors map is null\");\n+        } else {\n+          Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n+              knownCollectorsMap.entrySet();\n+          for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n+            ApplicationId appId \u003d entry.getKey();\n+            String collectorAddr \u003d entry.getValue();\n \n-          // Only handle applications running on local node.\n-          // Not include apps with timeline collectors running in local\n-          Application application \u003d context.getApplications().get(appId);\n-          if (application !\u003d null \u0026\u0026\n-              !context.getRegisteredCollectors().containsKey(appId)) {\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Sync a new collector address: \" + collectorAddr + \n-                  \" for application: \" + appId + \" from RM.\");\n+            // Only handle applications running on local node.\n+            // Not include apps with timeline collectors running in local\n+            Application application \u003d context.getApplications().get(appId);\n+            // TODO this logic could be problematic if the collector address\n+            // gets updated due to NM restart or collector service failure\n+            if (application !\u003d null \u0026\u0026\n+                !context.getRegisteredCollectors().containsKey(appId)) {\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n+                    \" for application: \" + appId + \" from RM.\");\n+              }\n+              TimelineClient client \u003d application.getTimelineClient();\n+              if (client !\u003d null) {\n+                client.setTimelineServiceAddress(collectorAddr);\n+              }\n             }\n-            TimelineClient client \u003d application.getTimelineClient();\n-            client.setTimelineServiceAddress(collectorAddr);\n           }\n         }\n       }\n\\ No newline at end of file\n",
      "actualSource": "      private void updateTimelineClientsAddress(\n          NodeHeartbeatResponse response) {\n        Map\u003cApplicationId, String\u003e knownCollectorsMap \u003d\n            response.getAppCollectorsMap();\n        if (knownCollectorsMap \u003d\u003d null) {\n          LOG.warn(\"the collectors map is null\");\n        } else {\n          Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d\n              knownCollectorsMap.entrySet();\n          for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n            ApplicationId appId \u003d entry.getKey();\n            String collectorAddr \u003d entry.getValue();\n\n            // Only handle applications running on local node.\n            // Not include apps with timeline collectors running in local\n            Application application \u003d context.getApplications().get(appId);\n            // TODO this logic could be problematic if the collector address\n            // gets updated due to NM restart or collector service failure\n            if (application !\u003d null \u0026\u0026\n                !context.getRegisteredCollectors().containsKey(appId)) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Sync a new collector address: \" + collectorAddr +\n                    \" for application: \" + appId + \" from RM.\");\n              }\n              TimelineClient client \u003d application.getTimelineClient();\n              if (client !\u003d null) {\n                client.setTimelineServiceAddress(collectorAddr);\n              }\n            }\n          }\n        }\n      }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "5712b8f9fd1859fe046b482889239bd164ed7dab": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3334. NM uses timeline client to publish container metrics to new timeline service. Contributed by Junping Du.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "5712b8f9fd1859fe046b482889239bd164ed7dab",
      "commitAuthor": "Zhijie Shen",
      "diff": "@@ -0,0 +1,22 @@\n+      private void updateTimelineClientsAddress(\n+          NodeHeartbeatResponse response) {\n+        Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d \n+            response.getAppCollectorsMap().entrySet();\n+        for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n+          ApplicationId appId \u003d entry.getKey();\n+          String collectorAddr \u003d entry.getValue();\n+\n+          // Only handle applications running on local node.\n+          // Not include apps with timeline collectors running in local\n+          Application application \u003d context.getApplications().get(appId);\n+          if (application !\u003d null \u0026\u0026\n+              !context.getRegisteredCollectors().containsKey(appId)) {\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Sync a new collector address: \" + collectorAddr + \n+                  \" for application: \" + appId + \" from RM.\");\n+            }\n+            TimelineClient client \u003d application.getTimelineClient();\n+            client.setTimelineServiceAddress(collectorAddr);\n+          }\n+        }\n+      }\n\\ No newline at end of file\n",
      "actualSource": "      private void updateTimelineClientsAddress(\n          NodeHeartbeatResponse response) {\n        Set\u003cMap.Entry\u003cApplicationId, String\u003e\u003e rmKnownCollectors \u003d \n            response.getAppCollectorsMap().entrySet();\n        for (Map.Entry\u003cApplicationId, String\u003e entry : rmKnownCollectors) {\n          ApplicationId appId \u003d entry.getKey();\n          String collectorAddr \u003d entry.getValue();\n\n          // Only handle applications running on local node.\n          // Not include apps with timeline collectors running in local\n          Application application \u003d context.getApplications().get(appId);\n          if (application !\u003d null \u0026\u0026\n              !context.getRegisteredCollectors().containsKey(appId)) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Sync a new collector address: \" + collectorAddr + \n                  \" for application: \" + appId + \" from RM.\");\n            }\n            TimelineClient client \u003d application.getTimelineClient();\n            client.setTimelineServiceAddress(collectorAddr);\n          }\n        }\n      }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java"
    }
  }
}