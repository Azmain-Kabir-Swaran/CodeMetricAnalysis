{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMAppManager.java",
  "functionName": "createAndPopulateNewRMApp",
  "functionId": "createAndPopulateNewRMApp___submissionContext-ApplicationSubmissionContext__submitTime-long__user-String__isRecovery-boolean__startTime-long__recoveredFinalState-RMAppState",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
  "functionStartLine": 396,
  "functionEndLine": 520,
  "numCommitsSeen": 294,
  "timeTaken": 17223,
  "changeHistory": [
    "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc",
    "5257f50abb71905ef3068fd45541d00ce9e8f355",
    "ed13cf84068ad50a78e66211132c1f08238fb65b",
    "e673dd1d4d78b66e7b6705ec6dc3679d2347d704",
    "bd15d2396ef0c24fb6b60c6393d16b37651b828e",
    "c9bf813c9a6c018d14f2bef49ba086ec0e60c761",
    "cb87e4dc927731e32b0bbcf678bb5600835ff28d",
    "8bb83a8f625953e2a45db4bbbfb95cd41bac6af5",
    "f9f317b70209d20161d66a73ddea3334d2b92f96",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
    "91f120f743662c6e037e8f21b1792e81d58ac664",
    "9bae6720cb8432efd78c909dc624c00e367cedf5",
    "3fa0d540dfca579f3c2840a959b748a7528b02ed",
    "287d3d6804a869723ae36605a3c2d2b3eae3941e",
    "020316458dfe6059b700f8d93a9791e4cb817b3f",
    "a926f895c11cd69cf2117c3b970304f3f1f53d92",
    "2ae5a3a5bf5ea355370469a53eeccff0b5220081",
    "874577a67df8a49243586909d866034df4e3b276",
    "702236129b930a799a5a3295f0aa0dc7b619c354",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "11e8905d8daf129afb6fe2e5a0eca11bcb1719c8",
    "04f6ebb66a4ffc04a635ab9c0234080f290b39f2",
    "3c33158d1cb38ee4ab3baa21752a3cdf0bdc8ccc",
    "c0537bcd2c2dcdb4812fcab7badf42e4f55a54d9",
    "8310b2e9ff3d6804bad703c4c15458b0dfeeb4af",
    "5468baa80aa2a3e2a02e9a902deebafd734daf23",
    "c39ca541f498712133890961598bbff50d89d68b",
    "f65eeb412d140a3808bcf99344a9f3a965918f70",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
    "90a0c03f0a696d32e871a5da4560828edea8cfa9",
    "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
    "512475e56f0a27bf3c3ff596184f96993bb4bef4"
  ],
  "changeHistoryShort": {
    "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc": "Ymultichange(Yparameterchange,Ybodychange)",
    "5257f50abb71905ef3068fd45541d00ce9e8f355": "Ybodychange",
    "ed13cf84068ad50a78e66211132c1f08238fb65b": "Ybodychange",
    "e673dd1d4d78b66e7b6705ec6dc3679d2347d704": "Ybodychange",
    "bd15d2396ef0c24fb6b60c6393d16b37651b828e": "Ybodychange",
    "c9bf813c9a6c018d14f2bef49ba086ec0e60c761": "Ybodychange",
    "cb87e4dc927731e32b0bbcf678bb5600835ff28d": "Ybodychange",
    "8bb83a8f625953e2a45db4bbbfb95cd41bac6af5": "Ybodychange",
    "f9f317b70209d20161d66a73ddea3334d2b92f96": "Ybodychange",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": "Ybodychange",
    "91f120f743662c6e037e8f21b1792e81d58ac664": "Ybodychange",
    "9bae6720cb8432efd78c909dc624c00e367cedf5": "Ybodychange",
    "3fa0d540dfca579f3c2840a959b748a7528b02ed": "Ybodychange",
    "287d3d6804a869723ae36605a3c2d2b3eae3941e": "Ybodychange",
    "020316458dfe6059b700f8d93a9791e4cb817b3f": "Ybodychange",
    "a926f895c11cd69cf2117c3b970304f3f1f53d92": "Ybodychange",
    "2ae5a3a5bf5ea355370469a53eeccff0b5220081": "Ybodychange",
    "874577a67df8a49243586909d866034df4e3b276": "Ymultichange(Yexceptionschange,Ybodychange)",
    "702236129b930a799a5a3295f0aa0dc7b619c354": "Ymultichange(Yparameterchange,Ybodychange)",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "11e8905d8daf129afb6fe2e5a0eca11bcb1719c8": "Ybodychange",
    "04f6ebb66a4ffc04a635ab9c0234080f290b39f2": "Ybodychange",
    "3c33158d1cb38ee4ab3baa21752a3cdf0bdc8ccc": "Ybodychange",
    "c0537bcd2c2dcdb4812fcab7badf42e4f55a54d9": "Ybodychange",
    "8310b2e9ff3d6804bad703c4c15458b0dfeeb4af": "Ymultichange(Yexceptionschange,Ybodychange)",
    "5468baa80aa2a3e2a02e9a902deebafd734daf23": "Ybodychange",
    "c39ca541f498712133890961598bbff50d89d68b": "Ybodychange",
    "f65eeb412d140a3808bcf99344a9f3a965918f70": "Ymultichange(Yparameterchange,Ybodychange)",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": "Ybodychange",
    "90a0c03f0a696d32e871a5da4560828edea8cfa9": "Ybodychange",
    "ebe0c17a95ae37d4768f2928ea193e89db34ead5": "Ybodychange",
    "512475e56f0a27bf3c3ff596184f96993bb4bef4": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-9723. ApplicationPlacementContext is not required for terminated jobs during recovery. Contributed by Prabhu Joseph\n",
      "commitDate": "12/08/19 6:15 AM",
      "commitName": "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc",
      "commitAuthor": "Szilard Nemeth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-9723. ApplicationPlacementContext is not required for terminated jobs during recovery. Contributed by Prabhu Joseph\n",
          "commitDate": "12/08/19 6:15 AM",
          "commitName": "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "15/05/19 1:00 AM",
          "commitNameOld": "570fa2da20706490dc7823efd0ce0cef3ddc81f9",
          "commitAuthorOld": "bibinchundatt",
          "daysBetweenCommits": 89.22,
          "commitsBetweenForRepo": 715,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,122 +1,125 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      String user, boolean isRecovery, long startTime) throws YarnException {\n+      String user, boolean isRecovery, long startTime,\n+      RMAppState recoveredFinalState) throws YarnException {\n \n-    ApplicationPlacementContext placementContext \u003d\n-        placeApplication(rmContext.getQueuePlacementManager(),\n-            submissionContext, user, isRecovery);\n+    ApplicationPlacementContext placementContext \u003d null;\n+    if (recoveredFinalState \u003d\u003d null) {\n+      placementContext \u003d placeApplication(rmContext.getQueuePlacementManager(),\n+          submissionContext, user, isRecovery);\n+    }\n \n     // We only replace the queue when it\u0027s a new application\n     if (!isRecovery) {\n       copyPlacementQueueToSubmissionContext(placementContext,\n           submissionContext);\n \n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n         submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     // Application priority needed to be validated only while submitting. During\n     // recovery, validated priority could be recovered from submission context.\n     if (!isRecovery) {\n       Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n           submissionContext.getPriority(), userUgi,\n           submissionContext.getQueue(),\n           applicationId);\n       submissionContext.setPriority(appPriority);\n     }\n \n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)) {\n       if (scheduler instanceof CapacityScheduler) {\n         String queueName \u003d submissionContext.getQueue();\n         String appName \u003d submissionContext.getApplicationName();\n         CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n \n         if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n           //could be an auto created queue through queue mapping. Validate\n           // parent queue exists and has valid acls\n           String parentQueueName \u003d placementContext.getParentQueue();\n           csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n         }\n \n         if (csqueue !\u003d null\n             \u0026\u0026 !authorizer.checkPermission(\n             new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                 SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                 applicationId.toString(), appName, Server.getRemoteAddress(),\n                 null))\n             \u0026\u0026 !authorizer.checkPermission(\n             new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                 SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                 applicationId.toString(), appName, Server.getRemoteAddress(),\n                 null))) {\n           throw RPCUtil.getRemoteException(new AccessControlException(\n               \"User \" + user + \" does not have permission to submit \"\n                   + applicationId + \" to queue \"\n                   + submissionContext.getQueue()));\n         }\n       }\n       if (scheduler instanceof FairScheduler) {\n         // if we have not placed the app just skip this, the submit will be\n         // rejected in the scheduler.\n         if (placementContext !\u003d null) {\n           // The queue might not be created yet. Walk up the tree to check the\n           // parent ACL. The queueName is assured root which always exists\n           String queueName \u003d submissionContext.getQueue();\n           FSQueue queue \u003d ((FairScheduler) scheduler).getQueueManager().\n               getQueue(queueName);\n           while (queue \u003d\u003d null) {\n             int sepIndex \u003d queueName.lastIndexOf(\".\");\n             queueName \u003d queueName.substring(0, sepIndex);\n             queue \u003d ((FairScheduler) scheduler).getQueueManager().\n                 getQueue(queueName);\n           }\n           if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026\n               !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n             throw RPCUtil.getRemoteException(new AccessControlException(\n                 \"User \" + user + \" does not have permission to submit \" +\n                     applicationId + \" to queue \" +\n                     submissionContext.getQueue() +\n                     \" denied by ACL for queue \" + queueName));\n           }\n         }\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReqs, placementContext,\n             startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (timelineServiceV2Enabled) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     return application;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime,\n      RMAppState recoveredFinalState) throws YarnException {\n\n    ApplicationPlacementContext placementContext \u003d null;\n    if (recoveredFinalState \u003d\u003d null) {\n      placementContext \u003d placeApplication(rmContext.getQueuePlacementManager(),\n          submissionContext, user, isRecovery);\n    }\n\n    // We only replace the queue when it\u0027s a new application\n    if (!isRecovery) {\n      copyPlacementQueueToSubmissionContext(placementContext,\n          submissionContext);\n\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n        submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    // Application priority needed to be validated only while submitting. During\n    // recovery, validated priority could be recovered from submission context.\n    if (!isRecovery) {\n      Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n          submissionContext.getPriority(), userUgi,\n          submissionContext.getQueue(),\n          applicationId);\n      submissionContext.setPriority(appPriority);\n    }\n\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)) {\n      if (scheduler instanceof CapacityScheduler) {\n        String queueName \u003d submissionContext.getQueue();\n        String appName \u003d submissionContext.getApplicationName();\n        CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n\n        if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n          //could be an auto created queue through queue mapping. Validate\n          // parent queue exists and has valid acls\n          String parentQueueName \u003d placementContext.getParentQueue();\n          csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n        }\n\n        if (csqueue !\u003d null\n            \u0026\u0026 !authorizer.checkPermission(\n            new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                applicationId.toString(), appName, Server.getRemoteAddress(),\n                null))\n            \u0026\u0026 !authorizer.checkPermission(\n            new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                applicationId.toString(), appName, Server.getRemoteAddress(),\n                null))) {\n          throw RPCUtil.getRemoteException(new AccessControlException(\n              \"User \" + user + \" does not have permission to submit \"\n                  + applicationId + \" to queue \"\n                  + submissionContext.getQueue()));\n        }\n      }\n      if (scheduler instanceof FairScheduler) {\n        // if we have not placed the app just skip this, the submit will be\n        // rejected in the scheduler.\n        if (placementContext !\u003d null) {\n          // The queue might not be created yet. Walk up the tree to check the\n          // parent ACL. The queueName is assured root which always exists\n          String queueName \u003d submissionContext.getQueue();\n          FSQueue queue \u003d ((FairScheduler) scheduler).getQueueManager().\n              getQueue(queueName);\n          while (queue \u003d\u003d null) {\n            int sepIndex \u003d queueName.lastIndexOf(\".\");\n            queueName \u003d queueName.substring(0, sepIndex);\n            queue \u003d ((FairScheduler) scheduler).getQueueManager().\n                getQueue(queueName);\n          }\n          if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026\n              !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n            throw RPCUtil.getRemoteException(new AccessControlException(\n                \"User \" + user + \" does not have permission to submit \" +\n                    applicationId + \" to queue \" +\n                    submissionContext.getQueue() +\n                    \" denied by ACL for queue \" + queueName));\n          }\n        }\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReqs, placementContext,\n            startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (timelineServiceV2Enabled) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    return application;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long, user-String, isRecovery-boolean, startTime-long]",
            "newValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long, user-String, isRecovery-boolean, startTime-long, recoveredFinalState-RMAppState]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9723. ApplicationPlacementContext is not required for terminated jobs during recovery. Contributed by Prabhu Joseph\n",
          "commitDate": "12/08/19 6:15 AM",
          "commitName": "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "15/05/19 1:00 AM",
          "commitNameOld": "570fa2da20706490dc7823efd0ce0cef3ddc81f9",
          "commitAuthorOld": "bibinchundatt",
          "daysBetweenCommits": 89.22,
          "commitsBetweenForRepo": 715,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,122 +1,125 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      String user, boolean isRecovery, long startTime) throws YarnException {\n+      String user, boolean isRecovery, long startTime,\n+      RMAppState recoveredFinalState) throws YarnException {\n \n-    ApplicationPlacementContext placementContext \u003d\n-        placeApplication(rmContext.getQueuePlacementManager(),\n-            submissionContext, user, isRecovery);\n+    ApplicationPlacementContext placementContext \u003d null;\n+    if (recoveredFinalState \u003d\u003d null) {\n+      placementContext \u003d placeApplication(rmContext.getQueuePlacementManager(),\n+          submissionContext, user, isRecovery);\n+    }\n \n     // We only replace the queue when it\u0027s a new application\n     if (!isRecovery) {\n       copyPlacementQueueToSubmissionContext(placementContext,\n           submissionContext);\n \n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n         submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     // Application priority needed to be validated only while submitting. During\n     // recovery, validated priority could be recovered from submission context.\n     if (!isRecovery) {\n       Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n           submissionContext.getPriority(), userUgi,\n           submissionContext.getQueue(),\n           applicationId);\n       submissionContext.setPriority(appPriority);\n     }\n \n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)) {\n       if (scheduler instanceof CapacityScheduler) {\n         String queueName \u003d submissionContext.getQueue();\n         String appName \u003d submissionContext.getApplicationName();\n         CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n \n         if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n           //could be an auto created queue through queue mapping. Validate\n           // parent queue exists and has valid acls\n           String parentQueueName \u003d placementContext.getParentQueue();\n           csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n         }\n \n         if (csqueue !\u003d null\n             \u0026\u0026 !authorizer.checkPermission(\n             new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                 SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                 applicationId.toString(), appName, Server.getRemoteAddress(),\n                 null))\n             \u0026\u0026 !authorizer.checkPermission(\n             new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                 SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                 applicationId.toString(), appName, Server.getRemoteAddress(),\n                 null))) {\n           throw RPCUtil.getRemoteException(new AccessControlException(\n               \"User \" + user + \" does not have permission to submit \"\n                   + applicationId + \" to queue \"\n                   + submissionContext.getQueue()));\n         }\n       }\n       if (scheduler instanceof FairScheduler) {\n         // if we have not placed the app just skip this, the submit will be\n         // rejected in the scheduler.\n         if (placementContext !\u003d null) {\n           // The queue might not be created yet. Walk up the tree to check the\n           // parent ACL. The queueName is assured root which always exists\n           String queueName \u003d submissionContext.getQueue();\n           FSQueue queue \u003d ((FairScheduler) scheduler).getQueueManager().\n               getQueue(queueName);\n           while (queue \u003d\u003d null) {\n             int sepIndex \u003d queueName.lastIndexOf(\".\");\n             queueName \u003d queueName.substring(0, sepIndex);\n             queue \u003d ((FairScheduler) scheduler).getQueueManager().\n                 getQueue(queueName);\n           }\n           if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026\n               !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n             throw RPCUtil.getRemoteException(new AccessControlException(\n                 \"User \" + user + \" does not have permission to submit \" +\n                     applicationId + \" to queue \" +\n                     submissionContext.getQueue() +\n                     \" denied by ACL for queue \" + queueName));\n           }\n         }\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReqs, placementContext,\n             startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (timelineServiceV2Enabled) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     return application;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime,\n      RMAppState recoveredFinalState) throws YarnException {\n\n    ApplicationPlacementContext placementContext \u003d null;\n    if (recoveredFinalState \u003d\u003d null) {\n      placementContext \u003d placeApplication(rmContext.getQueuePlacementManager(),\n          submissionContext, user, isRecovery);\n    }\n\n    // We only replace the queue when it\u0027s a new application\n    if (!isRecovery) {\n      copyPlacementQueueToSubmissionContext(placementContext,\n          submissionContext);\n\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n        submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    // Application priority needed to be validated only while submitting. During\n    // recovery, validated priority could be recovered from submission context.\n    if (!isRecovery) {\n      Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n          submissionContext.getPriority(), userUgi,\n          submissionContext.getQueue(),\n          applicationId);\n      submissionContext.setPriority(appPriority);\n    }\n\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)) {\n      if (scheduler instanceof CapacityScheduler) {\n        String queueName \u003d submissionContext.getQueue();\n        String appName \u003d submissionContext.getApplicationName();\n        CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n\n        if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n          //could be an auto created queue through queue mapping. Validate\n          // parent queue exists and has valid acls\n          String parentQueueName \u003d placementContext.getParentQueue();\n          csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n        }\n\n        if (csqueue !\u003d null\n            \u0026\u0026 !authorizer.checkPermission(\n            new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                applicationId.toString(), appName, Server.getRemoteAddress(),\n                null))\n            \u0026\u0026 !authorizer.checkPermission(\n            new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                applicationId.toString(), appName, Server.getRemoteAddress(),\n                null))) {\n          throw RPCUtil.getRemoteException(new AccessControlException(\n              \"User \" + user + \" does not have permission to submit \"\n                  + applicationId + \" to queue \"\n                  + submissionContext.getQueue()));\n        }\n      }\n      if (scheduler instanceof FairScheduler) {\n        // if we have not placed the app just skip this, the submit will be\n        // rejected in the scheduler.\n        if (placementContext !\u003d null) {\n          // The queue might not be created yet. Walk up the tree to check the\n          // parent ACL. The queueName is assured root which always exists\n          String queueName \u003d submissionContext.getQueue();\n          FSQueue queue \u003d ((FairScheduler) scheduler).getQueueManager().\n              getQueue(queueName);\n          while (queue \u003d\u003d null) {\n            int sepIndex \u003d queueName.lastIndexOf(\".\");\n            queueName \u003d queueName.substring(0, sepIndex);\n            queue \u003d ((FairScheduler) scheduler).getQueueManager().\n                getQueue(queueName);\n          }\n          if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026\n              !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n            throw RPCUtil.getRemoteException(new AccessControlException(\n                \"User \" + user + \" does not have permission to submit \" +\n                    applicationId + \" to queue \" +\n                    submissionContext.getQueue() +\n                    \" denied by ACL for queue \" + queueName));\n          }\n        }\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReqs, placementContext,\n            startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (timelineServiceV2Enabled) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    return application;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "5257f50abb71905ef3068fd45541d00ce9e8f355": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8967. Change FairScheduler to use PlacementRule interface. Contributed by Wilfred Spiegelenburg.\n",
      "commitDate": "25/03/19 10:47 PM",
      "commitName": "5257f50abb71905ef3068fd45541d00ce9e8f355",
      "commitAuthor": "yufei",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 10.27,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,122 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n \n     ApplicationPlacementContext placementContext \u003d\n         placeApplication(rmContext.getQueuePlacementManager(),\n             submissionContext, user, isRecovery);\n \n     // We only replace the queue when it\u0027s a new application\n     if (!isRecovery) {\n-      replaceQueueFromPlacementContext(placementContext, submissionContext);\n+      copyPlacementQueueToSubmissionContext(placementContext,\n+          submissionContext);\n \n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n         submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     // Application priority needed to be validated only while submitting. During\n     // recovery, validated priority could be recovered from submission context.\n     if (!isRecovery) {\n       Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n           submissionContext.getPriority(), userUgi,\n           submissionContext.getQueue(),\n           applicationId);\n       submissionContext.setPriority(appPriority);\n     }\n \n-    // Since FairScheduler queue mapping is done inside scheduler,\n-    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n-    // fail here because queue will be created inside FS. Ideally, FS queue\n-    // mapping should be done outside scheduler too like CS.\n-    // For now, exclude FS for the acl check.\n-    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n-        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n-      String queueName \u003d submissionContext.getQueue();\n-      String appName \u003d submissionContext.getApplicationName();\n-      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n+    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)) {\n+      if (scheduler instanceof CapacityScheduler) {\n+        String queueName \u003d submissionContext.getQueue();\n+        String appName \u003d submissionContext.getApplicationName();\n+        CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n \n-      if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n-        //could be an auto created queue through queue mapping. Validate\n-        // parent queue exists and has valid acls\n-        String parentQueueName \u003d placementContext.getParentQueue();\n-        csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n+        if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n+          //could be an auto created queue through queue mapping. Validate\n+          // parent queue exists and has valid acls\n+          String parentQueueName \u003d placementContext.getParentQueue();\n+          csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n+        }\n+\n+        if (csqueue !\u003d null\n+            \u0026\u0026 !authorizer.checkPermission(\n+            new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n+                SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n+                applicationId.toString(), appName, Server.getRemoteAddress(),\n+                null))\n+            \u0026\u0026 !authorizer.checkPermission(\n+            new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n+                SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n+                applicationId.toString(), appName, Server.getRemoteAddress(),\n+                null))) {\n+          throw RPCUtil.getRemoteException(new AccessControlException(\n+              \"User \" + user + \" does not have permission to submit \"\n+                  + applicationId + \" to queue \"\n+                  + submissionContext.getQueue()));\n+        }\n       }\n-\n-      if (csqueue !\u003d null\n-          \u0026\u0026 !authorizer.checkPermission(\n-              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n-                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n-                  applicationId.toString(), appName, Server.getRemoteAddress(),\n-                  null))\n-          \u0026\u0026 !authorizer.checkPermission(\n-              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n-                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n-                  applicationId.toString(), appName, Server.getRemoteAddress(),\n-                  null))) {\n-        throw RPCUtil.getRemoteException(new AccessControlException(\n-            \"User \" + user + \" does not have permission to submit \"\n-                + applicationId + \" to queue \" + submissionContext.getQueue()));\n+      if (scheduler instanceof FairScheduler) {\n+        // if we have not placed the app just skip this, the submit will be\n+        // rejected in the scheduler.\n+        if (placementContext !\u003d null) {\n+          // The queue might not be created yet. Walk up the tree to check the\n+          // parent ACL. The queueName is assured root which always exists\n+          String queueName \u003d submissionContext.getQueue();\n+          FSQueue queue \u003d ((FairScheduler) scheduler).getQueueManager().\n+              getQueue(queueName);\n+          while (queue \u003d\u003d null) {\n+            int sepIndex \u003d queueName.lastIndexOf(\".\");\n+            queueName \u003d queueName.substring(0, sepIndex);\n+            queue \u003d ((FairScheduler) scheduler).getQueueManager().\n+                getQueue(queueName);\n+          }\n+          if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026\n+              !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n+            throw RPCUtil.getRemoteException(new AccessControlException(\n+                \"User \" + user + \" does not have permission to submit \" +\n+                    applicationId + \" to queue \" +\n+                    submissionContext.getQueue() +\n+                    \" denied by ACL for queue \" + queueName));\n+          }\n+        }\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReqs, placementContext,\n             startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (timelineServiceV2Enabled) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n\n    ApplicationPlacementContext placementContext \u003d\n        placeApplication(rmContext.getQueuePlacementManager(),\n            submissionContext, user, isRecovery);\n\n    // We only replace the queue when it\u0027s a new application\n    if (!isRecovery) {\n      copyPlacementQueueToSubmissionContext(placementContext,\n          submissionContext);\n\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n        submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    // Application priority needed to be validated only while submitting. During\n    // recovery, validated priority could be recovered from submission context.\n    if (!isRecovery) {\n      Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n          submissionContext.getPriority(), userUgi,\n          submissionContext.getQueue(),\n          applicationId);\n      submissionContext.setPriority(appPriority);\n    }\n\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)) {\n      if (scheduler instanceof CapacityScheduler) {\n        String queueName \u003d submissionContext.getQueue();\n        String appName \u003d submissionContext.getApplicationName();\n        CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n\n        if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n          //could be an auto created queue through queue mapping. Validate\n          // parent queue exists and has valid acls\n          String parentQueueName \u003d placementContext.getParentQueue();\n          csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n        }\n\n        if (csqueue !\u003d null\n            \u0026\u0026 !authorizer.checkPermission(\n            new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                applicationId.toString(), appName, Server.getRemoteAddress(),\n                null))\n            \u0026\u0026 !authorizer.checkPermission(\n            new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                applicationId.toString(), appName, Server.getRemoteAddress(),\n                null))) {\n          throw RPCUtil.getRemoteException(new AccessControlException(\n              \"User \" + user + \" does not have permission to submit \"\n                  + applicationId + \" to queue \"\n                  + submissionContext.getQueue()));\n        }\n      }\n      if (scheduler instanceof FairScheduler) {\n        // if we have not placed the app just skip this, the submit will be\n        // rejected in the scheduler.\n        if (placementContext !\u003d null) {\n          // The queue might not be created yet. Walk up the tree to check the\n          // parent ACL. The queueName is assured root which always exists\n          String queueName \u003d submissionContext.getQueue();\n          FSQueue queue \u003d ((FairScheduler) scheduler).getQueueManager().\n              getQueue(queueName);\n          while (queue \u003d\u003d null) {\n            int sepIndex \u003d queueName.lastIndexOf(\".\");\n            queueName \u003d queueName.substring(0, sepIndex);\n            queue \u003d ((FairScheduler) scheduler).getQueueManager().\n                getQueue(queueName);\n          }\n          if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026\n              !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n            throw RPCUtil.getRemoteException(new AccessControlException(\n                \"User \" + user + \" does not have permission to submit \" +\n                    applicationId + \" to queue \" +\n                    submissionContext.getQueue() +\n                    \" denied by ACL for queue \" + queueName));\n          }\n        }\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReqs, placementContext,\n            startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (timelineServiceV2Enabled) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "ed13cf84068ad50a78e66211132c1f08238fb65b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9317. Avoid repeated YarnConfiguration#timelineServiceV2Enabled check. Contributed by Prabhu Joseph\n",
      "commitDate": "22/02/19 7:31 AM",
      "commitName": "ed13cf84068ad50a78e66211132c1f08238fb65b",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "25/01/19 1:17 PM",
      "commitNameOld": "6cace58e212d3ee0aec988926a5a17c9cc58e645",
      "commitAuthorOld": "Jonathan Hung",
      "daysBetweenCommits": 27.76,
      "commitsBetweenForRepo": 197,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n \n     ApplicationPlacementContext placementContext \u003d\n         placeApplication(rmContext.getQueuePlacementManager(),\n             submissionContext, user, isRecovery);\n \n     // We only replace the queue when it\u0027s a new application\n     if (!isRecovery) {\n       replaceQueueFromPlacementContext(placementContext, submissionContext);\n \n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n         submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     // Application priority needed to be validated only while submitting. During\n     // recovery, validated priority could be recovered from submission context.\n     if (!isRecovery) {\n       Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n           submissionContext.getPriority(), userUgi,\n           submissionContext.getQueue(),\n           applicationId);\n       submissionContext.setPriority(appPriority);\n     }\n \n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n \n       if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n         //could be an auto created queue through queue mapping. Validate\n         // parent queue exists and has valid acls\n         String parentQueueName \u003d placementContext.getParentQueue();\n         csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n       }\n \n       if (csqueue !\u003d null\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReqs, placementContext,\n             startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n-    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n+    if (timelineServiceV2Enabled) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n\n    ApplicationPlacementContext placementContext \u003d\n        placeApplication(rmContext.getQueuePlacementManager(),\n            submissionContext, user, isRecovery);\n\n    // We only replace the queue when it\u0027s a new application\n    if (!isRecovery) {\n      replaceQueueFromPlacementContext(placementContext, submissionContext);\n\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n        submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    // Application priority needed to be validated only while submitting. During\n    // recovery, validated priority could be recovered from submission context.\n    if (!isRecovery) {\n      Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n          submissionContext.getPriority(), userUgi,\n          submissionContext.getQueue(),\n          applicationId);\n      submissionContext.setPriority(appPriority);\n    }\n\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n\n      if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n        //could be an auto created queue through queue mapping. Validate\n        // parent queue exists and has valid acls\n        String parentQueueName \u003d placementContext.getParentQueue();\n        csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n      }\n\n      if (csqueue !\u003d null\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReqs, placementContext,\n            startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (timelineServiceV2Enabled) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "e673dd1d4d78b66e7b6705ec6dc3679d2347d704": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8541. RM startup failure on recovery after user deletion. Contributed by Bibin A Chundatt.\n",
      "commitDate": "24/07/18 10:56 AM",
      "commitName": "e673dd1d4d78b66e7b6705ec6dc3679d2347d704",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "22/05/18 1:33 PM",
      "commitNameOld": "bd15d2396ef0c24fb6b60c6393d16b37651b828e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 62.89,
      "commitsBetweenForRepo": 433,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,99 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n \n-    ApplicationPlacementContext placementContext \u003d null;\n-    try {\n-      placementContext \u003d placeApplication(rmContext, submissionContext, user);\n-    } catch (YarnException e) {\n-      String msg \u003d\n-          \"Failed to place application \" + submissionContext.getApplicationId()\n-              + \" to queue and specified \" + \"queue is invalid : \"\n-              + submissionContext.getQueue();\n-      LOG.error(msg, e);\n-      throw e;\n-    }\n+    ApplicationPlacementContext placementContext \u003d\n+        placeApplication(rmContext.getQueuePlacementManager(),\n+            submissionContext, user, isRecovery);\n \n     // We only replace the queue when it\u0027s a new application\n     if (!isRecovery) {\n       replaceQueueFromPlacementContext(placementContext, submissionContext);\n \n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n         submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     // Application priority needed to be validated only while submitting. During\n     // recovery, validated priority could be recovered from submission context.\n     if (!isRecovery) {\n       Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n           submissionContext.getPriority(), userUgi,\n           submissionContext.getQueue(),\n           applicationId);\n       submissionContext.setPriority(appPriority);\n     }\n \n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n \n       if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n         //could be an auto created queue through queue mapping. Validate\n         // parent queue exists and has valid acls\n         String parentQueueName \u003d placementContext.getParentQueue();\n         csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n       }\n \n       if (csqueue !\u003d null\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReqs, placementContext,\n             startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n\n    ApplicationPlacementContext placementContext \u003d\n        placeApplication(rmContext.getQueuePlacementManager(),\n            submissionContext, user, isRecovery);\n\n    // We only replace the queue when it\u0027s a new application\n    if (!isRecovery) {\n      replaceQueueFromPlacementContext(placementContext, submissionContext);\n\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n        submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    // Application priority needed to be validated only while submitting. During\n    // recovery, validated priority could be recovered from submission context.\n    if (!isRecovery) {\n      Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n          submissionContext.getPriority(), userUgi,\n          submissionContext.getQueue(),\n          applicationId);\n      submissionContext.setPriority(appPriority);\n    }\n\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n\n      if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n        //could be an auto created queue through queue mapping. Validate\n        // parent queue exists and has valid acls\n        String parentQueueName \u003d placementContext.getParentQueue();\n        csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n      }\n\n      if (csqueue !\u003d null\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReqs, placementContext,\n            startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "bd15d2396ef0c24fb6b60c6393d16b37651b828e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8290. SystemMetricsPublisher.appACLsUpdated should be invoked after application information is published to ATS to avoid \"User is not set in the application report\" Exception. (Eric Yang via wangda)\n\nChange-Id: I0ac6ddd19740d1aa7dd07111cd11af71ddc2fcaf\n",
      "commitDate": "22/05/18 1:33 PM",
      "commitName": "bd15d2396ef0c24fb6b60c6393d16b37651b828e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "03/01/18 4:50 AM",
      "commitNameOld": "c9bf813c9a6c018d14f2bef49ba086ec0e60c761",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 139.32,
      "commitsBetweenForRepo": 1557,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,107 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n \n     ApplicationPlacementContext placementContext \u003d null;\n     try {\n       placementContext \u003d placeApplication(rmContext, submissionContext, user);\n     } catch (YarnException e) {\n       String msg \u003d\n           \"Failed to place application \" + submissionContext.getApplicationId()\n               + \" to queue and specified \" + \"queue is invalid : \"\n               + submissionContext.getQueue();\n       LOG.error(msg, e);\n       throw e;\n     }\n \n     // We only replace the queue when it\u0027s a new application\n     if (!isRecovery) {\n       replaceQueueFromPlacementContext(placementContext, submissionContext);\n \n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n         submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     // Application priority needed to be validated only while submitting. During\n     // recovery, validated priority could be recovered from submission context.\n     if (!isRecovery) {\n       Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n           submissionContext.getPriority(), userUgi,\n           submissionContext.getQueue(),\n           applicationId);\n       submissionContext.setPriority(appPriority);\n     }\n \n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n \n       if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n         //could be an auto created queue through queue mapping. Validate\n         // parent queue exists and has valid acls\n         String parentQueueName \u003d placementContext.getParentQueue();\n         csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n       }\n \n       if (csqueue !\u003d null\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReqs, placementContext,\n             startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n-    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n-        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n-    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n-        application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n\n    ApplicationPlacementContext placementContext \u003d null;\n    try {\n      placementContext \u003d placeApplication(rmContext, submissionContext, user);\n    } catch (YarnException e) {\n      String msg \u003d\n          \"Failed to place application \" + submissionContext.getApplicationId()\n              + \" to queue and specified \" + \"queue is invalid : \"\n              + submissionContext.getQueue();\n      LOG.error(msg, e);\n      throw e;\n    }\n\n    // We only replace the queue when it\u0027s a new application\n    if (!isRecovery) {\n      replaceQueueFromPlacementContext(placementContext, submissionContext);\n\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n        submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    // Application priority needed to be validated only while submitting. During\n    // recovery, validated priority could be recovered from submission context.\n    if (!isRecovery) {\n      Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n          submissionContext.getPriority(), userUgi,\n          submissionContext.getQueue(),\n          applicationId);\n      submissionContext.setPriority(appPriority);\n    }\n\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n\n      if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n        //could be an auto created queue through queue mapping. Validate\n        // parent queue exists and has valid acls\n        String parentQueueName \u003d placementContext.getParentQueue();\n        csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n      }\n\n      if (csqueue !\u003d null\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReqs, placementContext,\n            startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "c9bf813c9a6c018d14f2bef49ba086ec0e60c761": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7692. Skip validating priority acls while recovering applications. Contributed by Sunil G.\n",
      "commitDate": "03/01/18 4:50 AM",
      "commitName": "c9bf813c9a6c018d14f2bef49ba086ec0e60c761",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "13/12/17 9:19 AM",
      "commitNameOld": "cb87e4dc927731e32b0bbcf678bb5600835ff28d",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 20.81,
      "commitsBetweenForRepo": 114,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,111 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n \n     ApplicationPlacementContext placementContext \u003d null;\n     try {\n       placementContext \u003d placeApplication(rmContext, submissionContext, user);\n     } catch (YarnException e) {\n       String msg \u003d\n           \"Failed to place application \" + submissionContext.getApplicationId()\n               + \" to queue and specified \" + \"queue is invalid : \"\n               + submissionContext.getQueue();\n       LOG.error(msg, e);\n       throw e;\n     }\n \n     // We only replace the queue when it\u0027s a new application\n     if (!isRecovery) {\n       replaceQueueFromPlacementContext(placementContext, submissionContext);\n \n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n         submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n-    Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n-        submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n-        applicationId);\n-    submissionContext.setPriority(appPriority);\n+\n+    // Application priority needed to be validated only while submitting. During\n+    // recovery, validated priority could be recovered from submission context.\n+    if (!isRecovery) {\n+      Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n+          submissionContext.getPriority(), userUgi,\n+          submissionContext.getQueue(),\n+          applicationId);\n+      submissionContext.setPriority(appPriority);\n+    }\n \n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n \n       if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n         //could be an auto created queue through queue mapping. Validate\n         // parent queue exists and has valid acls\n         String parentQueueName \u003d placementContext.getParentQueue();\n         csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n       }\n \n       if (csqueue !\u003d null\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReqs, placementContext,\n             startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n\n    ApplicationPlacementContext placementContext \u003d null;\n    try {\n      placementContext \u003d placeApplication(rmContext, submissionContext, user);\n    } catch (YarnException e) {\n      String msg \u003d\n          \"Failed to place application \" + submissionContext.getApplicationId()\n              + \" to queue and specified \" + \"queue is invalid : \"\n              + submissionContext.getQueue();\n      LOG.error(msg, e);\n      throw e;\n    }\n\n    // We only replace the queue when it\u0027s a new application\n    if (!isRecovery) {\n      replaceQueueFromPlacementContext(placementContext, submissionContext);\n\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n        submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    // Application priority needed to be validated only while submitting. During\n    // recovery, validated priority could be recovered from submission context.\n    if (!isRecovery) {\n      Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n          submissionContext.getPriority(), userUgi,\n          submissionContext.getQueue(),\n          applicationId);\n      submissionContext.setPriority(appPriority);\n    }\n\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n\n      if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n        //could be an auto created queue through queue mapping. Validate\n        // parent queue exists and has valid acls\n        String parentQueueName \u003d placementContext.getParentQueue();\n        csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n      }\n\n      if (csqueue !\u003d null\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReqs, placementContext,\n            startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "cb87e4dc927731e32b0bbcf678bb5600835ff28d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7643. Handle recovery of applications in case of auto-created leaf queue mapping. Contributed by Suma Shivaprasad.\n",
      "commitDate": "13/12/17 9:19 AM",
      "commitName": "cb87e4dc927731e32b0bbcf678bb5600835ff28d",
      "commitAuthor": "Sunil G",
      "commitDateOld": "12/12/17 1:50 AM",
      "commitNameOld": "8bb83a8f625953e2a45db4bbbfb95cd41bac6af5",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 1.31,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,105 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n \n     ApplicationPlacementContext placementContext \u003d null;\n+    try {\n+      placementContext \u003d placeApplication(rmContext, submissionContext, user);\n+    } catch (YarnException e) {\n+      String msg \u003d\n+          \"Failed to place application \" + submissionContext.getApplicationId()\n+              + \" to queue and specified \" + \"queue is invalid : \"\n+              + submissionContext.getQueue();\n+      LOG.error(msg, e);\n+      throw e;\n+    }\n \n-    // We only do queue mapping when it\u0027s a new application\n+    // We only replace the queue when it\u0027s a new application\n     if (!isRecovery) {\n-      try {\n-        // Do queue mapping\n-        placementContext \u003d placeApplication(rmContext,\n-            submissionContext, user);\n-        replaceQueueFromPlacementContext(placementContext,\n-            submissionContext);\n-      } catch (YarnException e) {\n-        String msg \u003d \"Failed to place application \" +\n-            submissionContext.getApplicationId() + \" to queue and specified \"\n-            + \"queue is invalid : \" + submissionContext.getQueue();\n-        LOG.error(msg, e);\n-        throw e;\n-      }\n+      replaceQueueFromPlacementContext(placementContext, submissionContext);\n \n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n         submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n         submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n         applicationId);\n     submissionContext.setPriority(appPriority);\n \n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n \n       if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n         //could be an auto created queue through queue mapping. Validate\n         // parent queue exists and has valid acls\n         String parentQueueName \u003d placementContext.getParentQueue();\n         csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n       }\n \n       if (csqueue !\u003d null\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReqs, placementContext,\n             startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n\n    ApplicationPlacementContext placementContext \u003d null;\n    try {\n      placementContext \u003d placeApplication(rmContext, submissionContext, user);\n    } catch (YarnException e) {\n      String msg \u003d\n          \"Failed to place application \" + submissionContext.getApplicationId()\n              + \" to queue and specified \" + \"queue is invalid : \"\n              + submissionContext.getQueue();\n      LOG.error(msg, e);\n      throw e;\n    }\n\n    // We only replace the queue when it\u0027s a new application\n    if (!isRecovery) {\n      replaceQueueFromPlacementContext(placementContext, submissionContext);\n\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n        submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n        submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n        applicationId);\n    submissionContext.setPriority(appPriority);\n\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n\n      if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n        //could be an auto created queue through queue mapping. Validate\n        // parent queue exists and has valid acls\n        String parentQueueName \u003d placementContext.getParentQueue();\n        csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n      }\n\n      if (csqueue !\u003d null\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReqs, placementContext,\n            startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "8bb83a8f625953e2a45db4bbbfb95cd41bac6af5": {
      "type": "Ybodychange",
      "commitMessage": "Queue ACL validations should validate parent queue ACLs before auto-creating leaf queues. Contributed by Suma Shivaprasad.\n",
      "commitDate": "12/12/17 1:50 AM",
      "commitName": "8bb83a8f625953e2a45db4bbbfb95cd41bac6af5",
      "commitAuthor": "Sunil G",
      "commitDateOld": "05/12/17 4:58 AM",
      "commitNameOld": "f9f317b70209d20161d66a73ddea3334d2b92f96",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 6.87,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,107 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n \n     ApplicationPlacementContext placementContext \u003d null;\n \n     // We only do queue mapping when it\u0027s a new application\n     if (!isRecovery) {\n       try {\n         // Do queue mapping\n         placementContext \u003d placeApplication(rmContext,\n             submissionContext, user);\n         replaceQueueFromPlacementContext(placementContext,\n             submissionContext);\n       } catch (YarnException e) {\n         String msg \u003d \"Failed to place application \" +\n             submissionContext.getApplicationId() + \" to queue and specified \"\n             + \"queue is invalid : \" + submissionContext.getQueue();\n         LOG.error(msg, e);\n         throw e;\n       }\n \n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n         submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n         submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n         applicationId);\n     submissionContext.setPriority(appPriority);\n \n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n-      if (null !\u003d csqueue\n+\n+      if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n+        //could be an auto created queue through queue mapping. Validate\n+        // parent queue exists and has valid acls\n+        String parentQueueName \u003d placementContext.getParentQueue();\n+        csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n+      }\n+\n+      if (csqueue !\u003d null\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReqs, placementContext,\n             startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n\n    ApplicationPlacementContext placementContext \u003d null;\n\n    // We only do queue mapping when it\u0027s a new application\n    if (!isRecovery) {\n      try {\n        // Do queue mapping\n        placementContext \u003d placeApplication(rmContext,\n            submissionContext, user);\n        replaceQueueFromPlacementContext(placementContext,\n            submissionContext);\n      } catch (YarnException e) {\n        String msg \u003d \"Failed to place application \" +\n            submissionContext.getApplicationId() + \" to queue and specified \"\n            + \"queue is invalid : \" + submissionContext.getQueue();\n        LOG.error(msg, e);\n        throw e;\n      }\n\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n        submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n        submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n        applicationId);\n    submissionContext.setPriority(appPriority);\n\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n\n      if (csqueue \u003d\u003d null \u0026\u0026 placementContext !\u003d null) {\n        //could be an auto created queue through queue mapping. Validate\n        // parent queue exists and has valid acls\n        String parentQueueName \u003d placementContext.getParentQueue();\n        csqueue \u003d ((CapacityScheduler) scheduler).getQueue(parentQueueName);\n      }\n\n      if (csqueue !\u003d null\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReqs, placementContext,\n            startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "f9f317b70209d20161d66a73ddea3334d2b92f96": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7586. Application Placement should be done before ACL checks in ResourceManager. Contributed by Suma Shivaprasad.\n",
      "commitDate": "05/12/17 4:58 AM",
      "commitName": "f9f317b70209d20161d66a73ddea3334d2b92f96",
      "commitAuthor": "Sunil G",
      "commitDateOld": "16/11/17 11:25 AM",
      "commitNameOld": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 18.73,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,99 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n \n+    ApplicationPlacementContext placementContext \u003d null;\n+\n+    // We only do queue mapping when it\u0027s a new application\n     if (!isRecovery) {\n+      try {\n+        // Do queue mapping\n+        placementContext \u003d placeApplication(rmContext,\n+            submissionContext, user);\n+        replaceQueueFromPlacementContext(placementContext,\n+            submissionContext);\n+      } catch (YarnException e) {\n+        String msg \u003d \"Failed to place application \" +\n+            submissionContext.getApplicationId() + \" to queue and specified \"\n+            + \"queue is invalid : \" + submissionContext.getQueue();\n+        LOG.error(msg, e);\n+        throw e;\n+      }\n+\n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n         submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n         submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n         applicationId);\n     submissionContext.setPriority(appPriority);\n \n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n-            submissionContext.getApplicationTags(), amReqs, startTime);\n+            submissionContext.getApplicationTags(), amReqs, placementContext,\n+            startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n\n    ApplicationPlacementContext placementContext \u003d null;\n\n    // We only do queue mapping when it\u0027s a new application\n    if (!isRecovery) {\n      try {\n        // Do queue mapping\n        placementContext \u003d placeApplication(rmContext,\n            submissionContext, user);\n        replaceQueueFromPlacementContext(placementContext,\n            submissionContext);\n      } catch (YarnException e) {\n        String msg \u003d \"Failed to place application \" +\n            submissionContext.getApplicationId() + \" to queue and specified \"\n            + \"queue is invalid : \" + submissionContext.getQueue();\n        LOG.error(msg, e);\n        throw e;\n      }\n\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n        submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n        submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n        applicationId);\n    submissionContext.setPriority(appPriority);\n\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReqs, placementContext,\n            startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7419. CapacityScheduler: Allow auto leaf queue creation after queue mapping. (Suma Shivaprasad via wangda)\n\nChange-Id: Ia1704bb8cb5070e5b180b5a85787d7b9ca57ebc6\n",
      "commitDate": "16/11/17 11:25 AM",
      "commitName": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "12/09/17 9:19 AM",
      "commitNameOld": "dae65f3bef8ffa34d02a37041f1dfdfeeee91845",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 65.13,
      "commitsBetweenForRepo": 609,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,81 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n+\n     if (!isRecovery) {\n-      // Do queue mapping\n-      if (rmContext.getQueuePlacementManager() !\u003d null) {\n-        // We only do queue mapping when it\u0027s a new application\n-        rmContext.getQueuePlacementManager().placeApplication(\n-            submissionContext, user);\n-      }\n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n         submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n         submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n         applicationId);\n     submissionContext.setPriority(appPriority);\n \n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReqs, startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n\n    if (!isRecovery) {\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n        submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n        submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n        applicationId);\n    submissionContext.setPriority(appPriority);\n\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReqs, startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "91f120f743662c6e037e8f21b1792e81d58ac664": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6872. Ensure apps could run given NodeLabels are disabled post RM switchover/restart. Contributed by Sunil G\n",
      "commitDate": "01/08/17 9:56 AM",
      "commitName": "91f120f743662c6e037e8f21b1792e81d58ac664",
      "commitAuthor": "Jian He",
      "commitDateOld": "09/05/17 9:22 AM",
      "commitNameOld": "543aac9f281871a40473e83061f6deadc0bbdab7",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 84.02,
      "commitsBetweenForRepo": 415,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,86 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n     if (!isRecovery) {\n       // Do queue mapping\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n-    List\u003cResourceRequest\u003e amReqs \u003d null;\n-    try {\n-      amReqs \u003d validateAndCreateResourceRequest(submissionContext, isRecovery);\n-    } catch (InvalidLabelResourceRequestException e) {\n-      // This can happen if the application had been submitted and run\n-      // with Node Label enabled but recover with Node Label disabled.\n-      // Thus there might be node label expression in the application\u0027s\n-      // resource requests. If this is the case, create RmAppImpl with\n-      // null amReq and reject the application later with clear error\n-      // message. So that the application can still be tracked by RM\n-      // after recovery and user can see what\u0027s going on and react accordingly.\n-      if (isRecovery \u0026\u0026\n-          !YarnConfiguration.areNodeLabelsEnabled(this.conf)) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"AMResourceRequest is not created for \" + applicationId\n-              + \". NodeLabel is not enabled in cluster, but AM resource \"\n-              + \"request contains a label expression.\");\n-        }\n-      } else {\n-        throw e;\n-      }\n-    }\n+    List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n+        submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n         submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n         applicationId);\n     submissionContext.setPriority(appPriority);\n \n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReqs, startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n    if (!isRecovery) {\n      // Do queue mapping\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    List\u003cResourceRequest\u003e amReqs \u003d validateAndCreateResourceRequest(\n        submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n        submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n        applicationId);\n    submissionContext.setPriority(appPriority);\n\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReqs, startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "9bae6720cb8432efd78c909dc624c00e367cedf5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6050. AMs can\u0027t be scheduled on racks or nodes (rkanter)\n",
      "commitDate": "27/03/17 5:23 PM",
      "commitName": "9bae6720cb8432efd78c909dc624c00e367cedf5",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "24/03/17 6:06 PM",
      "commitNameOld": "84ddedc0b2d58257d45c16ee5e83b15f94a7ba3a",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 2.97,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n     if (!isRecovery) {\n       // Do queue mapping\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n-    ResourceRequest amReq \u003d null;\n+    List\u003cResourceRequest\u003e amReqs \u003d null;\n     try {\n-      amReq \u003d validateAndCreateResourceRequest(submissionContext, isRecovery);\n+      amReqs \u003d validateAndCreateResourceRequest(submissionContext, isRecovery);\n     } catch (InvalidLabelResourceRequestException e) {\n       // This can happen if the application had been submitted and run\n       // with Node Label enabled but recover with Node Label disabled.\n       // Thus there might be node label expression in the application\u0027s\n       // resource requests. If this is the case, create RmAppImpl with\n       // null amReq and reject the application later with clear error\n       // message. So that the application can still be tracked by RM\n       // after recovery and user can see what\u0027s going on and react accordingly.\n       if (isRecovery \u0026\u0026\n           !YarnConfiguration.areNodeLabelsEnabled(this.conf)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"AMResourceRequest is not created for \" + applicationId\n               + \". NodeLabel is not enabled in cluster, but AM resource \"\n               + \"request contains a label expression.\");\n         }\n       } else {\n         throw e;\n       }\n     }\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n         submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n         applicationId);\n     submissionContext.setPriority(appPriority);\n \n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n-            submissionContext.getApplicationTags(), amReq, startTime);\n+            submissionContext.getApplicationTags(), amReqs, startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n    if (!isRecovery) {\n      // Do queue mapping\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    List\u003cResourceRequest\u003e amReqs \u003d null;\n    try {\n      amReqs \u003d validateAndCreateResourceRequest(submissionContext, isRecovery);\n    } catch (InvalidLabelResourceRequestException e) {\n      // This can happen if the application had been submitted and run\n      // with Node Label enabled but recover with Node Label disabled.\n      // Thus there might be node label expression in the application\u0027s\n      // resource requests. If this is the case, create RmAppImpl with\n      // null amReq and reject the application later with clear error\n      // message. So that the application can still be tracked by RM\n      // after recovery and user can see what\u0027s going on and react accordingly.\n      if (isRecovery \u0026\u0026\n          !YarnConfiguration.areNodeLabelsEnabled(this.conf)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"AMResourceRequest is not created for \" + applicationId\n              + \". NodeLabel is not enabled in cluster, but AM resource \"\n              + \"request contains a label expression.\");\n        }\n      } else {\n        throw e;\n      }\n    }\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n        submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n        applicationId);\n    submissionContext.setPriority(appPriority);\n\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReqs, startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "3fa0d540dfca579f3c2840a959b748a7528b02ed": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6031. Application recovery has failed when node label feature is turned off during RM recovery. Contributed by Ying Zhang.\n",
      "commitDate": "22/01/17 10:49 PM",
      "commitName": "3fa0d540dfca579f3c2840a959b748a7528b02ed",
      "commitAuthor": "Sunil G",
      "commitDateOld": "09/01/17 8:40 AM",
      "commitNameOld": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 13.59,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,106 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n     if (!isRecovery) {\n       // Do queue mapping\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n-    ResourceRequest amReq \u003d\n-        validateAndCreateResourceRequest(submissionContext, isRecovery);\n+    ResourceRequest amReq \u003d null;\n+    try {\n+      amReq \u003d validateAndCreateResourceRequest(submissionContext, isRecovery);\n+    } catch (InvalidLabelResourceRequestException e) {\n+      // This can happen if the application had been submitted and run\n+      // with Node Label enabled but recover with Node Label disabled.\n+      // Thus there might be node label expression in the application\u0027s\n+      // resource requests. If this is the case, create RmAppImpl with\n+      // null amReq and reject the application later with clear error\n+      // message. So that the application can still be tracked by RM\n+      // after recovery and user can see what\u0027s going on and react accordingly.\n+      if (isRecovery \u0026\u0026\n+          !YarnConfiguration.areNodeLabelsEnabled(this.conf)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"AMResourceRequest is not created for \" + applicationId\n+              + \". NodeLabel is not enabled in cluster, but AM resource \"\n+              + \"request contains a label expression.\");\n+        }\n+      } else {\n+        throw e;\n+      }\n+    }\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n         submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n         applicationId);\n     submissionContext.setPriority(appPriority);\n \n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReq, startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n    if (!isRecovery) {\n      // Do queue mapping\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d null;\n    try {\n      amReq \u003d validateAndCreateResourceRequest(submissionContext, isRecovery);\n    } catch (InvalidLabelResourceRequestException e) {\n      // This can happen if the application had been submitted and run\n      // with Node Label enabled but recover with Node Label disabled.\n      // Thus there might be node label expression in the application\u0027s\n      // resource requests. If this is the case, create RmAppImpl with\n      // null amReq and reject the application later with clear error\n      // message. So that the application can still be tracked by RM\n      // after recovery and user can see what\u0027s going on and react accordingly.\n      if (isRecovery \u0026\u0026\n          !YarnConfiguration.areNodeLabelsEnabled(this.conf)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"AMResourceRequest is not created for \" + applicationId\n              + \". NodeLabel is not enabled in cluster, but AM resource \"\n              + \"request contains a label expression.\");\n        }\n      } else {\n        throw e;\n      }\n    }\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n        submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n        applicationId);\n    submissionContext.setPriority(appPriority);\n\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq, startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "287d3d6804a869723ae36605a3c2d2b3eae3941e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3955. Support for application priority ACLs in queues of CapacityScheduler. (Sunil G via wangda)\n",
      "commitDate": "09/01/17 8:40 AM",
      "commitName": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/01/17 8:24 AM",
      "commitNameOld": "ac16400e1fb85a4186e5bf5bbc9cf204735ae74f",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 2.01,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,86 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n     if (!isRecovery) {\n       // Do queue mapping\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n       // fail the submission if configured application timeout value is invalid\n       RMServerUtils.validateApplicationTimeouts(\n           submissionContext.getApplicationTimeouts());\n     }\n-    \n+\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n+    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n-        submissionContext.getPriority(), user, submissionContext.getQueue(),\n+        submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n         applicationId);\n     submissionContext.setPriority(appPriority);\n \n-    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReq, startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n    if (!isRecovery) {\n      // Do queue mapping\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n        submissionContext.getPriority(), userUgi, submissionContext.getQueue(),\n        applicationId);\n    submissionContext.setPriority(appPriority);\n\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq, startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "020316458dfe6059b700f8d93a9791e4cb817b3f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6009. Skip validating app timeout value on recovery. Contributed by Rohith Sharma K S\n",
      "commitDate": "06/01/17 6:19 PM",
      "commitName": "020316458dfe6059b700f8d93a9791e4cb817b3f",
      "commitAuthor": "Jian He",
      "commitDateOld": "28/12/16 3:21 PM",
      "commitNameOld": "f216276d2164c6564632c571fd3adbb03bc8b3e4",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 9.12,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,86 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n-    // Do queue mapping\n     if (!isRecovery) {\n+      // Do queue mapping\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n+      // fail the submission if configured application timeout value is invalid\n+      RMServerUtils.validateApplicationTimeouts(\n+          submissionContext.getApplicationTimeouts());\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n         submissionContext.getPriority(), user, submissionContext.getQueue(),\n         applicationId);\n     submissionContext.setPriority(appPriority);\n \n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n-    // fail the submission if configured application timeout value is invalid\n-    RMServerUtils.validateApplicationTimeouts(\n-        submissionContext.getApplicationTimeouts());\n-\n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReq, startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n    if (!isRecovery) {\n      // Do queue mapping\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n      // fail the submission if configured application timeout value is invalid\n      RMServerUtils.validateApplicationTimeouts(\n          submissionContext.getApplicationTimeouts());\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n        submissionContext.getPriority(), user, submissionContext.getQueue(),\n        applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq, startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "a926f895c11cd69cf2117c3b970304f3f1f53d92": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5865. Retrospect updateApplicationPriority api to handle state store exception in align with YARN-5611. Contributed by Sunil G.\n",
      "commitDate": "22/11/16 1:19 AM",
      "commitName": "a926f895c11cd69cf2117c3b970304f3f1f53d92",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "10/11/16 2:35 PM",
      "commitNameOld": "93eeb13164707d0e3556c2bf737bd2ee09a335c6",
      "commitAuthorOld": "Eric Payne",
      "daysBetweenCommits": 11.45,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,87 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n     // Do queue mapping\n     if (!isRecovery) {\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n-    Priority appPriority \u003d rmContext.getScheduler()\n-        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n-            submissionContext.getQueue(), applicationId);\n+    Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n+        submissionContext.getPriority(), user, submissionContext.getQueue(),\n+        applicationId);\n     submissionContext.setPriority(appPriority);\n \n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // fail the submission if configured application timeout value is invalid\n     RMServerUtils.validateApplicationTimeouts(\n         submissionContext.getApplicationTimeouts());\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReq, startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d scheduler.checkAndGetApplicationPriority(\n        submissionContext.getPriority(), user, submissionContext.getQueue(),\n        applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // fail the submission if configured application timeout value is invalid\n    RMServerUtils.validateApplicationTimeouts(\n        submissionContext.getApplicationTimeouts());\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq, startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "2ae5a3a5bf5ea355370469a53eeccff0b5220081": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4205. Add a service for monitoring application life time out. Contributed by Rohith Sharma K S\n",
      "commitDate": "29/09/16 7:00 AM",
      "commitName": "2ae5a3a5bf5ea355370469a53eeccff0b5220081",
      "commitAuthor": "Jian He",
      "commitDateOld": "11/08/16 12:39 PM",
      "commitNameOld": "874577a67df8a49243586909d866034df4e3b276",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 48.76,
      "commitsBetweenForRepo": 284,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,87 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery, long startTime) throws YarnException {\n     // Do queue mapping\n     if (!isRecovery) {\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d rmContext.getScheduler()\n         .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n             submissionContext.getQueue(), applicationId);\n     submissionContext.setPriority(appPriority);\n \n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n+    // fail the submission if configured application timeout value is invalid\n+    RMServerUtils.validateApplicationTimeouts(\n+        submissionContext.getApplicationTimeouts());\n+\n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReq, startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // fail the submission if configured application timeout value is invalid\n    RMServerUtils.validateApplicationTimeouts(\n        submissionContext.getApplicationTimeouts());\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq, startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "874577a67df8a49243586909d866034df4e3b276": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-4833. For Queue AccessControlException client retries multiple times on both RM. Contributed by Bibin A Chundatt\n",
      "commitDate": "11/08/16 12:39 PM",
      "commitName": "874577a67df8a49243586909d866034df4e3b276",
      "commitAuthor": "Naganarasimha",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-4833. For Queue AccessControlException client retries multiple times on both RM. Contributed by Bibin A Chundatt\n",
          "commitDate": "11/08/16 12:39 PM",
          "commitName": "874577a67df8a49243586909d866034df4e3b276",
          "commitAuthor": "Naganarasimha",
          "commitDateOld": "10/07/16 8:46 AM",
          "commitNameOld": "702236129b930a799a5a3295f0aa0dc7b619c354",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 32.16,
          "commitsBetweenForRepo": 250,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,83 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      String user, boolean isRecovery, long startTime)\n-      throws YarnException, AccessControlException {\n+      String user, boolean isRecovery, long startTime) throws YarnException {\n     // Do queue mapping\n     if (!isRecovery) {\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d rmContext.getScheduler()\n         .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n             submissionContext.getQueue(), applicationId);\n     submissionContext.setPriority(appPriority);\n \n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n-        throw new AccessControlException(\n+        throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n-                + applicationId + \" to queue \" + submissionContext.getQueue());\n+                + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReq, startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq, startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[YarnException, AccessControlException]",
            "newValue": "[YarnException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4833. For Queue AccessControlException client retries multiple times on both RM. Contributed by Bibin A Chundatt\n",
          "commitDate": "11/08/16 12:39 PM",
          "commitName": "874577a67df8a49243586909d866034df4e3b276",
          "commitAuthor": "Naganarasimha",
          "commitDateOld": "10/07/16 8:46 AM",
          "commitNameOld": "702236129b930a799a5a3295f0aa0dc7b619c354",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 32.16,
          "commitsBetweenForRepo": 250,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,83 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      String user, boolean isRecovery, long startTime)\n-      throws YarnException, AccessControlException {\n+      String user, boolean isRecovery, long startTime) throws YarnException {\n     // Do queue mapping\n     if (!isRecovery) {\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d rmContext.getScheduler()\n         .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n             submissionContext.getQueue(), applicationId);\n     submissionContext.setPriority(appPriority);\n \n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n-        throw new AccessControlException(\n+        throw RPCUtil.getRemoteException(new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n-                + applicationId + \" to queue \" + submissionContext.getQueue());\n+                + applicationId + \" to queue \" + submissionContext.getQueue()));\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReq, startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime) throws YarnException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw RPCUtil.getRemoteException(new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue()));\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq, startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "702236129b930a799a5a3295f0aa0dc7b619c354": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5095. flow activities and flow runs are populated with wrong timestamp when RM restarts w/ recovery enabled (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:46 AM",
      "commitName": "702236129b930a799a5a3295f0aa0dc7b619c354",
      "commitAuthor": "Sangjin Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5095. flow activities and flow runs are populated with wrong timestamp when RM restarts w/ recovery enabled (Varun Saxena via sjlee)\n",
          "commitDate": "10/07/16 8:46 AM",
          "commitName": "702236129b930a799a5a3295f0aa0dc7b619c354",
          "commitAuthor": "Sangjin Lee",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
          "commitAuthorOld": "Li Lu",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,84 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      String user, boolean isRecovery)\n+      String user, boolean isRecovery, long startTime)\n       throws YarnException, AccessControlException {\n     // Do queue mapping\n     if (!isRecovery) {\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d rmContext.getScheduler()\n         .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n             submissionContext.getQueue(), applicationId);\n     submissionContext.setPriority(appPriority);\n \n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue());\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n-            submissionContext.getApplicationTags(), amReq);\n+            submissionContext.getApplicationTags(), amReq, startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime)\n      throws YarnException, AccessControlException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue());\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq, startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long, user-String, isRecovery-boolean]",
            "newValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long, user-String, isRecovery-boolean, startTime-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5095. flow activities and flow runs are populated with wrong timestamp when RM restarts w/ recovery enabled (Varun Saxena via sjlee)\n",
          "commitDate": "10/07/16 8:46 AM",
          "commitName": "702236129b930a799a5a3295f0aa0dc7b619c354",
          "commitAuthor": "Sangjin Lee",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
          "commitAuthorOld": "Li Lu",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,84 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      String user, boolean isRecovery)\n+      String user, boolean isRecovery, long startTime)\n       throws YarnException, AccessControlException {\n     // Do queue mapping\n     if (!isRecovery) {\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d rmContext.getScheduler()\n         .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n             submissionContext.getQueue(), applicationId);\n     submissionContext.setPriority(appPriority);\n \n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue());\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n-            submissionContext.getApplicationTags(), amReq);\n+            submissionContext.getApplicationTags(), amReq, startTime);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       // Start timeline collector for the submitted app\n       application.startTimelineCollector();\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery, long startTime)\n      throws YarnException, AccessControlException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue());\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq, startTime);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "11e8905d8daf129afb6fe2e5a0eca11bcb1719c8",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,84 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery)\n       throws YarnException, AccessControlException {\n     // Do queue mapping\n     if (!isRecovery) {\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d rmContext.getScheduler()\n         .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n             submissionContext.getQueue(), applicationId);\n     submissionContext.setPriority(appPriority);\n \n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue());\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReq);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n-    // Start timeline collector for the submitted app\n-    application.startTimelineCollector();\n+\n+    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n+      // Start timeline collector for the submitted app\n+      application.startTimelineCollector();\n+    }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery)\n      throws YarnException, AccessControlException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue());\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Start timeline collector for the submitted app\n      application.startTimelineCollector();\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "11e8905d8daf129afb6fe2e5a0eca11bcb1719c8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3390. Reuse TimelineCollectorManager for RM (Zhijie Shen via sjlee)\n\n(cherry picked from commit 58221188811e0f61d842dac89e1f4ad4fd8aa182)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "11e8905d8daf129afb6fe2e5a0eca11bcb1719c8",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "06/07/16 10:36 AM",
      "commitNameOld": "04f6ebb66a4ffc04a635ab9c0234080f290b39f2",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 3.92,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,81 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery)\n       throws YarnException, AccessControlException {\n     // Do queue mapping\n     if (!isRecovery) {\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d rmContext.getScheduler()\n         .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n             submissionContext.getQueue(), applicationId);\n     submissionContext.setPriority(appPriority);\n \n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                   applicationId.toString(), appName, Server.getRemoteAddress(),\n                   null))) {\n         throw new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue());\n       }\n     }\n \n     // Create RMApp\n-    RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n-        submissionContext.getApplicationName(), user,\n-        submissionContext.getQueue(), submissionContext, this.scheduler,\n-        this.masterService, submitTime, submissionContext.getApplicationType(),\n-        submissionContext.getApplicationTags(), amReq);\n-\n+    RMAppImpl application \u003d\n+        new RMAppImpl(applicationId, rmContext, this.conf,\n+            submissionContext.getApplicationName(), user,\n+            submissionContext.getQueue(),\n+            submissionContext, this.scheduler, this.masterService,\n+            submitTime, submissionContext.getApplicationType(),\n+            submissionContext.getApplicationTags(), amReq);\n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n+    // Start timeline collector for the submitted app\n+    application.startTimelineCollector();\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery)\n      throws YarnException, AccessControlException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue());\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq);\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n    // Start timeline collector for the submitted app\n    application.startTimelineCollector();\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "04f6ebb66a4ffc04a635ab9c0234080f290b39f2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5294. Pass remote ip address down to YarnAuthorizationProvider. (Jian He via wangda)\n",
      "commitDate": "06/07/16 10:36 AM",
      "commitName": "04f6ebb66a4ffc04a635ab9c0234080f290b39f2",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/03/16 1:07 PM",
      "commitNameOld": "3c33158d1cb38ee4ab3baa21752a3cdf0bdc8ccc",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 119.85,
      "commitsBetweenForRepo": 763,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,78 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery)\n       throws YarnException, AccessControlException {\n     // Do queue mapping\n     if (!isRecovery) {\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d rmContext.getScheduler()\n         .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n             submissionContext.getQueue(), applicationId);\n     submissionContext.setPriority(appPriority);\n \n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n         \u0026\u0026 scheduler instanceof CapacityScheduler) {\n       String queueName \u003d submissionContext.getQueue();\n       String appName \u003d submissionContext.getApplicationName();\n       CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n       if (null !\u003d csqueue\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n-                  applicationId.toString(), appName))\n+                  applicationId.toString(), appName, Server.getRemoteAddress(),\n+                  null))\n           \u0026\u0026 !authorizer.checkPermission(\n               new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                   SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n-                  applicationId.toString(), appName))) {\n+                  applicationId.toString(), appName, Server.getRemoteAddress(),\n+                  null))) {\n         throw new AccessControlException(\n             \"User \" + user + \" does not have permission to submit \"\n                 + applicationId + \" to queue \" + submissionContext.getQueue());\n       }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n         submissionContext.getApplicationName(), user,\n         submissionContext.getQueue(), submissionContext, this.scheduler,\n         this.masterService, submitTime, submissionContext.getApplicationType(),\n         submissionContext.getApplicationTags(), amReq);\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery)\n      throws YarnException, AccessControlException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName, Server.getRemoteAddress(),\n                  null))) {\n        throw new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue());\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n        submissionContext.getApplicationName(), user,\n        submissionContext.getQueue(), submissionContext, this.scheduler,\n        this.masterService, submitTime, submissionContext.getApplicationType(),\n        submissionContext.getApplicationTags(), amReq);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "3c33158d1cb38ee4ab3baa21752a3cdf0bdc8ccc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4764. Application submission fails when submitted queue is not available in scheduler xml. Contributed by Bibin A Chundatt\n",
      "commitDate": "08/03/16 1:07 PM",
      "commitName": "3c33158d1cb38ee4ab3baa21752a3cdf0bdc8ccc",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/01/16 9:18 PM",
      "commitNameOld": "c0537bcd2c2dcdb4812fcab7badf42e4f55a54d9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 55.66,
      "commitsBetweenForRepo": 394,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,76 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery)\n       throws YarnException, AccessControlException {\n     // Do queue mapping\n     if (!isRecovery) {\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d rmContext.getScheduler()\n         .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n             submissionContext.getQueue(), applicationId);\n     submissionContext.setPriority(appPriority);\n \n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n     if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n-        \u0026\u0026 scheduler instanceof CapacityScheduler \u0026\u0026\n-        !authorizer.checkPermission(new AccessRequest(\n-            ((CapacityScheduler) scheduler)\n-                .getQueue(submissionContext.getQueue()).getPrivilegedEntity(),\n-            userUgi, SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n-            submissionContext.getApplicationId().toString(),\n-            submissionContext.getApplicationName())) \u0026\u0026\n-        !authorizer.checkPermission(new AccessRequest(\n-            ((CapacityScheduler) scheduler)\n-                .getQueue(submissionContext.getQueue()).getPrivilegedEntity(),\n-            userUgi, SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n-            submissionContext.getApplicationId().toString(),\n-            submissionContext.getApplicationName()))) {\n-      throw new AccessControlException(\n-          \"User \" + user + \" does not have permission to submit \"\n-              + applicationId + \" to queue \" + submissionContext.getQueue());\n+        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n+      String queueName \u003d submissionContext.getQueue();\n+      String appName \u003d submissionContext.getApplicationName();\n+      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n+      if (null !\u003d csqueue\n+          \u0026\u0026 !authorizer.checkPermission(\n+              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n+                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n+                  applicationId.toString(), appName))\n+          \u0026\u0026 !authorizer.checkPermission(\n+              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n+                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n+                  applicationId.toString(), appName))) {\n+        throw new AccessControlException(\n+            \"User \" + user + \" does not have permission to submit \"\n+                + applicationId + \" to queue \" + submissionContext.getQueue());\n+      }\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n         submissionContext.getApplicationName(), user,\n         submissionContext.getQueue(), submissionContext, this.scheduler,\n         this.masterService, submitTime, submissionContext.getApplicationType(),\n         submissionContext.getApplicationTags(), amReq);\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery)\n      throws YarnException, AccessControlException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler) {\n      String queueName \u003d submissionContext.getQueue();\n      String appName \u003d submissionContext.getApplicationName();\n      CSQueue csqueue \u003d ((CapacityScheduler) scheduler).getQueue(queueName);\n      if (null !\u003d csqueue\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n                  applicationId.toString(), appName))\n          \u0026\u0026 !authorizer.checkPermission(\n              new AccessRequest(csqueue.getPrivilegedEntity(), userUgi,\n                  SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n                  applicationId.toString(), appName))) {\n        throw new AccessControlException(\n            \"User \" + user + \" does not have permission to submit \"\n                + applicationId + \" to queue \" + submissionContext.getQueue());\n      }\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n        submissionContext.getApplicationName(), user,\n        submissionContext.getQueue(), submissionContext, this.scheduler,\n        this.masterService, submitTime, submissionContext.getApplicationType(),\n        submissionContext.getApplicationTags(), amReq);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "c0537bcd2c2dcdb4812fcab7badf42e4f55a54d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4571. Make app id/name available to the yarn authorizer provider for better auditing. (Jian He via wangda)\n",
      "commitDate": "12/01/16 9:18 PM",
      "commitName": "c0537bcd2c2dcdb4812fcab7badf42e4f55a54d9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "30/12/15 3:30 PM",
      "commitNameOld": "8310b2e9ff3d6804bad703c4c15458b0dfeeb4af",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 13.24,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,75 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery)\n       throws YarnException, AccessControlException {\n     // Do queue mapping\n     if (!isRecovery) {\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d rmContext.getScheduler()\n         .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n             submissionContext.getQueue(), applicationId);\n     submissionContext.setPriority(appPriority);\n \n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     // Since FairScheduler queue mapping is done inside scheduler,\n     // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n     // fail here because queue will be created inside FS. Ideally, FS queue\n     // mapping should be done outside scheduler too like CS.\n     // For now, exclude FS for the acl check.\n-    if (!isRecovery \u0026\u0026 isAclEnabled \u0026\u0026 scheduler instanceof CapacityScheduler \u0026\u0026\n-        !scheduler.checkAccess(userUgi, QueueACL.SUBMIT_APPLICATIONS,\n-            submissionContext.getQueue()) \u0026\u0026\n-        !scheduler.checkAccess(userUgi, QueueACL.ADMINISTER_QUEUE,\n-            submissionContext.getQueue())) {\n+    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n+        \u0026\u0026 scheduler instanceof CapacityScheduler \u0026\u0026\n+        !authorizer.checkPermission(new AccessRequest(\n+            ((CapacityScheduler) scheduler)\n+                .getQueue(submissionContext.getQueue()).getPrivilegedEntity(),\n+            userUgi, SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n+            submissionContext.getApplicationId().toString(),\n+            submissionContext.getApplicationName())) \u0026\u0026\n+        !authorizer.checkPermission(new AccessRequest(\n+            ((CapacityScheduler) scheduler)\n+                .getQueue(submissionContext.getQueue()).getPrivilegedEntity(),\n+            userUgi, SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n+            submissionContext.getApplicationId().toString(),\n+            submissionContext.getApplicationName()))) {\n       throw new AccessControlException(\n           \"User \" + user + \" does not have permission to submit \"\n               + applicationId + \" to queue \" + submissionContext.getQueue());\n     }\n \n     // Create RMApp\n     RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n         submissionContext.getApplicationName(), user,\n         submissionContext.getQueue(), submissionContext, this.scheduler,\n         this.masterService, submitTime, submissionContext.getApplicationType(),\n         submissionContext.getApplicationTags(), amReq);\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery)\n      throws YarnException, AccessControlException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 YarnConfiguration.isAclEnabled(conf)\n        \u0026\u0026 scheduler instanceof CapacityScheduler \u0026\u0026\n        !authorizer.checkPermission(new AccessRequest(\n            ((CapacityScheduler) scheduler)\n                .getQueue(submissionContext.getQueue()).getPrivilegedEntity(),\n            userUgi, SchedulerUtils.toAccessType(QueueACL.SUBMIT_APPLICATIONS),\n            submissionContext.getApplicationId().toString(),\n            submissionContext.getApplicationName())) \u0026\u0026\n        !authorizer.checkPermission(new AccessRequest(\n            ((CapacityScheduler) scheduler)\n                .getQueue(submissionContext.getQueue()).getPrivilegedEntity(),\n            userUgi, SchedulerUtils.toAccessType(QueueACL.ADMINISTER_QUEUE),\n            submissionContext.getApplicationId().toString(),\n            submissionContext.getApplicationName()))) {\n      throw new AccessControlException(\n          \"User \" + user + \" does not have permission to submit \"\n              + applicationId + \" to queue \" + submissionContext.getQueue());\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n        submissionContext.getApplicationName(), user,\n        submissionContext.getQueue(), submissionContext, this.scheduler,\n        this.masterService, submitTime, submissionContext.getApplicationType(),\n        submissionContext.getApplicationTags(), amReq);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "8310b2e9ff3d6804bad703c4c15458b0dfeeb4af": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-4522. Queue acl can be checked at app submission. (Jian He via wangda)\n",
      "commitDate": "30/12/15 3:30 PM",
      "commitName": "8310b2e9ff3d6804bad703c4c15458b0dfeeb4af",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-4522. Queue acl can be checked at app submission. (Jian He via wangda)\n",
          "commitDate": "30/12/15 3:30 PM",
          "commitName": "8310b2e9ff3d6804bad703c4c15458b0dfeeb4af",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "07/12/15 12:24 PM",
          "commitNameOld": "4546c7582b6762c18ba150d80a8976eb51a8290c",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 23.13,
          "commitsBetweenForRepo": 129,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,66 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      String user, boolean isRecovery) throws YarnException {\n+      String user, boolean isRecovery)\n+      throws YarnException, AccessControlException {\n     // Do queue mapping\n     if (!isRecovery) {\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d rmContext.getScheduler()\n         .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n             submissionContext.getQueue(), applicationId);\n     submissionContext.setPriority(appPriority);\n \n+    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n+    // Since FairScheduler queue mapping is done inside scheduler,\n+    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n+    // fail here because queue will be created inside FS. Ideally, FS queue\n+    // mapping should be done outside scheduler too like CS.\n+    // For now, exclude FS for the acl check.\n+    if (!isRecovery \u0026\u0026 isAclEnabled \u0026\u0026 scheduler instanceof CapacityScheduler \u0026\u0026\n+        !scheduler.checkAccess(userUgi, QueueACL.SUBMIT_APPLICATIONS,\n+            submissionContext.getQueue()) \u0026\u0026\n+        !scheduler.checkAccess(userUgi, QueueACL.ADMINISTER_QUEUE,\n+            submissionContext.getQueue())) {\n+      throw new AccessControlException(\n+          \"User \" + user + \" does not have permission to submit \"\n+              + applicationId + \" to queue \" + submissionContext.getQueue());\n+    }\n+\n     // Create RMApp\n     RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n         submissionContext.getApplicationName(), user,\n         submissionContext.getQueue(), submissionContext, this.scheduler,\n         this.masterService, submitTime, submissionContext.getApplicationType(),\n         submissionContext.getApplicationTags(), amReq);\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery)\n      throws YarnException, AccessControlException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 isAclEnabled \u0026\u0026 scheduler instanceof CapacityScheduler \u0026\u0026\n        !scheduler.checkAccess(userUgi, QueueACL.SUBMIT_APPLICATIONS,\n            submissionContext.getQueue()) \u0026\u0026\n        !scheduler.checkAccess(userUgi, QueueACL.ADMINISTER_QUEUE,\n            submissionContext.getQueue())) {\n      throw new AccessControlException(\n          \"User \" + user + \" does not have permission to submit \"\n              + applicationId + \" to queue \" + submissionContext.getQueue());\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n        submissionContext.getApplicationName(), user,\n        submissionContext.getQueue(), submissionContext, this.scheduler,\n        this.masterService, submitTime, submissionContext.getApplicationType(),\n        submissionContext.getApplicationTags(), amReq);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[YarnException]",
            "newValue": "[YarnException, AccessControlException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4522. Queue acl can be checked at app submission. (Jian He via wangda)\n",
          "commitDate": "30/12/15 3:30 PM",
          "commitName": "8310b2e9ff3d6804bad703c4c15458b0dfeeb4af",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "07/12/15 12:24 PM",
          "commitNameOld": "4546c7582b6762c18ba150d80a8976eb51a8290c",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 23.13,
          "commitsBetweenForRepo": 129,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,66 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      String user, boolean isRecovery) throws YarnException {\n+      String user, boolean isRecovery)\n+      throws YarnException, AccessControlException {\n     // Do queue mapping\n     if (!isRecovery) {\n       if (rmContext.getQueuePlacementManager() !\u003d null) {\n         // We only do queue mapping when it\u0027s a new application\n         rmContext.getQueuePlacementManager().placeApplication(\n             submissionContext, user);\n       }\n     }\n     \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d rmContext.getScheduler()\n         .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n             submissionContext.getQueue(), applicationId);\n     submissionContext.setPriority(appPriority);\n \n+    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n+    // Since FairScheduler queue mapping is done inside scheduler,\n+    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n+    // fail here because queue will be created inside FS. Ideally, FS queue\n+    // mapping should be done outside scheduler too like CS.\n+    // For now, exclude FS for the acl check.\n+    if (!isRecovery \u0026\u0026 isAclEnabled \u0026\u0026 scheduler instanceof CapacityScheduler \u0026\u0026\n+        !scheduler.checkAccess(userUgi, QueueACL.SUBMIT_APPLICATIONS,\n+            submissionContext.getQueue()) \u0026\u0026\n+        !scheduler.checkAccess(userUgi, QueueACL.ADMINISTER_QUEUE,\n+            submissionContext.getQueue())) {\n+      throw new AccessControlException(\n+          \"User \" + user + \" does not have permission to submit \"\n+              + applicationId + \" to queue \" + submissionContext.getQueue());\n+    }\n+\n     // Create RMApp\n     RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n         submissionContext.getApplicationName(), user,\n         submissionContext.getQueue(), submissionContext, this.scheduler,\n         this.masterService, submitTime, submissionContext.getApplicationType(),\n         submissionContext.getApplicationTags(), amReq);\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery)\n      throws YarnException, AccessControlException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    // Since FairScheduler queue mapping is done inside scheduler,\n    // if FairScheduler is used and the queue doesn\u0027t exist, we should not\n    // fail here because queue will be created inside FS. Ideally, FS queue\n    // mapping should be done outside scheduler too like CS.\n    // For now, exclude FS for the acl check.\n    if (!isRecovery \u0026\u0026 isAclEnabled \u0026\u0026 scheduler instanceof CapacityScheduler \u0026\u0026\n        !scheduler.checkAccess(userUgi, QueueACL.SUBMIT_APPLICATIONS,\n            submissionContext.getQueue()) \u0026\u0026\n        !scheduler.checkAccess(userUgi, QueueACL.ADMINISTER_QUEUE,\n            submissionContext.getQueue())) {\n      throw new AccessControlException(\n          \"User \" + user + \" does not have permission to submit \"\n              + applicationId + \" to queue \" + submissionContext.getQueue());\n    }\n\n    // Create RMApp\n    RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n        submissionContext.getApplicationName(), user,\n        submissionContext.getQueue(), submissionContext, this.scheduler,\n        this.masterService, submitTime, submissionContext.getApplicationType(),\n        submissionContext.getApplicationTags(), amReq);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "5468baa80aa2a3e2a02e9a902deebafd734daf23": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3635. Refactored current queue mapping implementation in CapacityScheduler to use a generic PlacementManager framework. Contributed by Wangda Tan\n",
      "commitDate": "15/09/15 12:39 AM",
      "commitName": "5468baa80aa2a3e2a02e9a902deebafd734daf23",
      "commitAuthor": "Jian He",
      "commitDateOld": "21/07/15 9:57 AM",
      "commitNameOld": "c39ca541f498712133890961598bbff50d89d68b",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 55.61,
      "commitsBetweenForRepo": 310,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,49 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery) throws YarnException {\n+    // Do queue mapping\n+    if (!isRecovery) {\n+      if (rmContext.getQueuePlacementManager() !\u003d null) {\n+        // We only do queue mapping when it\u0027s a new application\n+        rmContext.getQueuePlacementManager().placeApplication(\n+            submissionContext, user);\n+      }\n+    }\n+    \n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n     // Verify and get the update application priority and set back to\n     // submissionContext\n     Priority appPriority \u003d rmContext.getScheduler()\n         .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n             submissionContext.getQueue(), applicationId);\n     submissionContext.setPriority(appPriority);\n \n     // Create RMApp\n     RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n         submissionContext.getApplicationName(), user,\n         submissionContext.getQueue(), submissionContext, this.scheduler,\n         this.masterService, submitTime, submissionContext.getApplicationType(),\n         submissionContext.getApplicationTags(), amReq);\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery) throws YarnException {\n    // Do queue mapping\n    if (!isRecovery) {\n      if (rmContext.getQueuePlacementManager() !\u003d null) {\n        // We only do queue mapping when it\u0027s a new application\n        rmContext.getQueuePlacementManager().placeApplication(\n            submissionContext, user);\n      }\n    }\n    \n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    // Create RMApp\n    RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n        submissionContext.getApplicationName(), user,\n        submissionContext.getQueue(), submissionContext, this.scheduler,\n        this.masterService, submitTime, submissionContext.getApplicationType(),\n        submissionContext.getApplicationTags(), amReq);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "c39ca541f498712133890961598bbff50d89d68b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2003. Support for Application priority : Changes in RM and Capacity Scheduler. (Sunil G via wangda)\n",
      "commitDate": "21/07/15 9:57 AM",
      "commitName": "c39ca541f498712133890961598bbff50d89d68b",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "19/05/15 4:59 PM",
      "commitNameOld": "7401e5b5e8060b6b027d714b5ceb641fcfe5b598",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 62.71,
      "commitsBetweenForRepo": 407,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,40 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user, boolean isRecovery) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     ResourceRequest amReq \u003d\n         validateAndCreateResourceRequest(submissionContext, isRecovery);\n \n+    // Verify and get the update application priority and set back to\n+    // submissionContext\n+    Priority appPriority \u003d rmContext.getScheduler()\n+        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n+            submissionContext.getQueue(), applicationId);\n+    submissionContext.setPriority(appPriority);\n+\n     // Create RMApp\n-    RMAppImpl application \u003d\n-        new RMAppImpl(applicationId, rmContext, this.conf,\n-            submissionContext.getApplicationName(), user,\n-            submissionContext.getQueue(),\n-            submissionContext, this.scheduler, this.masterService,\n-            submitTime, submissionContext.getApplicationType(),\n-            submissionContext.getApplicationTags(), amReq);\n+    RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n+        submissionContext.getApplicationName(), user,\n+        submissionContext.getQueue(), submissionContext, this.scheduler,\n+        this.masterService, submitTime, submissionContext.getApplicationType(),\n+        submissionContext.getApplicationTags(), amReq);\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw new YarnException(message);\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Verify and get the update application priority and set back to\n    // submissionContext\n    Priority appPriority \u003d rmContext.getScheduler()\n        .checkAndGetApplicationPriority(submissionContext.getPriority(), user,\n            submissionContext.getQueue(), applicationId);\n    submissionContext.setPriority(appPriority);\n\n    // Create RMApp\n    RMAppImpl application \u003d new RMAppImpl(applicationId, rmContext, this.conf,\n        submissionContext.getApplicationName(), user,\n        submissionContext.getQueue(), submissionContext, this.scheduler,\n        this.masterService, submitTime, submissionContext.getApplicationType(),\n        submissionContext.getApplicationTags(), amReq);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "f65eeb412d140a3808bcf99344a9f3a965918f70": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3493. RM fails to come up with error \"Failed to load/recover state\" when mem settings are changed. (Jian He via wangda)\n",
      "commitDate": "17/04/15 5:11 PM",
      "commitName": "f65eeb412d140a3808bcf99344a9f3a965918f70",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3493. RM fails to come up with error \"Failed to load/recover state\" when mem settings are changed. (Jian He via wangda)\n",
          "commitDate": "17/04/15 5:11 PM",
          "commitName": "f65eeb412d140a3808bcf99344a9f3a965918f70",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "17/03/15 1:49 PM",
          "commitNameOld": "968425e9f7b850ff9c2ab8ca37a64c3fdbe77dbf",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 31.14,
          "commitsBetweenForRepo": 283,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,35 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n-      ApplicationSubmissionContext submissionContext,\n-      long submitTime, String user)\n-      throws YarnException {\n+      ApplicationSubmissionContext submissionContext, long submitTime,\n+      String user, boolean isRecovery) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n-    ResourceRequest amReq \u003d validateAndCreateResourceRequest(submissionContext);\n+    ResourceRequest amReq \u003d\n+        validateAndCreateResourceRequest(submissionContext, isRecovery);\n+\n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReq);\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n-      throw RPCUtil.getRemoteException(message);\n+      throw new YarnException(message);\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long, user-String]",
            "newValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long, user-String, isRecovery-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3493. RM fails to come up with error \"Failed to load/recover state\" when mem settings are changed. (Jian He via wangda)\n",
          "commitDate": "17/04/15 5:11 PM",
          "commitName": "f65eeb412d140a3808bcf99344a9f3a965918f70",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "17/03/15 1:49 PM",
          "commitNameOld": "968425e9f7b850ff9c2ab8ca37a64c3fdbe77dbf",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 31.14,
          "commitsBetweenForRepo": 283,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,35 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n-      ApplicationSubmissionContext submissionContext,\n-      long submitTime, String user)\n-      throws YarnException {\n+      ApplicationSubmissionContext submissionContext, long submitTime,\n+      String user, boolean isRecovery) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n-    ResourceRequest amReq \u003d validateAndCreateResourceRequest(submissionContext);\n+    ResourceRequest amReq \u003d\n+        validateAndCreateResourceRequest(submissionContext, isRecovery);\n+\n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags(), amReq);\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n-      throw RPCUtil.getRemoteException(message);\n+      throw new YarnException(message);\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovery) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d\n        validateAndCreateResourceRequest(submissionContext, isRecovery);\n\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw new YarnException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
      "commitDate": "15/10/14 6:33 PM",
      "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/09/14 6:20 PM",
      "commitNameOld": "90a0c03f0a696d32e871a5da4560828edea8cfa9",
      "commitAuthorOld": "junping_du",
      "daysBetweenCommits": 29.01,
      "commitsBetweenForRepo": 311,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext,\n       long submitTime, String user)\n       throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n-    validateResourceRequest(submissionContext);\n+    ResourceRequest amReq \u003d validateAndCreateResourceRequest(submissionContext);\n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n-            submissionContext.getApplicationTags());\n+            submissionContext.getApplicationTags(), amReq);\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     String appViewACLs \u003d submissionContext.getAMContainerSpec()\n         .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n     rmContext.getSystemMetricsPublisher().appACLsUpdated(\n         application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext,\n      long submitTime, String user)\n      throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    ResourceRequest amReq \u003d validateAndCreateResourceRequest(submissionContext);\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags(), amReq);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "90a0c03f0a696d32e871a5da4560828edea8cfa9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1250. Generic history service should support application-acls. (Contributed by Zhijie Shen)\n",
      "commitDate": "16/09/14 6:20 PM",
      "commitName": "90a0c03f0a696d32e871a5da4560828edea8cfa9",
      "commitAuthor": "junping_du",
      "commitDateOld": "10/09/14 11:44 AM",
      "commitNameOld": "47bdfa044aa1d587b24edae8b1b0c796d829c960",
      "commitAuthorOld": "XUAN",
      "daysBetweenCommits": 6.28,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,34 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext,\n       long submitTime, String user)\n       throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     validateResourceRequest(submissionContext);\n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType(),\n             submissionContext.getApplicationTags());\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n+    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n+        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n+    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n+        application, appViewACLs, System.currentTimeMillis());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext,\n      long submitTime, String user)\n      throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    validateResourceRequest(submissionContext);\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags());\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    String appViewACLs \u003d submissionContext.getAMContainerSpec()\n        .getApplicationACLs().get(ApplicationAccessType.VIEW_APP);\n    rmContext.getSystemMetricsPublisher().appACLsUpdated(\n        application, appViewACLs, System.currentTimeMillis());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "ebe0c17a95ae37d4768f2928ea193e89db34ead5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1461. Added tags for YARN applications and changed RM to handle them. Contributed by Karthik Kambatla.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564633 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/02/14 8:55 PM",
      "commitName": "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "07/12/13 8:17 PM",
      "commitNameOld": "305ae48136d6e201de4451e824cb7b84f94ba2e0",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 59.03,
      "commitsBetweenForRepo": 306,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,30 @@\n   private RMAppImpl createAndPopulateNewRMApp(\n       ApplicationSubmissionContext submissionContext,\n       long submitTime, String user)\n       throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     validateResourceRequest(submissionContext);\n     // Create RMApp\n     RMAppImpl application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n-            submitTime, submissionContext.getApplicationType());\n+            submitTime, submissionContext.getApplicationType(),\n+            submissionContext.getApplicationTags());\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n     return application;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext,\n      long submitTime, String user)\n      throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    validateResourceRequest(submissionContext);\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType(),\n            submissionContext.getApplicationTags());\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "512475e56f0a27bf3c3ff596184f96993bb4bef4": {
      "type": "Yintroduced",
      "commitMessage": "YARN-674. Fixed ResourceManager to renew DelegationTokens on submission asynchronously to work around potential slowness in state-store. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543312 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/13 9:20 PM",
      "commitName": "512475e56f0a27bf3c3ff596184f96993bb4bef4",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,29 @@\n+  private RMAppImpl createAndPopulateNewRMApp(\n+      ApplicationSubmissionContext submissionContext,\n+      long submitTime, String user)\n+      throws YarnException {\n+    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n+    validateResourceRequest(submissionContext);\n+    // Create RMApp\n+    RMAppImpl application \u003d\n+        new RMAppImpl(applicationId, rmContext, this.conf,\n+            submissionContext.getApplicationName(), user,\n+            submissionContext.getQueue(),\n+            submissionContext, this.scheduler, this.masterService,\n+            submitTime, submissionContext.getApplicationType());\n+\n+    // Concurrent app submissions with same applicationId will fail here\n+    // Concurrent app submissions with different applicationIds will not\n+    // influence each other\n+    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n+        null) {\n+      String message \u003d \"Application with id \" + applicationId\n+          + \" is already present! Cannot add a duplicate!\";\n+      LOG.warn(message);\n+      throw RPCUtil.getRemoteException(message);\n+    }\n+    // Inform the ACLs Manager\n+    this.applicationACLsManager.addApplication(applicationId,\n+        submissionContext.getAMContainerSpec().getApplicationACLs());\n+    return application;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private RMAppImpl createAndPopulateNewRMApp(\n      ApplicationSubmissionContext submissionContext,\n      long submitTime, String user)\n      throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    validateResourceRequest(submissionContext);\n    // Create RMApp\n    RMAppImpl application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType());\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n    return application;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java"
    }
  }
}