{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DataXceiver.java",
  "functionName": "releaseShortCircuitFds",
  "functionId": "releaseShortCircuitFds___slotId-SlotId",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
  "functionStartLine": 440,
  "functionEndLine": 473,
  "numCommitsSeen": 151,
  "timeTaken": 3040,
  "changeHistory": [
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
    "4551da302d94cffea0313eac79479ab6f9b7cb34",
    "a18fd620d070cf8e84aaf80d93807ac9ee207a0f"
  ],
  "changeHistoryShort": {
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "4551da302d94cffea0313eac79479ab6f9b7cb34": "Ybodychange",
    "a18fd620d070cf8e84aaf80d93807ac9ee207a0f": "Ybodychange"
  },
  "changeHistoryDetails": {
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/03/14 7:58 PM",
      "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/03/14 7:58 PM",
          "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "30/01/14 11:15 AM",
          "commitNameOld": "3d9ad8e3b60dd21db45466f4736abe6b1812b522",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 31.36,
          "commitsBetweenForRepo": 251,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,34 @@\n-  public void requestShortCircuitFds(final ExtendedBlock blk,\n-      final Token\u003cBlockTokenIdentifier\u003e token,\n-      int maxVersion) throws IOException {\n-    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n-    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n-    FileInputStream fis[] \u003d null;\n+  public void releaseShortCircuitFds(SlotId slotId) throws IOException {\n+    boolean success \u003d false;\n     try {\n-      if (peer.getDomainSocket() \u003d\u003d null) {\n-        throw new IOException(\"You cannot pass file descriptors over \" +\n-            \"anything but a UNIX domain socket.\");\n+      String error;\n+      Status status;\n+      try {\n+        datanode.shortCircuitRegistry.unregisterSlot(slotId);\n+        error \u003d null;\n+        status \u003d Status.SUCCESS;\n+      } catch (UnsupportedOperationException e) {\n+        error \u003d \"unsupported operation\";\n+        status \u003d Status.ERROR_UNSUPPORTED;\n+      } catch (Throwable e) {\n+        error \u003d e.getMessage();\n+        status \u003d Status.ERROR_INVALID;\n       }\n-      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n-      bld.setStatus(SUCCESS);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-    } catch (ShortCircuitFdsVersionException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-      bld.setMessage(e.getMessage());\n-    } catch (ShortCircuitFdsUnsupportedException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setMessage(e.getMessage());\n-    } catch (InvalidToken e) {\n-      bld.setStatus(ERROR_ACCESS_TOKEN);\n-      bld.setMessage(e.getMessage());\n-    } catch (IOException e) {\n-      bld.setStatus(ERROR);\n-      bld.setMessage(e.getMessage());\n-    }\n-    try {\n+      ReleaseShortCircuitAccessResponseProto.Builder bld \u003d\n+          ReleaseShortCircuitAccessResponseProto.newBuilder();\n+      bld.setStatus(status);\n+      if (error !\u003d null) {\n+        bld.setError(error);\n+      }\n       bld.build().writeDelimitedTo(socketOut);\n-      if (fis !\u003d null) {\n-        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n-        for (int i \u003d 0; i \u003c fds.length; i++) {\n-          fds[i] \u003d fis[i].getFD();\n-        }\n-        byte buf[] \u003d new byte[] { (byte)0 };\n-        peer.getDomainSocket().\n-          sendFileDescriptors(fds, buf, 0, buf.length);\n-      }\n+      success \u003d true;\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n-        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n-            .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n-            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n-            \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n-          ));\n-      }\n-      if (fis !\u003d null) {\n-        IOUtils.cleanup(LOG, fis);\n+            \"src: 127.0.0.1, dest: 127.0.0.1, op: RELEASE_SHORT_CIRCUIT_FDS,\" +\n+            \" shmId: %016x%016x, slotIdx: %d, srvID: %s, success: %b\",\n+            slotId.getShmId().getHi(), slotId.getShmId().getLo(),\n+            slotId.getSlotIdx(), datanode.getDatanodeUuid(), success));\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void releaseShortCircuitFds(SlotId slotId) throws IOException {\n    boolean success \u003d false;\n    try {\n      String error;\n      Status status;\n      try {\n        datanode.shortCircuitRegistry.unregisterSlot(slotId);\n        error \u003d null;\n        status \u003d Status.SUCCESS;\n      } catch (UnsupportedOperationException e) {\n        error \u003d \"unsupported operation\";\n        status \u003d Status.ERROR_UNSUPPORTED;\n      } catch (Throwable e) {\n        error \u003d e.getMessage();\n        status \u003d Status.ERROR_INVALID;\n      }\n      ReleaseShortCircuitAccessResponseProto.Builder bld \u003d\n          ReleaseShortCircuitAccessResponseProto.newBuilder();\n      bld.setStatus(status);\n      if (error !\u003d null) {\n        bld.setError(error);\n      }\n      bld.build().writeDelimitedTo(socketOut);\n      success \u003d true;\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: RELEASE_SHORT_CIRCUIT_FDS,\" +\n            \" shmId: %016x%016x, slotIdx: %d, srvID: %s, success: %b\",\n            slotId.getShmId().getHi(), slotId.getShmId().getLo(),\n            slotId.getSlotIdx(), datanode.getDatanodeUuid(), success));\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "requestShortCircuitFds",
            "newValue": "releaseShortCircuitFds"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/03/14 7:58 PM",
          "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "30/01/14 11:15 AM",
          "commitNameOld": "3d9ad8e3b60dd21db45466f4736abe6b1812b522",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 31.36,
          "commitsBetweenForRepo": 251,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,34 @@\n-  public void requestShortCircuitFds(final ExtendedBlock blk,\n-      final Token\u003cBlockTokenIdentifier\u003e token,\n-      int maxVersion) throws IOException {\n-    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n-    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n-    FileInputStream fis[] \u003d null;\n+  public void releaseShortCircuitFds(SlotId slotId) throws IOException {\n+    boolean success \u003d false;\n     try {\n-      if (peer.getDomainSocket() \u003d\u003d null) {\n-        throw new IOException(\"You cannot pass file descriptors over \" +\n-            \"anything but a UNIX domain socket.\");\n+      String error;\n+      Status status;\n+      try {\n+        datanode.shortCircuitRegistry.unregisterSlot(slotId);\n+        error \u003d null;\n+        status \u003d Status.SUCCESS;\n+      } catch (UnsupportedOperationException e) {\n+        error \u003d \"unsupported operation\";\n+        status \u003d Status.ERROR_UNSUPPORTED;\n+      } catch (Throwable e) {\n+        error \u003d e.getMessage();\n+        status \u003d Status.ERROR_INVALID;\n       }\n-      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n-      bld.setStatus(SUCCESS);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-    } catch (ShortCircuitFdsVersionException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-      bld.setMessage(e.getMessage());\n-    } catch (ShortCircuitFdsUnsupportedException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setMessage(e.getMessage());\n-    } catch (InvalidToken e) {\n-      bld.setStatus(ERROR_ACCESS_TOKEN);\n-      bld.setMessage(e.getMessage());\n-    } catch (IOException e) {\n-      bld.setStatus(ERROR);\n-      bld.setMessage(e.getMessage());\n-    }\n-    try {\n+      ReleaseShortCircuitAccessResponseProto.Builder bld \u003d\n+          ReleaseShortCircuitAccessResponseProto.newBuilder();\n+      bld.setStatus(status);\n+      if (error !\u003d null) {\n+        bld.setError(error);\n+      }\n       bld.build().writeDelimitedTo(socketOut);\n-      if (fis !\u003d null) {\n-        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n-        for (int i \u003d 0; i \u003c fds.length; i++) {\n-          fds[i] \u003d fis[i].getFD();\n-        }\n-        byte buf[] \u003d new byte[] { (byte)0 };\n-        peer.getDomainSocket().\n-          sendFileDescriptors(fds, buf, 0, buf.length);\n-      }\n+      success \u003d true;\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n-        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n-            .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n-            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n-            \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n-          ));\n-      }\n-      if (fis !\u003d null) {\n-        IOUtils.cleanup(LOG, fis);\n+            \"src: 127.0.0.1, dest: 127.0.0.1, op: RELEASE_SHORT_CIRCUIT_FDS,\" +\n+            \" shmId: %016x%016x, slotIdx: %d, srvID: %s, success: %b\",\n+            slotId.getShmId().getHi(), slotId.getShmId().getLo(),\n+            slotId.getSlotIdx(), datanode.getDatanodeUuid(), success));\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void releaseShortCircuitFds(SlotId slotId) throws IOException {\n    boolean success \u003d false;\n    try {\n      String error;\n      Status status;\n      try {\n        datanode.shortCircuitRegistry.unregisterSlot(slotId);\n        error \u003d null;\n        status \u003d Status.SUCCESS;\n      } catch (UnsupportedOperationException e) {\n        error \u003d \"unsupported operation\";\n        status \u003d Status.ERROR_UNSUPPORTED;\n      } catch (Throwable e) {\n        error \u003d e.getMessage();\n        status \u003d Status.ERROR_INVALID;\n      }\n      ReleaseShortCircuitAccessResponseProto.Builder bld \u003d\n          ReleaseShortCircuitAccessResponseProto.newBuilder();\n      bld.setStatus(status);\n      if (error !\u003d null) {\n        bld.setError(error);\n      }\n      bld.build().writeDelimitedTo(socketOut);\n      success \u003d true;\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: RELEASE_SHORT_CIRCUIT_FDS,\" +\n            \" shmId: %016x%016x, slotIdx: %d, srvID: %s, success: %b\",\n            slotId.getShmId().getHi(), slotId.getShmId().getLo(),\n            slotId.getSlotIdx(), datanode.getDatanodeUuid(), success));\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[blk-ExtendedBlock(modifiers-final), token-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), maxVersion-int]",
            "newValue": "[slotId-SlotId]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/03/14 7:58 PM",
          "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "30/01/14 11:15 AM",
          "commitNameOld": "3d9ad8e3b60dd21db45466f4736abe6b1812b522",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 31.36,
          "commitsBetweenForRepo": 251,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,34 @@\n-  public void requestShortCircuitFds(final ExtendedBlock blk,\n-      final Token\u003cBlockTokenIdentifier\u003e token,\n-      int maxVersion) throws IOException {\n-    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n-    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n-    FileInputStream fis[] \u003d null;\n+  public void releaseShortCircuitFds(SlotId slotId) throws IOException {\n+    boolean success \u003d false;\n     try {\n-      if (peer.getDomainSocket() \u003d\u003d null) {\n-        throw new IOException(\"You cannot pass file descriptors over \" +\n-            \"anything but a UNIX domain socket.\");\n+      String error;\n+      Status status;\n+      try {\n+        datanode.shortCircuitRegistry.unregisterSlot(slotId);\n+        error \u003d null;\n+        status \u003d Status.SUCCESS;\n+      } catch (UnsupportedOperationException e) {\n+        error \u003d \"unsupported operation\";\n+        status \u003d Status.ERROR_UNSUPPORTED;\n+      } catch (Throwable e) {\n+        error \u003d e.getMessage();\n+        status \u003d Status.ERROR_INVALID;\n       }\n-      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n-      bld.setStatus(SUCCESS);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-    } catch (ShortCircuitFdsVersionException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n-      bld.setMessage(e.getMessage());\n-    } catch (ShortCircuitFdsUnsupportedException e) {\n-      bld.setStatus(ERROR_UNSUPPORTED);\n-      bld.setMessage(e.getMessage());\n-    } catch (InvalidToken e) {\n-      bld.setStatus(ERROR_ACCESS_TOKEN);\n-      bld.setMessage(e.getMessage());\n-    } catch (IOException e) {\n-      bld.setStatus(ERROR);\n-      bld.setMessage(e.getMessage());\n-    }\n-    try {\n+      ReleaseShortCircuitAccessResponseProto.Builder bld \u003d\n+          ReleaseShortCircuitAccessResponseProto.newBuilder();\n+      bld.setStatus(status);\n+      if (error !\u003d null) {\n+        bld.setError(error);\n+      }\n       bld.build().writeDelimitedTo(socketOut);\n-      if (fis !\u003d null) {\n-        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n-        for (int i \u003d 0; i \u003c fds.length; i++) {\n-          fds[i] \u003d fis[i].getFD();\n-        }\n-        byte buf[] \u003d new byte[] { (byte)0 };\n-        peer.getDomainSocket().\n-          sendFileDescriptors(fds, buf, 0, buf.length);\n-      }\n+      success \u003d true;\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n-        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n-            .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n-            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n-            \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n-          ));\n-      }\n-      if (fis !\u003d null) {\n-        IOUtils.cleanup(LOG, fis);\n+            \"src: 127.0.0.1, dest: 127.0.0.1, op: RELEASE_SHORT_CIRCUIT_FDS,\" +\n+            \" shmId: %016x%016x, slotIdx: %d, srvID: %s, success: %b\",\n+            slotId.getShmId().getHi(), slotId.getShmId().getLo(),\n+            slotId.getSlotIdx(), datanode.getDatanodeUuid(), success));\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void releaseShortCircuitFds(SlotId slotId) throws IOException {\n    boolean success \u003d false;\n    try {\n      String error;\n      Status status;\n      try {\n        datanode.shortCircuitRegistry.unregisterSlot(slotId);\n        error \u003d null;\n        status \u003d Status.SUCCESS;\n      } catch (UnsupportedOperationException e) {\n        error \u003d \"unsupported operation\";\n        status \u003d Status.ERROR_UNSUPPORTED;\n      } catch (Throwable e) {\n        error \u003d e.getMessage();\n        status \u003d Status.ERROR_INVALID;\n      }\n      ReleaseShortCircuitAccessResponseProto.Builder bld \u003d\n          ReleaseShortCircuitAccessResponseProto.newBuilder();\n      bld.setStatus(status);\n      if (error !\u003d null) {\n        bld.setError(error);\n      }\n      bld.build().writeDelimitedTo(socketOut);\n      success \u003d true;\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: RELEASE_SHORT_CIRCUIT_FDS,\" +\n            \" shmId: %016x%016x, slotIdx: %d, srvID: %s, success: %b\",\n            slotId.getShmId().getHi(), slotId.getShmId().getLo(),\n            slotId.getSlotIdx(), datanode.getDatanodeUuid(), success));\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {}
        }
      ]
    },
    "4551da302d94cffea0313eac79479ab6f9b7cb34": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5233. Use Datanode UUID to identify Datanodes.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1525407 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/09/13 11:03 AM",
      "commitName": "4551da302d94cffea0313eac79479ab6f9b7cb34",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "22/07/13 11:15 AM",
      "commitNameOld": "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 61.99,
      "commitsBetweenForRepo": 352,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n       int maxVersion) throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     try {\n       if (peer.getDomainSocket() \u003d\u003d null) {\n         throw new IOException(\"You cannot pass file descriptors over \" +\n             \"anything but a UNIX domain socket.\");\n       }\n       fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n       bld.setStatus(SUCCESS);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n     } catch (ShortCircuitFdsVersionException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       bld.setMessage(e.getMessage());\n     } catch (ShortCircuitFdsUnsupportedException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setMessage(e.getMessage());\n     } catch (InvalidToken e) {\n       bld.setStatus(ERROR_ACCESS_TOKEN);\n       bld.setMessage(e.getMessage());\n     } catch (IOException e) {\n       bld.setStatus(ERROR);\n       bld.setMessage(e.getMessage());\n     }\n     try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[] { (byte)0 };\n         peer.getDomainSocket().\n           sendFileDescriptors(fds, buf, 0, buf.length);\n       }\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n             \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n             \" blockid: %s, srvID: %s, success: %b\",\n-            blk.getBlockId(), dnR.getStorageID(), (fis !\u003d null)\n+            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n           ));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      int maxVersion) throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    try {\n      if (peer.getDomainSocket() \u003d\u003d null) {\n        throw new IOException(\"You cannot pass file descriptors over \" +\n            \"anything but a UNIX domain socket.\");\n      }\n      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n      bld.setStatus(SUCCESS);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n    } catch (ShortCircuitFdsVersionException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      bld.setMessage(e.getMessage());\n    } catch (ShortCircuitFdsUnsupportedException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setMessage(e.getMessage());\n    } catch (InvalidToken e) {\n      bld.setStatus(ERROR_ACCESS_TOKEN);\n      bld.setMessage(e.getMessage());\n    } catch (IOException e) {\n      bld.setStatus(ERROR);\n      bld.setMessage(e.getMessage());\n    }\n    try {\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[] { (byte)0 };\n        peer.getDomainSocket().\n          sendFileDescriptors(fds, buf, 0, buf.length);\n      }\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getDatanodeUuid(), (fis !\u003d null)\n          ));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "a18fd620d070cf8e84aaf80d93807ac9ee207a0f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4661. A few little code cleanups of some HDFS-347-related code. Contributed by Colin Patrick McCabe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480839 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/05/13 5:03 PM",
      "commitName": "a18fd620d070cf8e84aaf80d93807ac9ee207a0f",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "23/01/13 10:38 AM",
      "commitNameOld": "d12f465c674b3bb5102671b6d6c2746261602d7e",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 106.23,
      "commitsBetweenForRepo": 615,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,54 @@\n   public void requestShortCircuitFds(final ExtendedBlock blk,\n       final Token\u003cBlockTokenIdentifier\u003e token,\n       int maxVersion) throws IOException {\n     updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n     BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n     FileInputStream fis[] \u003d null;\n     try {\n       if (peer.getDomainSocket() \u003d\u003d null) {\n         throw new IOException(\"You cannot pass file descriptors over \" +\n             \"anything but a UNIX domain socket.\");\n       }\n       fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n       bld.setStatus(SUCCESS);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n     } catch (ShortCircuitFdsVersionException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n       bld.setMessage(e.getMessage());\n     } catch (ShortCircuitFdsUnsupportedException e) {\n       bld.setStatus(ERROR_UNSUPPORTED);\n       bld.setMessage(e.getMessage());\n     } catch (InvalidToken e) {\n       bld.setStatus(ERROR_ACCESS_TOKEN);\n       bld.setMessage(e.getMessage());\n     } catch (IOException e) {\n       bld.setStatus(ERROR);\n       bld.setMessage(e.getMessage());\n     }\n     try {\n       bld.build().writeDelimitedTo(socketOut);\n       if (fis !\u003d null) {\n         FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n         for (int i \u003d 0; i \u003c fds.length; i++) {\n           fds[i] \u003d fis[i].getFD();\n         }\n         byte buf[] \u003d new byte[] { (byte)0 };\n         peer.getDomainSocket().\n           sendFileDescriptors(fds, buf, 0, buf.length);\n       }\n     } finally {\n       if (ClientTraceLog.isInfoEnabled()) {\n         DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n             .getBlockPoolId());\n         BlockSender.ClientTraceLog.info(String.format(\n-          String.format(\n-            \"src: %s, dest: %s, op: %s, blockid: %s, srvID: %s, \" +\n-              \"success: %b\",\n-            \"127.0.0.1\",                   // src IP\n-            \"127.0.0.1\",                   // dst IP\n-            \"REQUEST_SHORT_CIRCUIT_FDS\",   // operation\n-            blk.getBlockId(),             // block id\n-            dnR.getStorageID(),\n-            (fis !\u003d null)\n-          )));\n+            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n+            \" blockid: %s, srvID: %s, success: %b\",\n+            blk.getBlockId(), dnR.getStorageID(), (fis !\u003d null)\n+          ));\n       }\n       if (fis !\u003d null) {\n         IOUtils.cleanup(LOG, fis);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void requestShortCircuitFds(final ExtendedBlock blk,\n      final Token\u003cBlockTokenIdentifier\u003e token,\n      int maxVersion) throws IOException {\n    updateCurrentThreadName(\"Passing file descriptors for block \" + blk);\n    BlockOpResponseProto.Builder bld \u003d BlockOpResponseProto.newBuilder();\n    FileInputStream fis[] \u003d null;\n    try {\n      if (peer.getDomainSocket() \u003d\u003d null) {\n        throw new IOException(\"You cannot pass file descriptors over \" +\n            \"anything but a UNIX domain socket.\");\n      }\n      fis \u003d datanode.requestShortCircuitFdsForRead(blk, token, maxVersion);\n      bld.setStatus(SUCCESS);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n    } catch (ShortCircuitFdsVersionException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setShortCircuitAccessVersion(DataNode.CURRENT_BLOCK_FORMAT_VERSION);\n      bld.setMessage(e.getMessage());\n    } catch (ShortCircuitFdsUnsupportedException e) {\n      bld.setStatus(ERROR_UNSUPPORTED);\n      bld.setMessage(e.getMessage());\n    } catch (InvalidToken e) {\n      bld.setStatus(ERROR_ACCESS_TOKEN);\n      bld.setMessage(e.getMessage());\n    } catch (IOException e) {\n      bld.setStatus(ERROR);\n      bld.setMessage(e.getMessage());\n    }\n    try {\n      bld.build().writeDelimitedTo(socketOut);\n      if (fis !\u003d null) {\n        FileDescriptor fds[] \u003d new FileDescriptor[fis.length];\n        for (int i \u003d 0; i \u003c fds.length; i++) {\n          fds[i] \u003d fis[i].getFD();\n        }\n        byte buf[] \u003d new byte[] { (byte)0 };\n        peer.getDomainSocket().\n          sendFileDescriptors(fds, buf, 0, buf.length);\n      }\n    } finally {\n      if (ClientTraceLog.isInfoEnabled()) {\n        DatanodeRegistration dnR \u003d datanode.getDNRegistrationForBP(blk\n            .getBlockPoolId());\n        BlockSender.ClientTraceLog.info(String.format(\n            \"src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS,\" +\n            \" blockid: %s, srvID: %s, success: %b\",\n            blk.getBlockId(), dnR.getStorageID(), (fis !\u003d null)\n          ));\n      }\n      if (fis !\u003d null) {\n        IOUtils.cleanup(LOG, fis);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    }
  }
}