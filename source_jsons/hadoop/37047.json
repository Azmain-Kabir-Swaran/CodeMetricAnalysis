{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PeriodicRLESparseResourceAllocation.java",
  "functionName": "getRangeOverlapping",
  "functionId": "getRangeOverlapping___start-long__end-long",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/PeriodicRLESparseResourceAllocation.java",
  "functionStartLine": 216,
  "functionEndLine": 240,
  "numCommitsSeen": 5,
  "timeTaken": 1576,
  "changeHistory": [
    "e6e614e380ed1d746973b50f666a9c40d272073e",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0"
  ],
  "changeHistoryShort": {
    "e6e614e380ed1d746973b50f666a9c40d272073e": "Ybodychange",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e6e614e380ed1d746973b50f666a9c40d272073e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
      "commitDate": "04/10/17 7:28 PM",
      "commitName": "e6e614e380ed1d746973b50f666a9c40d272073e",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "06/09/17 4:46 PM",
      "commitNameOld": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 28.11,
      "commitsBetweenForRepo": 262,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,25 @@\n   public RLESparseResourceAllocation getRangeOverlapping(long start, long end) {\n     NavigableMap\u003cLong, Resource\u003e unrolledMap \u003d new TreeMap\u003c\u003e();\n     readLock.lock();\n     try {\n       long relativeStart \u003d (start \u003e\u003d 0) ? start % timePeriod : 0;\n       NavigableMap\u003cLong, Resource\u003e cumulativeMap \u003d this.getCumulative();\n       Long previous \u003d cumulativeMap.floorKey(relativeStart);\n       previous \u003d (previous !\u003d null) ? previous : 0;\n-      for (long i \u003d 0; i \u003c\u003d (end - start) / timePeriod; i++) {\n+      //make sure to go one past end, to catch end times extending past period\n+      for (long i \u003d 0; i \u003c\u003d 1 + (end - start) / timePeriod; i++) {\n         for (Map.Entry\u003cLong, Resource\u003e e : cumulativeMap.entrySet()) {\n           long curKey \u003d e.getKey() + (i * timePeriod);\n           if (curKey \u003e\u003d previous \u0026\u0026 (start + curKey - relativeStart) \u003c\u003d end) {\n             unrolledMap.put(curKey, e.getValue());\n           }\n         }\n       }\n       RLESparseResourceAllocation rle \u003d\n           new RLESparseResourceAllocation(unrolledMap, getResourceCalculator());\n       rle.shift(start - relativeStart);\n       return rle;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RLESparseResourceAllocation getRangeOverlapping(long start, long end) {\n    NavigableMap\u003cLong, Resource\u003e unrolledMap \u003d new TreeMap\u003c\u003e();\n    readLock.lock();\n    try {\n      long relativeStart \u003d (start \u003e\u003d 0) ? start % timePeriod : 0;\n      NavigableMap\u003cLong, Resource\u003e cumulativeMap \u003d this.getCumulative();\n      Long previous \u003d cumulativeMap.floorKey(relativeStart);\n      previous \u003d (previous !\u003d null) ? previous : 0;\n      //make sure to go one past end, to catch end times extending past period\n      for (long i \u003d 0; i \u003c\u003d 1 + (end - start) / timePeriod; i++) {\n        for (Map.Entry\u003cLong, Resource\u003e e : cumulativeMap.entrySet()) {\n          long curKey \u003d e.getKey() + (i * timePeriod);\n          if (curKey \u003e\u003d previous \u0026\u0026 (start + curKey - relativeStart) \u003c\u003d end) {\n            unrolledMap.put(curKey, e.getValue());\n          }\n        }\n      }\n      RLESparseResourceAllocation rle \u003d\n          new RLESparseResourceAllocation(unrolledMap, getResourceCalculator());\n      rle.shift(start - relativeStart);\n      return rle;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/PeriodicRLESparseResourceAllocation.java",
      "extendedDetails": {}
    },
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5328. Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "06/09/17 4:46 PM",
      "commitName": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,24 @@\n+  public RLESparseResourceAllocation getRangeOverlapping(long start, long end) {\n+    NavigableMap\u003cLong, Resource\u003e unrolledMap \u003d new TreeMap\u003c\u003e();\n+    readLock.lock();\n+    try {\n+      long relativeStart \u003d (start \u003e\u003d 0) ? start % timePeriod : 0;\n+      NavigableMap\u003cLong, Resource\u003e cumulativeMap \u003d this.getCumulative();\n+      Long previous \u003d cumulativeMap.floorKey(relativeStart);\n+      previous \u003d (previous !\u003d null) ? previous : 0;\n+      for (long i \u003d 0; i \u003c\u003d (end - start) / timePeriod; i++) {\n+        for (Map.Entry\u003cLong, Resource\u003e e : cumulativeMap.entrySet()) {\n+          long curKey \u003d e.getKey() + (i * timePeriod);\n+          if (curKey \u003e\u003d previous \u0026\u0026 (start + curKey - relativeStart) \u003c\u003d end) {\n+            unrolledMap.put(curKey, e.getValue());\n+          }\n+        }\n+      }\n+      RLESparseResourceAllocation rle \u003d\n+          new RLESparseResourceAllocation(unrolledMap, getResourceCalculator());\n+      rle.shift(start - relativeStart);\n+      return rle;\n+    } finally {\n+      readLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public RLESparseResourceAllocation getRangeOverlapping(long start, long end) {\n    NavigableMap\u003cLong, Resource\u003e unrolledMap \u003d new TreeMap\u003c\u003e();\n    readLock.lock();\n    try {\n      long relativeStart \u003d (start \u003e\u003d 0) ? start % timePeriod : 0;\n      NavigableMap\u003cLong, Resource\u003e cumulativeMap \u003d this.getCumulative();\n      Long previous \u003d cumulativeMap.floorKey(relativeStart);\n      previous \u003d (previous !\u003d null) ? previous : 0;\n      for (long i \u003d 0; i \u003c\u003d (end - start) / timePeriod; i++) {\n        for (Map.Entry\u003cLong, Resource\u003e e : cumulativeMap.entrySet()) {\n          long curKey \u003d e.getKey() + (i * timePeriod);\n          if (curKey \u003e\u003d previous \u0026\u0026 (start + curKey - relativeStart) \u003c\u003d end) {\n            unrolledMap.put(curKey, e.getValue());\n          }\n        }\n      }\n      RLESparseResourceAllocation rle \u003d\n          new RLESparseResourceAllocation(unrolledMap, getResourceCalculator());\n      rle.shift(start - relativeStart);\n      return rle;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/PeriodicRLESparseResourceAllocation.java"
    }
  }
}