{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NodeStatusUpdaterImpl.java",
  "functionName": "getContainerStatuses",
  "functionId": "getContainerStatuses",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
  "functionStartLine": 597,
  "functionEndLine": 630,
  "numCommitsSeen": 153,
  "timeTaken": 5482,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6",
    "f45bc5a83ed2f2292ecf1f4c990b7153d8051fc9",
    "38aed1a94ed7b6da62e2445b5610bc02b1cddeeb",
    "cc2a745f7e82c9fa6de03242952347c54c52dccc",
    "3ef1cf187faeb530e74606dd7113fd1ba08140d7",
    "0a641496c706fc175e7bf66d69ebf71c7d078e84",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b",
    "44b6261bfacddea88a3cf02d406f970bbbb98d04",
    "1c4047b0e46e95a92509de2e59a93433f5968538",
    "cfa783141fa69c2cf154d1d9e5393353d14ce5e1"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6": "Ybodychange",
    "f45bc5a83ed2f2292ecf1f4c990b7153d8051fc9": "Ybodychange",
    "38aed1a94ed7b6da62e2445b5610bc02b1cddeeb": "Ybodychange",
    "cc2a745f7e82c9fa6de03242952347c54c52dccc": "Ybodychange",
    "3ef1cf187faeb530e74606dd7113fd1ba08140d7": "Ybodychange",
    "0a641496c706fc175e7bf66d69ebf71c7d078e84": "Ymultichange(Yexceptionschange,Ybodychange)",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": "Ybodychange",
    "44b6261bfacddea88a3cf02d406f970bbbb98d04": "Ybodychange",
    "1c4047b0e46e95a92509de2e59a93433f5968538": "Ymultichange(Yrename,Ymodifierchange,Ybodychange)",
    "cfa783141fa69c2cf154d1d9e5393353d14ce5e1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "22/02/19 7:31 AM",
      "commitNameOld": "ed13cf84068ad50a78e66211132c1f08238fb65b",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 21.33,
      "commitsBetweenForRepo": 206,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,34 @@\n   protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n     List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n     for (Container container : this.context.getContainers().values()) {\n       ContainerId containerId \u003d container.getContainerId();\n       ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n           .getApplicationId();\n       org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n           container.cloneAndGetContainerStatus();\n       if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n         if (isApplicationStopped(applicationId)) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(applicationId + \" is completing, \" + \" remove \"\n-                + containerId + \" from NM context.\");\n-          }\n+          LOG.debug(\"{} is completing, remove {} from NM context.\",\n+              applicationId, containerId);\n           context.getContainers().remove(containerId);\n           pendingCompletedContainers.put(containerId, containerStatus);\n         } else {\n           if (!isContainerRecentlyStopped(containerId)) {\n             pendingCompletedContainers.put(containerId, containerStatus);\n           }\n         }\n         // Adding to finished containers cache. Cache will keep it around at\n         // least for #durationToTrackStoppedContainers duration. In the\n         // subsequent call to stop container it will get removed from cache.\n         addCompletedContainer(containerId);\n       } else {\n         containerStatuses.add(containerStatus);\n       }\n     }\n \n     containerStatuses.addAll(pendingCompletedContainers.values());\n+    LOG.debug(\"Sending out {} container statuses: {}\",\n+        containerStatuses.size(), containerStatuses);\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Sending out \" + containerStatuses.size()\n-          + \" container statuses: \" + containerStatuses);\n-    }\n     return containerStatuses;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Container container : this.context.getContainers().values()) {\n      ContainerId containerId \u003d container.getContainerId();\n      ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n          .getApplicationId();\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n          container.cloneAndGetContainerStatus();\n      if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n        if (isApplicationStopped(applicationId)) {\n          LOG.debug(\"{} is completing, remove {} from NM context.\",\n              applicationId, containerId);\n          context.getContainers().remove(containerId);\n          pendingCompletedContainers.put(containerId, containerStatus);\n        } else {\n          if (!isContainerRecentlyStopped(containerId)) {\n            pendingCompletedContainers.put(containerId, containerStatus);\n          }\n        }\n        // Adding to finished containers cache. Cache will keep it around at\n        // least for #durationToTrackStoppedContainers duration. In the\n        // subsequent call to stop container it will get removed from cache.\n        addCompletedContainer(containerId);\n      } else {\n        containerStatuses.add(containerStatus);\n      }\n    }\n\n    containerStatuses.addAll(pendingCompletedContainers.values());\n    LOG.debug(\"Sending out {} container statuses: {}\",\n        containerStatuses.size(), containerStatuses);\n\n    return containerStatuses;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4597. Introduce ContainerScheduler and a SCHEDULED state to NodeManager container lifecycle. (asuresh)\n",
      "commitDate": "15/11/16 7:56 AM",
      "commitName": "3219b7b4ac7d12aee343f6ab2980b3357fc618b6",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "08/11/16 2:01 PM",
      "commitNameOld": "3f93ac0733058238a2c8f23960c986c71dca0e02",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 6.75,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,38 @@\n   protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n     List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n     for (Container container : this.context.getContainers().values()) {\n       ContainerId containerId \u003d container.getContainerId();\n       ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n           .getApplicationId();\n       org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n           container.cloneAndGetContainerStatus();\n       if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n         if (isApplicationStopped(applicationId)) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(applicationId + \" is completing, \" + \" remove \"\n                 + containerId + \" from NM context.\");\n           }\n           context.getContainers().remove(containerId);\n           pendingCompletedContainers.put(containerId, containerStatus);\n         } else {\n           if (!isContainerRecentlyStopped(containerId)) {\n             pendingCompletedContainers.put(containerId, containerStatus);\n           }\n         }\n         // Adding to finished containers cache. Cache will keep it around at\n         // least for #durationToTrackStoppedContainers duration. In the\n         // subsequent call to stop container it will get removed from cache.\n         addCompletedContainer(containerId);\n       } else {\n         containerStatuses.add(containerStatus);\n       }\n     }\n \n-    // Account for all containers that got killed while they were still queued.\n-    pendingCompletedContainers.putAll(getKilledQueuedContainerStatuses());\n-\n     containerStatuses.addAll(pendingCompletedContainers.values());\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Sending out \" + containerStatuses.size()\n           + \" container statuses: \" + containerStatuses);\n     }\n     return containerStatuses;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Container container : this.context.getContainers().values()) {\n      ContainerId containerId \u003d container.getContainerId();\n      ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n          .getApplicationId();\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n          container.cloneAndGetContainerStatus();\n      if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n        if (isApplicationStopped(applicationId)) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(applicationId + \" is completing, \" + \" remove \"\n                + containerId + \" from NM context.\");\n          }\n          context.getContainers().remove(containerId);\n          pendingCompletedContainers.put(containerId, containerStatus);\n        } else {\n          if (!isContainerRecentlyStopped(containerId)) {\n            pendingCompletedContainers.put(containerId, containerStatus);\n          }\n        }\n        // Adding to finished containers cache. Cache will keep it around at\n        // least for #durationToTrackStoppedContainers duration. In the\n        // subsequent call to stop container it will get removed from cache.\n        addCompletedContainer(containerId);\n      } else {\n        containerStatuses.add(containerStatus);\n      }\n    }\n\n    containerStatuses.addAll(pendingCompletedContainers.values());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Sending out \" + containerStatuses.size()\n          + \" container statuses: \" + containerStatuses);\n    }\n    return containerStatuses;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "f45bc5a83ed2f2292ecf1f4c990b7153d8051fc9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4738. Notify the RM about the status of OPPORTUNISTIC containers (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "15/05/16 5:54 PM",
      "commitName": "f45bc5a83ed2f2292ecf1f4c990b7153d8051fc9",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "13/05/16 1:38 PM",
      "commitNameOld": "f0ac18d001d97914a9ee810b1fab56c5cebff830",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 2.18,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,41 @@\n   protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n     List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n     for (Container container : this.context.getContainers().values()) {\n       ContainerId containerId \u003d container.getContainerId();\n       ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n           .getApplicationId();\n       org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n           container.cloneAndGetContainerStatus();\n       if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n         if (isApplicationStopped(applicationId)) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(applicationId + \" is completing, \" + \" remove \"\n                 + containerId + \" from NM context.\");\n           }\n           context.getContainers().remove(containerId);\n           pendingCompletedContainers.put(containerId, containerStatus);\n         } else {\n           if (!isContainerRecentlyStopped(containerId)) {\n             pendingCompletedContainers.put(containerId, containerStatus);\n           }\n         }\n         // Adding to finished containers cache. Cache will keep it around at\n         // least for #durationToTrackStoppedContainers duration. In the\n         // subsequent call to stop container it will get removed from cache.\n         addCompletedContainer(containerId);\n       } else {\n         containerStatuses.add(containerStatus);\n       }\n     }\n+\n+    // Account for all containers that got killed while they were still queued.\n+    pendingCompletedContainers.putAll(getKilledQueuedContainerStatuses());\n+\n     containerStatuses.addAll(pendingCompletedContainers.values());\n+\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Sending out \" + containerStatuses.size()\n           + \" container statuses: \" + containerStatuses);\n     }\n     return containerStatuses;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Container container : this.context.getContainers().values()) {\n      ContainerId containerId \u003d container.getContainerId();\n      ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n          .getApplicationId();\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n          container.cloneAndGetContainerStatus();\n      if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n        if (isApplicationStopped(applicationId)) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(applicationId + \" is completing, \" + \" remove \"\n                + containerId + \" from NM context.\");\n          }\n          context.getContainers().remove(containerId);\n          pendingCompletedContainers.put(containerId, containerStatus);\n        } else {\n          if (!isContainerRecentlyStopped(containerId)) {\n            pendingCompletedContainers.put(containerId, containerStatus);\n          }\n        }\n        // Adding to finished containers cache. Cache will keep it around at\n        // least for #durationToTrackStoppedContainers duration. In the\n        // subsequent call to stop container it will get removed from cache.\n        addCompletedContainer(containerId);\n      } else {\n        containerStatuses.add(containerStatus);\n      }\n    }\n\n    // Account for all containers that got killed while they were still queued.\n    pendingCompletedContainers.putAll(getKilledQueuedContainerStatuses());\n\n    containerStatuses.addAll(pendingCompletedContainers.values());\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Sending out \" + containerStatuses.size()\n          + \" container statuses: \" + containerStatuses);\n    }\n    return containerStatuses;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "38aed1a94ed7b6da62e2445b5610bc02b1cddeeb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4005. Completed container whose app is finished is possibly not removed from NMStateStore. Contributed by Jun Gong\n",
      "commitDate": "13/08/15 2:46 PM",
      "commitName": "38aed1a94ed7b6da62e2445b5610bc02b1cddeeb",
      "commitAuthor": "Jian He",
      "commitDateOld": "09/07/15 9:35 AM",
      "commitNameOld": "527c40e4d664c721b8f32d7cd8df21b2666fea8a",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 35.22,
      "commitsBetweenForRepo": 186,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n     List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n     for (Container container : this.context.getContainers().values()) {\n       ContainerId containerId \u003d container.getContainerId();\n       ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n           .getApplicationId();\n       org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n           container.cloneAndGetContainerStatus();\n       if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n         if (isApplicationStopped(applicationId)) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(applicationId + \" is completing, \" + \" remove \"\n                 + containerId + \" from NM context.\");\n           }\n           context.getContainers().remove(containerId);\n           pendingCompletedContainers.put(containerId, containerStatus);\n         } else {\n           if (!isContainerRecentlyStopped(containerId)) {\n             pendingCompletedContainers.put(containerId, containerStatus);\n-            // Adding to finished containers cache. Cache will keep it around at\n-            // least for #durationToTrackStoppedContainers duration. In the\n-            // subsequent call to stop container it will get removed from cache.\n-            addCompletedContainer(containerId);\n           }\n         }\n+        // Adding to finished containers cache. Cache will keep it around at\n+        // least for #durationToTrackStoppedContainers duration. In the\n+        // subsequent call to stop container it will get removed from cache.\n+        addCompletedContainer(containerId);\n       } else {\n         containerStatuses.add(containerStatus);\n       }\n     }\n     containerStatuses.addAll(pendingCompletedContainers.values());\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Sending out \" + containerStatuses.size()\n           + \" container statuses: \" + containerStatuses);\n     }\n     return containerStatuses;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Container container : this.context.getContainers().values()) {\n      ContainerId containerId \u003d container.getContainerId();\n      ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n          .getApplicationId();\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n          container.cloneAndGetContainerStatus();\n      if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n        if (isApplicationStopped(applicationId)) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(applicationId + \" is completing, \" + \" remove \"\n                + containerId + \" from NM context.\");\n          }\n          context.getContainers().remove(containerId);\n          pendingCompletedContainers.put(containerId, containerStatus);\n        } else {\n          if (!isContainerRecentlyStopped(containerId)) {\n            pendingCompletedContainers.put(containerId, containerStatus);\n          }\n        }\n        // Adding to finished containers cache. Cache will keep it around at\n        // least for #durationToTrackStoppedContainers duration. In the\n        // subsequent call to stop container it will get removed from cache.\n        addCompletedContainer(containerId);\n      } else {\n        containerStatuses.add(containerStatus);\n      }\n    }\n    containerStatuses.addAll(pendingCompletedContainers.values());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Sending out \" + containerStatuses.size()\n          + \" container statuses: \" + containerStatuses);\n    }\n    return containerStatuses;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "cc2a745f7e82c9fa6de03242952347c54c52dccc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2997. Fixed NodeStatusUpdater to not send alreay-sent completed container statuses on heartbeat. Contributed by Chengbing Liu\n",
      "commitDate": "08/01/15 11:12 AM",
      "commitName": "cc2a745f7e82c9fa6de03242952347c54c52dccc",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/11/14 11:07 AM",
      "commitNameOld": "be7bf956e96dd0fd9b521ca71df9124b9cc5ebd0",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 57.0,
      "commitsBetweenForRepo": 342,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,36 @@\n   protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n     List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n     for (Container container : this.context.getContainers().values()) {\n       ContainerId containerId \u003d container.getContainerId();\n-      ApplicationId applicationId \u003d container.getContainerId()\n-          .getApplicationAttemptId().getApplicationId();\n+      ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n+          .getApplicationId();\n       org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n           container.cloneAndGetContainerStatus();\n-      containerStatuses.add(containerStatus);\n       if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n         if (isApplicationStopped(applicationId)) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(applicationId + \" is completing, \" + \" remove \"\n                 + containerId + \" from NM context.\");\n           }\n           context.getContainers().remove(containerId);\n+          pendingCompletedContainers.put(containerId, containerStatus);\n         } else {\n-          // Adding to finished containers cache. Cache will keep it around at\n-          // least for #durationToTrackStoppedContainers duration. In the\n-          // subsequent call to stop container it will get removed from cache.\n-          addCompletedContainer(container.getContainerId());\n+          if (!isContainerRecentlyStopped(containerId)) {\n+            pendingCompletedContainers.put(containerId, containerStatus);\n+            // Adding to finished containers cache. Cache will keep it around at\n+            // least for #durationToTrackStoppedContainers duration. In the\n+            // subsequent call to stop container it will get removed from cache.\n+            addCompletedContainer(containerId);\n+          }\n         }\n+      } else {\n+        containerStatuses.add(containerStatus);\n       }\n     }\n+    containerStatuses.addAll(pendingCompletedContainers.values());\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Sending out \" + containerStatuses.size()\n           + \" container statuses: \" + containerStatuses);\n     }\n     return containerStatuses;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Container container : this.context.getContainers().values()) {\n      ContainerId containerId \u003d container.getContainerId();\n      ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n          .getApplicationId();\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n          container.cloneAndGetContainerStatus();\n      if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n        if (isApplicationStopped(applicationId)) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(applicationId + \" is completing, \" + \" remove \"\n                + containerId + \" from NM context.\");\n          }\n          context.getContainers().remove(containerId);\n          pendingCompletedContainers.put(containerId, containerStatus);\n        } else {\n          if (!isContainerRecentlyStopped(containerId)) {\n            pendingCompletedContainers.put(containerId, containerStatus);\n            // Adding to finished containers cache. Cache will keep it around at\n            // least for #durationToTrackStoppedContainers duration. In the\n            // subsequent call to stop container it will get removed from cache.\n            addCompletedContainer(containerId);\n          }\n        }\n      } else {\n        containerStatuses.add(containerStatus);\n      }\n    }\n    containerStatuses.addAll(pendingCompletedContainers.values());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Sending out \" + containerStatuses.size()\n          + \" container statuses: \" + containerStatuses);\n    }\n    return containerStatuses;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "3ef1cf187faeb530e74606dd7113fd1ba08140d7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2617. Fixed NM to not send duplicate container status whose app is not running. Contributed by Jun Gong\n",
      "commitDate": "02/10/14 10:04 AM",
      "commitName": "3ef1cf187faeb530e74606dd7113fd1ba08140d7",
      "commitAuthor": "Jian He",
      "commitDateOld": "01/10/14 3:38 PM",
      "commitNameOld": "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.77,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,30 @@\n   protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n     List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n     for (Container container : this.context.getContainers().values()) {\n       ContainerId containerId \u003d container.getContainerId();\n       ApplicationId applicationId \u003d container.getContainerId()\n           .getApplicationAttemptId().getApplicationId();\n-      if (!this.context.getApplications().containsKey(applicationId)) {\n-        context.getContainers().remove(containerId);\n-        continue;\n-      }\n       org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n           container.cloneAndGetContainerStatus();\n       containerStatuses.add(containerStatus);\n-      if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n-        // Adding to finished containers cache. Cache will keep it around at\n-        // least for #durationToTrackStoppedContainers duration. In the\n-        // subsequent call to stop container it will get removed from cache.\n-        addCompletedContainer(container.getContainerId());\n+      if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n+        if (isApplicationStopped(applicationId)) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(applicationId + \" is completing, \" + \" remove \"\n+                + containerId + \" from NM context.\");\n+          }\n+          context.getContainers().remove(containerId);\n+        } else {\n+          // Adding to finished containers cache. Cache will keep it around at\n+          // least for #durationToTrackStoppedContainers duration. In the\n+          // subsequent call to stop container it will get removed from cache.\n+          addCompletedContainer(container.getContainerId());\n+        }\n       }\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Sending out \" + containerStatuses.size()\n           + \" container statuses: \" + containerStatuses);\n     }\n     return containerStatuses;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Container container : this.context.getContainers().values()) {\n      ContainerId containerId \u003d container.getContainerId();\n      ApplicationId applicationId \u003d container.getContainerId()\n          .getApplicationAttemptId().getApplicationId();\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n          container.cloneAndGetContainerStatus();\n      containerStatuses.add(containerStatus);\n      if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n        if (isApplicationStopped(applicationId)) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(applicationId + \" is completing, \" + \" remove \"\n                + containerId + \" from NM context.\");\n          }\n          context.getContainers().remove(containerId);\n        } else {\n          // Adding to finished containers cache. Cache will keep it around at\n          // least for #durationToTrackStoppedContainers duration. In the\n          // subsequent call to stop container it will get removed from cache.\n          addCompletedContainer(container.getContainerId());\n        }\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Sending out \" + containerStatuses.size()\n          + \" container statuses: \" + containerStatuses);\n    }\n    return containerStatuses;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "0a641496c706fc175e7bf66d69ebf71c7d078e84": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-1372. Ensure all completed containers are reported to the AMs across RM restart. Contributed by Anubhav Dhoot\n",
      "commitDate": "22/09/14 10:30 AM",
      "commitName": "0a641496c706fc175e7bf66d69ebf71c7d078e84",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-1372. Ensure all completed containers are reported to the AMs across RM restart. Contributed by Anubhav Dhoot\n",
          "commitDate": "22/09/14 10:30 AM",
          "commitName": "0a641496c706fc175e7bf66d69ebf71c7d078e84",
          "commitAuthor": "Jian He",
          "commitDateOld": "12/08/14 3:56 AM",
          "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 41.27,
          "commitsBetweenForRepo": 399,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,26 @@\n-  protected List\u003cContainerStatus\u003e getContainerStatuses() {\n+  protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n     List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n     for (Container container : this.context.getContainers().values()) {\n+      ContainerId containerId \u003d container.getContainerId();\n+      ApplicationId applicationId \u003d container.getContainerId()\n+          .getApplicationAttemptId().getApplicationId();\n+      if (!this.context.getApplications().containsKey(applicationId)) {\n+        context.getContainers().remove(containerId);\n+        continue;\n+      }\n       org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n           container.cloneAndGetContainerStatus();\n       containerStatuses.add(containerStatus);\n       if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n         // Adding to finished containers cache. Cache will keep it around at\n         // least for #durationToTrackStoppedContainers duration. In the\n         // subsequent call to stop container it will get removed from cache.\n         addCompletedContainer(container.getContainerId());\n       }\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Sending out \" + containerStatuses.size()\n           + \" container statuses: \" + containerStatuses);\n     }\n     return containerStatuses;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Container container : this.context.getContainers().values()) {\n      ContainerId containerId \u003d container.getContainerId();\n      ApplicationId applicationId \u003d container.getContainerId()\n          .getApplicationAttemptId().getApplicationId();\n      if (!this.context.getApplications().containsKey(applicationId)) {\n        context.getContainers().remove(containerId);\n        continue;\n      }\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n          container.cloneAndGetContainerStatus();\n      containerStatuses.add(containerStatus);\n      if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n        // Adding to finished containers cache. Cache will keep it around at\n        // least for #durationToTrackStoppedContainers duration. In the\n        // subsequent call to stop container it will get removed from cache.\n        addCompletedContainer(container.getContainerId());\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Sending out \" + containerStatuses.size()\n          + \" container statuses: \" + containerStatuses);\n    }\n    return containerStatuses;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1372. Ensure all completed containers are reported to the AMs across RM restart. Contributed by Anubhav Dhoot\n",
          "commitDate": "22/09/14 10:30 AM",
          "commitName": "0a641496c706fc175e7bf66d69ebf71c7d078e84",
          "commitAuthor": "Jian He",
          "commitDateOld": "12/08/14 3:56 AM",
          "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 41.27,
          "commitsBetweenForRepo": 399,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,26 @@\n-  protected List\u003cContainerStatus\u003e getContainerStatuses() {\n+  protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n     List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n     for (Container container : this.context.getContainers().values()) {\n+      ContainerId containerId \u003d container.getContainerId();\n+      ApplicationId applicationId \u003d container.getContainerId()\n+          .getApplicationAttemptId().getApplicationId();\n+      if (!this.context.getApplications().containsKey(applicationId)) {\n+        context.getContainers().remove(containerId);\n+        continue;\n+      }\n       org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n           container.cloneAndGetContainerStatus();\n       containerStatuses.add(containerStatus);\n       if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n         // Adding to finished containers cache. Cache will keep it around at\n         // least for #durationToTrackStoppedContainers duration. In the\n         // subsequent call to stop container it will get removed from cache.\n         addCompletedContainer(container.getContainerId());\n       }\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Sending out \" + containerStatuses.size()\n           + \" container statuses: \" + containerStatuses);\n     }\n     return containerStatuses;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected List\u003cContainerStatus\u003e getContainerStatuses() throws IOException {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Container container : this.context.getContainers().values()) {\n      ContainerId containerId \u003d container.getContainerId();\n      ApplicationId applicationId \u003d container.getContainerId()\n          .getApplicationAttemptId().getApplicationId();\n      if (!this.context.getApplications().containsKey(applicationId)) {\n        context.getContainers().remove(containerId);\n        continue;\n      }\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n          container.cloneAndGetContainerStatus();\n      containerStatuses.add(containerStatus);\n      if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n        // Adding to finished containers cache. Cache will keep it around at\n        // least for #durationToTrackStoppedContainers duration. In the\n        // subsequent call to stop container it will get removed from cache.\n        addCompletedContainer(container.getContainerId());\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Sending out \" + containerStatuses.size()\n          + \" container statuses: \" + containerStatuses);\n    }\n    return containerStatuses;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1337. Recover containers upon nodemanager restart. (Contributed by Jason Lowe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617448 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 3:56 AM",
      "commitName": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthor": "Junping Du",
      "commitDateOld": "16/06/14 4:56 PM",
      "commitNameOld": "95897ca14b7abd7fe047fdcf150473a8a2cbb024",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 56.46,
      "commitsBetweenForRepo": 399,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,20 +1,19 @@\n   protected List\u003cContainerStatus\u003e getContainerStatuses() {\n     List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n     for (Container container : this.context.getContainers().values()) {\n       org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n           container.cloneAndGetContainerStatus();\n       containerStatuses.add(containerStatus);\n       if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n         // Adding to finished containers cache. Cache will keep it around at\n         // least for #durationToTrackStoppedContainers duration. In the\n         // subsequent call to stop container it will get removed from cache.\n-        updateStoppedContainersInCache(container.getContainerId());\n-        addCompletedContainer(container);\n+        addCompletedContainer(container.getContainerId());\n       }\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Sending out \" + containerStatuses.size()\n           + \" container statuses: \" + containerStatuses);\n     }\n     return containerStatuses;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cContainerStatus\u003e getContainerStatuses() {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Container container : this.context.getContainers().values()) {\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n          container.cloneAndGetContainerStatus();\n      containerStatuses.add(containerStatus);\n      if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n        // Adding to finished containers cache. Cache will keep it around at\n        // least for #durationToTrackStoppedContainers duration. In the\n        // subsequent call to stop container it will get removed from cache.\n        addCompletedContainer(container.getContainerId());\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Sending out \" + containerStatuses.size()\n          + \" container statuses: \" + containerStatuses);\n    }\n    return containerStatuses;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "44b6261bfacddea88a3cf02d406f970bbbb98d04": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1892. Improved some logs in the scheduler. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1587717 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/04/14 1:37 PM",
      "commitName": "44b6261bfacddea88a3cf02d406f970bbbb98d04",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "07/03/14 2:36 PM",
      "commitNameOld": "1c4047b0e46e95a92509de2e59a93433f5968538",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 38.92,
      "commitsBetweenForRepo": 286,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,20 @@\n   protected List\u003cContainerStatus\u003e getContainerStatuses() {\n     List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n     for (Container container : this.context.getContainers().values()) {\n       org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n           container.cloneAndGetContainerStatus();\n       containerStatuses.add(containerStatus);\n       if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n         // Adding to finished containers cache. Cache will keep it around at\n         // least for #durationToTrackStoppedContainers duration. In the\n         // subsequent call to stop container it will get removed from cache.\n         updateStoppedContainersInCache(container.getContainerId());\n         addCompletedContainer(container);\n       }\n     }\n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Sending out container statuses: \" + containerStatuses);\n+      LOG.debug(\"Sending out \" + containerStatuses.size()\n+          + \" container statuses: \" + containerStatuses);\n     }\n     return containerStatuses;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cContainerStatus\u003e getContainerStatuses() {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Container container : this.context.getContainers().values()) {\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n          container.cloneAndGetContainerStatus();\n      containerStatuses.add(containerStatus);\n      if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n        // Adding to finished containers cache. Cache will keep it around at\n        // least for #durationToTrackStoppedContainers duration. In the\n        // subsequent call to stop container it will get removed from cache.\n        updateStoppedContainersInCache(container.getContainerId());\n        addCompletedContainer(container);\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Sending out \" + containerStatuses.size()\n          + \" container statuses: \" + containerStatuses);\n    }\n    return containerStatuses;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
      "extendedDetails": {}
    },
    "1c4047b0e46e95a92509de2e59a93433f5968538": {
      "type": "Ymultichange(Yrename,Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-1783. Fixed a bug in NodeManager\u0027s status-updater that was losing completed container statuses when NodeManager is forced to resync by the ResourceManager. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575437 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/03/14 2:36 PM",
      "commitName": "1c4047b0e46e95a92509de2e59a93433f5968538",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-1783. Fixed a bug in NodeManager\u0027s status-updater that was losing completed container statuses when NodeManager is forced to resync by the ResourceManager. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575437 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/03/14 2:36 PM",
          "commitName": "1c4047b0e46e95a92509de2e59a93433f5968538",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "18/11/13 9:17 PM",
          "commitNameOld": "cfa783141fa69c2cf154d1d9e5393353d14ce5e1",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 108.72,
          "commitsBetweenForRepo": 763,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,19 @@\n-  private List\u003cContainerStatus\u003e updateAndGetContainerStatuses() {\n+  protected List\u003cContainerStatus\u003e getContainerStatuses() {\n     List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n-    for (Iterator\u003cEntry\u003cContainerId, Container\u003e\u003e i \u003d\n-        this.context.getContainers().entrySet().iterator(); i.hasNext();) {\n-      Entry\u003cContainerId, Container\u003e e \u003d i.next();\n-      ContainerId containerId \u003d e.getKey();\n-      Container container \u003d e.getValue();\n-\n-      // Clone the container to send it to the RM\n-      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d \n+    for (Container container : this.context.getContainers().values()) {\n+      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n           container.cloneAndGetContainerStatus();\n       containerStatuses.add(containerStatus);\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Sending out status for container: \" + containerStatus);\n-      }\n-\n-      if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n-        // Remove\n-        i.remove();\n+      if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n         // Adding to finished containers cache. Cache will keep it around at\n         // least for #durationToTrackStoppedContainers duration. In the\n         // subsequent call to stop container it will get removed from cache.\n-        addStoppedContainersToCache(containerId);\n-        \n-        LOG.info(\"Removed completed container \" + containerId);\n+        updateStoppedContainersInCache(container.getContainerId());\n+        addCompletedContainer(container);\n       }\n     }\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Sending out container statuses: \" + containerStatuses);\n+    }\n     return containerStatuses;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected List\u003cContainerStatus\u003e getContainerStatuses() {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Container container : this.context.getContainers().values()) {\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n          container.cloneAndGetContainerStatus();\n      containerStatuses.add(containerStatus);\n      if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n        // Adding to finished containers cache. Cache will keep it around at\n        // least for #durationToTrackStoppedContainers duration. In the\n        // subsequent call to stop container it will get removed from cache.\n        updateStoppedContainersInCache(container.getContainerId());\n        addCompletedContainer(container);\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Sending out container statuses: \" + containerStatuses);\n    }\n    return containerStatuses;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
          "extendedDetails": {
            "oldValue": "updateAndGetContainerStatuses",
            "newValue": "getContainerStatuses"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-1783. Fixed a bug in NodeManager\u0027s status-updater that was losing completed container statuses when NodeManager is forced to resync by the ResourceManager. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575437 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/03/14 2:36 PM",
          "commitName": "1c4047b0e46e95a92509de2e59a93433f5968538",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "18/11/13 9:17 PM",
          "commitNameOld": "cfa783141fa69c2cf154d1d9e5393353d14ce5e1",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 108.72,
          "commitsBetweenForRepo": 763,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,19 @@\n-  private List\u003cContainerStatus\u003e updateAndGetContainerStatuses() {\n+  protected List\u003cContainerStatus\u003e getContainerStatuses() {\n     List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n-    for (Iterator\u003cEntry\u003cContainerId, Container\u003e\u003e i \u003d\n-        this.context.getContainers().entrySet().iterator(); i.hasNext();) {\n-      Entry\u003cContainerId, Container\u003e e \u003d i.next();\n-      ContainerId containerId \u003d e.getKey();\n-      Container container \u003d e.getValue();\n-\n-      // Clone the container to send it to the RM\n-      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d \n+    for (Container container : this.context.getContainers().values()) {\n+      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n           container.cloneAndGetContainerStatus();\n       containerStatuses.add(containerStatus);\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Sending out status for container: \" + containerStatus);\n-      }\n-\n-      if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n-        // Remove\n-        i.remove();\n+      if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n         // Adding to finished containers cache. Cache will keep it around at\n         // least for #durationToTrackStoppedContainers duration. In the\n         // subsequent call to stop container it will get removed from cache.\n-        addStoppedContainersToCache(containerId);\n-        \n-        LOG.info(\"Removed completed container \" + containerId);\n+        updateStoppedContainersInCache(container.getContainerId());\n+        addCompletedContainer(container);\n       }\n     }\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Sending out container statuses: \" + containerStatuses);\n+    }\n     return containerStatuses;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected List\u003cContainerStatus\u003e getContainerStatuses() {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Container container : this.context.getContainers().values()) {\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n          container.cloneAndGetContainerStatus();\n      containerStatuses.add(containerStatus);\n      if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n        // Adding to finished containers cache. Cache will keep it around at\n        // least for #durationToTrackStoppedContainers duration. In the\n        // subsequent call to stop container it will get removed from cache.\n        updateStoppedContainersInCache(container.getContainerId());\n        addCompletedContainer(container);\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Sending out container statuses: \" + containerStatuses);\n    }\n    return containerStatuses;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1783. Fixed a bug in NodeManager\u0027s status-updater that was losing completed container statuses when NodeManager is forced to resync by the ResourceManager. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575437 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/03/14 2:36 PM",
          "commitName": "1c4047b0e46e95a92509de2e59a93433f5968538",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "18/11/13 9:17 PM",
          "commitNameOld": "cfa783141fa69c2cf154d1d9e5393353d14ce5e1",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 108.72,
          "commitsBetweenForRepo": 763,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,19 @@\n-  private List\u003cContainerStatus\u003e updateAndGetContainerStatuses() {\n+  protected List\u003cContainerStatus\u003e getContainerStatuses() {\n     List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n-    for (Iterator\u003cEntry\u003cContainerId, Container\u003e\u003e i \u003d\n-        this.context.getContainers().entrySet().iterator(); i.hasNext();) {\n-      Entry\u003cContainerId, Container\u003e e \u003d i.next();\n-      ContainerId containerId \u003d e.getKey();\n-      Container container \u003d e.getValue();\n-\n-      // Clone the container to send it to the RM\n-      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d \n+    for (Container container : this.context.getContainers().values()) {\n+      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n           container.cloneAndGetContainerStatus();\n       containerStatuses.add(containerStatus);\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Sending out status for container: \" + containerStatus);\n-      }\n-\n-      if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n-        // Remove\n-        i.remove();\n+      if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n         // Adding to finished containers cache. Cache will keep it around at\n         // least for #durationToTrackStoppedContainers duration. In the\n         // subsequent call to stop container it will get removed from cache.\n-        addStoppedContainersToCache(containerId);\n-        \n-        LOG.info(\"Removed completed container \" + containerId);\n+        updateStoppedContainersInCache(container.getContainerId());\n+        addCompletedContainer(container);\n       }\n     }\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Sending out container statuses: \" + containerStatuses);\n+    }\n     return containerStatuses;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected List\u003cContainerStatus\u003e getContainerStatuses() {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Container container : this.context.getContainers().values()) {\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d\n          container.cloneAndGetContainerStatus();\n      containerStatuses.add(containerStatus);\n      if (containerStatus.getState().equals(ContainerState.COMPLETE)) {\n        // Adding to finished containers cache. Cache will keep it around at\n        // least for #durationToTrackStoppedContainers duration. In the\n        // subsequent call to stop container it will get removed from cache.\n        updateStoppedContainersInCache(container.getContainerId());\n        addCompletedContainer(container);\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Sending out container statuses: \" + containerStatuses);\n    }\n    return containerStatuses;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "cfa783141fa69c2cf154d1d9e5393353d14ce5e1": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1210. Changed RM to start new app-attempts on RM restart only after ensuring that previous AM exited or after expiry time. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543310 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/13 9:17 PM",
      "commitName": "cfa783141fa69c2cf154d1d9e5393353d14ce5e1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,29 @@\n+  private List\u003cContainerStatus\u003e updateAndGetContainerStatuses() {\n+    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n+    for (Iterator\u003cEntry\u003cContainerId, Container\u003e\u003e i \u003d\n+        this.context.getContainers().entrySet().iterator(); i.hasNext();) {\n+      Entry\u003cContainerId, Container\u003e e \u003d i.next();\n+      ContainerId containerId \u003d e.getKey();\n+      Container container \u003d e.getValue();\n+\n+      // Clone the container to send it to the RM\n+      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d \n+          container.cloneAndGetContainerStatus();\n+      containerStatuses.add(containerStatus);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Sending out status for container: \" + containerStatus);\n+      }\n+\n+      if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n+        // Remove\n+        i.remove();\n+        // Adding to finished containers cache. Cache will keep it around at\n+        // least for #durationToTrackStoppedContainers duration. In the\n+        // subsequent call to stop container it will get removed from cache.\n+        addStoppedContainersToCache(containerId);\n+        \n+        LOG.info(\"Removed completed container \" + containerId);\n+      }\n+    }\n+    return containerStatuses;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cContainerStatus\u003e updateAndGetContainerStatuses() {\n    List\u003cContainerStatus\u003e containerStatuses \u003d new ArrayList\u003cContainerStatus\u003e();\n    for (Iterator\u003cEntry\u003cContainerId, Container\u003e\u003e i \u003d\n        this.context.getContainers().entrySet().iterator(); i.hasNext();) {\n      Entry\u003cContainerId, Container\u003e e \u003d i.next();\n      ContainerId containerId \u003d e.getKey();\n      Container container \u003d e.getValue();\n\n      // Clone the container to send it to the RM\n      org.apache.hadoop.yarn.api.records.ContainerStatus containerStatus \u003d \n          container.cloneAndGetContainerStatus();\n      containerStatuses.add(containerStatus);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Sending out status for container: \" + containerStatus);\n      }\n\n      if (containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n        // Remove\n        i.remove();\n        // Adding to finished containers cache. Cache will keep it around at\n        // least for #durationToTrackStoppedContainers duration. In the\n        // subsequent call to stop container it will get removed from cache.\n        addStoppedContainersToCache(containerId);\n        \n        LOG.info(\"Removed completed container \" + containerId);\n      }\n    }\n    return containerStatuses;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeStatusUpdaterImpl.java"
    }
  }
}