{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "IntraQueueCandidatesSelector.java",
  "functionName": "selectCandidates",
  "functionId": "selectCandidates___selectedCandidates-Map__ApplicationAttemptId,Set__RMContainer______clusterResource-Resource__totalPreemptedResourceAllowed-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
  "functionStartLine": 122,
  "functionEndLine": 195,
  "numCommitsSeen": 13,
  "timeTaken": 4226,
  "changeHistory": [
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
    "949721508467968d5f46170353716ad04349cd6f",
    "bddfe42e2ccda2e6cc9d149461640ba36eca5922",
    "c5e6e3de1c31eda052f89eddd7bba288625936b9",
    "c583ab02c730be0a63d974039a78f2dc67dc2db6",
    "d7762a55113a529abd6f4ecb8e6d9b0a84b56e08",
    "fad9609d13e76e9e3a4e01c96f698bb60b03807e",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9"
  ],
  "changeHistoryShort": {
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": "Ybodychange",
    "949721508467968d5f46170353716ad04349cd6f": "Ybodychange",
    "bddfe42e2ccda2e6cc9d149461640ba36eca5922": "Ybodychange",
    "c5e6e3de1c31eda052f89eddd7bba288625936b9": "Ybodychange",
    "c583ab02c730be0a63d974039a78f2dc67dc2db6": "Ybodychange",
    "d7762a55113a529abd6f4ecb8e6d9b0a84b56e08": "Ybodychange",
    "fad9609d13e76e9e3a4e01c96f698bb60b03807e": "Ybodychange",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n     Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n     // 1. Calculate the abnormality within each queue one by one.\n     computeIntraQueuePreemptionDemand(\n         clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n \n     // 2. Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct pre-emptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     // 3. Loop through all partitions to select containers for preemption.\n     for (String partition : preemptionContext.getAllPartitions()) {\n       LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n           .getUnderServedQueuesPerPartition(partition);\n \n       // Error check to handle non-mapped labels to queue.\n       if (null \u003d\u003d queueNames) {\n         continue;\n       }\n \n       // 4. Iterate from most under-served queue in order.\n       for (String queueName : queueNames) {\n         LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n             RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n         // skip if not a leafqueue\n         if (null \u003d\u003d leafQueue) {\n           continue;\n         }\n \n         // Don\u0027t preempt if intra-queue preemption is disabled for this queue.\n         if (leafQueue.getIntraQueuePreemptionDisabled()) {\n           continue;\n         }\n \n         // 5. Calculate the resource to obtain per partition\n         Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n             .getResourceDemandFromAppsPerQueue(queueName, partition);\n \n         // Default preemption iterator considers only FIFO+priority. For\n         // userlimit preemption, its possible that some lower priority apps\n         // needs from high priority app of another user. Hence use apps\n         // ordered by userlimit starvation as well.\n         Collection\u003cFiCaSchedulerApp\u003e apps \u003d fifoPreemptionComputePlugin\n             .getPreemptableApps(queueName, partition);\n \n         // 6. Get user-limit to ensure that we do not preempt resources which\n         // will force user\u0027s resource to come under its UL.\n         Map\u003cString, Resource\u003e rollingResourceUsagePerUser \u003d new HashMap\u003c\u003e();\n         initializeUsageAndUserLimitForCompute(clusterResource, partition,\n             leafQueue, rollingResourceUsagePerUser);\n \n         // 7. Based on the selected resource demand per partition, select\n         // containers with known policy from inter-queue preemption.\n+        leafQueue.getReadLock().lock();\n         try {\n-          leafQueue.getReadLock().lock();\n           for (FiCaSchedulerApp app : apps) {\n             preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,\n                 curCandidates, clusterResource, totalPreemptedResourceAllowed,\n                 resToObtainByPartition, rollingResourceUsagePerUser);\n           }\n         } finally {\n           leafQueue.getReadLock().unlock();\n         }\n       }\n     }\n \n     return curCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n    // 1. Calculate the abnormality within each queue one by one.\n    computeIntraQueuePreemptionDemand(\n        clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n\n    // 2. Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct pre-emptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    // 3. Loop through all partitions to select containers for preemption.\n    for (String partition : preemptionContext.getAllPartitions()) {\n      LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n          .getUnderServedQueuesPerPartition(partition);\n\n      // Error check to handle non-mapped labels to queue.\n      if (null \u003d\u003d queueNames) {\n        continue;\n      }\n\n      // 4. Iterate from most under-served queue in order.\n      for (String queueName : queueNames) {\n        LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n            RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n        // skip if not a leafqueue\n        if (null \u003d\u003d leafQueue) {\n          continue;\n        }\n\n        // Don\u0027t preempt if intra-queue preemption is disabled for this queue.\n        if (leafQueue.getIntraQueuePreemptionDisabled()) {\n          continue;\n        }\n\n        // 5. Calculate the resource to obtain per partition\n        Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n            .getResourceDemandFromAppsPerQueue(queueName, partition);\n\n        // Default preemption iterator considers only FIFO+priority. For\n        // userlimit preemption, its possible that some lower priority apps\n        // needs from high priority app of another user. Hence use apps\n        // ordered by userlimit starvation as well.\n        Collection\u003cFiCaSchedulerApp\u003e apps \u003d fifoPreemptionComputePlugin\n            .getPreemptableApps(queueName, partition);\n\n        // 6. Get user-limit to ensure that we do not preempt resources which\n        // will force user\u0027s resource to come under its UL.\n        Map\u003cString, Resource\u003e rollingResourceUsagePerUser \u003d new HashMap\u003c\u003e();\n        initializeUsageAndUserLimitForCompute(clusterResource, partition,\n            leafQueue, rollingResourceUsagePerUser);\n\n        // 7. Based on the selected resource demand per partition, select\n        // containers with known policy from inter-queue preemption.\n        leafQueue.getReadLock().lock();\n        try {\n          for (FiCaSchedulerApp app : apps) {\n            preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,\n                curCandidates, clusterResource, totalPreemptedResourceAllowed,\n                resToObtainByPartition, rollingResourceUsagePerUser);\n          }\n        } finally {\n          leafQueue.getReadLock().unlock();\n        }\n      }\n    }\n\n    return curCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
      "extendedDetails": {}
    },
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
      "commitDate": "28/06/18 10:23 AM",
      "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
      "commitAuthor": "Sunil G",
      "commitDateOld": "28/05/18 4:02 AM",
      "commitNameOld": "7c343669baf660df3b70d58987d6e68aec54d6fa",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 31.26,
      "commitsBetweenForRepo": 215,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n-\n+    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n     // 1. Calculate the abnormality within each queue one by one.\n     computeIntraQueuePreemptionDemand(\n         clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n \n     // 2. Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct pre-emptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     // 3. Loop through all partitions to select containers for preemption.\n     for (String partition : preemptionContext.getAllPartitions()) {\n       LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n           .getUnderServedQueuesPerPartition(partition);\n \n       // Error check to handle non-mapped labels to queue.\n       if (null \u003d\u003d queueNames) {\n         continue;\n       }\n \n       // 4. Iterate from most under-served queue in order.\n       for (String queueName : queueNames) {\n         LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n             RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n         // skip if not a leafqueue\n         if (null \u003d\u003d leafQueue) {\n           continue;\n         }\n \n         // Don\u0027t preempt if intra-queue preemption is disabled for this queue.\n         if (leafQueue.getIntraQueuePreemptionDisabled()) {\n           continue;\n         }\n \n         // 5. Calculate the resource to obtain per partition\n         Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n             .getResourceDemandFromAppsPerQueue(queueName, partition);\n \n         // Default preemption iterator considers only FIFO+priority. For\n         // userlimit preemption, its possible that some lower priority apps\n         // needs from high priority app of another user. Hence use apps\n         // ordered by userlimit starvation as well.\n         Collection\u003cFiCaSchedulerApp\u003e apps \u003d fifoPreemptionComputePlugin\n             .getPreemptableApps(queueName, partition);\n \n         // 6. Get user-limit to ensure that we do not preempt resources which\n         // will force user\u0027s resource to come under its UL.\n         Map\u003cString, Resource\u003e rollingResourceUsagePerUser \u003d new HashMap\u003c\u003e();\n         initializeUsageAndUserLimitForCompute(clusterResource, partition,\n             leafQueue, rollingResourceUsagePerUser);\n \n         // 7. Based on the selected resource demand per partition, select\n         // containers with known policy from inter-queue preemption.\n         try {\n           leafQueue.getReadLock().lock();\n           for (FiCaSchedulerApp app : apps) {\n             preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,\n-                clusterResource, totalPreemptedResourceAllowed,\n+                curCandidates, clusterResource, totalPreemptedResourceAllowed,\n                 resToObtainByPartition, rollingResourceUsagePerUser);\n           }\n         } finally {\n           leafQueue.getReadLock().unlock();\n         }\n       }\n     }\n \n-    return selectedCandidates;\n+    return curCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n    // 1. Calculate the abnormality within each queue one by one.\n    computeIntraQueuePreemptionDemand(\n        clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n\n    // 2. Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct pre-emptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    // 3. Loop through all partitions to select containers for preemption.\n    for (String partition : preemptionContext.getAllPartitions()) {\n      LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n          .getUnderServedQueuesPerPartition(partition);\n\n      // Error check to handle non-mapped labels to queue.\n      if (null \u003d\u003d queueNames) {\n        continue;\n      }\n\n      // 4. Iterate from most under-served queue in order.\n      for (String queueName : queueNames) {\n        LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n            RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n        // skip if not a leafqueue\n        if (null \u003d\u003d leafQueue) {\n          continue;\n        }\n\n        // Don\u0027t preempt if intra-queue preemption is disabled for this queue.\n        if (leafQueue.getIntraQueuePreemptionDisabled()) {\n          continue;\n        }\n\n        // 5. Calculate the resource to obtain per partition\n        Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n            .getResourceDemandFromAppsPerQueue(queueName, partition);\n\n        // Default preemption iterator considers only FIFO+priority. For\n        // userlimit preemption, its possible that some lower priority apps\n        // needs from high priority app of another user. Hence use apps\n        // ordered by userlimit starvation as well.\n        Collection\u003cFiCaSchedulerApp\u003e apps \u003d fifoPreemptionComputePlugin\n            .getPreemptableApps(queueName, partition);\n\n        // 6. Get user-limit to ensure that we do not preempt resources which\n        // will force user\u0027s resource to come under its UL.\n        Map\u003cString, Resource\u003e rollingResourceUsagePerUser \u003d new HashMap\u003c\u003e();\n        initializeUsageAndUserLimitForCompute(clusterResource, partition,\n            leafQueue, rollingResourceUsagePerUser);\n\n        // 7. Based on the selected resource demand per partition, select\n        // containers with known policy from inter-queue preemption.\n        try {\n          leafQueue.getReadLock().lock();\n          for (FiCaSchedulerApp app : apps) {\n            preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,\n                curCandidates, clusterResource, totalPreemptedResourceAllowed,\n                resToObtainByPartition, rollingResourceUsagePerUser);\n          }\n        } finally {\n          leafQueue.getReadLock().unlock();\n        }\n      }\n    }\n\n    return curCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
      "extendedDetails": {}
    },
    "949721508467968d5f46170353716ad04349cd6f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7813. Capacity Scheduler Intra-queue Preemption should be configurable for each queue. Contributed by Eric Payne\n",
      "commitDate": "19/02/18 12:06 PM",
      "commitName": "949721508467968d5f46170353716ad04349cd6f",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "14/02/18 12:29 PM",
      "commitNameOld": "bddfe42e2ccda2e6cc9d149461640ba36eca5922",
      "commitAuthorOld": "Eric Payne",
      "daysBetweenCommits": 4.98,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n \n     // 1. Calculate the abnormality within each queue one by one.\n     computeIntraQueuePreemptionDemand(\n         clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n \n     // 2. Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct pre-emptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     // 3. Loop through all partitions to select containers for preemption.\n     for (String partition : preemptionContext.getAllPartitions()) {\n       LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n           .getUnderServedQueuesPerPartition(partition);\n \n       // Error check to handle non-mapped labels to queue.\n       if (null \u003d\u003d queueNames) {\n         continue;\n       }\n \n       // 4. Iterate from most under-served queue in order.\n       for (String queueName : queueNames) {\n         LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n             RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n         // skip if not a leafqueue\n         if (null \u003d\u003d leafQueue) {\n           continue;\n         }\n \n-        // Don\u0027t preempt if disabled for this queue.\n-        if (leafQueue.getPreemptionDisabled()) {\n+        // Don\u0027t preempt if intra-queue preemption is disabled for this queue.\n+        if (leafQueue.getIntraQueuePreemptionDisabled()) {\n           continue;\n         }\n \n         // 5. Calculate the resource to obtain per partition\n         Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n             .getResourceDemandFromAppsPerQueue(queueName, partition);\n \n         // Default preemption iterator considers only FIFO+priority. For\n         // userlimit preemption, its possible that some lower priority apps\n         // needs from high priority app of another user. Hence use apps\n         // ordered by userlimit starvation as well.\n         Collection\u003cFiCaSchedulerApp\u003e apps \u003d fifoPreemptionComputePlugin\n             .getPreemptableApps(queueName, partition);\n \n         // 6. Get user-limit to ensure that we do not preempt resources which\n         // will force user\u0027s resource to come under its UL.\n         Map\u003cString, Resource\u003e rollingResourceUsagePerUser \u003d new HashMap\u003c\u003e();\n         initializeUsageAndUserLimitForCompute(clusterResource, partition,\n             leafQueue, rollingResourceUsagePerUser);\n \n         // 7. Based on the selected resource demand per partition, select\n         // containers with known policy from inter-queue preemption.\n         try {\n           leafQueue.getReadLock().lock();\n           for (FiCaSchedulerApp app : apps) {\n             preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,\n                 clusterResource, totalPreemptedResourceAllowed,\n                 resToObtainByPartition, rollingResourceUsagePerUser);\n           }\n         } finally {\n           leafQueue.getReadLock().unlock();\n         }\n       }\n     }\n \n     return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n\n    // 1. Calculate the abnormality within each queue one by one.\n    computeIntraQueuePreemptionDemand(\n        clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n\n    // 2. Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct pre-emptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    // 3. Loop through all partitions to select containers for preemption.\n    for (String partition : preemptionContext.getAllPartitions()) {\n      LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n          .getUnderServedQueuesPerPartition(partition);\n\n      // Error check to handle non-mapped labels to queue.\n      if (null \u003d\u003d queueNames) {\n        continue;\n      }\n\n      // 4. Iterate from most under-served queue in order.\n      for (String queueName : queueNames) {\n        LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n            RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n        // skip if not a leafqueue\n        if (null \u003d\u003d leafQueue) {\n          continue;\n        }\n\n        // Don\u0027t preempt if intra-queue preemption is disabled for this queue.\n        if (leafQueue.getIntraQueuePreemptionDisabled()) {\n          continue;\n        }\n\n        // 5. Calculate the resource to obtain per partition\n        Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n            .getResourceDemandFromAppsPerQueue(queueName, partition);\n\n        // Default preemption iterator considers only FIFO+priority. For\n        // userlimit preemption, its possible that some lower priority apps\n        // needs from high priority app of another user. Hence use apps\n        // ordered by userlimit starvation as well.\n        Collection\u003cFiCaSchedulerApp\u003e apps \u003d fifoPreemptionComputePlugin\n            .getPreemptableApps(queueName, partition);\n\n        // 6. Get user-limit to ensure that we do not preempt resources which\n        // will force user\u0027s resource to come under its UL.\n        Map\u003cString, Resource\u003e rollingResourceUsagePerUser \u003d new HashMap\u003c\u003e();\n        initializeUsageAndUserLimitForCompute(clusterResource, partition,\n            leafQueue, rollingResourceUsagePerUser);\n\n        // 7. Based on the selected resource demand per partition, select\n        // containers with known policy from inter-queue preemption.\n        try {\n          leafQueue.getReadLock().lock();\n          for (FiCaSchedulerApp app : apps) {\n            preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,\n                clusterResource, totalPreemptedResourceAllowed,\n                resToObtainByPartition, rollingResourceUsagePerUser);\n          }\n        } finally {\n          leafQueue.getReadLock().unlock();\n        }\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
      "extendedDetails": {}
    },
    "bddfe42e2ccda2e6cc9d149461640ba36eca5922": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-7813: Capacity Scheduler Intra-queue Preemption should be configurable for each queue\"\n\nThis reverts commit c5e6e3de1c31eda052f89eddd7bba288625936b9.\n",
      "commitDate": "14/02/18 12:29 PM",
      "commitName": "bddfe42e2ccda2e6cc9d149461640ba36eca5922",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "13/02/18 8:11 AM",
      "commitNameOld": "c5e6e3de1c31eda052f89eddd7bba288625936b9",
      "commitAuthorOld": "Eric Payne",
      "daysBetweenCommits": 1.18,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n \n     // 1. Calculate the abnormality within each queue one by one.\n     computeIntraQueuePreemptionDemand(\n         clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n \n     // 2. Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct pre-emptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     // 3. Loop through all partitions to select containers for preemption.\n     for (String partition : preemptionContext.getAllPartitions()) {\n       LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n           .getUnderServedQueuesPerPartition(partition);\n \n       // Error check to handle non-mapped labels to queue.\n       if (null \u003d\u003d queueNames) {\n         continue;\n       }\n \n       // 4. Iterate from most under-served queue in order.\n       for (String queueName : queueNames) {\n         LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n             RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n         // skip if not a leafqueue\n         if (null \u003d\u003d leafQueue) {\n           continue;\n         }\n \n-        // Don\u0027t preempt if intra-queue preemption is disabled for this queue.\n-        if (leafQueue.getIntraQueuePreemptionDisabled()) {\n+        // Don\u0027t preempt if disabled for this queue.\n+        if (leafQueue.getPreemptionDisabled()) {\n           continue;\n         }\n \n         // 5. Calculate the resource to obtain per partition\n         Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n             .getResourceDemandFromAppsPerQueue(queueName, partition);\n \n         // Default preemption iterator considers only FIFO+priority. For\n         // userlimit preemption, its possible that some lower priority apps\n         // needs from high priority app of another user. Hence use apps\n         // ordered by userlimit starvation as well.\n         Collection\u003cFiCaSchedulerApp\u003e apps \u003d fifoPreemptionComputePlugin\n             .getPreemptableApps(queueName, partition);\n \n         // 6. Get user-limit to ensure that we do not preempt resources which\n         // will force user\u0027s resource to come under its UL.\n         Map\u003cString, Resource\u003e rollingResourceUsagePerUser \u003d new HashMap\u003c\u003e();\n         initializeUsageAndUserLimitForCompute(clusterResource, partition,\n             leafQueue, rollingResourceUsagePerUser);\n \n         // 7. Based on the selected resource demand per partition, select\n         // containers with known policy from inter-queue preemption.\n         try {\n           leafQueue.getReadLock().lock();\n           for (FiCaSchedulerApp app : apps) {\n             preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,\n                 clusterResource, totalPreemptedResourceAllowed,\n                 resToObtainByPartition, rollingResourceUsagePerUser);\n           }\n         } finally {\n           leafQueue.getReadLock().unlock();\n         }\n       }\n     }\n \n     return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n\n    // 1. Calculate the abnormality within each queue one by one.\n    computeIntraQueuePreemptionDemand(\n        clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n\n    // 2. Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct pre-emptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    // 3. Loop through all partitions to select containers for preemption.\n    for (String partition : preemptionContext.getAllPartitions()) {\n      LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n          .getUnderServedQueuesPerPartition(partition);\n\n      // Error check to handle non-mapped labels to queue.\n      if (null \u003d\u003d queueNames) {\n        continue;\n      }\n\n      // 4. Iterate from most under-served queue in order.\n      for (String queueName : queueNames) {\n        LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n            RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n        // skip if not a leafqueue\n        if (null \u003d\u003d leafQueue) {\n          continue;\n        }\n\n        // Don\u0027t preempt if disabled for this queue.\n        if (leafQueue.getPreemptionDisabled()) {\n          continue;\n        }\n\n        // 5. Calculate the resource to obtain per partition\n        Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n            .getResourceDemandFromAppsPerQueue(queueName, partition);\n\n        // Default preemption iterator considers only FIFO+priority. For\n        // userlimit preemption, its possible that some lower priority apps\n        // needs from high priority app of another user. Hence use apps\n        // ordered by userlimit starvation as well.\n        Collection\u003cFiCaSchedulerApp\u003e apps \u003d fifoPreemptionComputePlugin\n            .getPreemptableApps(queueName, partition);\n\n        // 6. Get user-limit to ensure that we do not preempt resources which\n        // will force user\u0027s resource to come under its UL.\n        Map\u003cString, Resource\u003e rollingResourceUsagePerUser \u003d new HashMap\u003c\u003e();\n        initializeUsageAndUserLimitForCompute(clusterResource, partition,\n            leafQueue, rollingResourceUsagePerUser);\n\n        // 7. Based on the selected resource demand per partition, select\n        // containers with known policy from inter-queue preemption.\n        try {\n          leafQueue.getReadLock().lock();\n          for (FiCaSchedulerApp app : apps) {\n            preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,\n                clusterResource, totalPreemptedResourceAllowed,\n                resToObtainByPartition, rollingResourceUsagePerUser);\n          }\n        } finally {\n          leafQueue.getReadLock().unlock();\n        }\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
      "extendedDetails": {}
    },
    "c5e6e3de1c31eda052f89eddd7bba288625936b9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7813: Capacity Scheduler Intra-queue Preemption should be configurable for each queue\n",
      "commitDate": "13/02/18 8:11 AM",
      "commitName": "c5e6e3de1c31eda052f89eddd7bba288625936b9",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "22/05/17 2:26 PM",
      "commitNameOld": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 266.78,
      "commitsBetweenForRepo": 1843,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n \n     // 1. Calculate the abnormality within each queue one by one.\n     computeIntraQueuePreemptionDemand(\n         clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n \n     // 2. Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct pre-emptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     // 3. Loop through all partitions to select containers for preemption.\n     for (String partition : preemptionContext.getAllPartitions()) {\n       LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n           .getUnderServedQueuesPerPartition(partition);\n \n       // Error check to handle non-mapped labels to queue.\n       if (null \u003d\u003d queueNames) {\n         continue;\n       }\n \n       // 4. Iterate from most under-served queue in order.\n       for (String queueName : queueNames) {\n         LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n             RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n         // skip if not a leafqueue\n         if (null \u003d\u003d leafQueue) {\n           continue;\n         }\n \n-        // Don\u0027t preempt if disabled for this queue.\n-        if (leafQueue.getPreemptionDisabled()) {\n+        // Don\u0027t preempt if intra-queue preemption is disabled for this queue.\n+        if (leafQueue.getIntraQueuePreemptionDisabled()) {\n           continue;\n         }\n \n         // 5. Calculate the resource to obtain per partition\n         Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n             .getResourceDemandFromAppsPerQueue(queueName, partition);\n \n         // Default preemption iterator considers only FIFO+priority. For\n         // userlimit preemption, its possible that some lower priority apps\n         // needs from high priority app of another user. Hence use apps\n         // ordered by userlimit starvation as well.\n         Collection\u003cFiCaSchedulerApp\u003e apps \u003d fifoPreemptionComputePlugin\n             .getPreemptableApps(queueName, partition);\n \n         // 6. Get user-limit to ensure that we do not preempt resources which\n         // will force user\u0027s resource to come under its UL.\n         Map\u003cString, Resource\u003e rollingResourceUsagePerUser \u003d new HashMap\u003c\u003e();\n         initializeUsageAndUserLimitForCompute(clusterResource, partition,\n             leafQueue, rollingResourceUsagePerUser);\n \n         // 7. Based on the selected resource demand per partition, select\n         // containers with known policy from inter-queue preemption.\n         try {\n           leafQueue.getReadLock().lock();\n           for (FiCaSchedulerApp app : apps) {\n             preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,\n                 clusterResource, totalPreemptedResourceAllowed,\n                 resToObtainByPartition, rollingResourceUsagePerUser);\n           }\n         } finally {\n           leafQueue.getReadLock().unlock();\n         }\n       }\n     }\n \n     return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n\n    // 1. Calculate the abnormality within each queue one by one.\n    computeIntraQueuePreemptionDemand(\n        clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n\n    // 2. Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct pre-emptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    // 3. Loop through all partitions to select containers for preemption.\n    for (String partition : preemptionContext.getAllPartitions()) {\n      LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n          .getUnderServedQueuesPerPartition(partition);\n\n      // Error check to handle non-mapped labels to queue.\n      if (null \u003d\u003d queueNames) {\n        continue;\n      }\n\n      // 4. Iterate from most under-served queue in order.\n      for (String queueName : queueNames) {\n        LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n            RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n        // skip if not a leafqueue\n        if (null \u003d\u003d leafQueue) {\n          continue;\n        }\n\n        // Don\u0027t preempt if intra-queue preemption is disabled for this queue.\n        if (leafQueue.getIntraQueuePreemptionDisabled()) {\n          continue;\n        }\n\n        // 5. Calculate the resource to obtain per partition\n        Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n            .getResourceDemandFromAppsPerQueue(queueName, partition);\n\n        // Default preemption iterator considers only FIFO+priority. For\n        // userlimit preemption, its possible that some lower priority apps\n        // needs from high priority app of another user. Hence use apps\n        // ordered by userlimit starvation as well.\n        Collection\u003cFiCaSchedulerApp\u003e apps \u003d fifoPreemptionComputePlugin\n            .getPreemptableApps(queueName, partition);\n\n        // 6. Get user-limit to ensure that we do not preempt resources which\n        // will force user\u0027s resource to come under its UL.\n        Map\u003cString, Resource\u003e rollingResourceUsagePerUser \u003d new HashMap\u003c\u003e();\n        initializeUsageAndUserLimitForCompute(clusterResource, partition,\n            leafQueue, rollingResourceUsagePerUser);\n\n        // 7. Based on the selected resource demand per partition, select\n        // containers with known policy from inter-queue preemption.\n        try {\n          leafQueue.getReadLock().lock();\n          for (FiCaSchedulerApp app : apps) {\n            preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,\n                clusterResource, totalPreemptedResourceAllowed,\n                resToObtainByPartition, rollingResourceUsagePerUser);\n          }\n        } finally {\n          leafQueue.getReadLock().unlock();\n        }\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
      "extendedDetails": {}
    },
    "c583ab02c730be0a63d974039a78f2dc67dc2db6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2113. Add cross-user preemption within CapacityScheduler\u0027s leaf-queue. (Sunil G via wangda)\n\nChange-Id: I9b19f69788068be05b3295247cdd7b972f8a573c\n",
      "commitDate": "22/05/17 2:26 PM",
      "commitName": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/03/17 2:46 PM",
      "commitNameOld": "d7762a55113a529abd6f4ecb8e6d9b0a84b56e08",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 74.94,
      "commitsBetweenForRepo": 417,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,74 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n \n     // 1. Calculate the abnormality within each queue one by one.\n     computeIntraQueuePreemptionDemand(\n         clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n \n     // 2. Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct pre-emptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     // 3. Loop through all partitions to select containers for preemption.\n     for (String partition : preemptionContext.getAllPartitions()) {\n       LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n           .getUnderServedQueuesPerPartition(partition);\n \n       // Error check to handle non-mapped labels to queue.\n       if (null \u003d\u003d queueNames) {\n         continue;\n       }\n \n       // 4. Iterate from most under-served queue in order.\n       for (String queueName : queueNames) {\n         LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n             RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n         // skip if not a leafqueue\n         if (null \u003d\u003d leafQueue) {\n           continue;\n         }\n \n         // Don\u0027t preempt if disabled for this queue.\n         if (leafQueue.getPreemptionDisabled()) {\n           continue;\n         }\n \n         // 5. Calculate the resource to obtain per partition\n         Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n             .getResourceDemandFromAppsPerQueue(queueName, partition);\n \n-        // 6. Based on the selected resource demand per partition, select\n+        // Default preemption iterator considers only FIFO+priority. For\n+        // userlimit preemption, its possible that some lower priority apps\n+        // needs from high priority app of another user. Hence use apps\n+        // ordered by userlimit starvation as well.\n+        Collection\u003cFiCaSchedulerApp\u003e apps \u003d fifoPreemptionComputePlugin\n+            .getPreemptableApps(queueName, partition);\n+\n+        // 6. Get user-limit to ensure that we do not preempt resources which\n+        // will force user\u0027s resource to come under its UL.\n+        Map\u003cString, Resource\u003e rollingResourceUsagePerUser \u003d new HashMap\u003c\u003e();\n+        initializeUsageAndUserLimitForCompute(clusterResource, partition,\n+            leafQueue, rollingResourceUsagePerUser);\n+\n+        // 7. Based on the selected resource demand per partition, select\n         // containers with known policy from inter-queue preemption.\n         try {\n           leafQueue.getReadLock().lock();\n-          Iterator\u003cFiCaSchedulerApp\u003e desc \u003d leafQueue.getOrderingPolicy()\n-              .getPreemptionIterator();\n-          while (desc.hasNext()) {\n-            FiCaSchedulerApp app \u003d desc.next();\n-            preemptFromLeastStarvedApp(selectedCandidates, clusterResource,\n-                totalPreemptedResourceAllowed, resToObtainByPartition,\n-                leafQueue, app);\n+          for (FiCaSchedulerApp app : apps) {\n+            preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,\n+                clusterResource, totalPreemptedResourceAllowed,\n+                resToObtainByPartition, rollingResourceUsagePerUser);\n           }\n         } finally {\n           leafQueue.getReadLock().unlock();\n         }\n       }\n     }\n \n     return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n\n    // 1. Calculate the abnormality within each queue one by one.\n    computeIntraQueuePreemptionDemand(\n        clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n\n    // 2. Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct pre-emptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    // 3. Loop through all partitions to select containers for preemption.\n    for (String partition : preemptionContext.getAllPartitions()) {\n      LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n          .getUnderServedQueuesPerPartition(partition);\n\n      // Error check to handle non-mapped labels to queue.\n      if (null \u003d\u003d queueNames) {\n        continue;\n      }\n\n      // 4. Iterate from most under-served queue in order.\n      for (String queueName : queueNames) {\n        LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n            RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n        // skip if not a leafqueue\n        if (null \u003d\u003d leafQueue) {\n          continue;\n        }\n\n        // Don\u0027t preempt if disabled for this queue.\n        if (leafQueue.getPreemptionDisabled()) {\n          continue;\n        }\n\n        // 5. Calculate the resource to obtain per partition\n        Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n            .getResourceDemandFromAppsPerQueue(queueName, partition);\n\n        // Default preemption iterator considers only FIFO+priority. For\n        // userlimit preemption, its possible that some lower priority apps\n        // needs from high priority app of another user. Hence use apps\n        // ordered by userlimit starvation as well.\n        Collection\u003cFiCaSchedulerApp\u003e apps \u003d fifoPreemptionComputePlugin\n            .getPreemptableApps(queueName, partition);\n\n        // 6. Get user-limit to ensure that we do not preempt resources which\n        // will force user\u0027s resource to come under its UL.\n        Map\u003cString, Resource\u003e rollingResourceUsagePerUser \u003d new HashMap\u003c\u003e();\n        initializeUsageAndUserLimitForCompute(clusterResource, partition,\n            leafQueue, rollingResourceUsagePerUser);\n\n        // 7. Based on the selected resource demand per partition, select\n        // containers with known policy from inter-queue preemption.\n        try {\n          leafQueue.getReadLock().lock();\n          for (FiCaSchedulerApp app : apps) {\n            preemptFromLeastStarvedApp(leafQueue, app, selectedCandidates,\n                clusterResource, totalPreemptedResourceAllowed,\n                resToObtainByPartition, rollingResourceUsagePerUser);\n          }\n        } finally {\n          leafQueue.getReadLock().unlock();\n        }\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
      "extendedDetails": {}
    },
    "d7762a55113a529abd6f4ecb8e6d9b0a84b56e08": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6165. Intra-queue preemption occurs even when preemption is turned off for a specific queue. Contributed by Eric Payne\n",
      "commitDate": "08/03/17 2:46 PM",
      "commitName": "d7762a55113a529abd6f4ecb8e6d9b0a84b56e08",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "11/11/16 3:16 PM",
      "commitNameOld": "fad9609d13e76e9e3a4e01c96f698bb60b03807e",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 116.98,
      "commitsBetweenForRepo": 611,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,64 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n \n     // 1. Calculate the abnormality within each queue one by one.\n     computeIntraQueuePreemptionDemand(\n         clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n \n     // 2. Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct pre-emptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     // 3. Loop through all partitions to select containers for preemption.\n     for (String partition : preemptionContext.getAllPartitions()) {\n       LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n           .getUnderServedQueuesPerPartition(partition);\n \n       // Error check to handle non-mapped labels to queue.\n       if (null \u003d\u003d queueNames) {\n         continue;\n       }\n \n       // 4. Iterate from most under-served queue in order.\n       for (String queueName : queueNames) {\n         LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n             RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n         // skip if not a leafqueue\n         if (null \u003d\u003d leafQueue) {\n           continue;\n         }\n \n+        // Don\u0027t preempt if disabled for this queue.\n+        if (leafQueue.getPreemptionDisabled()) {\n+          continue;\n+        }\n+\n         // 5. Calculate the resource to obtain per partition\n         Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n             .getResourceDemandFromAppsPerQueue(queueName, partition);\n \n         // 6. Based on the selected resource demand per partition, select\n         // containers with known policy from inter-queue preemption.\n         try {\n           leafQueue.getReadLock().lock();\n           Iterator\u003cFiCaSchedulerApp\u003e desc \u003d leafQueue.getOrderingPolicy()\n               .getPreemptionIterator();\n           while (desc.hasNext()) {\n             FiCaSchedulerApp app \u003d desc.next();\n             preemptFromLeastStarvedApp(selectedCandidates, clusterResource,\n                 totalPreemptedResourceAllowed, resToObtainByPartition,\n                 leafQueue, app);\n           }\n         } finally {\n           leafQueue.getReadLock().unlock();\n         }\n       }\n     }\n \n     return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n\n    // 1. Calculate the abnormality within each queue one by one.\n    computeIntraQueuePreemptionDemand(\n        clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n\n    // 2. Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct pre-emptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    // 3. Loop through all partitions to select containers for preemption.\n    for (String partition : preemptionContext.getAllPartitions()) {\n      LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n          .getUnderServedQueuesPerPartition(partition);\n\n      // Error check to handle non-mapped labels to queue.\n      if (null \u003d\u003d queueNames) {\n        continue;\n      }\n\n      // 4. Iterate from most under-served queue in order.\n      for (String queueName : queueNames) {\n        LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n            RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n        // skip if not a leafqueue\n        if (null \u003d\u003d leafQueue) {\n          continue;\n        }\n\n        // Don\u0027t preempt if disabled for this queue.\n        if (leafQueue.getPreemptionDisabled()) {\n          continue;\n        }\n\n        // 5. Calculate the resource to obtain per partition\n        Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n            .getResourceDemandFromAppsPerQueue(queueName, partition);\n\n        // 6. Based on the selected resource demand per partition, select\n        // containers with known policy from inter-queue preemption.\n        try {\n          leafQueue.getReadLock().lock();\n          Iterator\u003cFiCaSchedulerApp\u003e desc \u003d leafQueue.getOrderingPolicy()\n              .getPreemptionIterator();\n          while (desc.hasNext()) {\n            FiCaSchedulerApp app \u003d desc.next();\n            preemptFromLeastStarvedApp(selectedCandidates, clusterResource,\n                totalPreemptedResourceAllowed, resToObtainByPartition,\n                leafQueue, app);\n          }\n        } finally {\n          leafQueue.getReadLock().unlock();\n        }\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
      "extendedDetails": {}
    },
    "fad9609d13e76e9e3a4e01c96f698bb60b03807e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5825. ProportionalPreemptionalPolicy should use readLock over LeafQueue instead of synchronized block. Contributed by Sunil G\n",
      "commitDate": "11/11/16 3:16 PM",
      "commitName": "fad9609d13e76e9e3a4e01c96f698bb60b03807e",
      "commitAuthor": "Jian He",
      "commitDateOld": "31/10/16 3:18 PM",
      "commitNameOld": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 11.04,
      "commitsBetweenForRepo": 127,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,59 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n \n     // 1. Calculate the abnormality within each queue one by one.\n     computeIntraQueuePreemptionDemand(\n         clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n \n     // 2. Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct pre-emptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     // 3. Loop through all partitions to select containers for preemption.\n     for (String partition : preemptionContext.getAllPartitions()) {\n       LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n           .getUnderServedQueuesPerPartition(partition);\n \n       // Error check to handle non-mapped labels to queue.\n       if (null \u003d\u003d queueNames) {\n         continue;\n       }\n \n       // 4. Iterate from most under-served queue in order.\n       for (String queueName : queueNames) {\n         LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n             RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n         // skip if not a leafqueue\n         if (null \u003d\u003d leafQueue) {\n           continue;\n         }\n \n         // 5. Calculate the resource to obtain per partition\n         Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n             .getResourceDemandFromAppsPerQueue(queueName, partition);\n \n         // 6. Based on the selected resource demand per partition, select\n         // containers with known policy from inter-queue preemption.\n-        synchronized (leafQueue) {\n+        try {\n+          leafQueue.getReadLock().lock();\n           Iterator\u003cFiCaSchedulerApp\u003e desc \u003d leafQueue.getOrderingPolicy()\n               .getPreemptionIterator();\n           while (desc.hasNext()) {\n             FiCaSchedulerApp app \u003d desc.next();\n             preemptFromLeastStarvedApp(selectedCandidates, clusterResource,\n                 totalPreemptedResourceAllowed, resToObtainByPartition,\n                 leafQueue, app);\n           }\n+        } finally {\n+          leafQueue.getReadLock().unlock();\n         }\n       }\n     }\n \n     return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n\n    // 1. Calculate the abnormality within each queue one by one.\n    computeIntraQueuePreemptionDemand(\n        clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n\n    // 2. Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct pre-emptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    // 3. Loop through all partitions to select containers for preemption.\n    for (String partition : preemptionContext.getAllPartitions()) {\n      LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n          .getUnderServedQueuesPerPartition(partition);\n\n      // Error check to handle non-mapped labels to queue.\n      if (null \u003d\u003d queueNames) {\n        continue;\n      }\n\n      // 4. Iterate from most under-served queue in order.\n      for (String queueName : queueNames) {\n        LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n            RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n        // skip if not a leafqueue\n        if (null \u003d\u003d leafQueue) {\n          continue;\n        }\n\n        // 5. Calculate the resource to obtain per partition\n        Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n            .getResourceDemandFromAppsPerQueue(queueName, partition);\n\n        // 6. Based on the selected resource demand per partition, select\n        // containers with known policy from inter-queue preemption.\n        try {\n          leafQueue.getReadLock().lock();\n          Iterator\u003cFiCaSchedulerApp\u003e desc \u003d leafQueue.getOrderingPolicy()\n              .getPreemptionIterator();\n          while (desc.hasNext()) {\n            FiCaSchedulerApp app \u003d desc.next();\n            preemptFromLeastStarvedApp(selectedCandidates, clusterResource,\n                totalPreemptedResourceAllowed, resToObtainByPartition,\n                leafQueue, app);\n          }\n        } finally {\n          leafQueue.getReadLock().unlock();\n        }\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java",
      "extendedDetails": {}
    },
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
      "commitDate": "31/10/16 3:18 PM",
      "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,56 @@\n+  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n+      Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n+\n+    // 1. Calculate the abnormality within each queue one by one.\n+    computeIntraQueuePreemptionDemand(\n+        clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n+\n+    // 2. Previous selectors (with higher priority) could have already\n+    // selected containers. We need to deduct pre-emptable resources\n+    // based on already selected candidates.\n+    CapacitySchedulerPreemptionUtils\n+        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n+            selectedCandidates);\n+\n+    // 3. Loop through all partitions to select containers for preemption.\n+    for (String partition : preemptionContext.getAllPartitions()) {\n+      LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n+          .getUnderServedQueuesPerPartition(partition);\n+\n+      // Error check to handle non-mapped labels to queue.\n+      if (null \u003d\u003d queueNames) {\n+        continue;\n+      }\n+\n+      // 4. Iterate from most under-served queue in order.\n+      for (String queueName : queueNames) {\n+        LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n+            RMNodeLabelsManager.NO_LABEL).leafQueue;\n+\n+        // skip if not a leafqueue\n+        if (null \u003d\u003d leafQueue) {\n+          continue;\n+        }\n+\n+        // 5. Calculate the resource to obtain per partition\n+        Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n+            .getResourceDemandFromAppsPerQueue(queueName, partition);\n+\n+        // 6. Based on the selected resource demand per partition, select\n+        // containers with known policy from inter-queue preemption.\n+        synchronized (leafQueue) {\n+          Iterator\u003cFiCaSchedulerApp\u003e desc \u003d leafQueue.getOrderingPolicy()\n+              .getPreemptionIterator();\n+          while (desc.hasNext()) {\n+            FiCaSchedulerApp app \u003d desc.next();\n+            preemptFromLeastStarvedApp(selectedCandidates, clusterResource,\n+                totalPreemptedResourceAllowed, resToObtainByPartition,\n+                leafQueue, app);\n+          }\n+        }\n+      }\n+    }\n+\n+    return selectedCandidates;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptedResourceAllowed) {\n\n    // 1. Calculate the abnormality within each queue one by one.\n    computeIntraQueuePreemptionDemand(\n        clusterResource, totalPreemptedResourceAllowed, selectedCandidates);\n\n    // 2. Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct pre-emptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    // 3. Loop through all partitions to select containers for preemption.\n    for (String partition : preemptionContext.getAllPartitions()) {\n      LinkedHashSet\u003cString\u003e queueNames \u003d preemptionContext\n          .getUnderServedQueuesPerPartition(partition);\n\n      // Error check to handle non-mapped labels to queue.\n      if (null \u003d\u003d queueNames) {\n        continue;\n      }\n\n      // 4. Iterate from most under-served queue in order.\n      for (String queueName : queueNames) {\n        LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n            RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n        // skip if not a leafqueue\n        if (null \u003d\u003d leafQueue) {\n          continue;\n        }\n\n        // 5. Calculate the resource to obtain per partition\n        Map\u003cString, Resource\u003e resToObtainByPartition \u003d fifoPreemptionComputePlugin\n            .getResourceDemandFromAppsPerQueue(queueName, partition);\n\n        // 6. Based on the selected resource demand per partition, select\n        // containers with known policy from inter-queue preemption.\n        synchronized (leafQueue) {\n          Iterator\u003cFiCaSchedulerApp\u003e desc \u003d leafQueue.getOrderingPolicy()\n              .getPreemptionIterator();\n          while (desc.hasNext()) {\n            FiCaSchedulerApp app \u003d desc.next();\n            preemptFromLeastStarvedApp(selectedCandidates, clusterResource,\n                totalPreemptedResourceAllowed, resToObtainByPartition,\n                leafQueue, app);\n          }\n        }\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/IntraQueueCandidatesSelector.java"
    }
  }
}