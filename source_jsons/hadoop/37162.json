{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StageAllocatorGreedy.java",
  "functionName": "computeStageAllocation",
  "functionId": "computeStageAllocation___plan-Plan__planLoads-RLESparseResourceAllocation__planModifications-RLESparseResourceAllocation__rr-ReservationRequest__stageEarliestStart-long__stageDeadline-long__period-long__user-String__oldId-ReservationId",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
  "functionStartLine": 43,
  "functionEndLine": 157,
  "numCommitsSeen": 19,
  "timeTaken": 8804,
  "changeHistory": [
    "e6e614e380ed1d746973b50f666a9c40d272073e",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
    "e3345e985bff93c6c74a76747e45376c6027f42c",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
    "a3a615eeab8c14ccdc548311097e62a916963dc5",
    "742632e346604fd2b263bd42367165638fcf2416",
    "156f24ead00436faad5d4aeef327a546392cd265",
    "0e602fa3a1529134214452fba10a90307d9c2072",
    "f66ffcf832235e0da0bb050fff08e248b547c360"
  ],
  "changeHistoryShort": {
    "e6e614e380ed1d746973b50f666a9c40d272073e": "Ymultichange(Yparameterchange,Ybodychange)",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": "Ybodychange",
    "e3345e985bff93c6c74a76747e45376c6027f42c": "Ybodychange",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": "Ybodychange",
    "a3a615eeab8c14ccdc548311097e62a916963dc5": "Yparameterchange",
    "742632e346604fd2b263bd42367165638fcf2416": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "156f24ead00436faad5d4aeef327a546392cd265": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange,Yrename,Yparameterchange)",
    "0e602fa3a1529134214452fba10a90307d9c2072": "Ybodychange",
    "f66ffcf832235e0da0bb050fff08e248b547c360": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e6e614e380ed1d746973b50f666a9c40d272073e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
      "commitDate": "04/10/17 7:28 PM",
      "commitName": "e6e614e380ed1d746973b50f666a9c40d272073e",
      "commitAuthor": "Subru Krishnan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
          "commitDate": "04/10/17 7:28 PM",
          "commitName": "e6e614e380ed1d746973b50f666a9c40d272073e",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "06/09/17 4:46 PM",
          "commitNameOld": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 28.11,
          "commitsBetweenForRepo": 262,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,115 +1,115 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageEarliestStart, long stageDeadline, String user,\n+      long stageEarliestStart, long stageDeadline, long period, String user,\n       ReservationId oldId) throws PlanningException {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     // compute the gang as a resource and get the duration\n     Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     int maxGang \u003d 0;\n \n     RLESparseResourceAllocation netAvailable \u003d\n         plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n-            stageDeadline, 0);\n+            stageDeadline, period);\n \n     netAvailable \u003d\n         RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n             plan.getTotalCapacity(), netAvailable, planModifications,\n             RLEOperator.subtract, stageEarliestStart, stageDeadline);\n \n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       maxGang \u003d gangsToPlace;\n       long minPoint \u003d stageDeadline;\n       int curMaxGang \u003d maxGang;\n \n       // start placing at deadline (excluded due to [,) interval semantics and\n       // move backward\n       for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n           \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n         Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n \n         // compute maximum number of gangs we could fit\n         curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, netAvailableRes, gang));\n \n         // pick the minimum between available resources in this instant, and how\n         // many gangs we have to place\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // if we were able to place any gang, record this, and decrement\n       // gangsToPlace\n       if (maxGang \u003e 0) {\n         gangsToPlace -\u003d maxGang;\n \n         ReservationInterval reservationInt \u003d\n             new ReservationInterval(stageDeadline - dur, stageDeadline);\n         Resource reservationRes \u003d\n             Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                 * maxGang);\n         // remember occupied space (plan is read-only till we find a plausible\n         // allocation for the entire request). This is needed since we might be\n         // placing other ReservationRequest within the same\n         // ReservationDefinition,\n         // and we must avoid double-counting the available resources\n         planModifications.addInterval(reservationInt, reservationRes);\n         allocationRequests.put(reservationInt, reservationRes);\n \n       }\n \n       // reset our new starting point (curDeadline) to the most constraining\n       // point so far, we will look \"left\" of that to find more places where\n       // to schedule gangs (for sure nothing on the \"right\" of this point can\n       // fit a full gang.\n       stageDeadline \u003d minPoint;\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is becasue we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n           : allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, long period, String user,\n      ReservationId oldId) throws PlanningException {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    RLESparseResourceAllocation netAvailable \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline, period);\n\n    netAvailable \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            plan.getTotalCapacity(), netAvailable, planModifications,\n            RLEOperator.subtract, stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
          "extendedDetails": {
            "oldValue": "[plan-Plan, planLoads-RLESparseResourceAllocation, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long, user-String, oldId-ReservationId]",
            "newValue": "[plan-Plan, planLoads-RLESparseResourceAllocation, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long, period-long, user-String, oldId-ReservationId]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
          "commitDate": "04/10/17 7:28 PM",
          "commitName": "e6e614e380ed1d746973b50f666a9c40d272073e",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "06/09/17 4:46 PM",
          "commitNameOld": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 28.11,
          "commitsBetweenForRepo": 262,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,115 +1,115 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageEarliestStart, long stageDeadline, String user,\n+      long stageEarliestStart, long stageDeadline, long period, String user,\n       ReservationId oldId) throws PlanningException {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     // compute the gang as a resource and get the duration\n     Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     int maxGang \u003d 0;\n \n     RLESparseResourceAllocation netAvailable \u003d\n         plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n-            stageDeadline, 0);\n+            stageDeadline, period);\n \n     netAvailable \u003d\n         RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n             plan.getTotalCapacity(), netAvailable, planModifications,\n             RLEOperator.subtract, stageEarliestStart, stageDeadline);\n \n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       maxGang \u003d gangsToPlace;\n       long minPoint \u003d stageDeadline;\n       int curMaxGang \u003d maxGang;\n \n       // start placing at deadline (excluded due to [,) interval semantics and\n       // move backward\n       for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n           \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n         Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n \n         // compute maximum number of gangs we could fit\n         curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, netAvailableRes, gang));\n \n         // pick the minimum between available resources in this instant, and how\n         // many gangs we have to place\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // if we were able to place any gang, record this, and decrement\n       // gangsToPlace\n       if (maxGang \u003e 0) {\n         gangsToPlace -\u003d maxGang;\n \n         ReservationInterval reservationInt \u003d\n             new ReservationInterval(stageDeadline - dur, stageDeadline);\n         Resource reservationRes \u003d\n             Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                 * maxGang);\n         // remember occupied space (plan is read-only till we find a plausible\n         // allocation for the entire request). This is needed since we might be\n         // placing other ReservationRequest within the same\n         // ReservationDefinition,\n         // and we must avoid double-counting the available resources\n         planModifications.addInterval(reservationInt, reservationRes);\n         allocationRequests.put(reservationInt, reservationRes);\n \n       }\n \n       // reset our new starting point (curDeadline) to the most constraining\n       // point so far, we will look \"left\" of that to find more places where\n       // to schedule gangs (for sure nothing on the \"right\" of this point can\n       // fit a full gang.\n       stageDeadline \u003d minPoint;\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is becasue we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n           : allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, long period, String user,\n      ReservationId oldId) throws PlanningException {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    RLESparseResourceAllocation netAvailable \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline, period);\n\n    netAvailable \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            plan.getTotalCapacity(), netAvailable, planModifications,\n            RLEOperator.subtract, stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
          "extendedDetails": {}
        }
      ]
    },
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5328. Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "06/09/17 4:46 PM",
      "commitName": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "06/09/17 4:39 PM",
      "commitNameOld": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,115 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n       long stageEarliestStart, long stageDeadline, String user,\n       ReservationId oldId) throws PlanningException {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     // compute the gang as a resource and get the duration\n     Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     int maxGang \u003d 0;\n \n     RLESparseResourceAllocation netAvailable \u003d\n         plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n-            stageDeadline);\n+            stageDeadline, 0);\n \n     netAvailable \u003d\n         RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n             plan.getTotalCapacity(), netAvailable, planModifications,\n             RLEOperator.subtract, stageEarliestStart, stageDeadline);\n \n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       maxGang \u003d gangsToPlace;\n       long minPoint \u003d stageDeadline;\n       int curMaxGang \u003d maxGang;\n \n       // start placing at deadline (excluded due to [,) interval semantics and\n       // move backward\n       for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n           \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n         Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n \n         // compute maximum number of gangs we could fit\n         curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, netAvailableRes, gang));\n \n         // pick the minimum between available resources in this instant, and how\n         // many gangs we have to place\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // if we were able to place any gang, record this, and decrement\n       // gangsToPlace\n       if (maxGang \u003e 0) {\n         gangsToPlace -\u003d maxGang;\n \n         ReservationInterval reservationInt \u003d\n             new ReservationInterval(stageDeadline - dur, stageDeadline);\n         Resource reservationRes \u003d\n             Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                 * maxGang);\n         // remember occupied space (plan is read-only till we find a plausible\n         // allocation for the entire request). This is needed since we might be\n         // placing other ReservationRequest within the same\n         // ReservationDefinition,\n         // and we must avoid double-counting the available resources\n         planModifications.addInterval(reservationInt, reservationRes);\n         allocationRequests.put(reservationInt, reservationRes);\n \n       }\n \n       // reset our new starting point (curDeadline) to the most constraining\n       // point so far, we will look \"left\" of that to find more places where\n       // to schedule gangs (for sure nothing on the \"right\" of this point can\n       // fit a full gang.\n       stageDeadline \u003d minPoint;\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is becasue we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n           : allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) throws PlanningException {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    RLESparseResourceAllocation netAvailable \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline, 0);\n\n    netAvailable \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            plan.getTotalCapacity(), netAvailable, planModifications,\n            RLEOperator.subtract, stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
      "extendedDetails": {}
    },
    "e3345e985bff93c6c74a76747e45376c6027f42c": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\"\n\nThis reverts commit 7996eca7dcfaa1bdf970e32022274f2699bef8a1.\n",
      "commitDate": "06/09/17 4:39 PM",
      "commitName": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/09/17 3:16 PM",
      "commitNameOld": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 5.06,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,115 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n       long stageEarliestStart, long stageDeadline, String user,\n       ReservationId oldId) throws PlanningException {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     // compute the gang as a resource and get the duration\n     Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     int maxGang \u003d 0;\n \n     RLESparseResourceAllocation netAvailable \u003d\n         plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n-            stageDeadline, 0);\n+            stageDeadline);\n \n     netAvailable \u003d\n         RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n             plan.getTotalCapacity(), netAvailable, planModifications,\n             RLEOperator.subtract, stageEarliestStart, stageDeadline);\n \n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       maxGang \u003d gangsToPlace;\n       long minPoint \u003d stageDeadline;\n       int curMaxGang \u003d maxGang;\n \n       // start placing at deadline (excluded due to [,) interval semantics and\n       // move backward\n       for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n           \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n         Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n \n         // compute maximum number of gangs we could fit\n         curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, netAvailableRes, gang));\n \n         // pick the minimum between available resources in this instant, and how\n         // many gangs we have to place\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // if we were able to place any gang, record this, and decrement\n       // gangsToPlace\n       if (maxGang \u003e 0) {\n         gangsToPlace -\u003d maxGang;\n \n         ReservationInterval reservationInt \u003d\n             new ReservationInterval(stageDeadline - dur, stageDeadline);\n         Resource reservationRes \u003d\n             Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                 * maxGang);\n         // remember occupied space (plan is read-only till we find a plausible\n         // allocation for the entire request). This is needed since we might be\n         // placing other ReservationRequest within the same\n         // ReservationDefinition,\n         // and we must avoid double-counting the available resources\n         planModifications.addInterval(reservationInt, reservationRes);\n         allocationRequests.put(reservationInt, reservationRes);\n \n       }\n \n       // reset our new starting point (curDeadline) to the most constraining\n       // point so far, we will look \"left\" of that to find more places where\n       // to schedule gangs (for sure nothing on the \"right\" of this point can\n       // fit a full gang.\n       stageDeadline \u003d minPoint;\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is becasue we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n           : allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) throws PlanningException {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    RLESparseResourceAllocation netAvailable \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline);\n\n    netAvailable \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            plan.getTotalCapacity(), netAvailable, planModifications,\n            RLEOperator.subtract, stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
      "extendedDetails": {}
    },
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": {
      "type": "Ybodychange",
      "commitMessage": "Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "01/09/17 3:16 PM",
      "commitName": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/05/17 4:01 PM",
      "commitNameOld": "a3a615eeab8c14ccdc548311097e62a916963dc5",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 122.97,
      "commitsBetweenForRepo": 775,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,115 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n       long stageEarliestStart, long stageDeadline, String user,\n       ReservationId oldId) throws PlanningException {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     // compute the gang as a resource and get the duration\n     Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     int maxGang \u003d 0;\n \n     RLESparseResourceAllocation netAvailable \u003d\n         plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n-            stageDeadline);\n+            stageDeadline, 0);\n \n     netAvailable \u003d\n         RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n             plan.getTotalCapacity(), netAvailable, planModifications,\n             RLEOperator.subtract, stageEarliestStart, stageDeadline);\n \n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       maxGang \u003d gangsToPlace;\n       long minPoint \u003d stageDeadline;\n       int curMaxGang \u003d maxGang;\n \n       // start placing at deadline (excluded due to [,) interval semantics and\n       // move backward\n       for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n           \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n         Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n \n         // compute maximum number of gangs we could fit\n         curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, netAvailableRes, gang));\n \n         // pick the minimum between available resources in this instant, and how\n         // many gangs we have to place\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // if we were able to place any gang, record this, and decrement\n       // gangsToPlace\n       if (maxGang \u003e 0) {\n         gangsToPlace -\u003d maxGang;\n \n         ReservationInterval reservationInt \u003d\n             new ReservationInterval(stageDeadline - dur, stageDeadline);\n         Resource reservationRes \u003d\n             Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                 * maxGang);\n         // remember occupied space (plan is read-only till we find a plausible\n         // allocation for the entire request). This is needed since we might be\n         // placing other ReservationRequest within the same\n         // ReservationDefinition,\n         // and we must avoid double-counting the available resources\n         planModifications.addInterval(reservationInt, reservationRes);\n         allocationRequests.put(reservationInt, reservationRes);\n \n       }\n \n       // reset our new starting point (curDeadline) to the most constraining\n       // point so far, we will look \"left\" of that to find more places where\n       // to schedule gangs (for sure nothing on the \"right\" of this point can\n       // fit a full gang.\n       stageDeadline \u003d minPoint;\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is becasue we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n           : allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) throws PlanningException {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    RLESparseResourceAllocation netAvailable \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline, 0);\n\n    netAvailable \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            plan.getTotalCapacity(), netAvailable, planModifications,\n            RLEOperator.subtract, stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
      "extendedDetails": {}
    },
    "a3a615eeab8c14ccdc548311097e62a916963dc5": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-4359. Update LowCost agents logic to take advantage of YARN-4358. (Jonathan Yaniv and Ishai Menache via Subru).\n",
      "commitDate": "01/05/17 4:01 PM",
      "commitName": "a3a615eeab8c14ccdc548311097e62a916963dc5",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "05/12/15 9:26 PM",
      "commitNameOld": "742632e346604fd2b263bd42367165638fcf2416",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 512.73,
      "commitsBetweenForRepo": 3348,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,115 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n-      Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n       long stageEarliestStart, long stageDeadline, String user,\n       ReservationId oldId) throws PlanningException {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     // compute the gang as a resource and get the duration\n     Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     int maxGang \u003d 0;\n \n     RLESparseResourceAllocation netAvailable \u003d\n         plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n             stageDeadline);\n \n     netAvailable \u003d\n         RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n             plan.getTotalCapacity(), netAvailable, planModifications,\n             RLEOperator.subtract, stageEarliestStart, stageDeadline);\n \n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       maxGang \u003d gangsToPlace;\n       long minPoint \u003d stageDeadline;\n       int curMaxGang \u003d maxGang;\n \n       // start placing at deadline (excluded due to [,) interval semantics and\n       // move backward\n       for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n           \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n         Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n \n         // compute maximum number of gangs we could fit\n         curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, netAvailableRes, gang));\n \n         // pick the minimum between available resources in this instant, and how\n         // many gangs we have to place\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // if we were able to place any gang, record this, and decrement\n       // gangsToPlace\n       if (maxGang \u003e 0) {\n         gangsToPlace -\u003d maxGang;\n \n         ReservationInterval reservationInt \u003d\n             new ReservationInterval(stageDeadline - dur, stageDeadline);\n         Resource reservationRes \u003d\n             Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                 * maxGang);\n         // remember occupied space (plan is read-only till we find a plausible\n         // allocation for the entire request). This is needed since we might be\n         // placing other ReservationRequest within the same\n         // ReservationDefinition,\n         // and we must avoid double-counting the available resources\n         planModifications.addInterval(reservationInt, reservationRes);\n         allocationRequests.put(reservationInt, reservationRes);\n \n       }\n \n       // reset our new starting point (curDeadline) to the most constraining\n       // point so far, we will look \"left\" of that to find more places where\n       // to schedule gangs (for sure nothing on the \"right\" of this point can\n       // fit a full gang.\n       stageDeadline \u003d minPoint;\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is becasue we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n           : allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) throws PlanningException {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    RLESparseResourceAllocation netAvailable \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline);\n\n    netAvailable \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            plan.getTotalCapacity(), netAvailable, planModifications,\n            RLEOperator.subtract, stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
      "extendedDetails": {
        "oldValue": "[plan-Plan, planLoads-Map\u003cLong,Resource\u003e, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long, user-String, oldId-ReservationId]",
        "newValue": "[plan-Plan, planLoads-RLESparseResourceAllocation, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long, user-String, oldId-ReservationId]"
      }
    },
    "742632e346604fd2b263bd42367165638fcf2416": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
      "commitDate": "05/12/15 9:26 PM",
      "commitName": "742632e346604fd2b263bd42367165638fcf2416",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
          "commitDate": "05/12/15 9:26 PM",
          "commitName": "742632e346604fd2b263bd42367165638fcf2416",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "25/07/15 7:39 AM",
          "commitNameOld": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthorOld": "ccurino",
          "daysBetweenCommits": 133.62,
          "commitsBetweenForRepo": 915,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,111 +1,115 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       Map\u003cLong, Resource\u003e planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageEarliestStart, long stageDeadline) {\n+      long stageEarliestStart, long stageDeadline, String user,\n+      ReservationId oldId) throws PlanningException {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     // compute the gang as a resource and get the duration\n     Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     int maxGang \u003d 0;\n \n+    RLESparseResourceAllocation netAvailable \u003d\n+        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n+            stageDeadline);\n+\n+    netAvailable \u003d\n+        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n+            plan.getTotalCapacity(), netAvailable, planModifications,\n+            RLEOperator.subtract, stageEarliestStart, stageDeadline);\n+\n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       maxGang \u003d gangsToPlace;\n       long minPoint \u003d stageDeadline;\n       int curMaxGang \u003d maxGang;\n \n       // start placing at deadline (excluded due to [,) interval semantics and\n       // move backward\n       for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n           \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n-        // compute net available resources\n-        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n-        // Resources.addTo(netAvailableRes, oldResCap);\n-        Resources.subtractFrom(netAvailableRes,\n-            plan.getTotalCommittedResources(t));\n-        Resources.subtractFrom(netAvailableRes,\n-            planModifications.getCapacityAtTime(t));\n+        Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n \n         // compute maximum number of gangs we could fit\n         curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, netAvailableRes, gang));\n \n         // pick the minimum between available resources in this instant, and how\n         // many gangs we have to place\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // if we were able to place any gang, record this, and decrement\n       // gangsToPlace\n       if (maxGang \u003e 0) {\n         gangsToPlace -\u003d maxGang;\n \n         ReservationInterval reservationInt \u003d\n             new ReservationInterval(stageDeadline - dur, stageDeadline);\n         Resource reservationRes \u003d\n             Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                 * maxGang);\n         // remember occupied space (plan is read-only till we find a plausible\n         // allocation for the entire request). This is needed since we might be\n         // placing other ReservationRequest within the same\n         // ReservationDefinition,\n         // and we must avoid double-counting the available resources\n         planModifications.addInterval(reservationInt, reservationRes);\n         allocationRequests.put(reservationInt, reservationRes);\n \n       }\n \n       // reset our new starting point (curDeadline) to the most constraining\n       // point so far, we will look \"left\" of that to find more places where\n       // to schedule gangs (for sure nothing on the \"right\" of this point can\n       // fit a full gang.\n       stageDeadline \u003d minPoint;\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is becasue we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n           : allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) throws PlanningException {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    RLESparseResourceAllocation netAvailable \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline);\n\n    netAvailable \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            plan.getTotalCapacity(), netAvailable, planModifications,\n            RLEOperator.subtract, stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
          "extendedDetails": {
            "oldValue": "[plan-Plan, planLoads-Map\u003cLong,Resource\u003e, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long]",
            "newValue": "[plan-Plan, planLoads-Map\u003cLong,Resource\u003e, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long, user-String, oldId-ReservationId]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
          "commitDate": "05/12/15 9:26 PM",
          "commitName": "742632e346604fd2b263bd42367165638fcf2416",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "25/07/15 7:39 AM",
          "commitNameOld": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthorOld": "ccurino",
          "daysBetweenCommits": 133.62,
          "commitsBetweenForRepo": 915,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,111 +1,115 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       Map\u003cLong, Resource\u003e planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageEarliestStart, long stageDeadline) {\n+      long stageEarliestStart, long stageDeadline, String user,\n+      ReservationId oldId) throws PlanningException {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     // compute the gang as a resource and get the duration\n     Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     int maxGang \u003d 0;\n \n+    RLESparseResourceAllocation netAvailable \u003d\n+        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n+            stageDeadline);\n+\n+    netAvailable \u003d\n+        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n+            plan.getTotalCapacity(), netAvailable, planModifications,\n+            RLEOperator.subtract, stageEarliestStart, stageDeadline);\n+\n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       maxGang \u003d gangsToPlace;\n       long minPoint \u003d stageDeadline;\n       int curMaxGang \u003d maxGang;\n \n       // start placing at deadline (excluded due to [,) interval semantics and\n       // move backward\n       for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n           \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n-        // compute net available resources\n-        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n-        // Resources.addTo(netAvailableRes, oldResCap);\n-        Resources.subtractFrom(netAvailableRes,\n-            plan.getTotalCommittedResources(t));\n-        Resources.subtractFrom(netAvailableRes,\n-            planModifications.getCapacityAtTime(t));\n+        Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n \n         // compute maximum number of gangs we could fit\n         curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, netAvailableRes, gang));\n \n         // pick the minimum between available resources in this instant, and how\n         // many gangs we have to place\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // if we were able to place any gang, record this, and decrement\n       // gangsToPlace\n       if (maxGang \u003e 0) {\n         gangsToPlace -\u003d maxGang;\n \n         ReservationInterval reservationInt \u003d\n             new ReservationInterval(stageDeadline - dur, stageDeadline);\n         Resource reservationRes \u003d\n             Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                 * maxGang);\n         // remember occupied space (plan is read-only till we find a plausible\n         // allocation for the entire request). This is needed since we might be\n         // placing other ReservationRequest within the same\n         // ReservationDefinition,\n         // and we must avoid double-counting the available resources\n         planModifications.addInterval(reservationInt, reservationRes);\n         allocationRequests.put(reservationInt, reservationRes);\n \n       }\n \n       // reset our new starting point (curDeadline) to the most constraining\n       // point so far, we will look \"left\" of that to find more places where\n       // to schedule gangs (for sure nothing on the \"right\" of this point can\n       // fit a full gang.\n       stageDeadline \u003d minPoint;\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is becasue we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n           : allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) throws PlanningException {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    RLESparseResourceAllocation netAvailable \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline);\n\n    netAvailable \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            plan.getTotalCapacity(), netAvailable, planModifications,\n            RLEOperator.subtract, stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[PlanningException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
          "commitDate": "05/12/15 9:26 PM",
          "commitName": "742632e346604fd2b263bd42367165638fcf2416",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "25/07/15 7:39 AM",
          "commitNameOld": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthorOld": "ccurino",
          "daysBetweenCommits": 133.62,
          "commitsBetweenForRepo": 915,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,111 +1,115 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       Map\u003cLong, Resource\u003e planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageEarliestStart, long stageDeadline) {\n+      long stageEarliestStart, long stageDeadline, String user,\n+      ReservationId oldId) throws PlanningException {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     // compute the gang as a resource and get the duration\n     Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     int maxGang \u003d 0;\n \n+    RLESparseResourceAllocation netAvailable \u003d\n+        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n+            stageDeadline);\n+\n+    netAvailable \u003d\n+        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n+            plan.getTotalCapacity(), netAvailable, planModifications,\n+            RLEOperator.subtract, stageEarliestStart, stageDeadline);\n+\n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       maxGang \u003d gangsToPlace;\n       long minPoint \u003d stageDeadline;\n       int curMaxGang \u003d maxGang;\n \n       // start placing at deadline (excluded due to [,) interval semantics and\n       // move backward\n       for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n           \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n-        // compute net available resources\n-        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n-        // Resources.addTo(netAvailableRes, oldResCap);\n-        Resources.subtractFrom(netAvailableRes,\n-            plan.getTotalCommittedResources(t));\n-        Resources.subtractFrom(netAvailableRes,\n-            planModifications.getCapacityAtTime(t));\n+        Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n \n         // compute maximum number of gangs we could fit\n         curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, netAvailableRes, gang));\n \n         // pick the minimum between available resources in this instant, and how\n         // many gangs we have to place\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // if we were able to place any gang, record this, and decrement\n       // gangsToPlace\n       if (maxGang \u003e 0) {\n         gangsToPlace -\u003d maxGang;\n \n         ReservationInterval reservationInt \u003d\n             new ReservationInterval(stageDeadline - dur, stageDeadline);\n         Resource reservationRes \u003d\n             Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                 * maxGang);\n         // remember occupied space (plan is read-only till we find a plausible\n         // allocation for the entire request). This is needed since we might be\n         // placing other ReservationRequest within the same\n         // ReservationDefinition,\n         // and we must avoid double-counting the available resources\n         planModifications.addInterval(reservationInt, reservationRes);\n         allocationRequests.put(reservationInt, reservationRes);\n \n       }\n \n       // reset our new starting point (curDeadline) to the most constraining\n       // point so far, we will look \"left\" of that to find more places where\n       // to schedule gangs (for sure nothing on the \"right\" of this point can\n       // fit a full gang.\n       stageDeadline \u003d minPoint;\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is becasue we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n           : allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) throws PlanningException {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    RLESparseResourceAllocation netAvailable \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline);\n\n    netAvailable \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            plan.getTotalCapacity(), netAvailable, planModifications,\n            RLEOperator.subtract, stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        Resource netAvailableRes \u003d netAvailable.getCapacityAtTime(t);\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
          "extendedDetails": {}
        }
      ]
    },
    "156f24ead00436faad5d4aeef327a546392cd265": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange,Yrename,Yparameterchange)",
      "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
      "commitDate": "25/07/15 7:39 AM",
      "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
      "commitAuthor": "ccurino",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,111 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n+      Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n-\n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n-        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n-            plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // compute the gang as a resource and get the duration\n+    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n+    long dur \u003d rr.getDuration();\n+    long step \u003d plan.getStep();\n \n-    boolean hasGang \u003d false;\n+    // ceil the duration to the next multiple of the plan step\n+    if (dur % step !\u003d 0) {\n+      dur +\u003d (step - (dur % step));\n+    }\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // we know for sure that this division has no remainder (part of contract\n+    // with user, validate before\n+    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    int maxGang \u003d 0;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // loop trying to place until we are done, or we are considering\n+    // an invalid range of times\n+    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // as we run along we remember how many gangs we can fit, and what\n+      // was the most constraining moment in time (we will restart just\n+      // after that to place the next batch)\n+      maxGang \u003d gangsToPlace;\n+      long minPoint \u003d stageDeadline;\n+      int curMaxGang \u003d maxGang;\n \n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+      // start placing at deadline (excluded due to [,) interval semantics and\n+      // move backward\n+      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n+          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n+        // compute net available resources\n+        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n+        // Resources.addTo(netAvailableRes, oldResCap);\n+        Resources.subtractFrom(netAvailableRes,\n+            plan.getTotalCommittedResources(t));\n+        Resources.subtractFrom(netAvailableRes,\n+            planModifications.getCapacityAtTime(t));\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // compute maximum number of gangs we could fit\n+        curMaxGang \u003d\n+            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n+                totalCapacity, netAvailableRes, gang));\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n+        // pick the minimum between available resources in this instant, and how\n+        // many gangs we have to place\n+        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n+        // compare with previous max, and set it. also remember *where* we found\n+        // the minimum (useful for next attempts)\n+        if (curMaxGang \u003c\u003d maxGang) {\n+          maxGang \u003d curMaxGang;\n+          minPoint \u003d t;\n         }\n       }\n+\n+      // if we were able to place any gang, record this, and decrement\n+      // gangsToPlace\n+      if (maxGang \u003e 0) {\n+        gangsToPlace -\u003d maxGang;\n+\n+        ReservationInterval reservationInt \u003d\n+            new ReservationInterval(stageDeadline - dur, stageDeadline);\n+        Resource reservationRes \u003d\n+            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+                * maxGang);\n+        // remember occupied space (plan is read-only till we find a plausible\n+        // allocation for the entire request). This is needed since we might be\n+        // placing other ReservationRequest within the same\n+        // ReservationDefinition,\n+        // and we must avoid double-counting the available resources\n+        planModifications.addInterval(reservationInt, reservationRes);\n+        allocationRequests.put(reservationInt, reservationRes);\n+\n+      }\n+\n+      // reset our new starting point (curDeadline) to the most constraining\n+      // point so far, we will look \"left\" of that to find more places where\n+      // to schedule gangs (for sure nothing on the \"right\" of this point can\n+      // fit a full gang.\n+      stageDeadline \u003d minPoint;\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n-    }\n-\n-    // create reservation with above allocations if not null/empty\n-\n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // if no gangs are left to place we succeed and return the allocation\n+    if (gangsToPlace \u003d\u003d 0) {\n+      return allocationRequests;\n     } else {\n-      return plan.addReservation(capReservation);\n+      // If we are here is becasue we did not manage to satisfy this request.\n+      // So we need to remove unwanted side-effect from tempAssigned (needed\n+      // for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocationRequests.entrySet()) {\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+      }\n+      // and return null to signal failure in this allocation\n+      return null;\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        // compute net available resources\n        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n        // Resources.addTo(netAvailableRes, oldResCap);\n        Resources.subtractFrom(netAvailableRes,\n            plan.getTotalCommittedResources(t));\n        Resources.subtractFrom(netAvailableRes,\n            planModifications.getCapacityAtTime(t));\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/GreedyReservationAgent.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
            "oldMethodName": "computeAllocation",
            "newMethodName": "computeStageAllocation"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,111 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n+      Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n-\n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n-        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n-            plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // compute the gang as a resource and get the duration\n+    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n+    long dur \u003d rr.getDuration();\n+    long step \u003d plan.getStep();\n \n-    boolean hasGang \u003d false;\n+    // ceil the duration to the next multiple of the plan step\n+    if (dur % step !\u003d 0) {\n+      dur +\u003d (step - (dur % step));\n+    }\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // we know for sure that this division has no remainder (part of contract\n+    // with user, validate before\n+    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    int maxGang \u003d 0;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // loop trying to place until we are done, or we are considering\n+    // an invalid range of times\n+    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // as we run along we remember how many gangs we can fit, and what\n+      // was the most constraining moment in time (we will restart just\n+      // after that to place the next batch)\n+      maxGang \u003d gangsToPlace;\n+      long minPoint \u003d stageDeadline;\n+      int curMaxGang \u003d maxGang;\n \n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+      // start placing at deadline (excluded due to [,) interval semantics and\n+      // move backward\n+      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n+          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n+        // compute net available resources\n+        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n+        // Resources.addTo(netAvailableRes, oldResCap);\n+        Resources.subtractFrom(netAvailableRes,\n+            plan.getTotalCommittedResources(t));\n+        Resources.subtractFrom(netAvailableRes,\n+            planModifications.getCapacityAtTime(t));\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // compute maximum number of gangs we could fit\n+        curMaxGang \u003d\n+            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n+                totalCapacity, netAvailableRes, gang));\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n+        // pick the minimum between available resources in this instant, and how\n+        // many gangs we have to place\n+        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n+        // compare with previous max, and set it. also remember *where* we found\n+        // the minimum (useful for next attempts)\n+        if (curMaxGang \u003c\u003d maxGang) {\n+          maxGang \u003d curMaxGang;\n+          minPoint \u003d t;\n         }\n       }\n+\n+      // if we were able to place any gang, record this, and decrement\n+      // gangsToPlace\n+      if (maxGang \u003e 0) {\n+        gangsToPlace -\u003d maxGang;\n+\n+        ReservationInterval reservationInt \u003d\n+            new ReservationInterval(stageDeadline - dur, stageDeadline);\n+        Resource reservationRes \u003d\n+            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+                * maxGang);\n+        // remember occupied space (plan is read-only till we find a plausible\n+        // allocation for the entire request). This is needed since we might be\n+        // placing other ReservationRequest within the same\n+        // ReservationDefinition,\n+        // and we must avoid double-counting the available resources\n+        planModifications.addInterval(reservationInt, reservationRes);\n+        allocationRequests.put(reservationInt, reservationRes);\n+\n+      }\n+\n+      // reset our new starting point (curDeadline) to the most constraining\n+      // point so far, we will look \"left\" of that to find more places where\n+      // to schedule gangs (for sure nothing on the \"right\" of this point can\n+      // fit a full gang.\n+      stageDeadline \u003d minPoint;\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n-    }\n-\n-    // create reservation with above allocations if not null/empty\n-\n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // if no gangs are left to place we succeed and return the allocation\n+    if (gangsToPlace \u003d\u003d 0) {\n+      return allocationRequests;\n     } else {\n-      return plan.addReservation(capReservation);\n+      // If we are here is becasue we did not manage to satisfy this request.\n+      // So we need to remove unwanted side-effect from tempAssigned (needed\n+      // for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocationRequests.entrySet()) {\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+      }\n+      // and return null to signal failure in this allocation\n+      return null;\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        // compute net available resources\n        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n        // Resources.addTo(netAvailableRes, oldResCap);\n        Resources.subtractFrom(netAvailableRes,\n            plan.getTotalCommittedResources(t));\n        Resources.subtractFrom(netAvailableRes,\n            planModifications.getCapacityAtTime(t));\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
          "extendedDetails": {
            "oldValue": "boolean",
            "newValue": "Map\u003cReservationInterval,Resource\u003e"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,111 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n+      Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n-\n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n-        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n-            plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // compute the gang as a resource and get the duration\n+    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n+    long dur \u003d rr.getDuration();\n+    long step \u003d plan.getStep();\n \n-    boolean hasGang \u003d false;\n+    // ceil the duration to the next multiple of the plan step\n+    if (dur % step !\u003d 0) {\n+      dur +\u003d (step - (dur % step));\n+    }\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // we know for sure that this division has no remainder (part of contract\n+    // with user, validate before\n+    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    int maxGang \u003d 0;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // loop trying to place until we are done, or we are considering\n+    // an invalid range of times\n+    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // as we run along we remember how many gangs we can fit, and what\n+      // was the most constraining moment in time (we will restart just\n+      // after that to place the next batch)\n+      maxGang \u003d gangsToPlace;\n+      long minPoint \u003d stageDeadline;\n+      int curMaxGang \u003d maxGang;\n \n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+      // start placing at deadline (excluded due to [,) interval semantics and\n+      // move backward\n+      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n+          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n+        // compute net available resources\n+        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n+        // Resources.addTo(netAvailableRes, oldResCap);\n+        Resources.subtractFrom(netAvailableRes,\n+            plan.getTotalCommittedResources(t));\n+        Resources.subtractFrom(netAvailableRes,\n+            planModifications.getCapacityAtTime(t));\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // compute maximum number of gangs we could fit\n+        curMaxGang \u003d\n+            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n+                totalCapacity, netAvailableRes, gang));\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n+        // pick the minimum between available resources in this instant, and how\n+        // many gangs we have to place\n+        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n+        // compare with previous max, and set it. also remember *where* we found\n+        // the minimum (useful for next attempts)\n+        if (curMaxGang \u003c\u003d maxGang) {\n+          maxGang \u003d curMaxGang;\n+          minPoint \u003d t;\n         }\n       }\n+\n+      // if we were able to place any gang, record this, and decrement\n+      // gangsToPlace\n+      if (maxGang \u003e 0) {\n+        gangsToPlace -\u003d maxGang;\n+\n+        ReservationInterval reservationInt \u003d\n+            new ReservationInterval(stageDeadline - dur, stageDeadline);\n+        Resource reservationRes \u003d\n+            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+                * maxGang);\n+        // remember occupied space (plan is read-only till we find a plausible\n+        // allocation for the entire request). This is needed since we might be\n+        // placing other ReservationRequest within the same\n+        // ReservationDefinition,\n+        // and we must avoid double-counting the available resources\n+        planModifications.addInterval(reservationInt, reservationRes);\n+        allocationRequests.put(reservationInt, reservationRes);\n+\n+      }\n+\n+      // reset our new starting point (curDeadline) to the most constraining\n+      // point so far, we will look \"left\" of that to find more places where\n+      // to schedule gangs (for sure nothing on the \"right\" of this point can\n+      // fit a full gang.\n+      stageDeadline \u003d minPoint;\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n-    }\n-\n-    // create reservation with above allocations if not null/empty\n-\n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // if no gangs are left to place we succeed and return the allocation\n+    if (gangsToPlace \u003d\u003d 0) {\n+      return allocationRequests;\n     } else {\n-      return plan.addReservation(capReservation);\n+      // If we are here is becasue we did not manage to satisfy this request.\n+      // So we need to remove unwanted side-effect from tempAssigned (needed\n+      // for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocationRequests.entrySet()) {\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+      }\n+      // and return null to signal failure in this allocation\n+      return null;\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        // compute net available resources\n        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n        // Resources.addTo(netAvailableRes, oldResCap);\n        Resources.subtractFrom(netAvailableRes,\n            plan.getTotalCommittedResources(t));\n        Resources.subtractFrom(netAvailableRes,\n            planModifications.getCapacityAtTime(t));\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,111 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n+      Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n-\n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n-        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n-            plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // compute the gang as a resource and get the duration\n+    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n+    long dur \u003d rr.getDuration();\n+    long step \u003d plan.getStep();\n \n-    boolean hasGang \u003d false;\n+    // ceil the duration to the next multiple of the plan step\n+    if (dur % step !\u003d 0) {\n+      dur +\u003d (step - (dur % step));\n+    }\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // we know for sure that this division has no remainder (part of contract\n+    // with user, validate before\n+    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    int maxGang \u003d 0;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // loop trying to place until we are done, or we are considering\n+    // an invalid range of times\n+    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // as we run along we remember how many gangs we can fit, and what\n+      // was the most constraining moment in time (we will restart just\n+      // after that to place the next batch)\n+      maxGang \u003d gangsToPlace;\n+      long minPoint \u003d stageDeadline;\n+      int curMaxGang \u003d maxGang;\n \n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+      // start placing at deadline (excluded due to [,) interval semantics and\n+      // move backward\n+      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n+          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n+        // compute net available resources\n+        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n+        // Resources.addTo(netAvailableRes, oldResCap);\n+        Resources.subtractFrom(netAvailableRes,\n+            plan.getTotalCommittedResources(t));\n+        Resources.subtractFrom(netAvailableRes,\n+            planModifications.getCapacityAtTime(t));\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // compute maximum number of gangs we could fit\n+        curMaxGang \u003d\n+            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n+                totalCapacity, netAvailableRes, gang));\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n+        // pick the minimum between available resources in this instant, and how\n+        // many gangs we have to place\n+        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n+        // compare with previous max, and set it. also remember *where* we found\n+        // the minimum (useful for next attempts)\n+        if (curMaxGang \u003c\u003d maxGang) {\n+          maxGang \u003d curMaxGang;\n+          minPoint \u003d t;\n         }\n       }\n+\n+      // if we were able to place any gang, record this, and decrement\n+      // gangsToPlace\n+      if (maxGang \u003e 0) {\n+        gangsToPlace -\u003d maxGang;\n+\n+        ReservationInterval reservationInt \u003d\n+            new ReservationInterval(stageDeadline - dur, stageDeadline);\n+        Resource reservationRes \u003d\n+            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+                * maxGang);\n+        // remember occupied space (plan is read-only till we find a plausible\n+        // allocation for the entire request). This is needed since we might be\n+        // placing other ReservationRequest within the same\n+        // ReservationDefinition,\n+        // and we must avoid double-counting the available resources\n+        planModifications.addInterval(reservationInt, reservationRes);\n+        allocationRequests.put(reservationInt, reservationRes);\n+\n+      }\n+\n+      // reset our new starting point (curDeadline) to the most constraining\n+      // point so far, we will look \"left\" of that to find more places where\n+      // to schedule gangs (for sure nothing on the \"right\" of this point can\n+      // fit a full gang.\n+      stageDeadline \u003d minPoint;\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n-    }\n-\n-    // create reservation with above allocations if not null/empty\n-\n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // if no gangs are left to place we succeed and return the allocation\n+    if (gangsToPlace \u003d\u003d 0) {\n+      return allocationRequests;\n     } else {\n-      return plan.addReservation(capReservation);\n+      // If we are here is becasue we did not manage to satisfy this request.\n+      // So we need to remove unwanted side-effect from tempAssigned (needed\n+      // for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocationRequests.entrySet()) {\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+      }\n+      // and return null to signal failure in this allocation\n+      return null;\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        // compute net available resources\n        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n        // Resources.addTo(netAvailableRes, oldResCap);\n        Resources.subtractFrom(netAvailableRes,\n            plan.getTotalCommittedResources(t));\n        Resources.subtractFrom(netAvailableRes,\n            planModifications.getCapacityAtTime(t));\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
          "extendedDetails": {
            "oldValue": "[PlanningException, ContractValidationException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,111 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n+      Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n-\n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n-        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n-            plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // compute the gang as a resource and get the duration\n+    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n+    long dur \u003d rr.getDuration();\n+    long step \u003d plan.getStep();\n \n-    boolean hasGang \u003d false;\n+    // ceil the duration to the next multiple of the plan step\n+    if (dur % step !\u003d 0) {\n+      dur +\u003d (step - (dur % step));\n+    }\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // we know for sure that this division has no remainder (part of contract\n+    // with user, validate before\n+    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    int maxGang \u003d 0;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // loop trying to place until we are done, or we are considering\n+    // an invalid range of times\n+    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // as we run along we remember how many gangs we can fit, and what\n+      // was the most constraining moment in time (we will restart just\n+      // after that to place the next batch)\n+      maxGang \u003d gangsToPlace;\n+      long minPoint \u003d stageDeadline;\n+      int curMaxGang \u003d maxGang;\n \n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+      // start placing at deadline (excluded due to [,) interval semantics and\n+      // move backward\n+      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n+          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n+        // compute net available resources\n+        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n+        // Resources.addTo(netAvailableRes, oldResCap);\n+        Resources.subtractFrom(netAvailableRes,\n+            plan.getTotalCommittedResources(t));\n+        Resources.subtractFrom(netAvailableRes,\n+            planModifications.getCapacityAtTime(t));\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // compute maximum number of gangs we could fit\n+        curMaxGang \u003d\n+            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n+                totalCapacity, netAvailableRes, gang));\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n+        // pick the minimum between available resources in this instant, and how\n+        // many gangs we have to place\n+        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n+        // compare with previous max, and set it. also remember *where* we found\n+        // the minimum (useful for next attempts)\n+        if (curMaxGang \u003c\u003d maxGang) {\n+          maxGang \u003d curMaxGang;\n+          minPoint \u003d t;\n         }\n       }\n+\n+      // if we were able to place any gang, record this, and decrement\n+      // gangsToPlace\n+      if (maxGang \u003e 0) {\n+        gangsToPlace -\u003d maxGang;\n+\n+        ReservationInterval reservationInt \u003d\n+            new ReservationInterval(stageDeadline - dur, stageDeadline);\n+        Resource reservationRes \u003d\n+            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+                * maxGang);\n+        // remember occupied space (plan is read-only till we find a plausible\n+        // allocation for the entire request). This is needed since we might be\n+        // placing other ReservationRequest within the same\n+        // ReservationDefinition,\n+        // and we must avoid double-counting the available resources\n+        planModifications.addInterval(reservationInt, reservationRes);\n+        allocationRequests.put(reservationInt, reservationRes);\n+\n+      }\n+\n+      // reset our new starting point (curDeadline) to the most constraining\n+      // point so far, we will look \"left\" of that to find more places where\n+      // to schedule gangs (for sure nothing on the \"right\" of this point can\n+      // fit a full gang.\n+      stageDeadline \u003d minPoint;\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n-    }\n-\n-    // create reservation with above allocations if not null/empty\n-\n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // if no gangs are left to place we succeed and return the allocation\n+    if (gangsToPlace \u003d\u003d 0) {\n+      return allocationRequests;\n     } else {\n-      return plan.addReservation(capReservation);\n+      // If we are here is becasue we did not manage to satisfy this request.\n+      // So we need to remove unwanted side-effect from tempAssigned (needed\n+      // for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocationRequests.entrySet()) {\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+      }\n+      // and return null to signal failure in this allocation\n+      return null;\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        // compute net available resources\n        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n        // Resources.addTo(netAvailableRes, oldResCap);\n        Resources.subtractFrom(netAvailableRes,\n            plan.getTotalCommittedResources(t));\n        Resources.subtractFrom(netAvailableRes,\n            planModifications.getCapacityAtTime(t));\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
          "extendedDetails": {}
        },
        {
          "type": "Yrename",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,111 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n+      Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n-\n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n-        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n-            plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // compute the gang as a resource and get the duration\n+    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n+    long dur \u003d rr.getDuration();\n+    long step \u003d plan.getStep();\n \n-    boolean hasGang \u003d false;\n+    // ceil the duration to the next multiple of the plan step\n+    if (dur % step !\u003d 0) {\n+      dur +\u003d (step - (dur % step));\n+    }\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // we know for sure that this division has no remainder (part of contract\n+    // with user, validate before\n+    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    int maxGang \u003d 0;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // loop trying to place until we are done, or we are considering\n+    // an invalid range of times\n+    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // as we run along we remember how many gangs we can fit, and what\n+      // was the most constraining moment in time (we will restart just\n+      // after that to place the next batch)\n+      maxGang \u003d gangsToPlace;\n+      long minPoint \u003d stageDeadline;\n+      int curMaxGang \u003d maxGang;\n \n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+      // start placing at deadline (excluded due to [,) interval semantics and\n+      // move backward\n+      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n+          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n+        // compute net available resources\n+        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n+        // Resources.addTo(netAvailableRes, oldResCap);\n+        Resources.subtractFrom(netAvailableRes,\n+            plan.getTotalCommittedResources(t));\n+        Resources.subtractFrom(netAvailableRes,\n+            planModifications.getCapacityAtTime(t));\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // compute maximum number of gangs we could fit\n+        curMaxGang \u003d\n+            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n+                totalCapacity, netAvailableRes, gang));\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n+        // pick the minimum between available resources in this instant, and how\n+        // many gangs we have to place\n+        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n+        // compare with previous max, and set it. also remember *where* we found\n+        // the minimum (useful for next attempts)\n+        if (curMaxGang \u003c\u003d maxGang) {\n+          maxGang \u003d curMaxGang;\n+          minPoint \u003d t;\n         }\n       }\n+\n+      // if we were able to place any gang, record this, and decrement\n+      // gangsToPlace\n+      if (maxGang \u003e 0) {\n+        gangsToPlace -\u003d maxGang;\n+\n+        ReservationInterval reservationInt \u003d\n+            new ReservationInterval(stageDeadline - dur, stageDeadline);\n+        Resource reservationRes \u003d\n+            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+                * maxGang);\n+        // remember occupied space (plan is read-only till we find a plausible\n+        // allocation for the entire request). This is needed since we might be\n+        // placing other ReservationRequest within the same\n+        // ReservationDefinition,\n+        // and we must avoid double-counting the available resources\n+        planModifications.addInterval(reservationInt, reservationRes);\n+        allocationRequests.put(reservationInt, reservationRes);\n+\n+      }\n+\n+      // reset our new starting point (curDeadline) to the most constraining\n+      // point so far, we will look \"left\" of that to find more places where\n+      // to schedule gangs (for sure nothing on the \"right\" of this point can\n+      // fit a full gang.\n+      stageDeadline \u003d minPoint;\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n-    }\n-\n-    // create reservation with above allocations if not null/empty\n-\n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // if no gangs are left to place we succeed and return the allocation\n+    if (gangsToPlace \u003d\u003d 0) {\n+      return allocationRequests;\n     } else {\n-      return plan.addReservation(capReservation);\n+      // If we are here is becasue we did not manage to satisfy this request.\n+      // So we need to remove unwanted side-effect from tempAssigned (needed\n+      // for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocationRequests.entrySet()) {\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+      }\n+      // and return null to signal failure in this allocation\n+      return null;\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        // compute net available resources\n        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n        // Resources.addTo(netAvailableRes, oldResCap);\n        Resources.subtractFrom(netAvailableRes,\n            plan.getTotalCommittedResources(t));\n        Resources.subtractFrom(netAvailableRes,\n            planModifications.getCapacityAtTime(t));\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
          "extendedDetails": {
            "oldValue": "computeAllocation",
            "newValue": "computeStageAllocation"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,111 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n+      Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n-    long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n-\n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n-        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n-            plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // compute the gang as a resource and get the duration\n+    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n+    long dur \u003d rr.getDuration();\n+    long step \u003d plan.getStep();\n \n-    boolean hasGang \u003d false;\n+    // ceil the duration to the next multiple of the plan step\n+    if (dur % step !\u003d 0) {\n+      dur +\u003d (step - (dur % step));\n+    }\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // we know for sure that this division has no remainder (part of contract\n+    // with user, validate before\n+    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    int maxGang \u003d 0;\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n+    // loop trying to place until we are done, or we are considering\n+    // an invalid range of times\n+    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n \n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+      // as we run along we remember how many gangs we can fit, and what\n+      // was the most constraining moment in time (we will restart just\n+      // after that to place the next batch)\n+      maxGang \u003d gangsToPlace;\n+      long minPoint \u003d stageDeadline;\n+      int curMaxGang \u003d maxGang;\n \n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n+      // start placing at deadline (excluded due to [,) interval semantics and\n+      // move backward\n+      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n+          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n \n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n+        // compute net available resources\n+        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n+        // Resources.addTo(netAvailableRes, oldResCap);\n+        Resources.subtractFrom(netAvailableRes,\n+            plan.getTotalCommittedResources(t));\n+        Resources.subtractFrom(netAvailableRes,\n+            planModifications.getCapacityAtTime(t));\n \n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n+        // compute maximum number of gangs we could fit\n+        curMaxGang \u003d\n+            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n+                totalCapacity, netAvailableRes, gang));\n \n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n+        // pick the minimum between available resources in this instant, and how\n+        // many gangs we have to place\n+        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n-            }\n-          }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n+        // compare with previous max, and set it. also remember *where* we found\n+        // the minimum (useful for next attempts)\n+        if (curMaxGang \u003c\u003d maxGang) {\n+          maxGang \u003d curMaxGang;\n+          minPoint \u003d t;\n         }\n       }\n+\n+      // if we were able to place any gang, record this, and decrement\n+      // gangsToPlace\n+      if (maxGang \u003e 0) {\n+        gangsToPlace -\u003d maxGang;\n+\n+        ReservationInterval reservationInt \u003d\n+            new ReservationInterval(stageDeadline - dur, stageDeadline);\n+        Resource reservationRes \u003d\n+            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+                * maxGang);\n+        // remember occupied space (plan is read-only till we find a plausible\n+        // allocation for the entire request). This is needed since we might be\n+        // placing other ReservationRequest within the same\n+        // ReservationDefinition,\n+        // and we must avoid double-counting the available resources\n+        planModifications.addInterval(reservationInt, reservationRes);\n+        allocationRequests.put(reservationInt, reservationRes);\n+\n+      }\n+\n+      // reset our new starting point (curDeadline) to the most constraining\n+      // point so far, we will look \"left\" of that to find more places where\n+      // to schedule gangs (for sure nothing on the \"right\" of this point can\n+      // fit a full gang.\n+      stageDeadline \u003d minPoint;\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n-    }\n-\n-    // create reservation with above allocations if not null/empty\n-\n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // if no gangs are left to place we succeed and return the allocation\n+    if (gangsToPlace \u003d\u003d 0) {\n+      return allocationRequests;\n     } else {\n-      return plan.addReservation(capReservation);\n+      // If we are here is becasue we did not manage to satisfy this request.\n+      // So we need to remove unwanted side-effect from tempAssigned (needed\n+      // for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocationRequests.entrySet()) {\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+      }\n+      // and return null to signal failure in this allocation\n+      return null;\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    // compute the gang as a resource and get the duration\n    Resource gang \u003d Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    int maxGang \u003d 0;\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageDeadline - dur \u003e\u003d stageEarliestStart) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      maxGang \u003d gangsToPlace;\n      long minPoint \u003d stageDeadline;\n      int curMaxGang \u003d maxGang;\n\n      // start placing at deadline (excluded due to [,) interval semantics and\n      // move backward\n      for (long t \u003d stageDeadline - plan.getStep(); t \u003e\u003d stageDeadline - dur\n          \u0026\u0026 maxGang \u003e 0; t \u003d t - plan.getStep()) {\n\n        // compute net available resources\n        Resource netAvailableRes \u003d Resources.clone(totalCapacity);\n        // Resources.addTo(netAvailableRes, oldResCap);\n        Resources.subtractFrom(netAvailableRes,\n            plan.getTotalCommittedResources(t));\n        Resources.subtractFrom(netAvailableRes,\n            planModifications.getCapacityAtTime(t));\n\n        // compute maximum number of gangs we could fit\n        curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, netAvailableRes, gang));\n\n        // pick the minimum between available resources in this instant, and how\n        // many gangs we have to place\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // if we were able to place any gang, record this, and decrement\n      // gangsToPlace\n      if (maxGang \u003e 0) {\n        gangsToPlace -\u003d maxGang;\n\n        ReservationInterval reservationInt \u003d\n            new ReservationInterval(stageDeadline - dur, stageDeadline);\n        Resource reservationRes \u003d\n            Resources.multiply(rr.getCapability(), rr.getConcurrency()\n                * maxGang);\n        // remember occupied space (plan is read-only till we find a plausible\n        // allocation for the entire request). This is needed since we might be\n        // placing other ReservationRequest within the same\n        // ReservationDefinition,\n        // and we must avoid double-counting the available resources\n        planModifications.addInterval(reservationInt, reservationRes);\n        allocationRequests.put(reservationInt, reservationRes);\n\n      }\n\n      // reset our new starting point (curDeadline) to the most constraining\n      // point so far, we will look \"left\" of that to find more places where\n      // to schedule gangs (for sure nothing on the \"right\" of this point can\n      // fit a full gang.\n      stageDeadline \u003d minPoint;\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is becasue we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedy.java",
          "extendedDetails": {
            "oldValue": "[reservationId-ReservationId, user-String, plan-Plan, contract-ReservationDefinition, oldReservation-ReservationAllocation]",
            "newValue": "[plan-Plan, planLoads-Map\u003cLong,Resource\u003e, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long]"
          }
        }
      ]
    },
    "0e602fa3a1529134214452fba10a90307d9c2072": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3800. Reduce storage footprint for ReservationAllocation. Contributed by Anubhav Dhoot.\n",
      "commitDate": "09/07/15 4:51 PM",
      "commitName": "0e602fa3a1529134214452fba10a90307d9c2072",
      "commitAuthor": "carlo curino",
      "commitDateOld": "03/10/14 3:43 PM",
      "commitNameOld": "5e10a13bb4759984494c6a870c7f08fb6693c9c0",
      "commitAuthorOld": "subru",
      "daysBetweenCommits": 279.05,
      "commitsBetweenForRepo": 2292,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,139 @@\n   private boolean computeAllocation(ReservationId reservationId, String user,\n       Plan plan, ReservationDefinition contract,\n       ReservationAllocation oldReservation) throws PlanningException,\n       ContractValidationException {\n     LOG.info(\"placing the following ReservationRequest: \" + contract);\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     // Here we can addd logic to adjust the ResourceDefinition to account for\n     // system \"imperfections\" (e.g., scheduling delays for large containers).\n \n     // Align with plan step conservatively (i.e., ceil arrival, and floor\n     // deadline)\n     long earliestStart \u003d contract.getArrival();\n     long step \u003d plan.getStep();\n     if (earliestStart % step !\u003d 0) {\n       earliestStart \u003d earliestStart + (step - (earliestStart % step));\n     }\n     long deadline \u003d\n         contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n     // setup temporary variables to handle time-relations between stages and\n     // intermediate answers\n     long curDeadline \u003d deadline;\n     long oldDeadline \u003d -1;\n \n-    Map\u003cReservationInterval, ReservationRequest\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, ReservationRequest\u003e();\n+    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+        new HashMap\u003cReservationInterval, Resource\u003e();\n     RLESparseResourceAllocation tempAssigned \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n     List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n         .getReservationResources();\n     ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n         .getInterpreter();\n \n+    boolean hasGang \u003d false;\n+\n     // Iterate the stages in backward from deadline\n     for (ListIterator\u003cReservationRequest\u003e li \u003d \n         stages.listIterator(stages.size()); li.hasPrevious();) {\n \n       ReservationRequest currentReservationStage \u003d li.previous();\n \n       // validate the RR respect basic constraints\n       validateInput(plan, currentReservationStage, totalCapacity);\n \n+      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+\n       // run allocation for a single stage\n-      Map\u003cReservationInterval, ReservationRequest\u003e curAlloc \u003d\n+      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n           placeSingleStage(plan, tempAssigned, currentReservationStage,\n               earliestStart, curDeadline, oldReservation, totalCapacity);\n \n       if (curAlloc \u003d\u003d null) {\n         // if we did not find an allocation for the currentReservationStage\n         // return null, unless the ReservationDefinition we are placing is of\n         // type ANY\n         if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n           throw new PlanningException(\"The GreedyAgent\"\n               + \" couldn\u0027t find a valid allocation for your request\");\n         } else {\n           continue;\n         }\n       } else {\n \n         // if we did find an allocation add it to the set of allocations\n         allocations.putAll(curAlloc);\n \n         // if this request is of type ANY we are done searching (greedy)\n         // and can return the current allocation (break-out of the search)\n         if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           break;\n         }\n \n         // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n         // round of allocation to precede the current allocation, by setting\n         // curDeadline\n         if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n             || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n           curDeadline \u003d findEarliestTime(curAlloc.keySet());\n \n           // for ORDER_NO_GAP verify that the allocation found so far has no\n           // gap, return null otherwise (the greedy procedure failed to find a\n           // no-gap\n           // allocation)\n           if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n               \u0026\u0026 oldDeadline \u003e 0) {\n             if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n                 .getStep()) {\n               throw new PlanningException(\"The GreedyAgent\"\n                   + \" couldn\u0027t find a valid allocation for your request\");\n             }\n           }\n           // keep the variable oldDeadline pointing to the last deadline we\n           // found\n           oldDeadline \u003d curDeadline;\n         }\n       }\n     }\n \n     // / If we got here is because we failed to find an allocation for the\n     // ReservationDefinition give-up and report failure to the user\n     if (allocations.isEmpty()) {\n       throw new PlanningException(\"The GreedyAgent\"\n           + \" couldn\u0027t find a valid allocation for your request\");\n     }\n \n     // create reservation with above allocations if not null/empty\n \n-    ReservationRequest ZERO_RES \u003d\n-        ReservationRequest.newInstance(Resource.newInstance(0, 0), 0);\n+    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n \n     long firstStartTime \u003d findEarliestTime(allocations.keySet());\n     \n     // add zero-padding from arrival up to the first non-null allocation\n     // to guarantee that the reservation exists starting at arrival\n     if (firstStartTime \u003e earliestStart) {\n       allocations.put(new ReservationInterval(earliestStart,\n           firstStartTime), ZERO_RES);\n       firstStartTime \u003d earliestStart;\n       // consider to add trailing zeros at the end for simmetry\n     }\n \n     // Actually add/update the reservation in the plan.\n     // This is subject to validation as other agents might be placing\n     // in parallel and there might be sharing policies the agent is not\n     // aware off.\n     ReservationAllocation capReservation \u003d\n         new InMemoryReservationAllocation(reservationId, contract, user,\n             plan.getQueueName(), firstStartTime,\n             findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation());\n+            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n     if (oldReservation !\u003d null) {\n       return plan.updateReservation(capReservation);\n     } else {\n       return plan.addReservation(capReservation);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean computeAllocation(ReservationId reservationId, String user,\n      Plan plan, ReservationDefinition contract,\n      ReservationAllocation oldReservation) throws PlanningException,\n      ContractValidationException {\n    LOG.info(\"placing the following ReservationRequest: \" + contract);\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // Here we can addd logic to adjust the ResourceDefinition to account for\n    // system \"imperfections\" (e.g., scheduling delays for large containers).\n\n    // Align with plan step conservatively (i.e., ceil arrival, and floor\n    // deadline)\n    long earliestStart \u003d contract.getArrival();\n    long step \u003d plan.getStep();\n    if (earliestStart % step !\u003d 0) {\n      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n    }\n    long deadline \u003d\n        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n\n    // setup temporary variables to handle time-relations between stages and\n    // intermediate answers\n    long curDeadline \u003d deadline;\n    long oldDeadline \u003d -1;\n\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n    RLESparseResourceAllocation tempAssigned \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n        .getReservationResources();\n    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n        .getInterpreter();\n\n    boolean hasGang \u003d false;\n\n    // Iterate the stages in backward from deadline\n    for (ListIterator\u003cReservationRequest\u003e li \u003d \n        stages.listIterator(stages.size()); li.hasPrevious();) {\n\n      ReservationRequest currentReservationStage \u003d li.previous();\n\n      // validate the RR respect basic constraints\n      validateInput(plan, currentReservationStage, totalCapacity);\n\n      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n\n      // run allocation for a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          placeSingleStage(plan, tempAssigned, currentReservationStage,\n              earliestStart, curDeadline, oldReservation, totalCapacity);\n\n      if (curAlloc \u003d\u003d null) {\n        // if we did not find an allocation for the currentReservationStage\n        // return null, unless the ReservationDefinition we are placing is of\n        // type ANY\n        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n          throw new PlanningException(\"The GreedyAgent\"\n              + \" couldn\u0027t find a valid allocation for your request\");\n        } else {\n          continue;\n        }\n      } else {\n\n        // if we did find an allocation add it to the set of allocations\n        allocations.putAll(curAlloc);\n\n        // if this request is of type ANY we are done searching (greedy)\n        // and can return the current allocation (break-out of the search)\n        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          break;\n        }\n\n        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n        // round of allocation to precede the current allocation, by setting\n        // curDeadline\n        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n\n          // for ORDER_NO_GAP verify that the allocation found so far has no\n          // gap, return null otherwise (the greedy procedure failed to find a\n          // no-gap\n          // allocation)\n          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n              \u0026\u0026 oldDeadline \u003e 0) {\n            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n                .getStep()) {\n              throw new PlanningException(\"The GreedyAgent\"\n                  + \" couldn\u0027t find a valid allocation for your request\");\n            }\n          }\n          // keep the variable oldDeadline pointing to the last deadline we\n          // found\n          oldDeadline \u003d curDeadline;\n        }\n      }\n    }\n\n    // / If we got here is because we failed to find an allocation for the\n    // ReservationDefinition give-up and report failure to the user\n    if (allocations.isEmpty()) {\n      throw new PlanningException(\"The GreedyAgent\"\n          + \" couldn\u0027t find a valid allocation for your request\");\n    }\n\n    // create reservation with above allocations if not null/empty\n\n    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n\n    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n    \n    // add zero-padding from arrival up to the first non-null allocation\n    // to guarantee that the reservation exists starting at arrival\n    if (firstStartTime \u003e earliestStart) {\n      allocations.put(new ReservationInterval(earliestStart,\n          firstStartTime), ZERO_RES);\n      firstStartTime \u003d earliestStart;\n      // consider to add trailing zeros at the end for simmetry\n    }\n\n    // Actually add/update the reservation in the plan.\n    // This is subject to validation as other agents might be placing\n    // in parallel and there might be sharing policies the agent is not\n    // aware off.\n    ReservationAllocation capReservation \u003d\n        new InMemoryReservationAllocation(reservationId, contract, user,\n            plan.getQueueName(), firstStartTime,\n            findLatestTime(allocations.keySet()), allocations,\n            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n    if (oldReservation !\u003d null) {\n      return plan.updateReservation(capReservation);\n    } else {\n      return plan.addReservation(capReservation);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/GreedyReservationAgent.java",
      "extendedDetails": {}
    },
    "f66ffcf832235e0da0bb050fff08e248b547c360": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1710. Logic to find allocations within a Plan that satisfy user ReservationRequest(s). Contributed by Carlo Curino and Subru Krishnan.\n(cherry picked from commit aef7928899b37262773f3dc117157bb746bf8918)\n",
      "commitDate": "03/10/14 3:41 PM",
      "commitName": "f66ffcf832235e0da0bb050fff08e248b547c360",
      "commitAuthor": "carlo curino",
      "diff": "@@ -0,0 +1,136 @@\n+  private boolean computeAllocation(ReservationId reservationId, String user,\n+      Plan plan, ReservationDefinition contract,\n+      ReservationAllocation oldReservation) throws PlanningException,\n+      ContractValidationException {\n+    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+\n+    Resource totalCapacity \u003d plan.getTotalCapacity();\n+\n+    // Here we can addd logic to adjust the ResourceDefinition to account for\n+    // system \"imperfections\" (e.g., scheduling delays for large containers).\n+\n+    // Align with plan step conservatively (i.e., ceil arrival, and floor\n+    // deadline)\n+    long earliestStart \u003d contract.getArrival();\n+    long step \u003d plan.getStep();\n+    if (earliestStart % step !\u003d 0) {\n+      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n+    }\n+    long deadline \u003d\n+        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n+\n+    // setup temporary variables to handle time-relations between stages and\n+    // intermediate answers\n+    long curDeadline \u003d deadline;\n+    long oldDeadline \u003d -1;\n+\n+    Map\u003cReservationInterval, ReservationRequest\u003e allocations \u003d\n+        new HashMap\u003cReservationInterval, ReservationRequest\u003e();\n+    RLESparseResourceAllocation tempAssigned \u003d\n+        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n+            plan.getMinimumAllocation());\n+\n+    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n+        .getReservationResources();\n+    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n+        .getInterpreter();\n+\n+    // Iterate the stages in backward from deadline\n+    for (ListIterator\u003cReservationRequest\u003e li \u003d \n+        stages.listIterator(stages.size()); li.hasPrevious();) {\n+\n+      ReservationRequest currentReservationStage \u003d li.previous();\n+\n+      // validate the RR respect basic constraints\n+      validateInput(plan, currentReservationStage, totalCapacity);\n+\n+      // run allocation for a single stage\n+      Map\u003cReservationInterval, ReservationRequest\u003e curAlloc \u003d\n+          placeSingleStage(plan, tempAssigned, currentReservationStage,\n+              earliestStart, curDeadline, oldReservation, totalCapacity);\n+\n+      if (curAlloc \u003d\u003d null) {\n+        // if we did not find an allocation for the currentReservationStage\n+        // return null, unless the ReservationDefinition we are placing is of\n+        // type ANY\n+        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n+          throw new PlanningException(\"The GreedyAgent\"\n+              + \" couldn\u0027t find a valid allocation for your request\");\n+        } else {\n+          continue;\n+        }\n+      } else {\n+\n+        // if we did find an allocation add it to the set of allocations\n+        allocations.putAll(curAlloc);\n+\n+        // if this request is of type ANY we are done searching (greedy)\n+        // and can return the current allocation (break-out of the search)\n+        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n+          break;\n+        }\n+\n+        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n+        // round of allocation to precede the current allocation, by setting\n+        // curDeadline\n+        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n+\n+          // for ORDER_NO_GAP verify that the allocation found so far has no\n+          // gap, return null otherwise (the greedy procedure failed to find a\n+          // no-gap\n+          // allocation)\n+          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n+              \u0026\u0026 oldDeadline \u003e 0) {\n+            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n+                .getStep()) {\n+              throw new PlanningException(\"The GreedyAgent\"\n+                  + \" couldn\u0027t find a valid allocation for your request\");\n+            }\n+          }\n+          // keep the variable oldDeadline pointing to the last deadline we\n+          // found\n+          oldDeadline \u003d curDeadline;\n+        }\n+      }\n+    }\n+\n+    // / If we got here is because we failed to find an allocation for the\n+    // ReservationDefinition give-up and report failure to the user\n+    if (allocations.isEmpty()) {\n+      throw new PlanningException(\"The GreedyAgent\"\n+          + \" couldn\u0027t find a valid allocation for your request\");\n+    }\n+\n+    // create reservation with above allocations if not null/empty\n+\n+    ReservationRequest ZERO_RES \u003d\n+        ReservationRequest.newInstance(Resource.newInstance(0, 0), 0);\n+\n+    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n+    \n+    // add zero-padding from arrival up to the first non-null allocation\n+    // to guarantee that the reservation exists starting at arrival\n+    if (firstStartTime \u003e earliestStart) {\n+      allocations.put(new ReservationInterval(earliestStart,\n+          firstStartTime), ZERO_RES);\n+      firstStartTime \u003d earliestStart;\n+      // consider to add trailing zeros at the end for simmetry\n+    }\n+\n+    // Actually add/update the reservation in the plan.\n+    // This is subject to validation as other agents might be placing\n+    // in parallel and there might be sharing policies the agent is not\n+    // aware off.\n+    ReservationAllocation capReservation \u003d\n+        new InMemoryReservationAllocation(reservationId, contract, user,\n+            plan.getQueueName(), firstStartTime,\n+            findLatestTime(allocations.keySet()), allocations,\n+            plan.getResourceCalculator(), plan.getMinimumAllocation());\n+    if (oldReservation !\u003d null) {\n+      return plan.updateReservation(capReservation);\n+    } else {\n+      return plan.addReservation(capReservation);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean computeAllocation(ReservationId reservationId, String user,\n      Plan plan, ReservationDefinition contract,\n      ReservationAllocation oldReservation) throws PlanningException,\n      ContractValidationException {\n    LOG.info(\"placing the following ReservationRequest: \" + contract);\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // Here we can addd logic to adjust the ResourceDefinition to account for\n    // system \"imperfections\" (e.g., scheduling delays for large containers).\n\n    // Align with plan step conservatively (i.e., ceil arrival, and floor\n    // deadline)\n    long earliestStart \u003d contract.getArrival();\n    long step \u003d plan.getStep();\n    if (earliestStart % step !\u003d 0) {\n      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n    }\n    long deadline \u003d\n        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n\n    // setup temporary variables to handle time-relations between stages and\n    // intermediate answers\n    long curDeadline \u003d deadline;\n    long oldDeadline \u003d -1;\n\n    Map\u003cReservationInterval, ReservationRequest\u003e allocations \u003d\n        new HashMap\u003cReservationInterval, ReservationRequest\u003e();\n    RLESparseResourceAllocation tempAssigned \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n        .getReservationResources();\n    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n        .getInterpreter();\n\n    // Iterate the stages in backward from deadline\n    for (ListIterator\u003cReservationRequest\u003e li \u003d \n        stages.listIterator(stages.size()); li.hasPrevious();) {\n\n      ReservationRequest currentReservationStage \u003d li.previous();\n\n      // validate the RR respect basic constraints\n      validateInput(plan, currentReservationStage, totalCapacity);\n\n      // run allocation for a single stage\n      Map\u003cReservationInterval, ReservationRequest\u003e curAlloc \u003d\n          placeSingleStage(plan, tempAssigned, currentReservationStage,\n              earliestStart, curDeadline, oldReservation, totalCapacity);\n\n      if (curAlloc \u003d\u003d null) {\n        // if we did not find an allocation for the currentReservationStage\n        // return null, unless the ReservationDefinition we are placing is of\n        // type ANY\n        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n          throw new PlanningException(\"The GreedyAgent\"\n              + \" couldn\u0027t find a valid allocation for your request\");\n        } else {\n          continue;\n        }\n      } else {\n\n        // if we did find an allocation add it to the set of allocations\n        allocations.putAll(curAlloc);\n\n        // if this request is of type ANY we are done searching (greedy)\n        // and can return the current allocation (break-out of the search)\n        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          break;\n        }\n\n        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n        // round of allocation to precede the current allocation, by setting\n        // curDeadline\n        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n\n          // for ORDER_NO_GAP verify that the allocation found so far has no\n          // gap, return null otherwise (the greedy procedure failed to find a\n          // no-gap\n          // allocation)\n          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n              \u0026\u0026 oldDeadline \u003e 0) {\n            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n                .getStep()) {\n              throw new PlanningException(\"The GreedyAgent\"\n                  + \" couldn\u0027t find a valid allocation for your request\");\n            }\n          }\n          // keep the variable oldDeadline pointing to the last deadline we\n          // found\n          oldDeadline \u003d curDeadline;\n        }\n      }\n    }\n\n    // / If we got here is because we failed to find an allocation for the\n    // ReservationDefinition give-up and report failure to the user\n    if (allocations.isEmpty()) {\n      throw new PlanningException(\"The GreedyAgent\"\n          + \" couldn\u0027t find a valid allocation for your request\");\n    }\n\n    // create reservation with above allocations if not null/empty\n\n    ReservationRequest ZERO_RES \u003d\n        ReservationRequest.newInstance(Resource.newInstance(0, 0), 0);\n\n    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n    \n    // add zero-padding from arrival up to the first non-null allocation\n    // to guarantee that the reservation exists starting at arrival\n    if (firstStartTime \u003e earliestStart) {\n      allocations.put(new ReservationInterval(earliestStart,\n          firstStartTime), ZERO_RES);\n      firstStartTime \u003d earliestStart;\n      // consider to add trailing zeros at the end for simmetry\n    }\n\n    // Actually add/update the reservation in the plan.\n    // This is subject to validation as other agents might be placing\n    // in parallel and there might be sharing policies the agent is not\n    // aware off.\n    ReservationAllocation capReservation \u003d\n        new InMemoryReservationAllocation(reservationId, contract, user,\n            plan.getQueueName(), firstStartTime,\n            findLatestTime(allocations.keySet()), allocations,\n            plan.getResourceCalculator(), plan.getMinimumAllocation());\n    if (oldReservation !\u003d null) {\n      return plan.updateReservation(capReservation);\n    } else {\n      return plan.addReservation(capReservation);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/GreedyReservationAgent.java"
    }
  }
}