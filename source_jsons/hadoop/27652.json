{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "WeightedRandomRouterPolicy.java",
  "functionName": "getHomeSubcluster",
  "functionId": "getHomeSubcluster___appSubmissionContext-ApplicationSubmissionContext__blacklist-List__SubClusterId__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/router/WeightedRandomRouterPolicy.java",
  "functionStartLine": 40,
  "functionEndLine": 79,
  "numCommitsSeen": 9,
  "timeTaken": 2553,
  "changeHistory": [
    "13fcfb3d46ee7a0d606b4bb221d1cd66ef2a5a7c",
    "43a97174fe49aa0c25d03b8a970a46d4bebf1aa8",
    "4cfec943b177e2123a935e70d39776521883c2bc",
    "4128c9522dcdc16bb3527f74a48ed1242458a165",
    "0662996b6af19deece21b95b961d9362accc5159"
  ],
  "changeHistoryShort": {
    "13fcfb3d46ee7a0d606b4bb221d1cd66ef2a5a7c": "Ybodychange",
    "43a97174fe49aa0c25d03b8a970a46d4bebf1aa8": "Ybodychange",
    "4cfec943b177e2123a935e70d39776521883c2bc": "Ymultichange(Yparameterchange,Ybodychange)",
    "4128c9522dcdc16bb3527f74a48ed1242458a165": "Ybodychange",
    "0662996b6af19deece21b95b961d9362accc5159": "Yintroduced"
  },
  "changeHistoryDetails": {
    "13fcfb3d46ee7a0d606b4bb221d1cd66ef2a5a7c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7317. Fix overallocation resulted from ceiling in LocalityMulticastAMRMProxyPolicy. (contributed by Botong Huang via curino)\n",
      "commitDate": "12/10/17 10:38 AM",
      "commitName": "13fcfb3d46ee7a0d606b4bb221d1cd66ef2a5a7c",
      "commitAuthor": "Carlo Curino",
      "commitDateOld": "01/08/17 5:28 PM",
      "commitNameOld": "43a97174fe49aa0c25d03b8a970a46d4bebf1aa8",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 71.72,
      "commitsBetweenForRepo": 638,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,40 @@\n   public SubClusterId getHomeSubcluster(\n       ApplicationSubmissionContext appSubmissionContext,\n       List\u003cSubClusterId\u003e blacklist) throws YarnException {\n \n     // null checks and default-queue behavior\n     validate(appSubmissionContext);\n \n     Map\u003cSubClusterId, SubClusterInfo\u003e activeSubclusters \u003d\n         getActiveSubclusters();\n \n     FederationPolicyUtils.validateSubClusterAvailability(\n         new ArrayList\u003cSubClusterId\u003e(activeSubclusters.keySet()), blacklist);\n \n     // note: we cannot pre-compute the weights, as the set of activeSubcluster\n     // changes dynamically (and this would unfairly spread the load to\n     // sub-clusters adjacent to an inactive one), hence we need to count/scan\n     // the list and based on weight pick the next sub-cluster.\n     Map\u003cSubClusterIdInfo, Float\u003e weights \u003d\n         getPolicyInfo().getRouterPolicyWeights();\n \n-    float totActiveWeight \u003d 0;\n+    ArrayList\u003cFloat\u003e weightList \u003d new ArrayList\u003c\u003e();\n+    ArrayList\u003cSubClusterId\u003e scIdList \u003d new ArrayList\u003c\u003e();\n     for (Map.Entry\u003cSubClusterIdInfo, Float\u003e entry : weights.entrySet()) {\n       if (blacklist !\u003d null \u0026\u0026 blacklist.contains(entry.getKey().toId())) {\n         continue;\n       }\n       if (entry.getKey() !\u003d null\n           \u0026\u0026 activeSubclusters.containsKey(entry.getKey().toId())) {\n-        totActiveWeight +\u003d entry.getValue();\n+        weightList.add(entry.getValue());\n+        scIdList.add(entry.getKey().toId());\n       }\n     }\n-    float lookupValue \u003d rand.nextFloat() * totActiveWeight;\n \n-    for (SubClusterId id : activeSubclusters.keySet()) {\n-      if (blacklist !\u003d null \u0026\u0026 blacklist.contains(id)) {\n-        continue;\n-      }\n-      SubClusterIdInfo idInfo \u003d new SubClusterIdInfo(id);\n-      if (weights.containsKey(idInfo)) {\n-        lookupValue -\u003d weights.get(idInfo);\n-      }\n-      if (lookupValue \u003c\u003d 0) {\n-        return id;\n-      }\n+    int pickedIndex \u003d FederationPolicyUtils.getWeightedRandom(weightList);\n+    if (pickedIndex \u003d\u003d -1) {\n+      throw new FederationPolicyException(\n+          \"No positive weight found on active subclusters\");\n     }\n-    // should never happen\n-    return null;\n+    return scIdList.get(pickedIndex);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public SubClusterId getHomeSubcluster(\n      ApplicationSubmissionContext appSubmissionContext,\n      List\u003cSubClusterId\u003e blacklist) throws YarnException {\n\n    // null checks and default-queue behavior\n    validate(appSubmissionContext);\n\n    Map\u003cSubClusterId, SubClusterInfo\u003e activeSubclusters \u003d\n        getActiveSubclusters();\n\n    FederationPolicyUtils.validateSubClusterAvailability(\n        new ArrayList\u003cSubClusterId\u003e(activeSubclusters.keySet()), blacklist);\n\n    // note: we cannot pre-compute the weights, as the set of activeSubcluster\n    // changes dynamically (and this would unfairly spread the load to\n    // sub-clusters adjacent to an inactive one), hence we need to count/scan\n    // the list and based on weight pick the next sub-cluster.\n    Map\u003cSubClusterIdInfo, Float\u003e weights \u003d\n        getPolicyInfo().getRouterPolicyWeights();\n\n    ArrayList\u003cFloat\u003e weightList \u003d new ArrayList\u003c\u003e();\n    ArrayList\u003cSubClusterId\u003e scIdList \u003d new ArrayList\u003c\u003e();\n    for (Map.Entry\u003cSubClusterIdInfo, Float\u003e entry : weights.entrySet()) {\n      if (blacklist !\u003d null \u0026\u0026 blacklist.contains(entry.getKey().toId())) {\n        continue;\n      }\n      if (entry.getKey() !\u003d null\n          \u0026\u0026 activeSubclusters.containsKey(entry.getKey().toId())) {\n        weightList.add(entry.getValue());\n        scIdList.add(entry.getKey().toId());\n      }\n    }\n\n    int pickedIndex \u003d FederationPolicyUtils.getWeightedRandom(weightList);\n    if (pickedIndex \u003d\u003d -1) {\n      throw new FederationPolicyException(\n          \"No positive weight found on active subclusters\");\n    }\n    return scIdList.get(pickedIndex);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/router/WeightedRandomRouterPolicy.java",
      "extendedDetails": {}
    },
    "43a97174fe49aa0c25d03b8a970a46d4bebf1aa8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3659. Federation: routing client invocations transparently to multiple RMs. (Giovanni Matteo Fumarola via Subru).\n\n(cherry picked from commit 52daa6d971ae408d121b3737ea8c0575e7e8516d)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "43a97174fe49aa0c25d03b8a970a46d4bebf1aa8",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/08/17 5:28 PM",
      "commitNameOld": "4cfec943b177e2123a935e70d39776521883c2bc",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,47 @@\n   public SubClusterId getHomeSubcluster(\n       ApplicationSubmissionContext appSubmissionContext,\n       List\u003cSubClusterId\u003e blacklist) throws YarnException {\n \n     // null checks and default-queue behavior\n     validate(appSubmissionContext);\n \n     Map\u003cSubClusterId, SubClusterInfo\u003e activeSubclusters \u003d\n         getActiveSubclusters();\n \n+    FederationPolicyUtils.validateSubClusterAvailability(\n+        new ArrayList\u003cSubClusterId\u003e(activeSubclusters.keySet()), blacklist);\n+\n     // note: we cannot pre-compute the weights, as the set of activeSubcluster\n     // changes dynamically (and this would unfairly spread the load to\n     // sub-clusters adjacent to an inactive one), hence we need to count/scan\n     // the list and based on weight pick the next sub-cluster.\n     Map\u003cSubClusterIdInfo, Float\u003e weights \u003d\n         getPolicyInfo().getRouterPolicyWeights();\n \n     float totActiveWeight \u003d 0;\n     for (Map.Entry\u003cSubClusterIdInfo, Float\u003e entry : weights.entrySet()) {\n       if (blacklist !\u003d null \u0026\u0026 blacklist.contains(entry.getKey().toId())) {\n         continue;\n       }\n       if (entry.getKey() !\u003d null\n           \u0026\u0026 activeSubclusters.containsKey(entry.getKey().toId())) {\n         totActiveWeight +\u003d entry.getValue();\n       }\n     }\n     float lookupValue \u003d rand.nextFloat() * totActiveWeight;\n \n     for (SubClusterId id : activeSubclusters.keySet()) {\n       if (blacklist !\u003d null \u0026\u0026 blacklist.contains(id)) {\n         continue;\n       }\n       SubClusterIdInfo idInfo \u003d new SubClusterIdInfo(id);\n       if (weights.containsKey(idInfo)) {\n         lookupValue -\u003d weights.get(idInfo);\n       }\n       if (lookupValue \u003c\u003d 0) {\n         return id;\n       }\n     }\n     // should never happen\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public SubClusterId getHomeSubcluster(\n      ApplicationSubmissionContext appSubmissionContext,\n      List\u003cSubClusterId\u003e blacklist) throws YarnException {\n\n    // null checks and default-queue behavior\n    validate(appSubmissionContext);\n\n    Map\u003cSubClusterId, SubClusterInfo\u003e activeSubclusters \u003d\n        getActiveSubclusters();\n\n    FederationPolicyUtils.validateSubClusterAvailability(\n        new ArrayList\u003cSubClusterId\u003e(activeSubclusters.keySet()), blacklist);\n\n    // note: we cannot pre-compute the weights, as the set of activeSubcluster\n    // changes dynamically (and this would unfairly spread the load to\n    // sub-clusters adjacent to an inactive one), hence we need to count/scan\n    // the list and based on weight pick the next sub-cluster.\n    Map\u003cSubClusterIdInfo, Float\u003e weights \u003d\n        getPolicyInfo().getRouterPolicyWeights();\n\n    float totActiveWeight \u003d 0;\n    for (Map.Entry\u003cSubClusterIdInfo, Float\u003e entry : weights.entrySet()) {\n      if (blacklist !\u003d null \u0026\u0026 blacklist.contains(entry.getKey().toId())) {\n        continue;\n      }\n      if (entry.getKey() !\u003d null\n          \u0026\u0026 activeSubclusters.containsKey(entry.getKey().toId())) {\n        totActiveWeight +\u003d entry.getValue();\n      }\n    }\n    float lookupValue \u003d rand.nextFloat() * totActiveWeight;\n\n    for (SubClusterId id : activeSubclusters.keySet()) {\n      if (blacklist !\u003d null \u0026\u0026 blacklist.contains(id)) {\n        continue;\n      }\n      SubClusterIdInfo idInfo \u003d new SubClusterIdInfo(id);\n      if (weights.containsKey(idInfo)) {\n        lookupValue -\u003d weights.get(idInfo);\n      }\n      if (lookupValue \u003c\u003d 0) {\n        return id;\n      }\n    }\n    // should never happen\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/router/WeightedRandomRouterPolicy.java",
      "extendedDetails": {}
    },
    "4cfec943b177e2123a935e70d39776521883c2bc": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6724. Add ability to blacklist sub-clusters when invoking Routing policies. (Giovanni Matteo Fumarola via Subru).\n\n(cherry picked from commit f8e5de59697cb78686f0e605dc7e93628b5f3297)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "4cfec943b177e2123a935e70d39776521883c2bc",
      "commitAuthor": "Subru Krishnan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6724. Add ability to blacklist sub-clusters when invoking Routing policies. (Giovanni Matteo Fumarola via Subru).\n\n(cherry picked from commit f8e5de59697cb78686f0e605dc7e93628b5f3297)\n",
          "commitDate": "01/08/17 5:28 PM",
          "commitName": "4cfec943b177e2123a935e70d39776521883c2bc",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "01/08/17 5:28 PM",
          "commitNameOld": "4128c9522dcdc16bb3527f74a48ed1242458a165",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,44 @@\n   public SubClusterId getHomeSubcluster(\n-      ApplicationSubmissionContext appSubmissionContext) throws YarnException {\n+      ApplicationSubmissionContext appSubmissionContext,\n+      List\u003cSubClusterId\u003e blacklist) throws YarnException {\n \n     // null checks and default-queue behavior\n     validate(appSubmissionContext);\n \n     Map\u003cSubClusterId, SubClusterInfo\u003e activeSubclusters \u003d\n         getActiveSubclusters();\n \n     // note: we cannot pre-compute the weights, as the set of activeSubcluster\n     // changes dynamically (and this would unfairly spread the load to\n     // sub-clusters adjacent to an inactive one), hence we need to count/scan\n     // the list and based on weight pick the next sub-cluster.\n     Map\u003cSubClusterIdInfo, Float\u003e weights \u003d\n         getPolicyInfo().getRouterPolicyWeights();\n \n     float totActiveWeight \u003d 0;\n     for (Map.Entry\u003cSubClusterIdInfo, Float\u003e entry : weights.entrySet()) {\n+      if (blacklist !\u003d null \u0026\u0026 blacklist.contains(entry.getKey().toId())) {\n+        continue;\n+      }\n       if (entry.getKey() !\u003d null\n           \u0026\u0026 activeSubclusters.containsKey(entry.getKey().toId())) {\n         totActiveWeight +\u003d entry.getValue();\n       }\n     }\n     float lookupValue \u003d rand.nextFloat() * totActiveWeight;\n \n     for (SubClusterId id : activeSubclusters.keySet()) {\n+      if (blacklist !\u003d null \u0026\u0026 blacklist.contains(id)) {\n+        continue;\n+      }\n       SubClusterIdInfo idInfo \u003d new SubClusterIdInfo(id);\n       if (weights.containsKey(idInfo)) {\n         lookupValue -\u003d weights.get(idInfo);\n       }\n       if (lookupValue \u003c\u003d 0) {\n         return id;\n       }\n     }\n     // should never happen\n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public SubClusterId getHomeSubcluster(\n      ApplicationSubmissionContext appSubmissionContext,\n      List\u003cSubClusterId\u003e blacklist) throws YarnException {\n\n    // null checks and default-queue behavior\n    validate(appSubmissionContext);\n\n    Map\u003cSubClusterId, SubClusterInfo\u003e activeSubclusters \u003d\n        getActiveSubclusters();\n\n    // note: we cannot pre-compute the weights, as the set of activeSubcluster\n    // changes dynamically (and this would unfairly spread the load to\n    // sub-clusters adjacent to an inactive one), hence we need to count/scan\n    // the list and based on weight pick the next sub-cluster.\n    Map\u003cSubClusterIdInfo, Float\u003e weights \u003d\n        getPolicyInfo().getRouterPolicyWeights();\n\n    float totActiveWeight \u003d 0;\n    for (Map.Entry\u003cSubClusterIdInfo, Float\u003e entry : weights.entrySet()) {\n      if (blacklist !\u003d null \u0026\u0026 blacklist.contains(entry.getKey().toId())) {\n        continue;\n      }\n      if (entry.getKey() !\u003d null\n          \u0026\u0026 activeSubclusters.containsKey(entry.getKey().toId())) {\n        totActiveWeight +\u003d entry.getValue();\n      }\n    }\n    float lookupValue \u003d rand.nextFloat() * totActiveWeight;\n\n    for (SubClusterId id : activeSubclusters.keySet()) {\n      if (blacklist !\u003d null \u0026\u0026 blacklist.contains(id)) {\n        continue;\n      }\n      SubClusterIdInfo idInfo \u003d new SubClusterIdInfo(id);\n      if (weights.containsKey(idInfo)) {\n        lookupValue -\u003d weights.get(idInfo);\n      }\n      if (lookupValue \u003c\u003d 0) {\n        return id;\n      }\n    }\n    // should never happen\n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/router/WeightedRandomRouterPolicy.java",
          "extendedDetails": {
            "oldValue": "[appSubmissionContext-ApplicationSubmissionContext]",
            "newValue": "[appSubmissionContext-ApplicationSubmissionContext, blacklist-List\u003cSubClusterId\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6724. Add ability to blacklist sub-clusters when invoking Routing policies. (Giovanni Matteo Fumarola via Subru).\n\n(cherry picked from commit f8e5de59697cb78686f0e605dc7e93628b5f3297)\n",
          "commitDate": "01/08/17 5:28 PM",
          "commitName": "4cfec943b177e2123a935e70d39776521883c2bc",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "01/08/17 5:28 PM",
          "commitNameOld": "4128c9522dcdc16bb3527f74a48ed1242458a165",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,44 @@\n   public SubClusterId getHomeSubcluster(\n-      ApplicationSubmissionContext appSubmissionContext) throws YarnException {\n+      ApplicationSubmissionContext appSubmissionContext,\n+      List\u003cSubClusterId\u003e blacklist) throws YarnException {\n \n     // null checks and default-queue behavior\n     validate(appSubmissionContext);\n \n     Map\u003cSubClusterId, SubClusterInfo\u003e activeSubclusters \u003d\n         getActiveSubclusters();\n \n     // note: we cannot pre-compute the weights, as the set of activeSubcluster\n     // changes dynamically (and this would unfairly spread the load to\n     // sub-clusters adjacent to an inactive one), hence we need to count/scan\n     // the list and based on weight pick the next sub-cluster.\n     Map\u003cSubClusterIdInfo, Float\u003e weights \u003d\n         getPolicyInfo().getRouterPolicyWeights();\n \n     float totActiveWeight \u003d 0;\n     for (Map.Entry\u003cSubClusterIdInfo, Float\u003e entry : weights.entrySet()) {\n+      if (blacklist !\u003d null \u0026\u0026 blacklist.contains(entry.getKey().toId())) {\n+        continue;\n+      }\n       if (entry.getKey() !\u003d null\n           \u0026\u0026 activeSubclusters.containsKey(entry.getKey().toId())) {\n         totActiveWeight +\u003d entry.getValue();\n       }\n     }\n     float lookupValue \u003d rand.nextFloat() * totActiveWeight;\n \n     for (SubClusterId id : activeSubclusters.keySet()) {\n+      if (blacklist !\u003d null \u0026\u0026 blacklist.contains(id)) {\n+        continue;\n+      }\n       SubClusterIdInfo idInfo \u003d new SubClusterIdInfo(id);\n       if (weights.containsKey(idInfo)) {\n         lookupValue -\u003d weights.get(idInfo);\n       }\n       if (lookupValue \u003c\u003d 0) {\n         return id;\n       }\n     }\n     // should never happen\n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public SubClusterId getHomeSubcluster(\n      ApplicationSubmissionContext appSubmissionContext,\n      List\u003cSubClusterId\u003e blacklist) throws YarnException {\n\n    // null checks and default-queue behavior\n    validate(appSubmissionContext);\n\n    Map\u003cSubClusterId, SubClusterInfo\u003e activeSubclusters \u003d\n        getActiveSubclusters();\n\n    // note: we cannot pre-compute the weights, as the set of activeSubcluster\n    // changes dynamically (and this would unfairly spread the load to\n    // sub-clusters adjacent to an inactive one), hence we need to count/scan\n    // the list and based on weight pick the next sub-cluster.\n    Map\u003cSubClusterIdInfo, Float\u003e weights \u003d\n        getPolicyInfo().getRouterPolicyWeights();\n\n    float totActiveWeight \u003d 0;\n    for (Map.Entry\u003cSubClusterIdInfo, Float\u003e entry : weights.entrySet()) {\n      if (blacklist !\u003d null \u0026\u0026 blacklist.contains(entry.getKey().toId())) {\n        continue;\n      }\n      if (entry.getKey() !\u003d null\n          \u0026\u0026 activeSubclusters.containsKey(entry.getKey().toId())) {\n        totActiveWeight +\u003d entry.getValue();\n      }\n    }\n    float lookupValue \u003d rand.nextFloat() * totActiveWeight;\n\n    for (SubClusterId id : activeSubclusters.keySet()) {\n      if (blacklist !\u003d null \u0026\u0026 blacklist.contains(id)) {\n        continue;\n      }\n      SubClusterIdInfo idInfo \u003d new SubClusterIdInfo(id);\n      if (weights.containsKey(idInfo)) {\n        lookupValue -\u003d weights.get(idInfo);\n      }\n      if (lookupValue \u003c\u003d 0) {\n        return id;\n      }\n    }\n    // should never happen\n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/router/WeightedRandomRouterPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "4128c9522dcdc16bb3527f74a48ed1242458a165": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5676. Add a HashBasedRouterPolicy, and small policies and test refactoring. (Carlo Curino via Subru).\n\n(cherry picked from commit 575137f41c27eb72d05d923337f3030a35403e8f)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "4128c9522dcdc16bb3527f74a48ed1242458a165",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/08/17 5:28 PM",
      "commitNameOld": "1dadd0b45a6a605da72eb304808edb49fc66da45",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,37 @@\n   public SubClusterId getHomeSubcluster(\n       ApplicationSubmissionContext appSubmissionContext) throws YarnException {\n \n+    // null checks and default-queue behavior\n+    validate(appSubmissionContext);\n+\n     Map\u003cSubClusterId, SubClusterInfo\u003e activeSubclusters \u003d\n         getActiveSubclusters();\n \n     // note: we cannot pre-compute the weights, as the set of activeSubcluster\n     // changes dynamically (and this would unfairly spread the load to\n     // sub-clusters adjacent to an inactive one), hence we need to count/scan\n     // the list and based on weight pick the next sub-cluster.\n     Map\u003cSubClusterIdInfo, Float\u003e weights \u003d\n         getPolicyInfo().getRouterPolicyWeights();\n \n     float totActiveWeight \u003d 0;\n     for (Map.Entry\u003cSubClusterIdInfo, Float\u003e entry : weights.entrySet()) {\n       if (entry.getKey() !\u003d null\n           \u0026\u0026 activeSubclusters.containsKey(entry.getKey().toId())) {\n         totActiveWeight +\u003d entry.getValue();\n       }\n     }\n     float lookupValue \u003d rand.nextFloat() * totActiveWeight;\n \n     for (SubClusterId id : activeSubclusters.keySet()) {\n       SubClusterIdInfo idInfo \u003d new SubClusterIdInfo(id);\n       if (weights.containsKey(idInfo)) {\n         lookupValue -\u003d weights.get(idInfo);\n       }\n       if (lookupValue \u003c\u003d 0) {\n         return id;\n       }\n     }\n     // should never happen\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public SubClusterId getHomeSubcluster(\n      ApplicationSubmissionContext appSubmissionContext) throws YarnException {\n\n    // null checks and default-queue behavior\n    validate(appSubmissionContext);\n\n    Map\u003cSubClusterId, SubClusterInfo\u003e activeSubclusters \u003d\n        getActiveSubclusters();\n\n    // note: we cannot pre-compute the weights, as the set of activeSubcluster\n    // changes dynamically (and this would unfairly spread the load to\n    // sub-clusters adjacent to an inactive one), hence we need to count/scan\n    // the list and based on weight pick the next sub-cluster.\n    Map\u003cSubClusterIdInfo, Float\u003e weights \u003d\n        getPolicyInfo().getRouterPolicyWeights();\n\n    float totActiveWeight \u003d 0;\n    for (Map.Entry\u003cSubClusterIdInfo, Float\u003e entry : weights.entrySet()) {\n      if (entry.getKey() !\u003d null\n          \u0026\u0026 activeSubclusters.containsKey(entry.getKey().toId())) {\n        totActiveWeight +\u003d entry.getValue();\n      }\n    }\n    float lookupValue \u003d rand.nextFloat() * totActiveWeight;\n\n    for (SubClusterId id : activeSubclusters.keySet()) {\n      SubClusterIdInfo idInfo \u003d new SubClusterIdInfo(id);\n      if (weights.containsKey(idInfo)) {\n        lookupValue -\u003d weights.get(idInfo);\n      }\n      if (lookupValue \u003c\u003d 0) {\n        return id;\n      }\n    }\n    // should never happen\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/router/WeightedRandomRouterPolicy.java",
      "extendedDetails": {}
    },
    "0662996b6af19deece21b95b961d9362accc5159": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5324. Stateless Federation router policies implementation. (Carlo Curino via Subru).\n\n(cherry picked from commit 1298127bdad60a961441dc7e25cdc2553c119f33)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "0662996b6af19deece21b95b961d9362accc5159",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,35 @@\n+  public SubClusterId getHomeSubcluster(\n+      ApplicationSubmissionContext appSubmissionContext)\n+      throws YarnException {\n+\n+    Map\u003cSubClusterId, SubClusterInfo\u003e activeSubclusters \u003d\n+        getActiveSubclusters();\n+\n+    // note: we cannot pre-compute the weights, as the set of activeSubcluster\n+    // changes dynamically (and this would unfairly spread the load to\n+    // sub-clusters adjacent to an inactive one), hence we need to count/scan\n+    // the list and based on weight pick the next sub-cluster.\n+    Map\u003cSubClusterIdInfo, Float\u003e weights \u003d getPolicyInfo()\n+        .getRouterPolicyWeights();\n+\n+    float totActiveWeight \u003d 0;\n+    for(Map.Entry\u003cSubClusterIdInfo, Float\u003e entry : weights.entrySet()){\n+      if(entry.getKey()!\u003dnull \u0026\u0026 activeSubclusters.containsKey(entry.getKey()\n+          .toId())){\n+        totActiveWeight +\u003d entry.getValue();\n+      }\n+    }\n+    float lookupValue \u003d rand.nextFloat() * totActiveWeight;\n+\n+    for (SubClusterId id : activeSubclusters.keySet()) {\n+      SubClusterIdInfo idInfo \u003d new SubClusterIdInfo(id);\n+      if (weights.containsKey(idInfo)) {\n+        lookupValue -\u003d weights.get(idInfo);\n+      }\n+      if (lookupValue \u003c\u003d 0) {\n+        return id;\n+      }\n+    }\n+    //should never happen\n+    return null;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public SubClusterId getHomeSubcluster(\n      ApplicationSubmissionContext appSubmissionContext)\n      throws YarnException {\n\n    Map\u003cSubClusterId, SubClusterInfo\u003e activeSubclusters \u003d\n        getActiveSubclusters();\n\n    // note: we cannot pre-compute the weights, as the set of activeSubcluster\n    // changes dynamically (and this would unfairly spread the load to\n    // sub-clusters adjacent to an inactive one), hence we need to count/scan\n    // the list and based on weight pick the next sub-cluster.\n    Map\u003cSubClusterIdInfo, Float\u003e weights \u003d getPolicyInfo()\n        .getRouterPolicyWeights();\n\n    float totActiveWeight \u003d 0;\n    for(Map.Entry\u003cSubClusterIdInfo, Float\u003e entry : weights.entrySet()){\n      if(entry.getKey()!\u003dnull \u0026\u0026 activeSubclusters.containsKey(entry.getKey()\n          .toId())){\n        totActiveWeight +\u003d entry.getValue();\n      }\n    }\n    float lookupValue \u003d rand.nextFloat() * totActiveWeight;\n\n    for (SubClusterId id : activeSubclusters.keySet()) {\n      SubClusterIdInfo idInfo \u003d new SubClusterIdInfo(id);\n      if (weights.containsKey(idInfo)) {\n        lookupValue -\u003d weights.get(idInfo);\n      }\n      if (lookupValue \u003c\u003d 0) {\n        return id;\n      }\n    }\n    //should never happen\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/router/WeightedRandomRouterPolicy.java"
    }
  }
}