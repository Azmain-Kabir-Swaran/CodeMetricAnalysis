{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "MaxRunningAppsEnforcer.java",
  "functionName": "updateRunnabilityOnAppRemoval",
  "functionId": "updateRunnabilityOnAppRemoval___app-FSAppAttempt__queue-FSLeafQueue",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/MaxRunningAppsEnforcer.java",
  "functionStartLine": 174,
  "functionEndLine": 220,
  "numCommitsSeen": 18,
  "timeTaken": 3264,
  "changeHistory": [
    "f6ea9be5473ab66798b0536317d2f32c5348eb57",
    "22426a1c9f4bd616558089b6862fd34ab42d19a7",
    "24ee9e3431d27811530ffa01d8d241133fd643fe",
    "486e718fc1f5befd231494e2ec06bb360484f191",
    "e6eccf20defcaf84a9566482371c7be196779c0d",
    "7f2b01a742b8972870a47f7a02e4cb8898f398cd",
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
    "61b6ed73f8a5a75951c7b355c673459874eef7c3"
  ],
  "changeHistoryShort": {
    "f6ea9be5473ab66798b0536317d2f32c5348eb57": "Ybodychange",
    "22426a1c9f4bd616558089b6862fd34ab42d19a7": "Ybodychange",
    "24ee9e3431d27811530ffa01d8d241133fd643fe": "Ybodychange",
    "486e718fc1f5befd231494e2ec06bb360484f191": "Ymultichange(Yparameterchange,Ybodychange)",
    "e6eccf20defcaf84a9566482371c7be196779c0d": "Ymultichange(Yparameterchange,Ybodychange)",
    "7f2b01a742b8972870a47f7a02e4cb8898f398cd": "Ybodychange",
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc": "Ybodychange",
    "61b6ed73f8a5a75951c7b355c673459874eef7c3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f6ea9be5473ab66798b0536317d2f32c5348eb57": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5264. Store all queue-specific information in FSQueue. (Yufei Gu via kasha)\n",
      "commitDate": "02/09/16 2:56 PM",
      "commitName": "f6ea9be5473ab66798b0536317d2f32c5348eb57",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "04/03/15 6:06 PM",
      "commitNameOld": "22426a1c9f4bd616558089b6862fd34ab42d19a7",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 547.83,
      "commitsBetweenForRepo": 4165,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,47 @@\n   public void updateRunnabilityOnAppRemoval(FSAppAttempt app, FSLeafQueue queue) {\n     AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n     \n     // childqueueX might have no pending apps itself, but if a queue higher up\n     // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n     // in childqueueX could allow an app in some other distant child of\n     // parentqueueY to become runnable.\n     // An app removal will only possibly allow another app to become runnable if\n     // the queue was already at its max before the removal.\n     // Thus we find the ancestor queue highest in the tree for which the app\n     // that was at its maxRunningApps before the removal.\n     FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n-        allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n+        queue.getMaxRunningApps() - 1) ? queue : null;\n     FSParentQueue parent \u003d queue.getParent();\n     while (parent !\u003d null) {\n-      if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n-          .getName()) - 1) {\n+      if (parent.getNumRunnableApps() \u003d\u003d parent.getMaxRunningApps() - 1) {\n         highestQueueWithAppsNowRunnable \u003d parent;\n       }\n       parent \u003d parent.getParent();\n     }\n \n     List\u003cList\u003cFSAppAttempt\u003e\u003e appsNowMaybeRunnable \u003d\n         new ArrayList\u003cList\u003cFSAppAttempt\u003e\u003e();\n \n     // Compile lists of apps which may now be runnable\n     // We gather lists instead of building a set of all non-runnable apps so\n     // that this whole operation can be O(number of queues) instead of\n     // O(number of apps)\n     if (highestQueueWithAppsNowRunnable !\u003d null) {\n       gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n           appsNowMaybeRunnable);\n     }\n     String user \u003d app.getUser();\n     Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n     if (userNumRunning \u003d\u003d null) {\n       userNumRunning \u003d 0;\n     }\n     if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n       List\u003cFSAppAttempt\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n       if (userWaitingApps !\u003d null) {\n         appsNowMaybeRunnable.add(userWaitingApps);\n       }\n     }\n \n     updateAppsRunnability(appsNowMaybeRunnable,\n         appsNowMaybeRunnable.size());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateRunnabilityOnAppRemoval(FSAppAttempt app, FSLeafQueue queue) {\n    AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n    \n    // childqueueX might have no pending apps itself, but if a queue higher up\n    // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n    // in childqueueX could allow an app in some other distant child of\n    // parentqueueY to become runnable.\n    // An app removal will only possibly allow another app to become runnable if\n    // the queue was already at its max before the removal.\n    // Thus we find the ancestor queue highest in the tree for which the app\n    // that was at its maxRunningApps before the removal.\n    FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n        queue.getMaxRunningApps() - 1) ? queue : null;\n    FSParentQueue parent \u003d queue.getParent();\n    while (parent !\u003d null) {\n      if (parent.getNumRunnableApps() \u003d\u003d parent.getMaxRunningApps() - 1) {\n        highestQueueWithAppsNowRunnable \u003d parent;\n      }\n      parent \u003d parent.getParent();\n    }\n\n    List\u003cList\u003cFSAppAttempt\u003e\u003e appsNowMaybeRunnable \u003d\n        new ArrayList\u003cList\u003cFSAppAttempt\u003e\u003e();\n\n    // Compile lists of apps which may now be runnable\n    // We gather lists instead of building a set of all non-runnable apps so\n    // that this whole operation can be O(number of queues) instead of\n    // O(number of apps)\n    if (highestQueueWithAppsNowRunnable !\u003d null) {\n      gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n          appsNowMaybeRunnable);\n    }\n    String user \u003d app.getUser();\n    Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n    if (userNumRunning \u003d\u003d null) {\n      userNumRunning \u003d 0;\n    }\n    if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n      List\u003cFSAppAttempt\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n      if (userWaitingApps !\u003d null) {\n        appsNowMaybeRunnable.add(userWaitingApps);\n      }\n    }\n\n    updateAppsRunnability(appsNowMaybeRunnable,\n        appsNowMaybeRunnable.size());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/MaxRunningAppsEnforcer.java",
      "extendedDetails": {}
    },
    "22426a1c9f4bd616558089b6862fd34ab42d19a7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3231. FairScheduler: Changing queueMaxRunningApps interferes with pending jobs. (Siqi Li via kasha)\n",
      "commitDate": "04/03/15 6:06 PM",
      "commitName": "22426a1c9f4bd616558089b6862fd34ab42d19a7",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "20/12/14 12:17 PM",
      "commitNameOld": "24ee9e3431d27811530ffa01d8d241133fd643fe",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 74.24,
      "commitsBetweenForRepo": 561,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,48 @@\n   public void updateRunnabilityOnAppRemoval(FSAppAttempt app, FSLeafQueue queue) {\n     AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n     \n     // childqueueX might have no pending apps itself, but if a queue higher up\n     // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n     // in childqueueX could allow an app in some other distant child of\n     // parentqueueY to become runnable.\n     // An app removal will only possibly allow another app to become runnable if\n     // the queue was already at its max before the removal.\n     // Thus we find the ancestor queue highest in the tree for which the app\n     // that was at its maxRunningApps before the removal.\n     FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n         allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n     FSParentQueue parent \u003d queue.getParent();\n     while (parent !\u003d null) {\n       if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n           .getName()) - 1) {\n         highestQueueWithAppsNowRunnable \u003d parent;\n       }\n       parent \u003d parent.getParent();\n     }\n \n     List\u003cList\u003cFSAppAttempt\u003e\u003e appsNowMaybeRunnable \u003d\n         new ArrayList\u003cList\u003cFSAppAttempt\u003e\u003e();\n \n     // Compile lists of apps which may now be runnable\n     // We gather lists instead of building a set of all non-runnable apps so\n     // that this whole operation can be O(number of queues) instead of\n     // O(number of apps)\n     if (highestQueueWithAppsNowRunnable !\u003d null) {\n       gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n           appsNowMaybeRunnable);\n     }\n     String user \u003d app.getUser();\n     Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n     if (userNumRunning \u003d\u003d null) {\n       userNumRunning \u003d 0;\n     }\n     if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n       List\u003cFSAppAttempt\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n       if (userWaitingApps !\u003d null) {\n         appsNowMaybeRunnable.add(userWaitingApps);\n       }\n     }\n \n-    // Scan through and check whether this means that any apps are now runnable\n-    Iterator\u003cFSAppAttempt\u003e iter \u003d new MultiListStartTimeIterator(\n-        appsNowMaybeRunnable);\n-    FSAppAttempt prev \u003d null;\n-    List\u003cFSAppAttempt\u003e noLongerPendingApps \u003d new ArrayList\u003cFSAppAttempt\u003e();\n-    while (iter.hasNext()) {\n-      FSAppAttempt next \u003d iter.next();\n-      if (next \u003d\u003d prev) {\n-        continue;\n-      }\n-\n-      if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n-        trackRunnableApp(next);\n-        FSAppAttempt appSched \u003d next;\n-        next.getQueue().addApp(appSched, true);\n-        noLongerPendingApps.add(appSched);\n-\n-        // No more than one app per list will be able to be made runnable, so\n-        // we can stop looking after we\u0027ve found that many\n-        if (noLongerPendingApps.size() \u003e\u003d appsNowMaybeRunnable.size()) {\n-          break;\n-        }\n-      }\n-\n-      prev \u003d next;\n-    }\n-    \n-    // We remove the apps from their pending lists afterwards so that we don\u0027t\n-    // pull them out from under the iterator.  If they are not in these lists\n-    // in the first place, there is a bug.\n-    for (FSAppAttempt appSched : noLongerPendingApps) {\n-      if (!appSched.getQueue().removeNonRunnableApp(appSched)) {\n-        LOG.error(\"Can\u0027t make app runnable that does not already exist in queue\"\n-            + \" as non-runnable: \" + appSched + \". This should never happen.\");\n-      }\n-      \n-      if (!usersNonRunnableApps.remove(appSched.getUser(), appSched)) {\n-        LOG.error(\"Waiting app \" + appSched + \" expected to be in \"\n-        \t\t+ \"usersNonRunnableApps, but was not. This should never happen.\");\n-      }\n-    }\n+    updateAppsRunnability(appsNowMaybeRunnable,\n+        appsNowMaybeRunnable.size());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateRunnabilityOnAppRemoval(FSAppAttempt app, FSLeafQueue queue) {\n    AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n    \n    // childqueueX might have no pending apps itself, but if a queue higher up\n    // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n    // in childqueueX could allow an app in some other distant child of\n    // parentqueueY to become runnable.\n    // An app removal will only possibly allow another app to become runnable if\n    // the queue was already at its max before the removal.\n    // Thus we find the ancestor queue highest in the tree for which the app\n    // that was at its maxRunningApps before the removal.\n    FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n        allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n    FSParentQueue parent \u003d queue.getParent();\n    while (parent !\u003d null) {\n      if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n          .getName()) - 1) {\n        highestQueueWithAppsNowRunnable \u003d parent;\n      }\n      parent \u003d parent.getParent();\n    }\n\n    List\u003cList\u003cFSAppAttempt\u003e\u003e appsNowMaybeRunnable \u003d\n        new ArrayList\u003cList\u003cFSAppAttempt\u003e\u003e();\n\n    // Compile lists of apps which may now be runnable\n    // We gather lists instead of building a set of all non-runnable apps so\n    // that this whole operation can be O(number of queues) instead of\n    // O(number of apps)\n    if (highestQueueWithAppsNowRunnable !\u003d null) {\n      gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n          appsNowMaybeRunnable);\n    }\n    String user \u003d app.getUser();\n    Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n    if (userNumRunning \u003d\u003d null) {\n      userNumRunning \u003d 0;\n    }\n    if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n      List\u003cFSAppAttempt\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n      if (userWaitingApps !\u003d null) {\n        appsNowMaybeRunnable.add(userWaitingApps);\n      }\n    }\n\n    updateAppsRunnability(appsNowMaybeRunnable,\n        appsNowMaybeRunnable.size());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/MaxRunningAppsEnforcer.java",
      "extendedDetails": {}
    },
    "24ee9e3431d27811530ffa01d8d241133fd643fe": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2975. FSLeafQueue app lists are accessed without required locks. (kasha)\n",
      "commitDate": "20/12/14 12:17 PM",
      "commitName": "24ee9e3431d27811530ffa01d8d241133fd643fe",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "12/08/14 2:43 PM",
      "commitNameOld": "486e718fc1f5befd231494e2ec06bb360484f191",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 129.94,
      "commitsBetweenForRepo": 1206,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,87 @@\n   public void updateRunnabilityOnAppRemoval(FSAppAttempt app, FSLeafQueue queue) {\n     AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n     \n     // childqueueX might have no pending apps itself, but if a queue higher up\n     // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n     // in childqueueX could allow an app in some other distant child of\n     // parentqueueY to become runnable.\n     // An app removal will only possibly allow another app to become runnable if\n     // the queue was already at its max before the removal.\n     // Thus we find the ancestor queue highest in the tree for which the app\n     // that was at its maxRunningApps before the removal.\n     FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n         allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n     FSParentQueue parent \u003d queue.getParent();\n     while (parent !\u003d null) {\n       if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n           .getName()) - 1) {\n         highestQueueWithAppsNowRunnable \u003d parent;\n       }\n       parent \u003d parent.getParent();\n     }\n \n     List\u003cList\u003cFSAppAttempt\u003e\u003e appsNowMaybeRunnable \u003d\n         new ArrayList\u003cList\u003cFSAppAttempt\u003e\u003e();\n \n     // Compile lists of apps which may now be runnable\n     // We gather lists instead of building a set of all non-runnable apps so\n     // that this whole operation can be O(number of queues) instead of\n     // O(number of apps)\n     if (highestQueueWithAppsNowRunnable !\u003d null) {\n       gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n           appsNowMaybeRunnable);\n     }\n     String user \u003d app.getUser();\n     Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n     if (userNumRunning \u003d\u003d null) {\n       userNumRunning \u003d 0;\n     }\n     if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n       List\u003cFSAppAttempt\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n       if (userWaitingApps !\u003d null) {\n         appsNowMaybeRunnable.add(userWaitingApps);\n       }\n     }\n \n     // Scan through and check whether this means that any apps are now runnable\n     Iterator\u003cFSAppAttempt\u003e iter \u003d new MultiListStartTimeIterator(\n         appsNowMaybeRunnable);\n     FSAppAttempt prev \u003d null;\n     List\u003cFSAppAttempt\u003e noLongerPendingApps \u003d new ArrayList\u003cFSAppAttempt\u003e();\n     while (iter.hasNext()) {\n       FSAppAttempt next \u003d iter.next();\n       if (next \u003d\u003d prev) {\n         continue;\n       }\n \n       if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n         trackRunnableApp(next);\n         FSAppAttempt appSched \u003d next;\n-        next.getQueue().getRunnableAppSchedulables().add(appSched);\n+        next.getQueue().addApp(appSched, true);\n         noLongerPendingApps.add(appSched);\n \n         // No more than one app per list will be able to be made runnable, so\n         // we can stop looking after we\u0027ve found that many\n         if (noLongerPendingApps.size() \u003e\u003d appsNowMaybeRunnable.size()) {\n           break;\n         }\n       }\n \n       prev \u003d next;\n     }\n     \n     // We remove the apps from their pending lists afterwards so that we don\u0027t\n     // pull them out from under the iterator.  If they are not in these lists\n     // in the first place, there is a bug.\n     for (FSAppAttempt appSched : noLongerPendingApps) {\n-      if (!appSched.getQueue().getNonRunnableAppSchedulables()\n-          .remove(appSched)) {\n+      if (!appSched.getQueue().removeNonRunnableApp(appSched)) {\n         LOG.error(\"Can\u0027t make app runnable that does not already exist in queue\"\n             + \" as non-runnable: \" + appSched + \". This should never happen.\");\n       }\n       \n       if (!usersNonRunnableApps.remove(appSched.getUser(), appSched)) {\n         LOG.error(\"Waiting app \" + appSched + \" expected to be in \"\n         \t\t+ \"usersNonRunnableApps, but was not. This should never happen.\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateRunnabilityOnAppRemoval(FSAppAttempt app, FSLeafQueue queue) {\n    AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n    \n    // childqueueX might have no pending apps itself, but if a queue higher up\n    // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n    // in childqueueX could allow an app in some other distant child of\n    // parentqueueY to become runnable.\n    // An app removal will only possibly allow another app to become runnable if\n    // the queue was already at its max before the removal.\n    // Thus we find the ancestor queue highest in the tree for which the app\n    // that was at its maxRunningApps before the removal.\n    FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n        allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n    FSParentQueue parent \u003d queue.getParent();\n    while (parent !\u003d null) {\n      if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n          .getName()) - 1) {\n        highestQueueWithAppsNowRunnable \u003d parent;\n      }\n      parent \u003d parent.getParent();\n    }\n\n    List\u003cList\u003cFSAppAttempt\u003e\u003e appsNowMaybeRunnable \u003d\n        new ArrayList\u003cList\u003cFSAppAttempt\u003e\u003e();\n\n    // Compile lists of apps which may now be runnable\n    // We gather lists instead of building a set of all non-runnable apps so\n    // that this whole operation can be O(number of queues) instead of\n    // O(number of apps)\n    if (highestQueueWithAppsNowRunnable !\u003d null) {\n      gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n          appsNowMaybeRunnable);\n    }\n    String user \u003d app.getUser();\n    Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n    if (userNumRunning \u003d\u003d null) {\n      userNumRunning \u003d 0;\n    }\n    if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n      List\u003cFSAppAttempt\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n      if (userWaitingApps !\u003d null) {\n        appsNowMaybeRunnable.add(userWaitingApps);\n      }\n    }\n\n    // Scan through and check whether this means that any apps are now runnable\n    Iterator\u003cFSAppAttempt\u003e iter \u003d new MultiListStartTimeIterator(\n        appsNowMaybeRunnable);\n    FSAppAttempt prev \u003d null;\n    List\u003cFSAppAttempt\u003e noLongerPendingApps \u003d new ArrayList\u003cFSAppAttempt\u003e();\n    while (iter.hasNext()) {\n      FSAppAttempt next \u003d iter.next();\n      if (next \u003d\u003d prev) {\n        continue;\n      }\n\n      if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n        trackRunnableApp(next);\n        FSAppAttempt appSched \u003d next;\n        next.getQueue().addApp(appSched, true);\n        noLongerPendingApps.add(appSched);\n\n        // No more than one app per list will be able to be made runnable, so\n        // we can stop looking after we\u0027ve found that many\n        if (noLongerPendingApps.size() \u003e\u003d appsNowMaybeRunnable.size()) {\n          break;\n        }\n      }\n\n      prev \u003d next;\n    }\n    \n    // We remove the apps from their pending lists afterwards so that we don\u0027t\n    // pull them out from under the iterator.  If they are not in these lists\n    // in the first place, there is a bug.\n    for (FSAppAttempt appSched : noLongerPendingApps) {\n      if (!appSched.getQueue().removeNonRunnableApp(appSched)) {\n        LOG.error(\"Can\u0027t make app runnable that does not already exist in queue\"\n            + \" as non-runnable: \" + appSched + \". This should never happen.\");\n      }\n      \n      if (!usersNonRunnableApps.remove(appSched.getUser(), appSched)) {\n        LOG.error(\"Waiting app \" + appSched + \" expected to be in \"\n        \t\t+ \"usersNonRunnableApps, but was not. This should never happen.\");\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/MaxRunningAppsEnforcer.java",
      "extendedDetails": {}
    },
    "486e718fc1f5befd231494e2ec06bb360484f191": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2399. FairScheduler: Merge AppSchedulable and FSSchedulerApp into FSAppAttempt. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617600 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 2:43 PM",
      "commitName": "486e718fc1f5befd231494e2ec06bb360484f191",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2399. FairScheduler: Merge AppSchedulable and FSSchedulerApp into FSAppAttempt. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617600 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/08/14 2:43 PM",
          "commitName": "486e718fc1f5befd231494e2ec06bb360484f191",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "05/02/14 10:09 AM",
          "commitNameOld": "e6eccf20defcaf84a9566482371c7be196779c0d",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 188.15,
          "commitsBetweenForRepo": 1328,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,88 +1,88 @@\n-  public void updateRunnabilityOnAppRemoval(FSSchedulerApp app, FSLeafQueue queue) {\n+  public void updateRunnabilityOnAppRemoval(FSAppAttempt app, FSLeafQueue queue) {\n     AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n     \n     // childqueueX might have no pending apps itself, but if a queue higher up\n     // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n     // in childqueueX could allow an app in some other distant child of\n     // parentqueueY to become runnable.\n     // An app removal will only possibly allow another app to become runnable if\n     // the queue was already at its max before the removal.\n     // Thus we find the ancestor queue highest in the tree for which the app\n     // that was at its maxRunningApps before the removal.\n     FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n         allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n     FSParentQueue parent \u003d queue.getParent();\n     while (parent !\u003d null) {\n       if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n           .getName()) - 1) {\n         highestQueueWithAppsNowRunnable \u003d parent;\n       }\n       parent \u003d parent.getParent();\n     }\n \n-    List\u003cList\u003cAppSchedulable\u003e\u003e appsNowMaybeRunnable \u003d\n-        new ArrayList\u003cList\u003cAppSchedulable\u003e\u003e();\n+    List\u003cList\u003cFSAppAttempt\u003e\u003e appsNowMaybeRunnable \u003d\n+        new ArrayList\u003cList\u003cFSAppAttempt\u003e\u003e();\n \n     // Compile lists of apps which may now be runnable\n     // We gather lists instead of building a set of all non-runnable apps so\n     // that this whole operation can be O(number of queues) instead of\n     // O(number of apps)\n     if (highestQueueWithAppsNowRunnable !\u003d null) {\n       gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n           appsNowMaybeRunnable);\n     }\n     String user \u003d app.getUser();\n     Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n     if (userNumRunning \u003d\u003d null) {\n       userNumRunning \u003d 0;\n     }\n     if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n-      List\u003cAppSchedulable\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n+      List\u003cFSAppAttempt\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n       if (userWaitingApps !\u003d null) {\n         appsNowMaybeRunnable.add(userWaitingApps);\n       }\n     }\n \n     // Scan through and check whether this means that any apps are now runnable\n-    Iterator\u003cFSSchedulerApp\u003e iter \u003d new MultiListStartTimeIterator(\n+    Iterator\u003cFSAppAttempt\u003e iter \u003d new MultiListStartTimeIterator(\n         appsNowMaybeRunnable);\n-    FSSchedulerApp prev \u003d null;\n-    List\u003cAppSchedulable\u003e noLongerPendingApps \u003d new ArrayList\u003cAppSchedulable\u003e();\n+    FSAppAttempt prev \u003d null;\n+    List\u003cFSAppAttempt\u003e noLongerPendingApps \u003d new ArrayList\u003cFSAppAttempt\u003e();\n     while (iter.hasNext()) {\n-      FSSchedulerApp next \u003d iter.next();\n+      FSAppAttempt next \u003d iter.next();\n       if (next \u003d\u003d prev) {\n         continue;\n       }\n \n       if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n         trackRunnableApp(next);\n-        AppSchedulable appSched \u003d next.getAppSchedulable();\n+        FSAppAttempt appSched \u003d next;\n         next.getQueue().getRunnableAppSchedulables().add(appSched);\n         noLongerPendingApps.add(appSched);\n \n         // No more than one app per list will be able to be made runnable, so\n         // we can stop looking after we\u0027ve found that many\n         if (noLongerPendingApps.size() \u003e\u003d appsNowMaybeRunnable.size()) {\n           break;\n         }\n       }\n \n       prev \u003d next;\n     }\n     \n     // We remove the apps from their pending lists afterwards so that we don\u0027t\n     // pull them out from under the iterator.  If they are not in these lists\n     // in the first place, there is a bug.\n-    for (AppSchedulable appSched : noLongerPendingApps) {\n-      if (!appSched.getApp().getQueue().getNonRunnableAppSchedulables()\n+    for (FSAppAttempt appSched : noLongerPendingApps) {\n+      if (!appSched.getQueue().getNonRunnableAppSchedulables()\n           .remove(appSched)) {\n         LOG.error(\"Can\u0027t make app runnable that does not already exist in queue\"\n             + \" as non-runnable: \" + appSched + \". This should never happen.\");\n       }\n       \n-      if (!usersNonRunnableApps.remove(appSched.getApp().getUser(), appSched)) {\n+      if (!usersNonRunnableApps.remove(appSched.getUser(), appSched)) {\n         LOG.error(\"Waiting app \" + appSched + \" expected to be in \"\n         \t\t+ \"usersNonRunnableApps, but was not. This should never happen.\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void updateRunnabilityOnAppRemoval(FSAppAttempt app, FSLeafQueue queue) {\n    AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n    \n    // childqueueX might have no pending apps itself, but if a queue higher up\n    // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n    // in childqueueX could allow an app in some other distant child of\n    // parentqueueY to become runnable.\n    // An app removal will only possibly allow another app to become runnable if\n    // the queue was already at its max before the removal.\n    // Thus we find the ancestor queue highest in the tree for which the app\n    // that was at its maxRunningApps before the removal.\n    FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n        allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n    FSParentQueue parent \u003d queue.getParent();\n    while (parent !\u003d null) {\n      if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n          .getName()) - 1) {\n        highestQueueWithAppsNowRunnable \u003d parent;\n      }\n      parent \u003d parent.getParent();\n    }\n\n    List\u003cList\u003cFSAppAttempt\u003e\u003e appsNowMaybeRunnable \u003d\n        new ArrayList\u003cList\u003cFSAppAttempt\u003e\u003e();\n\n    // Compile lists of apps which may now be runnable\n    // We gather lists instead of building a set of all non-runnable apps so\n    // that this whole operation can be O(number of queues) instead of\n    // O(number of apps)\n    if (highestQueueWithAppsNowRunnable !\u003d null) {\n      gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n          appsNowMaybeRunnable);\n    }\n    String user \u003d app.getUser();\n    Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n    if (userNumRunning \u003d\u003d null) {\n      userNumRunning \u003d 0;\n    }\n    if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n      List\u003cFSAppAttempt\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n      if (userWaitingApps !\u003d null) {\n        appsNowMaybeRunnable.add(userWaitingApps);\n      }\n    }\n\n    // Scan through and check whether this means that any apps are now runnable\n    Iterator\u003cFSAppAttempt\u003e iter \u003d new MultiListStartTimeIterator(\n        appsNowMaybeRunnable);\n    FSAppAttempt prev \u003d null;\n    List\u003cFSAppAttempt\u003e noLongerPendingApps \u003d new ArrayList\u003cFSAppAttempt\u003e();\n    while (iter.hasNext()) {\n      FSAppAttempt next \u003d iter.next();\n      if (next \u003d\u003d prev) {\n        continue;\n      }\n\n      if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n        trackRunnableApp(next);\n        FSAppAttempt appSched \u003d next;\n        next.getQueue().getRunnableAppSchedulables().add(appSched);\n        noLongerPendingApps.add(appSched);\n\n        // No more than one app per list will be able to be made runnable, so\n        // we can stop looking after we\u0027ve found that many\n        if (noLongerPendingApps.size() \u003e\u003d appsNowMaybeRunnable.size()) {\n          break;\n        }\n      }\n\n      prev \u003d next;\n    }\n    \n    // We remove the apps from their pending lists afterwards so that we don\u0027t\n    // pull them out from under the iterator.  If they are not in these lists\n    // in the first place, there is a bug.\n    for (FSAppAttempt appSched : noLongerPendingApps) {\n      if (!appSched.getQueue().getNonRunnableAppSchedulables()\n          .remove(appSched)) {\n        LOG.error(\"Can\u0027t make app runnable that does not already exist in queue\"\n            + \" as non-runnable: \" + appSched + \". This should never happen.\");\n      }\n      \n      if (!usersNonRunnableApps.remove(appSched.getUser(), appSched)) {\n        LOG.error(\"Waiting app \" + appSched + \" expected to be in \"\n        \t\t+ \"usersNonRunnableApps, but was not. This should never happen.\");\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/MaxRunningAppsEnforcer.java",
          "extendedDetails": {
            "oldValue": "[app-FSSchedulerApp, queue-FSLeafQueue]",
            "newValue": "[app-FSAppAttempt, queue-FSLeafQueue]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2399. FairScheduler: Merge AppSchedulable and FSSchedulerApp into FSAppAttempt. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617600 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/08/14 2:43 PM",
          "commitName": "486e718fc1f5befd231494e2ec06bb360484f191",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "05/02/14 10:09 AM",
          "commitNameOld": "e6eccf20defcaf84a9566482371c7be196779c0d",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 188.15,
          "commitsBetweenForRepo": 1328,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,88 +1,88 @@\n-  public void updateRunnabilityOnAppRemoval(FSSchedulerApp app, FSLeafQueue queue) {\n+  public void updateRunnabilityOnAppRemoval(FSAppAttempt app, FSLeafQueue queue) {\n     AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n     \n     // childqueueX might have no pending apps itself, but if a queue higher up\n     // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n     // in childqueueX could allow an app in some other distant child of\n     // parentqueueY to become runnable.\n     // An app removal will only possibly allow another app to become runnable if\n     // the queue was already at its max before the removal.\n     // Thus we find the ancestor queue highest in the tree for which the app\n     // that was at its maxRunningApps before the removal.\n     FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n         allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n     FSParentQueue parent \u003d queue.getParent();\n     while (parent !\u003d null) {\n       if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n           .getName()) - 1) {\n         highestQueueWithAppsNowRunnable \u003d parent;\n       }\n       parent \u003d parent.getParent();\n     }\n \n-    List\u003cList\u003cAppSchedulable\u003e\u003e appsNowMaybeRunnable \u003d\n-        new ArrayList\u003cList\u003cAppSchedulable\u003e\u003e();\n+    List\u003cList\u003cFSAppAttempt\u003e\u003e appsNowMaybeRunnable \u003d\n+        new ArrayList\u003cList\u003cFSAppAttempt\u003e\u003e();\n \n     // Compile lists of apps which may now be runnable\n     // We gather lists instead of building a set of all non-runnable apps so\n     // that this whole operation can be O(number of queues) instead of\n     // O(number of apps)\n     if (highestQueueWithAppsNowRunnable !\u003d null) {\n       gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n           appsNowMaybeRunnable);\n     }\n     String user \u003d app.getUser();\n     Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n     if (userNumRunning \u003d\u003d null) {\n       userNumRunning \u003d 0;\n     }\n     if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n-      List\u003cAppSchedulable\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n+      List\u003cFSAppAttempt\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n       if (userWaitingApps !\u003d null) {\n         appsNowMaybeRunnable.add(userWaitingApps);\n       }\n     }\n \n     // Scan through and check whether this means that any apps are now runnable\n-    Iterator\u003cFSSchedulerApp\u003e iter \u003d new MultiListStartTimeIterator(\n+    Iterator\u003cFSAppAttempt\u003e iter \u003d new MultiListStartTimeIterator(\n         appsNowMaybeRunnable);\n-    FSSchedulerApp prev \u003d null;\n-    List\u003cAppSchedulable\u003e noLongerPendingApps \u003d new ArrayList\u003cAppSchedulable\u003e();\n+    FSAppAttempt prev \u003d null;\n+    List\u003cFSAppAttempt\u003e noLongerPendingApps \u003d new ArrayList\u003cFSAppAttempt\u003e();\n     while (iter.hasNext()) {\n-      FSSchedulerApp next \u003d iter.next();\n+      FSAppAttempt next \u003d iter.next();\n       if (next \u003d\u003d prev) {\n         continue;\n       }\n \n       if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n         trackRunnableApp(next);\n-        AppSchedulable appSched \u003d next.getAppSchedulable();\n+        FSAppAttempt appSched \u003d next;\n         next.getQueue().getRunnableAppSchedulables().add(appSched);\n         noLongerPendingApps.add(appSched);\n \n         // No more than one app per list will be able to be made runnable, so\n         // we can stop looking after we\u0027ve found that many\n         if (noLongerPendingApps.size() \u003e\u003d appsNowMaybeRunnable.size()) {\n           break;\n         }\n       }\n \n       prev \u003d next;\n     }\n     \n     // We remove the apps from their pending lists afterwards so that we don\u0027t\n     // pull them out from under the iterator.  If they are not in these lists\n     // in the first place, there is a bug.\n-    for (AppSchedulable appSched : noLongerPendingApps) {\n-      if (!appSched.getApp().getQueue().getNonRunnableAppSchedulables()\n+    for (FSAppAttempt appSched : noLongerPendingApps) {\n+      if (!appSched.getQueue().getNonRunnableAppSchedulables()\n           .remove(appSched)) {\n         LOG.error(\"Can\u0027t make app runnable that does not already exist in queue\"\n             + \" as non-runnable: \" + appSched + \". This should never happen.\");\n       }\n       \n-      if (!usersNonRunnableApps.remove(appSched.getApp().getUser(), appSched)) {\n+      if (!usersNonRunnableApps.remove(appSched.getUser(), appSched)) {\n         LOG.error(\"Waiting app \" + appSched + \" expected to be in \"\n         \t\t+ \"usersNonRunnableApps, but was not. This should never happen.\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void updateRunnabilityOnAppRemoval(FSAppAttempt app, FSLeafQueue queue) {\n    AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n    \n    // childqueueX might have no pending apps itself, but if a queue higher up\n    // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n    // in childqueueX could allow an app in some other distant child of\n    // parentqueueY to become runnable.\n    // An app removal will only possibly allow another app to become runnable if\n    // the queue was already at its max before the removal.\n    // Thus we find the ancestor queue highest in the tree for which the app\n    // that was at its maxRunningApps before the removal.\n    FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n        allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n    FSParentQueue parent \u003d queue.getParent();\n    while (parent !\u003d null) {\n      if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n          .getName()) - 1) {\n        highestQueueWithAppsNowRunnable \u003d parent;\n      }\n      parent \u003d parent.getParent();\n    }\n\n    List\u003cList\u003cFSAppAttempt\u003e\u003e appsNowMaybeRunnable \u003d\n        new ArrayList\u003cList\u003cFSAppAttempt\u003e\u003e();\n\n    // Compile lists of apps which may now be runnable\n    // We gather lists instead of building a set of all non-runnable apps so\n    // that this whole operation can be O(number of queues) instead of\n    // O(number of apps)\n    if (highestQueueWithAppsNowRunnable !\u003d null) {\n      gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n          appsNowMaybeRunnable);\n    }\n    String user \u003d app.getUser();\n    Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n    if (userNumRunning \u003d\u003d null) {\n      userNumRunning \u003d 0;\n    }\n    if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n      List\u003cFSAppAttempt\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n      if (userWaitingApps !\u003d null) {\n        appsNowMaybeRunnable.add(userWaitingApps);\n      }\n    }\n\n    // Scan through and check whether this means that any apps are now runnable\n    Iterator\u003cFSAppAttempt\u003e iter \u003d new MultiListStartTimeIterator(\n        appsNowMaybeRunnable);\n    FSAppAttempt prev \u003d null;\n    List\u003cFSAppAttempt\u003e noLongerPendingApps \u003d new ArrayList\u003cFSAppAttempt\u003e();\n    while (iter.hasNext()) {\n      FSAppAttempt next \u003d iter.next();\n      if (next \u003d\u003d prev) {\n        continue;\n      }\n\n      if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n        trackRunnableApp(next);\n        FSAppAttempt appSched \u003d next;\n        next.getQueue().getRunnableAppSchedulables().add(appSched);\n        noLongerPendingApps.add(appSched);\n\n        // No more than one app per list will be able to be made runnable, so\n        // we can stop looking after we\u0027ve found that many\n        if (noLongerPendingApps.size() \u003e\u003d appsNowMaybeRunnable.size()) {\n          break;\n        }\n      }\n\n      prev \u003d next;\n    }\n    \n    // We remove the apps from their pending lists afterwards so that we don\u0027t\n    // pull them out from under the iterator.  If they are not in these lists\n    // in the first place, there is a bug.\n    for (FSAppAttempt appSched : noLongerPendingApps) {\n      if (!appSched.getQueue().getNonRunnableAppSchedulables()\n          .remove(appSched)) {\n        LOG.error(\"Can\u0027t make app runnable that does not already exist in queue\"\n            + \" as non-runnable: \" + appSched + \". This should never happen.\");\n      }\n      \n      if (!usersNonRunnableApps.remove(appSched.getUser(), appSched)) {\n        LOG.error(\"Waiting app \" + appSched + \" expected to be in \"\n        \t\t+ \"usersNonRunnableApps, but was not. This should never happen.\");\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/MaxRunningAppsEnforcer.java",
          "extendedDetails": {}
        }
      ]
    },
    "e6eccf20defcaf84a9566482371c7be196779c0d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1499. Fair Scheduler changes for moving apps between queues (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564856 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/02/14 10:09 AM",
      "commitName": "e6eccf20defcaf84a9566482371c7be196779c0d",
      "commitAuthor": "Sanford Ryza",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1499. Fair Scheduler changes for moving apps between queues (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564856 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "05/02/14 10:09 AM",
          "commitName": "e6eccf20defcaf84a9566482371c7be196779c0d",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "28/01/14 12:34 AM",
          "commitNameOld": "7f2b01a742b8972870a47f7a02e4cb8898f398cd",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 8.4,
          "commitsBetweenForRepo": 66,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,95 +1,88 @@\n-  public void updateRunnabilityOnAppRemoval(FSSchedulerApp app) {\n+  public void updateRunnabilityOnAppRemoval(FSSchedulerApp app, FSLeafQueue queue) {\n     AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n     \n-    // Update usersRunnableApps\n-    String user \u003d app.getUser();\n-    int newUserNumRunning \u003d usersNumRunnableApps.get(user) - 1;\n-    if (newUserNumRunning \u003d\u003d 0) {\n-      usersNumRunnableApps.remove(user);\n-    } else {\n-      usersNumRunnableApps.put(user, newUserNumRunning);\n-    }\n-\n-    // Update runnable app bookkeeping for queues:\n     // childqueueX might have no pending apps itself, but if a queue higher up\n     // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n     // in childqueueX could allow an app in some other distant child of\n     // parentqueueY to become runnable.\n     // An app removal will only possibly allow another app to become runnable if\n     // the queue was already at its max before the removal.\n     // Thus we find the ancestor queue highest in the tree for which the app\n     // that was at its maxRunningApps before the removal.\n-    FSLeafQueue queue \u003d app.getQueue();\n     FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n         allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n     FSParentQueue parent \u003d queue.getParent();\n     while (parent !\u003d null) {\n       if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n-          .getName())) {\n+          .getName()) - 1) {\n         highestQueueWithAppsNowRunnable \u003d parent;\n       }\n-      parent.decrementRunnableApps();\n       parent \u003d parent.getParent();\n     }\n \n     List\u003cList\u003cAppSchedulable\u003e\u003e appsNowMaybeRunnable \u003d\n         new ArrayList\u003cList\u003cAppSchedulable\u003e\u003e();\n \n     // Compile lists of apps which may now be runnable\n     // We gather lists instead of building a set of all non-runnable apps so\n     // that this whole operation can be O(number of queues) instead of\n     // O(number of apps)\n     if (highestQueueWithAppsNowRunnable !\u003d null) {\n       gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n           appsNowMaybeRunnable);\n     }\n-    if (newUserNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n+    String user \u003d app.getUser();\n+    Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n+    if (userNumRunning \u003d\u003d null) {\n+      userNumRunning \u003d 0;\n+    }\n+    if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n       List\u003cAppSchedulable\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n       if (userWaitingApps !\u003d null) {\n         appsNowMaybeRunnable.add(userWaitingApps);\n       }\n     }\n \n     // Scan through and check whether this means that any apps are now runnable\n     Iterator\u003cFSSchedulerApp\u003e iter \u003d new MultiListStartTimeIterator(\n         appsNowMaybeRunnable);\n     FSSchedulerApp prev \u003d null;\n     List\u003cAppSchedulable\u003e noLongerPendingApps \u003d new ArrayList\u003cAppSchedulable\u003e();\n     while (iter.hasNext()) {\n       FSSchedulerApp next \u003d iter.next();\n       if (next \u003d\u003d prev) {\n         continue;\n       }\n \n       if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n         trackRunnableApp(next);\n         AppSchedulable appSched \u003d next.getAppSchedulable();\n         next.getQueue().getRunnableAppSchedulables().add(appSched);\n         noLongerPendingApps.add(appSched);\n \n         // No more than one app per list will be able to be made runnable, so\n         // we can stop looking after we\u0027ve found that many\n         if (noLongerPendingApps.size() \u003e\u003d appsNowMaybeRunnable.size()) {\n           break;\n         }\n       }\n \n       prev \u003d next;\n     }\n     \n     // We remove the apps from their pending lists afterwards so that we don\u0027t\n     // pull them out from under the iterator.  If they are not in these lists\n     // in the first place, there is a bug.\n     for (AppSchedulable appSched : noLongerPendingApps) {\n       if (!appSched.getApp().getQueue().getNonRunnableAppSchedulables()\n           .remove(appSched)) {\n         LOG.error(\"Can\u0027t make app runnable that does not already exist in queue\"\n             + \" as non-runnable: \" + appSched + \". This should never happen.\");\n       }\n       \n       if (!usersNonRunnableApps.remove(appSched.getApp().getUser(), appSched)) {\n         LOG.error(\"Waiting app \" + appSched + \" expected to be in \"\n         \t\t+ \"usersNonRunnableApps, but was not. This should never happen.\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void updateRunnabilityOnAppRemoval(FSSchedulerApp app, FSLeafQueue queue) {\n    AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n    \n    // childqueueX might have no pending apps itself, but if a queue higher up\n    // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n    // in childqueueX could allow an app in some other distant child of\n    // parentqueueY to become runnable.\n    // An app removal will only possibly allow another app to become runnable if\n    // the queue was already at its max before the removal.\n    // Thus we find the ancestor queue highest in the tree for which the app\n    // that was at its maxRunningApps before the removal.\n    FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n        allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n    FSParentQueue parent \u003d queue.getParent();\n    while (parent !\u003d null) {\n      if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n          .getName()) - 1) {\n        highestQueueWithAppsNowRunnable \u003d parent;\n      }\n      parent \u003d parent.getParent();\n    }\n\n    List\u003cList\u003cAppSchedulable\u003e\u003e appsNowMaybeRunnable \u003d\n        new ArrayList\u003cList\u003cAppSchedulable\u003e\u003e();\n\n    // Compile lists of apps which may now be runnable\n    // We gather lists instead of building a set of all non-runnable apps so\n    // that this whole operation can be O(number of queues) instead of\n    // O(number of apps)\n    if (highestQueueWithAppsNowRunnable !\u003d null) {\n      gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n          appsNowMaybeRunnable);\n    }\n    String user \u003d app.getUser();\n    Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n    if (userNumRunning \u003d\u003d null) {\n      userNumRunning \u003d 0;\n    }\n    if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n      List\u003cAppSchedulable\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n      if (userWaitingApps !\u003d null) {\n        appsNowMaybeRunnable.add(userWaitingApps);\n      }\n    }\n\n    // Scan through and check whether this means that any apps are now runnable\n    Iterator\u003cFSSchedulerApp\u003e iter \u003d new MultiListStartTimeIterator(\n        appsNowMaybeRunnable);\n    FSSchedulerApp prev \u003d null;\n    List\u003cAppSchedulable\u003e noLongerPendingApps \u003d new ArrayList\u003cAppSchedulable\u003e();\n    while (iter.hasNext()) {\n      FSSchedulerApp next \u003d iter.next();\n      if (next \u003d\u003d prev) {\n        continue;\n      }\n\n      if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n        trackRunnableApp(next);\n        AppSchedulable appSched \u003d next.getAppSchedulable();\n        next.getQueue().getRunnableAppSchedulables().add(appSched);\n        noLongerPendingApps.add(appSched);\n\n        // No more than one app per list will be able to be made runnable, so\n        // we can stop looking after we\u0027ve found that many\n        if (noLongerPendingApps.size() \u003e\u003d appsNowMaybeRunnable.size()) {\n          break;\n        }\n      }\n\n      prev \u003d next;\n    }\n    \n    // We remove the apps from their pending lists afterwards so that we don\u0027t\n    // pull them out from under the iterator.  If they are not in these lists\n    // in the first place, there is a bug.\n    for (AppSchedulable appSched : noLongerPendingApps) {\n      if (!appSched.getApp().getQueue().getNonRunnableAppSchedulables()\n          .remove(appSched)) {\n        LOG.error(\"Can\u0027t make app runnable that does not already exist in queue\"\n            + \" as non-runnable: \" + appSched + \". This should never happen.\");\n      }\n      \n      if (!usersNonRunnableApps.remove(appSched.getApp().getUser(), appSched)) {\n        LOG.error(\"Waiting app \" + appSched + \" expected to be in \"\n        \t\t+ \"usersNonRunnableApps, but was not. This should never happen.\");\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/MaxRunningAppsEnforcer.java",
          "extendedDetails": {
            "oldValue": "[app-FSSchedulerApp]",
            "newValue": "[app-FSSchedulerApp, queue-FSLeafQueue]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1499. Fair Scheduler changes for moving apps between queues (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564856 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "05/02/14 10:09 AM",
          "commitName": "e6eccf20defcaf84a9566482371c7be196779c0d",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "28/01/14 12:34 AM",
          "commitNameOld": "7f2b01a742b8972870a47f7a02e4cb8898f398cd",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 8.4,
          "commitsBetweenForRepo": 66,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,95 +1,88 @@\n-  public void updateRunnabilityOnAppRemoval(FSSchedulerApp app) {\n+  public void updateRunnabilityOnAppRemoval(FSSchedulerApp app, FSLeafQueue queue) {\n     AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n     \n-    // Update usersRunnableApps\n-    String user \u003d app.getUser();\n-    int newUserNumRunning \u003d usersNumRunnableApps.get(user) - 1;\n-    if (newUserNumRunning \u003d\u003d 0) {\n-      usersNumRunnableApps.remove(user);\n-    } else {\n-      usersNumRunnableApps.put(user, newUserNumRunning);\n-    }\n-\n-    // Update runnable app bookkeeping for queues:\n     // childqueueX might have no pending apps itself, but if a queue higher up\n     // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n     // in childqueueX could allow an app in some other distant child of\n     // parentqueueY to become runnable.\n     // An app removal will only possibly allow another app to become runnable if\n     // the queue was already at its max before the removal.\n     // Thus we find the ancestor queue highest in the tree for which the app\n     // that was at its maxRunningApps before the removal.\n-    FSLeafQueue queue \u003d app.getQueue();\n     FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n         allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n     FSParentQueue parent \u003d queue.getParent();\n     while (parent !\u003d null) {\n       if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n-          .getName())) {\n+          .getName()) - 1) {\n         highestQueueWithAppsNowRunnable \u003d parent;\n       }\n-      parent.decrementRunnableApps();\n       parent \u003d parent.getParent();\n     }\n \n     List\u003cList\u003cAppSchedulable\u003e\u003e appsNowMaybeRunnable \u003d\n         new ArrayList\u003cList\u003cAppSchedulable\u003e\u003e();\n \n     // Compile lists of apps which may now be runnable\n     // We gather lists instead of building a set of all non-runnable apps so\n     // that this whole operation can be O(number of queues) instead of\n     // O(number of apps)\n     if (highestQueueWithAppsNowRunnable !\u003d null) {\n       gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n           appsNowMaybeRunnable);\n     }\n-    if (newUserNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n+    String user \u003d app.getUser();\n+    Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n+    if (userNumRunning \u003d\u003d null) {\n+      userNumRunning \u003d 0;\n+    }\n+    if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n       List\u003cAppSchedulable\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n       if (userWaitingApps !\u003d null) {\n         appsNowMaybeRunnable.add(userWaitingApps);\n       }\n     }\n \n     // Scan through and check whether this means that any apps are now runnable\n     Iterator\u003cFSSchedulerApp\u003e iter \u003d new MultiListStartTimeIterator(\n         appsNowMaybeRunnable);\n     FSSchedulerApp prev \u003d null;\n     List\u003cAppSchedulable\u003e noLongerPendingApps \u003d new ArrayList\u003cAppSchedulable\u003e();\n     while (iter.hasNext()) {\n       FSSchedulerApp next \u003d iter.next();\n       if (next \u003d\u003d prev) {\n         continue;\n       }\n \n       if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n         trackRunnableApp(next);\n         AppSchedulable appSched \u003d next.getAppSchedulable();\n         next.getQueue().getRunnableAppSchedulables().add(appSched);\n         noLongerPendingApps.add(appSched);\n \n         // No more than one app per list will be able to be made runnable, so\n         // we can stop looking after we\u0027ve found that many\n         if (noLongerPendingApps.size() \u003e\u003d appsNowMaybeRunnable.size()) {\n           break;\n         }\n       }\n \n       prev \u003d next;\n     }\n     \n     // We remove the apps from their pending lists afterwards so that we don\u0027t\n     // pull them out from under the iterator.  If they are not in these lists\n     // in the first place, there is a bug.\n     for (AppSchedulable appSched : noLongerPendingApps) {\n       if (!appSched.getApp().getQueue().getNonRunnableAppSchedulables()\n           .remove(appSched)) {\n         LOG.error(\"Can\u0027t make app runnable that does not already exist in queue\"\n             + \" as non-runnable: \" + appSched + \". This should never happen.\");\n       }\n       \n       if (!usersNonRunnableApps.remove(appSched.getApp().getUser(), appSched)) {\n         LOG.error(\"Waiting app \" + appSched + \" expected to be in \"\n         \t\t+ \"usersNonRunnableApps, but was not. This should never happen.\");\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void updateRunnabilityOnAppRemoval(FSSchedulerApp app, FSLeafQueue queue) {\n    AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n    \n    // childqueueX might have no pending apps itself, but if a queue higher up\n    // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n    // in childqueueX could allow an app in some other distant child of\n    // parentqueueY to become runnable.\n    // An app removal will only possibly allow another app to become runnable if\n    // the queue was already at its max before the removal.\n    // Thus we find the ancestor queue highest in the tree for which the app\n    // that was at its maxRunningApps before the removal.\n    FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n        allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n    FSParentQueue parent \u003d queue.getParent();\n    while (parent !\u003d null) {\n      if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n          .getName()) - 1) {\n        highestQueueWithAppsNowRunnable \u003d parent;\n      }\n      parent \u003d parent.getParent();\n    }\n\n    List\u003cList\u003cAppSchedulable\u003e\u003e appsNowMaybeRunnable \u003d\n        new ArrayList\u003cList\u003cAppSchedulable\u003e\u003e();\n\n    // Compile lists of apps which may now be runnable\n    // We gather lists instead of building a set of all non-runnable apps so\n    // that this whole operation can be O(number of queues) instead of\n    // O(number of apps)\n    if (highestQueueWithAppsNowRunnable !\u003d null) {\n      gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n          appsNowMaybeRunnable);\n    }\n    String user \u003d app.getUser();\n    Integer userNumRunning \u003d usersNumRunnableApps.get(user);\n    if (userNumRunning \u003d\u003d null) {\n      userNumRunning \u003d 0;\n    }\n    if (userNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n      List\u003cAppSchedulable\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n      if (userWaitingApps !\u003d null) {\n        appsNowMaybeRunnable.add(userWaitingApps);\n      }\n    }\n\n    // Scan through and check whether this means that any apps are now runnable\n    Iterator\u003cFSSchedulerApp\u003e iter \u003d new MultiListStartTimeIterator(\n        appsNowMaybeRunnable);\n    FSSchedulerApp prev \u003d null;\n    List\u003cAppSchedulable\u003e noLongerPendingApps \u003d new ArrayList\u003cAppSchedulable\u003e();\n    while (iter.hasNext()) {\n      FSSchedulerApp next \u003d iter.next();\n      if (next \u003d\u003d prev) {\n        continue;\n      }\n\n      if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n        trackRunnableApp(next);\n        AppSchedulable appSched \u003d next.getAppSchedulable();\n        next.getQueue().getRunnableAppSchedulables().add(appSched);\n        noLongerPendingApps.add(appSched);\n\n        // No more than one app per list will be able to be made runnable, so\n        // we can stop looking after we\u0027ve found that many\n        if (noLongerPendingApps.size() \u003e\u003d appsNowMaybeRunnable.size()) {\n          break;\n        }\n      }\n\n      prev \u003d next;\n    }\n    \n    // We remove the apps from their pending lists afterwards so that we don\u0027t\n    // pull them out from under the iterator.  If they are not in these lists\n    // in the first place, there is a bug.\n    for (AppSchedulable appSched : noLongerPendingApps) {\n      if (!appSched.getApp().getQueue().getNonRunnableAppSchedulables()\n          .remove(appSched)) {\n        LOG.error(\"Can\u0027t make app runnable that does not already exist in queue\"\n            + \" as non-runnable: \" + appSched + \". This should never happen.\");\n      }\n      \n      if (!usersNonRunnableApps.remove(appSched.getApp().getUser(), appSched)) {\n        LOG.error(\"Waiting app \" + appSched + \" expected to be in \"\n        \t\t+ \"usersNonRunnableApps, but was not. This should never happen.\");\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/MaxRunningAppsEnforcer.java",
          "extendedDetails": {}
        }
      ]
    },
    "7f2b01a742b8972870a47f7a02e4cb8898f398cd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1629. IndexOutOfBoundsException in MaxRunningAppsEnforcer (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561996 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/01/14 12:34 AM",
      "commitName": "7f2b01a742b8972870a47f7a02e4cb8898f398cd",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "04/12/13 7:26 PM",
      "commitNameOld": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 54.21,
      "commitsBetweenForRepo": 268,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,95 @@\n   public void updateRunnabilityOnAppRemoval(FSSchedulerApp app) {\n     AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n     \n     // Update usersRunnableApps\n     String user \u003d app.getUser();\n     int newUserNumRunning \u003d usersNumRunnableApps.get(user) - 1;\n     if (newUserNumRunning \u003d\u003d 0) {\n       usersNumRunnableApps.remove(user);\n     } else {\n       usersNumRunnableApps.put(user, newUserNumRunning);\n     }\n \n     // Update runnable app bookkeeping for queues:\n     // childqueueX might have no pending apps itself, but if a queue higher up\n     // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n     // in childqueueX could allow an app in some other distant child of\n     // parentqueueY to become runnable.\n     // An app removal will only possibly allow another app to become runnable if\n     // the queue was already at its max before the removal.\n     // Thus we find the ancestor queue highest in the tree for which the app\n     // that was at its maxRunningApps before the removal.\n     FSLeafQueue queue \u003d app.getQueue();\n     FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n         allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n     FSParentQueue parent \u003d queue.getParent();\n     while (parent !\u003d null) {\n       if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n           .getName())) {\n         highestQueueWithAppsNowRunnable \u003d parent;\n       }\n       parent.decrementRunnableApps();\n       parent \u003d parent.getParent();\n     }\n \n     List\u003cList\u003cAppSchedulable\u003e\u003e appsNowMaybeRunnable \u003d\n         new ArrayList\u003cList\u003cAppSchedulable\u003e\u003e();\n \n     // Compile lists of apps which may now be runnable\n     // We gather lists instead of building a set of all non-runnable apps so\n     // that this whole operation can be O(number of queues) instead of\n     // O(number of apps)\n     if (highestQueueWithAppsNowRunnable !\u003d null) {\n       gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n           appsNowMaybeRunnable);\n     }\n     if (newUserNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n       List\u003cAppSchedulable\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n       if (userWaitingApps !\u003d null) {\n         appsNowMaybeRunnable.add(userWaitingApps);\n       }\n     }\n \n     // Scan through and check whether this means that any apps are now runnable\n     Iterator\u003cFSSchedulerApp\u003e iter \u003d new MultiListStartTimeIterator(\n         appsNowMaybeRunnable);\n     FSSchedulerApp prev \u003d null;\n-    int numNowRunnable \u003d 0;\n+    List\u003cAppSchedulable\u003e noLongerPendingApps \u003d new ArrayList\u003cAppSchedulable\u003e();\n     while (iter.hasNext()) {\n       FSSchedulerApp next \u003d iter.next();\n       if (next \u003d\u003d prev) {\n         continue;\n       }\n \n       if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n         trackRunnableApp(next);\n         AppSchedulable appSched \u003d next.getAppSchedulable();\n-        next.getQueue().makeAppRunnable(appSched);\n-        if (!usersNonRunnableApps.remove(next.getUser(), appSched)) {\n-          throw new IllegalStateException(\"Waiting app \" + next\n-              + \" expected to be in usersNonRunnableApps\");\n-        }\n+        next.getQueue().getRunnableAppSchedulables().add(appSched);\n+        noLongerPendingApps.add(appSched);\n \n         // No more than one app per list will be able to be made runnable, so\n         // we can stop looking after we\u0027ve found that many\n-        if (numNowRunnable \u003e\u003d appsNowMaybeRunnable.size()) {\n+        if (noLongerPendingApps.size() \u003e\u003d appsNowMaybeRunnable.size()) {\n           break;\n         }\n       }\n \n       prev \u003d next;\n     }\n+    \n+    // We remove the apps from their pending lists afterwards so that we don\u0027t\n+    // pull them out from under the iterator.  If they are not in these lists\n+    // in the first place, there is a bug.\n+    for (AppSchedulable appSched : noLongerPendingApps) {\n+      if (!appSched.getApp().getQueue().getNonRunnableAppSchedulables()\n+          .remove(appSched)) {\n+        LOG.error(\"Can\u0027t make app runnable that does not already exist in queue\"\n+            + \" as non-runnable: \" + appSched + \". This should never happen.\");\n+      }\n+      \n+      if (!usersNonRunnableApps.remove(appSched.getApp().getUser(), appSched)) {\n+        LOG.error(\"Waiting app \" + appSched + \" expected to be in \"\n+        \t\t+ \"usersNonRunnableApps, but was not. This should never happen.\");\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateRunnabilityOnAppRemoval(FSSchedulerApp app) {\n    AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n    \n    // Update usersRunnableApps\n    String user \u003d app.getUser();\n    int newUserNumRunning \u003d usersNumRunnableApps.get(user) - 1;\n    if (newUserNumRunning \u003d\u003d 0) {\n      usersNumRunnableApps.remove(user);\n    } else {\n      usersNumRunnableApps.put(user, newUserNumRunning);\n    }\n\n    // Update runnable app bookkeeping for queues:\n    // childqueueX might have no pending apps itself, but if a queue higher up\n    // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n    // in childqueueX could allow an app in some other distant child of\n    // parentqueueY to become runnable.\n    // An app removal will only possibly allow another app to become runnable if\n    // the queue was already at its max before the removal.\n    // Thus we find the ancestor queue highest in the tree for which the app\n    // that was at its maxRunningApps before the removal.\n    FSLeafQueue queue \u003d app.getQueue();\n    FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n        allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n    FSParentQueue parent \u003d queue.getParent();\n    while (parent !\u003d null) {\n      if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n          .getName())) {\n        highestQueueWithAppsNowRunnable \u003d parent;\n      }\n      parent.decrementRunnableApps();\n      parent \u003d parent.getParent();\n    }\n\n    List\u003cList\u003cAppSchedulable\u003e\u003e appsNowMaybeRunnable \u003d\n        new ArrayList\u003cList\u003cAppSchedulable\u003e\u003e();\n\n    // Compile lists of apps which may now be runnable\n    // We gather lists instead of building a set of all non-runnable apps so\n    // that this whole operation can be O(number of queues) instead of\n    // O(number of apps)\n    if (highestQueueWithAppsNowRunnable !\u003d null) {\n      gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n          appsNowMaybeRunnable);\n    }\n    if (newUserNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n      List\u003cAppSchedulable\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n      if (userWaitingApps !\u003d null) {\n        appsNowMaybeRunnable.add(userWaitingApps);\n      }\n    }\n\n    // Scan through and check whether this means that any apps are now runnable\n    Iterator\u003cFSSchedulerApp\u003e iter \u003d new MultiListStartTimeIterator(\n        appsNowMaybeRunnable);\n    FSSchedulerApp prev \u003d null;\n    List\u003cAppSchedulable\u003e noLongerPendingApps \u003d new ArrayList\u003cAppSchedulable\u003e();\n    while (iter.hasNext()) {\n      FSSchedulerApp next \u003d iter.next();\n      if (next \u003d\u003d prev) {\n        continue;\n      }\n\n      if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n        trackRunnableApp(next);\n        AppSchedulable appSched \u003d next.getAppSchedulable();\n        next.getQueue().getRunnableAppSchedulables().add(appSched);\n        noLongerPendingApps.add(appSched);\n\n        // No more than one app per list will be able to be made runnable, so\n        // we can stop looking after we\u0027ve found that many\n        if (noLongerPendingApps.size() \u003e\u003d appsNowMaybeRunnable.size()) {\n          break;\n        }\n      }\n\n      prev \u003d next;\n    }\n    \n    // We remove the apps from their pending lists afterwards so that we don\u0027t\n    // pull them out from under the iterator.  If they are not in these lists\n    // in the first place, there is a bug.\n    for (AppSchedulable appSched : noLongerPendingApps) {\n      if (!appSched.getApp().getQueue().getNonRunnableAppSchedulables()\n          .remove(appSched)) {\n        LOG.error(\"Can\u0027t make app runnable that does not already exist in queue\"\n            + \" as non-runnable: \" + appSched + \". This should never happen.\");\n      }\n      \n      if (!usersNonRunnableApps.remove(appSched.getApp().getUser(), appSched)) {\n        LOG.error(\"Waiting app \" + appSched + \" expected to be in \"\n        \t\t+ \"usersNonRunnableApps, but was not. This should never happen.\");\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/MaxRunningAppsEnforcer.java",
      "extendedDetails": {}
    },
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1403. Separate out configuration loading from QueueManager in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548006 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/12/13 7:26 PM",
      "commitName": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "29/11/13 11:08 AM",
      "commitNameOld": "61b6ed73f8a5a75951c7b355c673459874eef7c3",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 5.35,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,82 @@\n   public void updateRunnabilityOnAppRemoval(FSSchedulerApp app) {\n+    AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n+    \n     // Update usersRunnableApps\n     String user \u003d app.getUser();\n     int newUserNumRunning \u003d usersNumRunnableApps.get(user) - 1;\n     if (newUserNumRunning \u003d\u003d 0) {\n       usersNumRunnableApps.remove(user);\n     } else {\n       usersNumRunnableApps.put(user, newUserNumRunning);\n     }\n \n     // Update runnable app bookkeeping for queues:\n     // childqueueX might have no pending apps itself, but if a queue higher up\n     // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n     // in childqueueX could allow an app in some other distant child of\n     // parentqueueY to become runnable.\n     // An app removal will only possibly allow another app to become runnable if\n     // the queue was already at its max before the removal.\n     // Thus we find the ancestor queue highest in the tree for which the app\n     // that was at its maxRunningApps before the removal.\n     FSLeafQueue queue \u003d app.getQueue();\n     FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n-        queueMgr.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n+        allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n     FSParentQueue parent \u003d queue.getParent();\n     while (parent !\u003d null) {\n-      if (parent.getNumRunnableApps() \u003d\u003d queueMgr.getQueueMaxApps(parent\n+      if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n           .getName())) {\n         highestQueueWithAppsNowRunnable \u003d parent;\n       }\n       parent.decrementRunnableApps();\n       parent \u003d parent.getParent();\n     }\n \n     List\u003cList\u003cAppSchedulable\u003e\u003e appsNowMaybeRunnable \u003d\n         new ArrayList\u003cList\u003cAppSchedulable\u003e\u003e();\n \n     // Compile lists of apps which may now be runnable\n     // We gather lists instead of building a set of all non-runnable apps so\n     // that this whole operation can be O(number of queues) instead of\n     // O(number of apps)\n     if (highestQueueWithAppsNowRunnable !\u003d null) {\n       gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n           appsNowMaybeRunnable);\n     }\n-    if (newUserNumRunning \u003d\u003d queueMgr.getUserMaxApps(user) - 1) {\n+    if (newUserNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n       List\u003cAppSchedulable\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n       if (userWaitingApps !\u003d null) {\n         appsNowMaybeRunnable.add(userWaitingApps);\n       }\n     }\n \n     // Scan through and check whether this means that any apps are now runnable\n     Iterator\u003cFSSchedulerApp\u003e iter \u003d new MultiListStartTimeIterator(\n         appsNowMaybeRunnable);\n     FSSchedulerApp prev \u003d null;\n     int numNowRunnable \u003d 0;\n     while (iter.hasNext()) {\n       FSSchedulerApp next \u003d iter.next();\n       if (next \u003d\u003d prev) {\n         continue;\n       }\n \n       if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n         trackRunnableApp(next);\n         AppSchedulable appSched \u003d next.getAppSchedulable();\n         next.getQueue().makeAppRunnable(appSched);\n         if (!usersNonRunnableApps.remove(next.getUser(), appSched)) {\n           throw new IllegalStateException(\"Waiting app \" + next\n               + \" expected to be in usersNonRunnableApps\");\n         }\n \n         // No more than one app per list will be able to be made runnable, so\n         // we can stop looking after we\u0027ve found that many\n         if (numNowRunnable \u003e\u003d appsNowMaybeRunnable.size()) {\n           break;\n         }\n       }\n \n       prev \u003d next;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateRunnabilityOnAppRemoval(FSSchedulerApp app) {\n    AllocationConfiguration allocConf \u003d scheduler.getAllocationConfiguration();\n    \n    // Update usersRunnableApps\n    String user \u003d app.getUser();\n    int newUserNumRunning \u003d usersNumRunnableApps.get(user) - 1;\n    if (newUserNumRunning \u003d\u003d 0) {\n      usersNumRunnableApps.remove(user);\n    } else {\n      usersNumRunnableApps.put(user, newUserNumRunning);\n    }\n\n    // Update runnable app bookkeeping for queues:\n    // childqueueX might have no pending apps itself, but if a queue higher up\n    // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n    // in childqueueX could allow an app in some other distant child of\n    // parentqueueY to become runnable.\n    // An app removal will only possibly allow another app to become runnable if\n    // the queue was already at its max before the removal.\n    // Thus we find the ancestor queue highest in the tree for which the app\n    // that was at its maxRunningApps before the removal.\n    FSLeafQueue queue \u003d app.getQueue();\n    FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n        allocConf.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n    FSParentQueue parent \u003d queue.getParent();\n    while (parent !\u003d null) {\n      if (parent.getNumRunnableApps() \u003d\u003d allocConf.getQueueMaxApps(parent\n          .getName())) {\n        highestQueueWithAppsNowRunnable \u003d parent;\n      }\n      parent.decrementRunnableApps();\n      parent \u003d parent.getParent();\n    }\n\n    List\u003cList\u003cAppSchedulable\u003e\u003e appsNowMaybeRunnable \u003d\n        new ArrayList\u003cList\u003cAppSchedulable\u003e\u003e();\n\n    // Compile lists of apps which may now be runnable\n    // We gather lists instead of building a set of all non-runnable apps so\n    // that this whole operation can be O(number of queues) instead of\n    // O(number of apps)\n    if (highestQueueWithAppsNowRunnable !\u003d null) {\n      gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n          appsNowMaybeRunnable);\n    }\n    if (newUserNumRunning \u003d\u003d allocConf.getUserMaxApps(user) - 1) {\n      List\u003cAppSchedulable\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n      if (userWaitingApps !\u003d null) {\n        appsNowMaybeRunnable.add(userWaitingApps);\n      }\n    }\n\n    // Scan through and check whether this means that any apps are now runnable\n    Iterator\u003cFSSchedulerApp\u003e iter \u003d new MultiListStartTimeIterator(\n        appsNowMaybeRunnable);\n    FSSchedulerApp prev \u003d null;\n    int numNowRunnable \u003d 0;\n    while (iter.hasNext()) {\n      FSSchedulerApp next \u003d iter.next();\n      if (next \u003d\u003d prev) {\n        continue;\n      }\n\n      if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n        trackRunnableApp(next);\n        AppSchedulable appSched \u003d next.getAppSchedulable();\n        next.getQueue().makeAppRunnable(appSched);\n        if (!usersNonRunnableApps.remove(next.getUser(), appSched)) {\n          throw new IllegalStateException(\"Waiting app \" + next\n              + \" expected to be in usersNonRunnableApps\");\n        }\n\n        // No more than one app per list will be able to be made runnable, so\n        // we can stop looking after we\u0027ve found that many\n        if (numNowRunnable \u003e\u003d appsNowMaybeRunnable.size()) {\n          break;\n        }\n      }\n\n      prev \u003d next;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/MaxRunningAppsEnforcer.java",
      "extendedDetails": {}
    },
    "61b6ed73f8a5a75951c7b355c673459874eef7c3": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1241: Include missing files\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546625 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/13 11:08 AM",
      "commitName": "61b6ed73f8a5a75951c7b355c673459874eef7c3",
      "commitAuthor": "Sanford Ryza",
      "diff": "@@ -0,0 +1,80 @@\n+  public void updateRunnabilityOnAppRemoval(FSSchedulerApp app) {\n+    // Update usersRunnableApps\n+    String user \u003d app.getUser();\n+    int newUserNumRunning \u003d usersNumRunnableApps.get(user) - 1;\n+    if (newUserNumRunning \u003d\u003d 0) {\n+      usersNumRunnableApps.remove(user);\n+    } else {\n+      usersNumRunnableApps.put(user, newUserNumRunning);\n+    }\n+\n+    // Update runnable app bookkeeping for queues:\n+    // childqueueX might have no pending apps itself, but if a queue higher up\n+    // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n+    // in childqueueX could allow an app in some other distant child of\n+    // parentqueueY to become runnable.\n+    // An app removal will only possibly allow another app to become runnable if\n+    // the queue was already at its max before the removal.\n+    // Thus we find the ancestor queue highest in the tree for which the app\n+    // that was at its maxRunningApps before the removal.\n+    FSLeafQueue queue \u003d app.getQueue();\n+    FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n+        queueMgr.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n+    FSParentQueue parent \u003d queue.getParent();\n+    while (parent !\u003d null) {\n+      if (parent.getNumRunnableApps() \u003d\u003d queueMgr.getQueueMaxApps(parent\n+          .getName())) {\n+        highestQueueWithAppsNowRunnable \u003d parent;\n+      }\n+      parent.decrementRunnableApps();\n+      parent \u003d parent.getParent();\n+    }\n+\n+    List\u003cList\u003cAppSchedulable\u003e\u003e appsNowMaybeRunnable \u003d\n+        new ArrayList\u003cList\u003cAppSchedulable\u003e\u003e();\n+\n+    // Compile lists of apps which may now be runnable\n+    // We gather lists instead of building a set of all non-runnable apps so\n+    // that this whole operation can be O(number of queues) instead of\n+    // O(number of apps)\n+    if (highestQueueWithAppsNowRunnable !\u003d null) {\n+      gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n+          appsNowMaybeRunnable);\n+    }\n+    if (newUserNumRunning \u003d\u003d queueMgr.getUserMaxApps(user) - 1) {\n+      List\u003cAppSchedulable\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n+      if (userWaitingApps !\u003d null) {\n+        appsNowMaybeRunnable.add(userWaitingApps);\n+      }\n+    }\n+\n+    // Scan through and check whether this means that any apps are now runnable\n+    Iterator\u003cFSSchedulerApp\u003e iter \u003d new MultiListStartTimeIterator(\n+        appsNowMaybeRunnable);\n+    FSSchedulerApp prev \u003d null;\n+    int numNowRunnable \u003d 0;\n+    while (iter.hasNext()) {\n+      FSSchedulerApp next \u003d iter.next();\n+      if (next \u003d\u003d prev) {\n+        continue;\n+      }\n+\n+      if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n+        trackRunnableApp(next);\n+        AppSchedulable appSched \u003d next.getAppSchedulable();\n+        next.getQueue().makeAppRunnable(appSched);\n+        if (!usersNonRunnableApps.remove(next.getUser(), appSched)) {\n+          throw new IllegalStateException(\"Waiting app \" + next\n+              + \" expected to be in usersNonRunnableApps\");\n+        }\n+\n+        // No more than one app per list will be able to be made runnable, so\n+        // we can stop looking after we\u0027ve found that many\n+        if (numNowRunnable \u003e\u003d appsNowMaybeRunnable.size()) {\n+          break;\n+        }\n+      }\n+\n+      prev \u003d next;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateRunnabilityOnAppRemoval(FSSchedulerApp app) {\n    // Update usersRunnableApps\n    String user \u003d app.getUser();\n    int newUserNumRunning \u003d usersNumRunnableApps.get(user) - 1;\n    if (newUserNumRunning \u003d\u003d 0) {\n      usersNumRunnableApps.remove(user);\n    } else {\n      usersNumRunnableApps.put(user, newUserNumRunning);\n    }\n\n    // Update runnable app bookkeeping for queues:\n    // childqueueX might have no pending apps itself, but if a queue higher up\n    // in the hierarchy parentqueueY has a maxRunningApps set, an app completion\n    // in childqueueX could allow an app in some other distant child of\n    // parentqueueY to become runnable.\n    // An app removal will only possibly allow another app to become runnable if\n    // the queue was already at its max before the removal.\n    // Thus we find the ancestor queue highest in the tree for which the app\n    // that was at its maxRunningApps before the removal.\n    FSLeafQueue queue \u003d app.getQueue();\n    FSQueue highestQueueWithAppsNowRunnable \u003d (queue.getNumRunnableApps() \u003d\u003d\n        queueMgr.getQueueMaxApps(queue.getName()) - 1) ? queue : null;\n    FSParentQueue parent \u003d queue.getParent();\n    while (parent !\u003d null) {\n      if (parent.getNumRunnableApps() \u003d\u003d queueMgr.getQueueMaxApps(parent\n          .getName())) {\n        highestQueueWithAppsNowRunnable \u003d parent;\n      }\n      parent.decrementRunnableApps();\n      parent \u003d parent.getParent();\n    }\n\n    List\u003cList\u003cAppSchedulable\u003e\u003e appsNowMaybeRunnable \u003d\n        new ArrayList\u003cList\u003cAppSchedulable\u003e\u003e();\n\n    // Compile lists of apps which may now be runnable\n    // We gather lists instead of building a set of all non-runnable apps so\n    // that this whole operation can be O(number of queues) instead of\n    // O(number of apps)\n    if (highestQueueWithAppsNowRunnable !\u003d null) {\n      gatherPossiblyRunnableAppLists(highestQueueWithAppsNowRunnable,\n          appsNowMaybeRunnable);\n    }\n    if (newUserNumRunning \u003d\u003d queueMgr.getUserMaxApps(user) - 1) {\n      List\u003cAppSchedulable\u003e userWaitingApps \u003d usersNonRunnableApps.get(user);\n      if (userWaitingApps !\u003d null) {\n        appsNowMaybeRunnable.add(userWaitingApps);\n      }\n    }\n\n    // Scan through and check whether this means that any apps are now runnable\n    Iterator\u003cFSSchedulerApp\u003e iter \u003d new MultiListStartTimeIterator(\n        appsNowMaybeRunnable);\n    FSSchedulerApp prev \u003d null;\n    int numNowRunnable \u003d 0;\n    while (iter.hasNext()) {\n      FSSchedulerApp next \u003d iter.next();\n      if (next \u003d\u003d prev) {\n        continue;\n      }\n\n      if (canAppBeRunnable(next.getQueue(), next.getUser())) {\n        trackRunnableApp(next);\n        AppSchedulable appSched \u003d next.getAppSchedulable();\n        next.getQueue().makeAppRunnable(appSched);\n        if (!usersNonRunnableApps.remove(next.getUser(), appSched)) {\n          throw new IllegalStateException(\"Waiting app \" + next\n              + \" expected to be in usersNonRunnableApps\");\n        }\n\n        // No more than one app per list will be able to be made runnable, so\n        // we can stop looking after we\u0027ve found that many\n        if (numNowRunnable \u003e\u003d appsNowMaybeRunnable.size()) {\n          break;\n        }\n      }\n\n      prev \u003d next;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/MaxRunningAppsEnforcer.java"
    }
  }
}