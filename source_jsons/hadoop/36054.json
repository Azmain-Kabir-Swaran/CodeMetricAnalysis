{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMAppManager.java",
  "functionName": "recoverApplication",
  "functionId": "recoverApplication___appState-ApplicationStateData__rmState-RMState",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
  "functionStartLine": 381,
  "functionEndLine": 394,
  "numCommitsSeen": 170,
  "timeTaken": 6413,
  "changeHistory": [
    "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc",
    "91f120f743662c6e037e8f21b1792e81d58ac664",
    "9bae6720cb8432efd78c909dc624c00e367cedf5",
    "3fa0d540dfca579f3c2840a959b748a7528b02ed",
    "702236129b930a799a5a3295f0aa0dc7b619c354",
    "f65eeb412d140a3808bcf99344a9f3a965918f70",
    "5805a81efbc024024d8172489dfdc6cf77879416",
    "b2cd2698028118b6384904732dbf94942f644732",
    "a16d022ca4313a41425c8e97841c841a2d6f2f54",
    "4de17c60528cb29bf7306dbaa720b96063948b17",
    "512475e56f0a27bf3c3ff596184f96993bb4bef4"
  ],
  "changeHistoryShort": {
    "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc": "Ybodychange",
    "91f120f743662c6e037e8f21b1792e81d58ac664": "Ybodychange",
    "9bae6720cb8432efd78c909dc624c00e367cedf5": "Ybodychange",
    "3fa0d540dfca579f3c2840a959b748a7528b02ed": "Ybodychange",
    "702236129b930a799a5a3295f0aa0dc7b619c354": "Ybodychange",
    "f65eeb412d140a3808bcf99344a9f3a965918f70": "Ybodychange",
    "5805a81efbc024024d8172489dfdc6cf77879416": "Ymultichange(Yparameterchange,Ybodychange)",
    "b2cd2698028118b6384904732dbf94942f644732": "Ybodychange",
    "a16d022ca4313a41425c8e97841c841a2d6f2f54": "Ybodychange",
    "4de17c60528cb29bf7306dbaa720b96063948b17": "Ymultichange(Yparameterchange,Ymodifierchange,Yexceptionschange,Ybodychange)",
    "512475e56f0a27bf3c3ff596184f96993bb4bef4": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9723. ApplicationPlacementContext is not required for terminated jobs during recovery. Contributed by Prabhu Joseph\n",
      "commitDate": "12/08/19 6:15 AM",
      "commitName": "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "15/05/19 1:00 AM",
      "commitNameOld": "570fa2da20706490dc7823efd0ce0cef3ddc81f9",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 89.22,
      "commitsBetweenForRepo": 715,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,14 @@\n   protected void recoverApplication(ApplicationStateData appState,\n       RMState rmState) throws Exception {\n     ApplicationSubmissionContext appContext \u003d\n         appState.getApplicationSubmissionContext();\n     ApplicationId appId \u003d appContext.getApplicationId();\n \n     // create and recover app.\n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n-            appState.getUser(), true, appState.getStartTime());\n+            appState.getUser(), true, appState.getStartTime(),\n+            appState.getState());\n \n     application.handle(new RMAppRecoverEvent(appId, rmState));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void recoverApplication(ApplicationStateData appState,\n      RMState rmState) throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appContext.getApplicationId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n            appState.getUser(), true, appState.getStartTime(),\n            appState.getState());\n\n    application.handle(new RMAppRecoverEvent(appId, rmState));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "91f120f743662c6e037e8f21b1792e81d58ac664": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6872. Ensure apps could run given NodeLabels are disabled post RM switchover/restart. Contributed by Sunil G\n",
      "commitDate": "01/08/17 9:56 AM",
      "commitName": "91f120f743662c6e037e8f21b1792e81d58ac664",
      "commitAuthor": "Jian He",
      "commitDateOld": "09/05/17 9:22 AM",
      "commitNameOld": "543aac9f281871a40473e83061f6deadc0bbdab7",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 84.02,
      "commitsBetweenForRepo": 415,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,13 @@\n   protected void recoverApplication(ApplicationStateData appState,\n       RMState rmState) throws Exception {\n     ApplicationSubmissionContext appContext \u003d\n         appState.getApplicationSubmissionContext();\n     ApplicationId appId \u003d appContext.getApplicationId();\n \n     // create and recover app.\n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n             appState.getUser(), true, appState.getStartTime());\n \n-    // If null amReq has been returned, check if it is the case that\n-    // application has specified node label expression while node label\n-    // has been disabled. Reject the recovery of this application if it\n-    // is true and give clear message so that user can react properly.\n-    if (!appContext.getUnmanagedAM() \u0026\u0026\n-        (application.getAMResourceRequests() \u003d\u003d null ||\n-            application.getAMResourceRequests().isEmpty()) \u0026\u0026\n-        !YarnConfiguration.areNodeLabelsEnabled(this.conf)) {\n-      // check application submission context and see if am resource request\n-      // or application itself contains any node label expression.\n-      List\u003cResourceRequest\u003e amReqsFromAppContext \u003d\n-          appContext.getAMContainerResourceRequests();\n-      String labelExp \u003d\n-          (amReqsFromAppContext !\u003d null \u0026\u0026 !amReqsFromAppContext.isEmpty()) ?\n-          amReqsFromAppContext.get(0).getNodeLabelExpression() : null;\n-      if (labelExp \u003d\u003d null) {\n-        labelExp \u003d appContext.getNodeLabelExpression();\n-      }\n-      if (labelExp !\u003d null \u0026\u0026\n-          !labelExp.equals(RMNodeLabelsManager.NO_LABEL)) {\n-        String message \u003d \"Failed to recover application \" + appId\n-            + \". NodeLabel is not enabled in cluster, but AM resource request \"\n-            + \"contains a label expression.\";\n-        LOG.warn(message);\n-        application.handle(\n-            new RMAppEvent(appId, RMAppEventType.APP_REJECTED, message));\n-        return;\n-      }\n-    }\n-\n     application.handle(new RMAppRecoverEvent(appId, rmState));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void recoverApplication(ApplicationStateData appState,\n      RMState rmState) throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appContext.getApplicationId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n            appState.getUser(), true, appState.getStartTime());\n\n    application.handle(new RMAppRecoverEvent(appId, rmState));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "9bae6720cb8432efd78c909dc624c00e367cedf5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6050. AMs can\u0027t be scheduled on racks or nodes (rkanter)\n",
      "commitDate": "27/03/17 5:23 PM",
      "commitName": "9bae6720cb8432efd78c909dc624c00e367cedf5",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "24/03/17 6:06 PM",
      "commitNameOld": "84ddedc0b2d58257d45c16ee5e83b15f94a7ba3a",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 2.97,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,43 @@\n   protected void recoverApplication(ApplicationStateData appState,\n       RMState rmState) throws Exception {\n     ApplicationSubmissionContext appContext \u003d\n         appState.getApplicationSubmissionContext();\n     ApplicationId appId \u003d appContext.getApplicationId();\n \n     // create and recover app.\n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n             appState.getUser(), true, appState.getStartTime());\n \n     // If null amReq has been returned, check if it is the case that\n     // application has specified node label expression while node label\n     // has been disabled. Reject the recovery of this application if it\n     // is true and give clear message so that user can react properly.\n     if (!appContext.getUnmanagedAM() \u0026\u0026\n-        application.getAMResourceRequest() \u003d\u003d null \u0026\u0026\n+        (application.getAMResourceRequests() \u003d\u003d null ||\n+            application.getAMResourceRequests().isEmpty()) \u0026\u0026\n         !YarnConfiguration.areNodeLabelsEnabled(this.conf)) {\n       // check application submission context and see if am resource request\n       // or application itself contains any node label expression.\n-      ResourceRequest amReqFromAppContext \u003d\n-          appContext.getAMContainerResourceRequest();\n-      String labelExp \u003d (amReqFromAppContext !\u003d null) ?\n-          amReqFromAppContext.getNodeLabelExpression() : null;\n+      List\u003cResourceRequest\u003e amReqsFromAppContext \u003d\n+          appContext.getAMContainerResourceRequests();\n+      String labelExp \u003d\n+          (amReqsFromAppContext !\u003d null \u0026\u0026 !amReqsFromAppContext.isEmpty()) ?\n+          amReqsFromAppContext.get(0).getNodeLabelExpression() : null;\n       if (labelExp \u003d\u003d null) {\n         labelExp \u003d appContext.getNodeLabelExpression();\n       }\n       if (labelExp !\u003d null \u0026\u0026\n           !labelExp.equals(RMNodeLabelsManager.NO_LABEL)) {\n         String message \u003d \"Failed to recover application \" + appId\n             + \". NodeLabel is not enabled in cluster, but AM resource request \"\n             + \"contains a label expression.\";\n         LOG.warn(message);\n         application.handle(\n             new RMAppEvent(appId, RMAppEventType.APP_REJECTED, message));\n         return;\n       }\n     }\n \n     application.handle(new RMAppRecoverEvent(appId, rmState));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void recoverApplication(ApplicationStateData appState,\n      RMState rmState) throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appContext.getApplicationId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n            appState.getUser(), true, appState.getStartTime());\n\n    // If null amReq has been returned, check if it is the case that\n    // application has specified node label expression while node label\n    // has been disabled. Reject the recovery of this application if it\n    // is true and give clear message so that user can react properly.\n    if (!appContext.getUnmanagedAM() \u0026\u0026\n        (application.getAMResourceRequests() \u003d\u003d null ||\n            application.getAMResourceRequests().isEmpty()) \u0026\u0026\n        !YarnConfiguration.areNodeLabelsEnabled(this.conf)) {\n      // check application submission context and see if am resource request\n      // or application itself contains any node label expression.\n      List\u003cResourceRequest\u003e amReqsFromAppContext \u003d\n          appContext.getAMContainerResourceRequests();\n      String labelExp \u003d\n          (amReqsFromAppContext !\u003d null \u0026\u0026 !amReqsFromAppContext.isEmpty()) ?\n          amReqsFromAppContext.get(0).getNodeLabelExpression() : null;\n      if (labelExp \u003d\u003d null) {\n        labelExp \u003d appContext.getNodeLabelExpression();\n      }\n      if (labelExp !\u003d null \u0026\u0026\n          !labelExp.equals(RMNodeLabelsManager.NO_LABEL)) {\n        String message \u003d \"Failed to recover application \" + appId\n            + \". NodeLabel is not enabled in cluster, but AM resource request \"\n            + \"contains a label expression.\";\n        LOG.warn(message);\n        application.handle(\n            new RMAppEvent(appId, RMAppEventType.APP_REJECTED, message));\n        return;\n      }\n    }\n\n    application.handle(new RMAppRecoverEvent(appId, rmState));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "3fa0d540dfca579f3c2840a959b748a7528b02ed": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6031. Application recovery has failed when node label feature is turned off during RM recovery. Contributed by Ying Zhang.\n",
      "commitDate": "22/01/17 10:49 PM",
      "commitName": "3fa0d540dfca579f3c2840a959b748a7528b02ed",
      "commitAuthor": "Sunil G",
      "commitDateOld": "09/01/17 8:40 AM",
      "commitNameOld": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 13.59,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,41 @@\n   protected void recoverApplication(ApplicationStateData appState,\n       RMState rmState) throws Exception {\n     ApplicationSubmissionContext appContext \u003d\n         appState.getApplicationSubmissionContext();\n     ApplicationId appId \u003d appContext.getApplicationId();\n \n     // create and recover app.\n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n             appState.getUser(), true, appState.getStartTime());\n \n+    // If null amReq has been returned, check if it is the case that\n+    // application has specified node label expression while node label\n+    // has been disabled. Reject the recovery of this application if it\n+    // is true and give clear message so that user can react properly.\n+    if (!appContext.getUnmanagedAM() \u0026\u0026\n+        application.getAMResourceRequest() \u003d\u003d null \u0026\u0026\n+        !YarnConfiguration.areNodeLabelsEnabled(this.conf)) {\n+      // check application submission context and see if am resource request\n+      // or application itself contains any node label expression.\n+      ResourceRequest amReqFromAppContext \u003d\n+          appContext.getAMContainerResourceRequest();\n+      String labelExp \u003d (amReqFromAppContext !\u003d null) ?\n+          amReqFromAppContext.getNodeLabelExpression() : null;\n+      if (labelExp \u003d\u003d null) {\n+        labelExp \u003d appContext.getNodeLabelExpression();\n+      }\n+      if (labelExp !\u003d null \u0026\u0026\n+          !labelExp.equals(RMNodeLabelsManager.NO_LABEL)) {\n+        String message \u003d \"Failed to recover application \" + appId\n+            + \". NodeLabel is not enabled in cluster, but AM resource request \"\n+            + \"contains a label expression.\";\n+        LOG.warn(message);\n+        application.handle(\n+            new RMAppEvent(appId, RMAppEventType.APP_REJECTED, message));\n+        return;\n+      }\n+    }\n+\n     application.handle(new RMAppRecoverEvent(appId, rmState));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void recoverApplication(ApplicationStateData appState,\n      RMState rmState) throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appContext.getApplicationId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n            appState.getUser(), true, appState.getStartTime());\n\n    // If null amReq has been returned, check if it is the case that\n    // application has specified node label expression while node label\n    // has been disabled. Reject the recovery of this application if it\n    // is true and give clear message so that user can react properly.\n    if (!appContext.getUnmanagedAM() \u0026\u0026\n        application.getAMResourceRequest() \u003d\u003d null \u0026\u0026\n        !YarnConfiguration.areNodeLabelsEnabled(this.conf)) {\n      // check application submission context and see if am resource request\n      // or application itself contains any node label expression.\n      ResourceRequest amReqFromAppContext \u003d\n          appContext.getAMContainerResourceRequest();\n      String labelExp \u003d (amReqFromAppContext !\u003d null) ?\n          amReqFromAppContext.getNodeLabelExpression() : null;\n      if (labelExp \u003d\u003d null) {\n        labelExp \u003d appContext.getNodeLabelExpression();\n      }\n      if (labelExp !\u003d null \u0026\u0026\n          !labelExp.equals(RMNodeLabelsManager.NO_LABEL)) {\n        String message \u003d \"Failed to recover application \" + appId\n            + \". NodeLabel is not enabled in cluster, but AM resource request \"\n            + \"contains a label expression.\";\n        LOG.warn(message);\n        application.handle(\n            new RMAppEvent(appId, RMAppEventType.APP_REJECTED, message));\n        return;\n      }\n    }\n\n    application.handle(new RMAppRecoverEvent(appId, rmState));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "702236129b930a799a5a3295f0aa0dc7b619c354": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5095. flow activities and flow runs are populated with wrong timestamp when RM restarts w/ recovery enabled (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:46 AM",
      "commitName": "702236129b930a799a5a3295f0aa0dc7b619c354",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,13 @@\n   protected void recoverApplication(ApplicationStateData appState,\n       RMState rmState) throws Exception {\n     ApplicationSubmissionContext appContext \u003d\n         appState.getApplicationSubmissionContext();\n     ApplicationId appId \u003d appContext.getApplicationId();\n \n     // create and recover app.\n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n-            appState.getUser(), true);\n+            appState.getUser(), true, appState.getStartTime());\n \n     application.handle(new RMAppRecoverEvent(appId, rmState));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void recoverApplication(ApplicationStateData appState,\n      RMState rmState) throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appContext.getApplicationId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n            appState.getUser(), true, appState.getStartTime());\n\n    application.handle(new RMAppRecoverEvent(appId, rmState));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "f65eeb412d140a3808bcf99344a9f3a965918f70": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3493. RM fails to come up with error \"Failed to load/recover state\" when mem settings are changed. (Jian He via wangda)\n",
      "commitDate": "17/04/15 5:11 PM",
      "commitName": "f65eeb412d140a3808bcf99344a9f3a965918f70",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/03/15 1:49 PM",
      "commitNameOld": "968425e9f7b850ff9c2ab8ca37a64c3fdbe77dbf",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 31.14,
      "commitsBetweenForRepo": 283,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,12 +1,13 @@\n   protected void recoverApplication(ApplicationStateData appState,\n       RMState rmState) throws Exception {\n     ApplicationSubmissionContext appContext \u003d\n         appState.getApplicationSubmissionContext();\n     ApplicationId appId \u003d appContext.getApplicationId();\n \n     // create and recover app.\n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n-          appState.getUser());\n+            appState.getUser(), true);\n+\n     application.handle(new RMAppRecoverEvent(appId, rmState));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void recoverApplication(ApplicationStateData appState,\n      RMState rmState) throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appContext.getApplicationId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n            appState.getUser(), true);\n\n    application.handle(new RMAppRecoverEvent(appId, rmState));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "5805a81efbc024024d8172489dfdc6cf77879416": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2404. Removed ApplicationAttemptState and ApplicationState class in RMStateStore. Contributed by Tsuyoshi OZAWA\n",
      "commitDate": "25/11/14 12:48 PM",
      "commitName": "5805a81efbc024024d8172489dfdc6cf77879416",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2404. Removed ApplicationAttemptState and ApplicationState class in RMStateStore. Contributed by Tsuyoshi OZAWA\n",
          "commitDate": "25/11/14 12:48 PM",
          "commitName": "5805a81efbc024024d8172489dfdc6cf77879416",
          "commitAuthor": "Jian He",
          "commitDateOld": "12/11/14 9:01 AM",
          "commitNameOld": "f8aefa5e9c8c6d2817205b5ed8d914db31f56ae7",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 13.16,
          "commitsBetweenForRepo": 94,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,12 +1,12 @@\n-  protected void recoverApplication(ApplicationState appState, RMState rmState)\n-      throws Exception {\n+  protected void recoverApplication(ApplicationStateData appState,\n+      RMState rmState) throws Exception {\n     ApplicationSubmissionContext appContext \u003d\n         appState.getApplicationSubmissionContext();\n-    ApplicationId appId \u003d appState.getAppId();\n+    ApplicationId appId \u003d appContext.getApplicationId();\n \n     // create and recover app.\n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n           appState.getUser());\n     application.handle(new RMAppRecoverEvent(appId, rmState));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void recoverApplication(ApplicationStateData appState,\n      RMState rmState) throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appContext.getApplicationId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n          appState.getUser());\n    application.handle(new RMAppRecoverEvent(appId, rmState));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[appState-ApplicationState, rmState-RMState]",
            "newValue": "[appState-ApplicationStateData, rmState-RMState]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2404. Removed ApplicationAttemptState and ApplicationState class in RMStateStore. Contributed by Tsuyoshi OZAWA\n",
          "commitDate": "25/11/14 12:48 PM",
          "commitName": "5805a81efbc024024d8172489dfdc6cf77879416",
          "commitAuthor": "Jian He",
          "commitDateOld": "12/11/14 9:01 AM",
          "commitNameOld": "f8aefa5e9c8c6d2817205b5ed8d914db31f56ae7",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 13.16,
          "commitsBetweenForRepo": 94,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,12 +1,12 @@\n-  protected void recoverApplication(ApplicationState appState, RMState rmState)\n-      throws Exception {\n+  protected void recoverApplication(ApplicationStateData appState,\n+      RMState rmState) throws Exception {\n     ApplicationSubmissionContext appContext \u003d\n         appState.getApplicationSubmissionContext();\n-    ApplicationId appId \u003d appState.getAppId();\n+    ApplicationId appId \u003d appContext.getApplicationId();\n \n     // create and recover app.\n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n           appState.getUser());\n     application.handle(new RMAppRecoverEvent(appId, rmState));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void recoverApplication(ApplicationStateData appState,\n      RMState rmState) throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appContext.getApplicationId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n          appState.getUser());\n    application.handle(new RMAppRecoverEvent(appId, rmState));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "b2cd2698028118b6384904732dbf94942f644732": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2010. Handle app-recovery failures gracefully. (Jian He and Karthik Kambatla via kasha)\n",
      "commitDate": "04/11/14 5:45 PM",
      "commitName": "b2cd2698028118b6384904732dbf94942f644732",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "27/10/14 3:49 PM",
      "commitNameOld": "a16d022ca4313a41425c8e97841c841a2d6f2f54",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 8.12,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,12 @@\n-      recoverApplication(ApplicationState appState, RMState rmState)\n-          throws Exception {\n+  protected void recoverApplication(ApplicationState appState, RMState rmState)\n+      throws Exception {\n     ApplicationSubmissionContext appContext \u003d\n         appState.getApplicationSubmissionContext();\n     ApplicationId appId \u003d appState.getAppId();\n \n     // create and recover app.\n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n           appState.getUser());\n-    application.recover(rmState);\n-    if (isApplicationInFinalState(appState.getState())) {\n-      // We are synchronously moving the application into final state so that\n-      // momentarily client will not see this application in NEW state. Also\n-      // for finished applications we will avoid renewing tokens.\n-      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n-      return;\n-    }\n-\n-    if (UserGroupInformation.isSecurityEnabled()) {\n-      Credentials credentials \u003d null;\n-      try {\n-        credentials \u003d parseCredentials(appContext);\n-        // synchronously renew delegation token on recovery.\n-        rmContext.getDelegationTokenRenewer().addApplicationSync(appId,\n-          credentials, appContext.getCancelTokensWhenComplete(),\n-          application.getUser());\n-        application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n-      } catch (Exception e) {\n-        LOG.warn(\"Unable to parse and renew delegation tokens.\", e);\n-        this.rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppRejectedEvent(appId, e.getMessage()));\n-        throw e;\n-      }\n-    } else {\n-      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n-    }\n+    application.handle(new RMAppRecoverEvent(appId, rmState));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void recoverApplication(ApplicationState appState, RMState rmState)\n      throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appState.getAppId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n          appState.getUser());\n    application.handle(new RMAppRecoverEvent(appId, rmState));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "a16d022ca4313a41425c8e97841c841a2d6f2f54": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2704. Changed ResourceManager to optionally obtain tokens itself for the sake of localization and log-aggregation for long-running services. Contributed by Jian He.\n",
      "commitDate": "27/10/14 3:49 PM",
      "commitName": "a16d022ca4313a41425c8e97841c841a2d6f2f54",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "15/10/14 6:33 PM",
      "commitNameOld": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 11.89,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,38 @@\n       recoverApplication(ApplicationState appState, RMState rmState)\n           throws Exception {\n     ApplicationSubmissionContext appContext \u003d\n         appState.getApplicationSubmissionContext();\n     ApplicationId appId \u003d appState.getAppId();\n \n     // create and recover app.\n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n           appState.getUser());\n     application.recover(rmState);\n     if (isApplicationInFinalState(appState.getState())) {\n       // We are synchronously moving the application into final state so that\n       // momentarily client will not see this application in NEW state. Also\n       // for finished applications we will avoid renewing tokens.\n       application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n       return;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials credentials \u003d null;\n       try {\n         credentials \u003d parseCredentials(appContext);\n         // synchronously renew delegation token on recovery.\n         rmContext.getDelegationTokenRenewer().addApplicationSync(appId,\n-          credentials, appContext.getCancelTokensWhenComplete());\n+          credentials, appContext.getCancelTokensWhenComplete(),\n+          application.getUser());\n         application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n       } catch (Exception e) {\n         LOG.warn(\"Unable to parse and renew delegation tokens.\", e);\n         this.rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(appId, e.getMessage()));\n         throw e;\n       }\n     } else {\n       application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "      recoverApplication(ApplicationState appState, RMState rmState)\n          throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appState.getAppId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n          appState.getUser());\n    application.recover(rmState);\n    if (isApplicationInFinalState(appState.getState())) {\n      // We are synchronously moving the application into final state so that\n      // momentarily client will not see this application in NEW state. Also\n      // for finished applications we will avoid renewing tokens.\n      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials credentials \u003d null;\n      try {\n        credentials \u003d parseCredentials(appContext);\n        // synchronously renew delegation token on recovery.\n        rmContext.getDelegationTokenRenewer().addApplicationSync(appId,\n          credentials, appContext.getCancelTokensWhenComplete(),\n          application.getUser());\n        application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n      } catch (Exception e) {\n        LOG.warn(\"Unable to parse and renew delegation tokens.\", e);\n        this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(appId, e.getMessage()));\n        throw e;\n      }\n    } else {\n      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "4de17c60528cb29bf7306dbaa720b96063948b17": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-1812. Fixed ResourceManager to synchrously renew tokens after recovery and thus recover app itself synchronously and avoid races with resyncing NodeManagers. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1576843 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/03/14 11:25 AM",
      "commitName": "4de17c60528cb29bf7306dbaa720b96063948b17",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1812. Fixed ResourceManager to synchrously renew tokens after recovery and thus recover app itself synchronously and avoid races with resyncing NodeManagers. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1576843 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/03/14 11:25 AM",
          "commitName": "4de17c60528cb29bf7306dbaa720b96063948b17",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "04/02/14 8:55 PM",
          "commitNameOld": "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 35.56,
          "commitsBetweenForRepo": 336,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,9 +1,37 @@\n-  private void recoverApplication(RMState state, RMAppImpl application)\n-      throws YarnException {\n-    try {\n-      application.recover(state);\n-    } catch (Exception e) {\n-      LOG.error(\"Error recovering application\", e);\n-      throw new YarnException(e);\n+      recoverApplication(ApplicationState appState, RMState rmState)\n+          throws Exception {\n+    ApplicationSubmissionContext appContext \u003d\n+        appState.getApplicationSubmissionContext();\n+    ApplicationId appId \u003d appState.getAppId();\n+\n+    // create and recover app.\n+    RMAppImpl application \u003d\n+        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n+          appState.getUser());\n+    application.recover(rmState);\n+    if (isApplicationInFinalState(appState.getState())) {\n+      // We are synchronously moving the application into final state so that\n+      // momentarily client will not see this application in NEW state. Also\n+      // for finished applications we will avoid renewing tokens.\n+      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n+      return;\n+    }\n+\n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      Credentials credentials \u003d null;\n+      try {\n+        credentials \u003d parseCredentials(appContext);\n+        // synchronously renew delegation token on recovery.\n+        rmContext.getDelegationTokenRenewer().addApplicationSync(appId,\n+          credentials, appContext.getCancelTokensWhenComplete());\n+        application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n+      } catch (Exception e) {\n+        LOG.warn(\"Unable to parse and renew delegation tokens.\", e);\n+        this.rmContext.getDispatcher().getEventHandler()\n+          .handle(new RMAppRejectedEvent(appId, e.getMessage()));\n+        throw e;\n+      }\n+    } else {\n+      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "      recoverApplication(ApplicationState appState, RMState rmState)\n          throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appState.getAppId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n          appState.getUser());\n    application.recover(rmState);\n    if (isApplicationInFinalState(appState.getState())) {\n      // We are synchronously moving the application into final state so that\n      // momentarily client will not see this application in NEW state. Also\n      // for finished applications we will avoid renewing tokens.\n      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials credentials \u003d null;\n      try {\n        credentials \u003d parseCredentials(appContext);\n        // synchronously renew delegation token on recovery.\n        rmContext.getDelegationTokenRenewer().addApplicationSync(appId,\n          credentials, appContext.getCancelTokensWhenComplete());\n        application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n      } catch (Exception e) {\n        LOG.warn(\"Unable to parse and renew delegation tokens.\", e);\n        this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(appId, e.getMessage()));\n        throw e;\n      }\n    } else {\n      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[state-RMState, application-RMAppImpl]",
            "newValue": "[appState-ApplicationState, rmState-RMState]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-1812. Fixed ResourceManager to synchrously renew tokens after recovery and thus recover app itself synchronously and avoid races with resyncing NodeManagers. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1576843 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/03/14 11:25 AM",
          "commitName": "4de17c60528cb29bf7306dbaa720b96063948b17",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "04/02/14 8:55 PM",
          "commitNameOld": "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 35.56,
          "commitsBetweenForRepo": 336,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,9 +1,37 @@\n-  private void recoverApplication(RMState state, RMAppImpl application)\n-      throws YarnException {\n-    try {\n-      application.recover(state);\n-    } catch (Exception e) {\n-      LOG.error(\"Error recovering application\", e);\n-      throw new YarnException(e);\n+      recoverApplication(ApplicationState appState, RMState rmState)\n+          throws Exception {\n+    ApplicationSubmissionContext appContext \u003d\n+        appState.getApplicationSubmissionContext();\n+    ApplicationId appId \u003d appState.getAppId();\n+\n+    // create and recover app.\n+    RMAppImpl application \u003d\n+        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n+          appState.getUser());\n+    application.recover(rmState);\n+    if (isApplicationInFinalState(appState.getState())) {\n+      // We are synchronously moving the application into final state so that\n+      // momentarily client will not see this application in NEW state. Also\n+      // for finished applications we will avoid renewing tokens.\n+      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n+      return;\n+    }\n+\n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      Credentials credentials \u003d null;\n+      try {\n+        credentials \u003d parseCredentials(appContext);\n+        // synchronously renew delegation token on recovery.\n+        rmContext.getDelegationTokenRenewer().addApplicationSync(appId,\n+          credentials, appContext.getCancelTokensWhenComplete());\n+        application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n+      } catch (Exception e) {\n+        LOG.warn(\"Unable to parse and renew delegation tokens.\", e);\n+        this.rmContext.getDispatcher().getEventHandler()\n+          .handle(new RMAppRejectedEvent(appId, e.getMessage()));\n+        throw e;\n+      }\n+    } else {\n+      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "      recoverApplication(ApplicationState appState, RMState rmState)\n          throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appState.getAppId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n          appState.getUser());\n    application.recover(rmState);\n    if (isApplicationInFinalState(appState.getState())) {\n      // We are synchronously moving the application into final state so that\n      // momentarily client will not see this application in NEW state. Also\n      // for finished applications we will avoid renewing tokens.\n      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials credentials \u003d null;\n      try {\n        credentials \u003d parseCredentials(appContext);\n        // synchronously renew delegation token on recovery.\n        rmContext.getDelegationTokenRenewer().addApplicationSync(appId,\n          credentials, appContext.getCancelTokensWhenComplete());\n        application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n      } catch (Exception e) {\n        LOG.warn(\"Unable to parse and renew delegation tokens.\", e);\n        this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(appId, e.getMessage()));\n        throw e;\n      }\n    } else {\n      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-1812. Fixed ResourceManager to synchrously renew tokens after recovery and thus recover app itself synchronously and avoid races with resyncing NodeManagers. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1576843 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/03/14 11:25 AM",
          "commitName": "4de17c60528cb29bf7306dbaa720b96063948b17",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "04/02/14 8:55 PM",
          "commitNameOld": "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 35.56,
          "commitsBetweenForRepo": 336,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,9 +1,37 @@\n-  private void recoverApplication(RMState state, RMAppImpl application)\n-      throws YarnException {\n-    try {\n-      application.recover(state);\n-    } catch (Exception e) {\n-      LOG.error(\"Error recovering application\", e);\n-      throw new YarnException(e);\n+      recoverApplication(ApplicationState appState, RMState rmState)\n+          throws Exception {\n+    ApplicationSubmissionContext appContext \u003d\n+        appState.getApplicationSubmissionContext();\n+    ApplicationId appId \u003d appState.getAppId();\n+\n+    // create and recover app.\n+    RMAppImpl application \u003d\n+        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n+          appState.getUser());\n+    application.recover(rmState);\n+    if (isApplicationInFinalState(appState.getState())) {\n+      // We are synchronously moving the application into final state so that\n+      // momentarily client will not see this application in NEW state. Also\n+      // for finished applications we will avoid renewing tokens.\n+      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n+      return;\n+    }\n+\n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      Credentials credentials \u003d null;\n+      try {\n+        credentials \u003d parseCredentials(appContext);\n+        // synchronously renew delegation token on recovery.\n+        rmContext.getDelegationTokenRenewer().addApplicationSync(appId,\n+          credentials, appContext.getCancelTokensWhenComplete());\n+        application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n+      } catch (Exception e) {\n+        LOG.warn(\"Unable to parse and renew delegation tokens.\", e);\n+        this.rmContext.getDispatcher().getEventHandler()\n+          .handle(new RMAppRejectedEvent(appId, e.getMessage()));\n+        throw e;\n+      }\n+    } else {\n+      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "      recoverApplication(ApplicationState appState, RMState rmState)\n          throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appState.getAppId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n          appState.getUser());\n    application.recover(rmState);\n    if (isApplicationInFinalState(appState.getState())) {\n      // We are synchronously moving the application into final state so that\n      // momentarily client will not see this application in NEW state. Also\n      // for finished applications we will avoid renewing tokens.\n      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials credentials \u003d null;\n      try {\n        credentials \u003d parseCredentials(appContext);\n        // synchronously renew delegation token on recovery.\n        rmContext.getDelegationTokenRenewer().addApplicationSync(appId,\n          credentials, appContext.getCancelTokensWhenComplete());\n        application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n      } catch (Exception e) {\n        LOG.warn(\"Unable to parse and renew delegation tokens.\", e);\n        this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(appId, e.getMessage()));\n        throw e;\n      }\n    } else {\n      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[YarnException]",
            "newValue": "[Exception]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1812. Fixed ResourceManager to synchrously renew tokens after recovery and thus recover app itself synchronously and avoid races with resyncing NodeManagers. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1576843 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/03/14 11:25 AM",
          "commitName": "4de17c60528cb29bf7306dbaa720b96063948b17",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "04/02/14 8:55 PM",
          "commitNameOld": "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 35.56,
          "commitsBetweenForRepo": 336,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,9 +1,37 @@\n-  private void recoverApplication(RMState state, RMAppImpl application)\n-      throws YarnException {\n-    try {\n-      application.recover(state);\n-    } catch (Exception e) {\n-      LOG.error(\"Error recovering application\", e);\n-      throw new YarnException(e);\n+      recoverApplication(ApplicationState appState, RMState rmState)\n+          throws Exception {\n+    ApplicationSubmissionContext appContext \u003d\n+        appState.getApplicationSubmissionContext();\n+    ApplicationId appId \u003d appState.getAppId();\n+\n+    // create and recover app.\n+    RMAppImpl application \u003d\n+        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n+          appState.getUser());\n+    application.recover(rmState);\n+    if (isApplicationInFinalState(appState.getState())) {\n+      // We are synchronously moving the application into final state so that\n+      // momentarily client will not see this application in NEW state. Also\n+      // for finished applications we will avoid renewing tokens.\n+      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n+      return;\n+    }\n+\n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      Credentials credentials \u003d null;\n+      try {\n+        credentials \u003d parseCredentials(appContext);\n+        // synchronously renew delegation token on recovery.\n+        rmContext.getDelegationTokenRenewer().addApplicationSync(appId,\n+          credentials, appContext.getCancelTokensWhenComplete());\n+        application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n+      } catch (Exception e) {\n+        LOG.warn(\"Unable to parse and renew delegation tokens.\", e);\n+        this.rmContext.getDispatcher().getEventHandler()\n+          .handle(new RMAppRejectedEvent(appId, e.getMessage()));\n+        throw e;\n+      }\n+    } else {\n+      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "      recoverApplication(ApplicationState appState, RMState rmState)\n          throws Exception {\n    ApplicationSubmissionContext appContext \u003d\n        appState.getApplicationSubmissionContext();\n    ApplicationId appId \u003d appState.getAppId();\n\n    // create and recover app.\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(appContext, appState.getSubmitTime(),\n          appState.getUser());\n    application.recover(rmState);\n    if (isApplicationInFinalState(appState.getState())) {\n      // We are synchronously moving the application into final state so that\n      // momentarily client will not see this application in NEW state. Also\n      // for finished applications we will avoid renewing tokens.\n      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n      return;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials credentials \u003d null;\n      try {\n        credentials \u003d parseCredentials(appContext);\n        // synchronously renew delegation token on recovery.\n        rmContext.getDelegationTokenRenewer().addApplicationSync(appId,\n          credentials, appContext.getCancelTokensWhenComplete());\n        application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n      } catch (Exception e) {\n        LOG.warn(\"Unable to parse and renew delegation tokens.\", e);\n        this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(appId, e.getMessage()));\n        throw e;\n      }\n    } else {\n      application.handle(new RMAppEvent(appId, RMAppEventType.RECOVER));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "512475e56f0a27bf3c3ff596184f96993bb4bef4": {
      "type": "Yintroduced",
      "commitMessage": "YARN-674. Fixed ResourceManager to renew DelegationTokens on submission asynchronously to work around potential slowness in state-store. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543312 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/13 9:20 PM",
      "commitName": "512475e56f0a27bf3c3ff596184f96993bb4bef4",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,9 @@\n+  private void recoverApplication(RMState state, RMAppImpl application)\n+      throws YarnException {\n+    try {\n+      application.recover(state);\n+    } catch (Exception e) {\n+      LOG.error(\"Error recovering application\", e);\n+      throw new YarnException(e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void recoverApplication(RMState state, RMAppImpl application)\n      throws YarnException {\n    try {\n      application.recover(state);\n    } catch (Exception e) {\n      LOG.error(\"Error recovering application\", e);\n      throw new YarnException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java"
    }
  }
}