{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AMRMProxyService.java",
  "functionName": "updateAMRMTokens",
  "functionId": "updateAMRMTokens___amrmTokenIdentifier-AMRMTokenIdentifier__pipeline-RequestInterceptorChainWrapper__allocateResponse-AllocateResponse",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/AMRMProxyService.java",
  "functionStartLine": 584,
  "functionEndLine": 646,
  "numCommitsSeen": 17,
  "timeTaken": 1981,
  "changeHistory": [
    "d5f66888b8d767ee6706fab9950c194a1bf26d32",
    "49aa60e50d20f8c18ed6f00fa8966244536fe7da",
    "4d1f3d9020b8a8bf1d2a81e4d6ad20418ed9bcc2",
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02"
  ],
  "changeHistoryShort": {
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": "Ybodychange",
    "49aa60e50d20f8c18ed6f00fa8966244536fe7da": "Ybodychange",
    "4d1f3d9020b8a8bf1d2a81e4d6ad20418ed9bcc2": "Ybodychange",
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6128. Add support for AMRMProxy HA. (Botong Huang via Subru).\n",
      "commitDate": "17/11/17 5:39 PM",
      "commitName": "d5f66888b8d767ee6706fab9950c194a1bf26d32",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "22/06/17 11:27 AM",
      "commitNameOld": "49aa60e50d20f8c18ed6f00fa8966244536fe7da",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 148.3,
      "commitsBetweenForRepo": 1203,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,63 @@\n   private void updateAMRMTokens(AMRMTokenIdentifier amrmTokenIdentifier,\n       RequestInterceptorChainWrapper pipeline,\n       AllocateResponse allocateResponse) {\n     AMRMProxyApplicationContextImpl context \u003d\n         (AMRMProxyApplicationContextImpl) pipeline.getRootInterceptor()\n             .getApplicationContext();\n \n     // check to see if the RM has issued a new AMRMToken \u0026 accordingly update\n     // the real ARMRMToken in the current context\n     if (allocateResponse.getAMRMToken() !\u003d null) {\n       LOG.info(\"RM rolled master-key for amrm-tokens\");\n \n       org.apache.hadoop.yarn.api.records.Token token \u003d\n           allocateResponse.getAMRMToken();\n \n       // Do not propagate this info back to AM\n       allocateResponse.setAMRMToken(null);\n \n       org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e newToken \u003d\n-          new org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e(\n-              token.getIdentifier().array(), token.getPassword().array(),\n-              new Text(token.getKind()), new Text(token.getService()));\n+          ConverterUtils.convertFromYarn(token, (Text) null);\n \n-      context.setAMRMToken(newToken);\n-\n-      // Update the AMRMToken in context map in NM state store\n-      if (this.nmContext.getNMStateStore() !\u003d null) {\n+      // Update the AMRMToken in context map, and in NM state store if it is\n+      // different\n+      if (context.setAMRMToken(newToken)\n+          \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n         try {\n           this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n               context.getApplicationAttemptId(), NMSS_AMRMTOKEN_KEY,\n               newToken.encodeToUrlString().getBytes(\"UTF-8\"));\n         } catch (IOException e) {\n           LOG.error(\"Error storing AMRMProxy application context entry for \"\n               + context.getApplicationAttemptId(), e);\n         }\n       }\n     }\n \n     // Check if the local AMRMToken is rolled up and update the context and\n     // response accordingly\n     MasterKeyData nextMasterKey \u003d\n         this.secretManager.getNextMasterKeyData();\n \n     if (nextMasterKey !\u003d null\n         \u0026\u0026 nextMasterKey.getMasterKey().getKeyId() !\u003d amrmTokenIdentifier\n             .getKeyId()) {\n       Token\u003cAMRMTokenIdentifier\u003e localToken \u003d context.getLocalAMRMToken();\n       if (nextMasterKey.getMasterKey().getKeyId() !\u003d context\n           .getLocalAMRMTokenKeyId()) {\n         LOG.info(\"The local AMRMToken has been rolled-over.\"\n             + \" Send new local AMRMToken back to application: \"\n             + pipeline.getApplicationId());\n         localToken \u003d\n             this.secretManager.createAndGetAMRMToken(pipeline\n                 .getApplicationAttemptId());\n         context.setLocalAMRMToken(localToken);\n       }\n \n       allocateResponse\n           .setAMRMToken(org.apache.hadoop.yarn.api.records.Token\n               .newInstance(localToken.getIdentifier(), localToken\n                   .getKind().toString(), localToken.getPassword(),\n                   localToken.getService().toString()));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateAMRMTokens(AMRMTokenIdentifier amrmTokenIdentifier,\n      RequestInterceptorChainWrapper pipeline,\n      AllocateResponse allocateResponse) {\n    AMRMProxyApplicationContextImpl context \u003d\n        (AMRMProxyApplicationContextImpl) pipeline.getRootInterceptor()\n            .getApplicationContext();\n\n    // check to see if the RM has issued a new AMRMToken \u0026 accordingly update\n    // the real ARMRMToken in the current context\n    if (allocateResponse.getAMRMToken() !\u003d null) {\n      LOG.info(\"RM rolled master-key for amrm-tokens\");\n\n      org.apache.hadoop.yarn.api.records.Token token \u003d\n          allocateResponse.getAMRMToken();\n\n      // Do not propagate this info back to AM\n      allocateResponse.setAMRMToken(null);\n\n      org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e newToken \u003d\n          ConverterUtils.convertFromYarn(token, (Text) null);\n\n      // Update the AMRMToken in context map, and in NM state store if it is\n      // different\n      if (context.setAMRMToken(newToken)\n          \u0026\u0026 this.nmContext.getNMStateStore() !\u003d null) {\n        try {\n          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n              context.getApplicationAttemptId(), NMSS_AMRMTOKEN_KEY,\n              newToken.encodeToUrlString().getBytes(\"UTF-8\"));\n        } catch (IOException e) {\n          LOG.error(\"Error storing AMRMProxy application context entry for \"\n              + context.getApplicationAttemptId(), e);\n        }\n      }\n    }\n\n    // Check if the local AMRMToken is rolled up and update the context and\n    // response accordingly\n    MasterKeyData nextMasterKey \u003d\n        this.secretManager.getNextMasterKeyData();\n\n    if (nextMasterKey !\u003d null\n        \u0026\u0026 nextMasterKey.getMasterKey().getKeyId() !\u003d amrmTokenIdentifier\n            .getKeyId()) {\n      Token\u003cAMRMTokenIdentifier\u003e localToken \u003d context.getLocalAMRMToken();\n      if (nextMasterKey.getMasterKey().getKeyId() !\u003d context\n          .getLocalAMRMTokenKeyId()) {\n        LOG.info(\"The local AMRMToken has been rolled-over.\"\n            + \" Send new local AMRMToken back to application: \"\n            + pipeline.getApplicationId());\n        localToken \u003d\n            this.secretManager.createAndGetAMRMToken(pipeline\n                .getApplicationAttemptId());\n        context.setLocalAMRMToken(localToken);\n      }\n\n      allocateResponse\n          .setAMRMToken(org.apache.hadoop.yarn.api.records.Token\n              .newInstance(localToken.getIdentifier(), localToken\n                  .getKind().toString(), localToken.getPassword(),\n                  localToken.getService().toString()));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/AMRMProxyService.java",
      "extendedDetails": {}
    },
    "49aa60e50d20f8c18ed6f00fa8966244536fe7da": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6127. Add support for work preserving NM restart when AMRMProxy is enabled. (Botong Huang via asuresh).\n",
      "commitDate": "22/06/17 11:27 AM",
      "commitName": "49aa60e50d20f8c18ed6f00fa8966244536fe7da",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "08/05/17 4:55 PM",
      "commitNameOld": "749e5c09b9990590c282ea944e24735b795351fc",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 44.77,
      "commitsBetweenForRepo": 224,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,65 @@\n   private void updateAMRMTokens(AMRMTokenIdentifier amrmTokenIdentifier,\n       RequestInterceptorChainWrapper pipeline,\n       AllocateResponse allocateResponse) {\n     AMRMProxyApplicationContextImpl context \u003d\n         (AMRMProxyApplicationContextImpl) pipeline.getRootInterceptor()\n             .getApplicationContext();\n \n     // check to see if the RM has issued a new AMRMToken \u0026 accordingly update\n     // the real ARMRMToken in the current context\n     if (allocateResponse.getAMRMToken() !\u003d null) {\n       LOG.info(\"RM rolled master-key for amrm-tokens\");\n \n       org.apache.hadoop.yarn.api.records.Token token \u003d\n           allocateResponse.getAMRMToken();\n \n       // Do not propagate this info back to AM\n       allocateResponse.setAMRMToken(null);\n \n-      org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e newTokenId \u003d\n+      org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e newToken \u003d\n           new org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e(\n               token.getIdentifier().array(), token.getPassword().array(),\n               new Text(token.getKind()), new Text(token.getService()));\n \n-      context.setAMRMToken(newTokenId);\n+      context.setAMRMToken(newToken);\n+\n+      // Update the AMRMToken in context map in NM state store\n+      if (this.nmContext.getNMStateStore() !\u003d null) {\n+        try {\n+          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n+              context.getApplicationAttemptId(), NMSS_AMRMTOKEN_KEY,\n+              newToken.encodeToUrlString().getBytes(\"UTF-8\"));\n+        } catch (IOException e) {\n+          LOG.error(\"Error storing AMRMProxy application context entry for \"\n+              + context.getApplicationAttemptId(), e);\n+        }\n+      }\n     }\n \n     // Check if the local AMRMToken is rolled up and update the context and\n     // response accordingly\n     MasterKeyData nextMasterKey \u003d\n         this.secretManager.getNextMasterKeyData();\n \n     if (nextMasterKey !\u003d null\n         \u0026\u0026 nextMasterKey.getMasterKey().getKeyId() !\u003d amrmTokenIdentifier\n             .getKeyId()) {\n       Token\u003cAMRMTokenIdentifier\u003e localToken \u003d context.getLocalAMRMToken();\n       if (nextMasterKey.getMasterKey().getKeyId() !\u003d context\n           .getLocalAMRMTokenKeyId()) {\n         LOG.info(\"The local AMRMToken has been rolled-over.\"\n             + \" Send new local AMRMToken back to application: \"\n             + pipeline.getApplicationId());\n         localToken \u003d\n             this.secretManager.createAndGetAMRMToken(pipeline\n                 .getApplicationAttemptId());\n         context.setLocalAMRMToken(localToken);\n       }\n \n       allocateResponse\n           .setAMRMToken(org.apache.hadoop.yarn.api.records.Token\n               .newInstance(localToken.getIdentifier(), localToken\n                   .getKind().toString(), localToken.getPassword(),\n                   localToken.getService().toString()));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateAMRMTokens(AMRMTokenIdentifier amrmTokenIdentifier,\n      RequestInterceptorChainWrapper pipeline,\n      AllocateResponse allocateResponse) {\n    AMRMProxyApplicationContextImpl context \u003d\n        (AMRMProxyApplicationContextImpl) pipeline.getRootInterceptor()\n            .getApplicationContext();\n\n    // check to see if the RM has issued a new AMRMToken \u0026 accordingly update\n    // the real ARMRMToken in the current context\n    if (allocateResponse.getAMRMToken() !\u003d null) {\n      LOG.info(\"RM rolled master-key for amrm-tokens\");\n\n      org.apache.hadoop.yarn.api.records.Token token \u003d\n          allocateResponse.getAMRMToken();\n\n      // Do not propagate this info back to AM\n      allocateResponse.setAMRMToken(null);\n\n      org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e newToken \u003d\n          new org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e(\n              token.getIdentifier().array(), token.getPassword().array(),\n              new Text(token.getKind()), new Text(token.getService()));\n\n      context.setAMRMToken(newToken);\n\n      // Update the AMRMToken in context map in NM state store\n      if (this.nmContext.getNMStateStore() !\u003d null) {\n        try {\n          this.nmContext.getNMStateStore().storeAMRMProxyAppContextEntry(\n              context.getApplicationAttemptId(), NMSS_AMRMTOKEN_KEY,\n              newToken.encodeToUrlString().getBytes(\"UTF-8\"));\n        } catch (IOException e) {\n          LOG.error(\"Error storing AMRMProxy application context entry for \"\n              + context.getApplicationAttemptId(), e);\n        }\n      }\n    }\n\n    // Check if the local AMRMToken is rolled up and update the context and\n    // response accordingly\n    MasterKeyData nextMasterKey \u003d\n        this.secretManager.getNextMasterKeyData();\n\n    if (nextMasterKey !\u003d null\n        \u0026\u0026 nextMasterKey.getMasterKey().getKeyId() !\u003d amrmTokenIdentifier\n            .getKeyId()) {\n      Token\u003cAMRMTokenIdentifier\u003e localToken \u003d context.getLocalAMRMToken();\n      if (nextMasterKey.getMasterKey().getKeyId() !\u003d context\n          .getLocalAMRMTokenKeyId()) {\n        LOG.info(\"The local AMRMToken has been rolled-over.\"\n            + \" Send new local AMRMToken back to application: \"\n            + pipeline.getApplicationId());\n        localToken \u003d\n            this.secretManager.createAndGetAMRMToken(pipeline\n                .getApplicationAttemptId());\n        context.setLocalAMRMToken(localToken);\n      }\n\n      allocateResponse\n          .setAMRMToken(org.apache.hadoop.yarn.api.records.Token\n              .newInstance(localToken.getIdentifier(), localToken\n                  .getKind().toString(), localToken.getPassword(),\n                  localToken.getService().toString()));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/AMRMProxyService.java",
      "extendedDetails": {}
    },
    "4d1f3d9020b8a8bf1d2a81e4d6ad20418ed9bcc2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6016. Fix minor bugs in handling of local AMRMToken in AMRMProxy. (Botong Huang via Subru).\n",
      "commitDate": "17/01/17 2:48 PM",
      "commitName": "4d1f3d9020b8a8bf1d2a81e4d6ad20418ed9bcc2",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "16/12/16 8:14 AM",
      "commitNameOld": "2273a74c1f3895163046cca09ff5e983df301d22",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 32.27,
      "commitsBetweenForRepo": 135,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,53 @@\n   private void updateAMRMTokens(AMRMTokenIdentifier amrmTokenIdentifier,\n       RequestInterceptorChainWrapper pipeline,\n       AllocateResponse allocateResponse) {\n     AMRMProxyApplicationContextImpl context \u003d\n         (AMRMProxyApplicationContextImpl) pipeline.getRootInterceptor()\n             .getApplicationContext();\n \n     // check to see if the RM has issued a new AMRMToken \u0026 accordingly update\n     // the real ARMRMToken in the current context\n     if (allocateResponse.getAMRMToken() !\u003d null) {\n+      LOG.info(\"RM rolled master-key for amrm-tokens\");\n+\n       org.apache.hadoop.yarn.api.records.Token token \u003d\n           allocateResponse.getAMRMToken();\n \n+      // Do not propagate this info back to AM\n+      allocateResponse.setAMRMToken(null);\n+\n       org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e newTokenId \u003d\n           new org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e(\n               token.getIdentifier().array(), token.getPassword().array(),\n               new Text(token.getKind()), new Text(token.getService()));\n \n       context.setAMRMToken(newTokenId);\n     }\n \n     // Check if the local AMRMToken is rolled up and update the context and\n     // response accordingly\n     MasterKeyData nextMasterKey \u003d\n         this.secretManager.getNextMasterKeyData();\n \n     if (nextMasterKey !\u003d null\n         \u0026\u0026 nextMasterKey.getMasterKey().getKeyId() !\u003d amrmTokenIdentifier\n             .getKeyId()) {\n       Token\u003cAMRMTokenIdentifier\u003e localToken \u003d context.getLocalAMRMToken();\n       if (nextMasterKey.getMasterKey().getKeyId() !\u003d context\n           .getLocalAMRMTokenKeyId()) {\n         LOG.info(\"The local AMRMToken has been rolled-over.\"\n             + \" Send new local AMRMToken back to application: \"\n             + pipeline.getApplicationId());\n         localToken \u003d\n             this.secretManager.createAndGetAMRMToken(pipeline\n                 .getApplicationAttemptId());\n         context.setLocalAMRMToken(localToken);\n       }\n \n       allocateResponse\n           .setAMRMToken(org.apache.hadoop.yarn.api.records.Token\n               .newInstance(localToken.getIdentifier(), localToken\n                   .getKind().toString(), localToken.getPassword(),\n                   localToken.getService().toString()));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateAMRMTokens(AMRMTokenIdentifier amrmTokenIdentifier,\n      RequestInterceptorChainWrapper pipeline,\n      AllocateResponse allocateResponse) {\n    AMRMProxyApplicationContextImpl context \u003d\n        (AMRMProxyApplicationContextImpl) pipeline.getRootInterceptor()\n            .getApplicationContext();\n\n    // check to see if the RM has issued a new AMRMToken \u0026 accordingly update\n    // the real ARMRMToken in the current context\n    if (allocateResponse.getAMRMToken() !\u003d null) {\n      LOG.info(\"RM rolled master-key for amrm-tokens\");\n\n      org.apache.hadoop.yarn.api.records.Token token \u003d\n          allocateResponse.getAMRMToken();\n\n      // Do not propagate this info back to AM\n      allocateResponse.setAMRMToken(null);\n\n      org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e newTokenId \u003d\n          new org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e(\n              token.getIdentifier().array(), token.getPassword().array(),\n              new Text(token.getKind()), new Text(token.getService()));\n\n      context.setAMRMToken(newTokenId);\n    }\n\n    // Check if the local AMRMToken is rolled up and update the context and\n    // response accordingly\n    MasterKeyData nextMasterKey \u003d\n        this.secretManager.getNextMasterKeyData();\n\n    if (nextMasterKey !\u003d null\n        \u0026\u0026 nextMasterKey.getMasterKey().getKeyId() !\u003d amrmTokenIdentifier\n            .getKeyId()) {\n      Token\u003cAMRMTokenIdentifier\u003e localToken \u003d context.getLocalAMRMToken();\n      if (nextMasterKey.getMasterKey().getKeyId() !\u003d context\n          .getLocalAMRMTokenKeyId()) {\n        LOG.info(\"The local AMRMToken has been rolled-over.\"\n            + \" Send new local AMRMToken back to application: \"\n            + pipeline.getApplicationId());\n        localToken \u003d\n            this.secretManager.createAndGetAMRMToken(pipeline\n                .getApplicationAttemptId());\n        context.setLocalAMRMToken(localToken);\n      }\n\n      allocateResponse\n          .setAMRMToken(org.apache.hadoop.yarn.api.records.Token\n              .newInstance(localToken.getIdentifier(), localToken\n                  .getKind().toString(), localToken.getPassword(),\n                  localToken.getService().toString()));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/AMRMProxyService.java",
      "extendedDetails": {}
    },
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2884. Added a proxy service in NM to proxy the the communication between AM and RM. Contributed by Kishore Chaliparambil\n",
      "commitDate": "07/09/15 6:35 PM",
      "commitName": "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,48 @@\n+  private void updateAMRMTokens(AMRMTokenIdentifier amrmTokenIdentifier,\n+      RequestInterceptorChainWrapper pipeline,\n+      AllocateResponse allocateResponse) {\n+    AMRMProxyApplicationContextImpl context \u003d\n+        (AMRMProxyApplicationContextImpl) pipeline.getRootInterceptor()\n+            .getApplicationContext();\n+\n+    // check to see if the RM has issued a new AMRMToken \u0026 accordingly update\n+    // the real ARMRMToken in the current context\n+    if (allocateResponse.getAMRMToken() !\u003d null) {\n+      org.apache.hadoop.yarn.api.records.Token token \u003d\n+          allocateResponse.getAMRMToken();\n+\n+      org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e newTokenId \u003d\n+          new org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e(\n+              token.getIdentifier().array(), token.getPassword().array(),\n+              new Text(token.getKind()), new Text(token.getService()));\n+\n+      context.setAMRMToken(newTokenId);\n+    }\n+\n+    // Check if the local AMRMToken is rolled up and update the context and\n+    // response accordingly\n+    MasterKeyData nextMasterKey \u003d\n+        this.secretManager.getNextMasterKeyData();\n+\n+    if (nextMasterKey !\u003d null\n+        \u0026\u0026 nextMasterKey.getMasterKey().getKeyId() !\u003d amrmTokenIdentifier\n+            .getKeyId()) {\n+      Token\u003cAMRMTokenIdentifier\u003e localToken \u003d context.getLocalAMRMToken();\n+      if (nextMasterKey.getMasterKey().getKeyId() !\u003d context\n+          .getLocalAMRMTokenKeyId()) {\n+        LOG.info(\"The local AMRMToken has been rolled-over.\"\n+            + \" Send new local AMRMToken back to application: \"\n+            + pipeline.getApplicationId());\n+        localToken \u003d\n+            this.secretManager.createAndGetAMRMToken(pipeline\n+                .getApplicationAttemptId());\n+        context.setLocalAMRMToken(localToken);\n+      }\n+\n+      allocateResponse\n+          .setAMRMToken(org.apache.hadoop.yarn.api.records.Token\n+              .newInstance(localToken.getIdentifier(), localToken\n+                  .getKind().toString(), localToken.getPassword(),\n+                  localToken.getService().toString()));\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateAMRMTokens(AMRMTokenIdentifier amrmTokenIdentifier,\n      RequestInterceptorChainWrapper pipeline,\n      AllocateResponse allocateResponse) {\n    AMRMProxyApplicationContextImpl context \u003d\n        (AMRMProxyApplicationContextImpl) pipeline.getRootInterceptor()\n            .getApplicationContext();\n\n    // check to see if the RM has issued a new AMRMToken \u0026 accordingly update\n    // the real ARMRMToken in the current context\n    if (allocateResponse.getAMRMToken() !\u003d null) {\n      org.apache.hadoop.yarn.api.records.Token token \u003d\n          allocateResponse.getAMRMToken();\n\n      org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e newTokenId \u003d\n          new org.apache.hadoop.security.token.Token\u003cAMRMTokenIdentifier\u003e(\n              token.getIdentifier().array(), token.getPassword().array(),\n              new Text(token.getKind()), new Text(token.getService()));\n\n      context.setAMRMToken(newTokenId);\n    }\n\n    // Check if the local AMRMToken is rolled up and update the context and\n    // response accordingly\n    MasterKeyData nextMasterKey \u003d\n        this.secretManager.getNextMasterKeyData();\n\n    if (nextMasterKey !\u003d null\n        \u0026\u0026 nextMasterKey.getMasterKey().getKeyId() !\u003d amrmTokenIdentifier\n            .getKeyId()) {\n      Token\u003cAMRMTokenIdentifier\u003e localToken \u003d context.getLocalAMRMToken();\n      if (nextMasterKey.getMasterKey().getKeyId() !\u003d context\n          .getLocalAMRMTokenKeyId()) {\n        LOG.info(\"The local AMRMToken has been rolled-over.\"\n            + \" Send new local AMRMToken back to application: \"\n            + pipeline.getApplicationId());\n        localToken \u003d\n            this.secretManager.createAndGetAMRMToken(pipeline\n                .getApplicationAttemptId());\n        context.setLocalAMRMToken(localToken);\n      }\n\n      allocateResponse\n          .setAMRMToken(org.apache.hadoop.yarn.api.records.Token\n              .newInstance(localToken.getIdentifier(), localToken\n                  .getKind().toString(), localToken.getPassword(),\n                  localToken.getService().toString()));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/AMRMProxyService.java"
    }
  }
}