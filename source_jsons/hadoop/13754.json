{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockManager.java",
  "functionName": "createBlockTokenSecretManager",
  "functionId": "createBlockTokenSecretManager___conf-Configuration(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
  "functionStartLine": 636,
  "functionEndLine": 696,
  "numCommitsSeen": 502,
  "timeTaken": 17892,
  "changeHistory": [
    "8fb5ca3f405550828a17e689b9c60ddf7fb95ec1",
    "a7f085d6bf499edf23e650a4f7211c53a442da0e",
    "4ed33e9ca3d85568e3904753a3ef61a85f801838",
    "49dfad942970459297f72632ed8dfd353e0c86de",
    "d45aa7647b1fecf81860ec7b563085be2af99a0b",
    "0dc5824a83716468a88bcd669ed24fc19871332a",
    "0603447f2a9db7a5a40850de9ba85837ec4940aa",
    "9b4a7900c7dfc0590316eedaa97144f938885651",
    "fb95fce24056c0b0aa5b77683c684fe1b68c4f76",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "b0944651681337e81b41250f43bd1e8eebc78125"
  ],
  "changeHistoryShort": {
    "8fb5ca3f405550828a17e689b9c60ddf7fb95ec1": "Ybodychange",
    "a7f085d6bf499edf23e650a4f7211c53a442da0e": "Ybodychange",
    "4ed33e9ca3d85568e3904753a3ef61a85f801838": "Ybodychange",
    "49dfad942970459297f72632ed8dfd353e0c86de": "Ybodychange",
    "d45aa7647b1fecf81860ec7b563085be2af99a0b": "Ymultichange(Yexceptionschange,Ybodychange)",
    "0dc5824a83716468a88bcd669ed24fc19871332a": "Ybodychange",
    "0603447f2a9db7a5a40850de9ba85837ec4940aa": "Yexceptionschange",
    "9b4a7900c7dfc0590316eedaa97144f938885651": "Ybodychange",
    "fb95fce24056c0b0aa5b77683c684fe1b68c4f76": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "b0944651681337e81b41250f43bd1e8eebc78125": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8fb5ca3f405550828a17e689b9c60ddf7fb95ec1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14611. Move handshake secret field from Token to BlockAccessToken. Contributed by Chen Liang.\n",
      "commitDate": "11/07/19 1:23 PM",
      "commitName": "8fb5ca3f405550828a17e689b9c60ddf7fb95ec1",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "17/06/19 4:20 PM",
      "commitNameOld": "6822193ee6d6ac8b08822fa76c89e1dd61c5ddca",
      "commitAuthorOld": "Santosh Marella",
      "daysBetweenCommits": 23.88,
      "commitsBetweenForRepo": 218,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,61 @@\n   private static BlockTokenSecretManager createBlockTokenSecretManager(\n       final Configuration conf) throws IOException {\n     final boolean isEnabled \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n     LOG.info(\"{} \u003d {}\", DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY,\n             isEnabled);\n \n     if (!isEnabled) {\n       if (UserGroupInformation.isSecurityEnabled()) {\n         String errMessage \u003d \"Security is enabled but block access tokens \" +\n             \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n             \"aren\u0027t enabled. This may cause issues \" +\n             \"when clients attempt to connect to a DataNode. Aborting NameNode\";\n         throw new IOException(errMessage);\n       }\n       return null;\n     }\n \n     final long updateMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n     final long lifetimeMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n     final String encryptionAlgorithm \u003d conf.get(\n         DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n     LOG.info(\"{}\u003d{} min(s), {}\u003d{} min(s), {}\u003d{}\",\n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, updateMin,\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, lifetimeMin,\n         DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY, encryptionAlgorithm);\n     \n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n     boolean shouldWriteProtobufToken \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE,\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE_DEFAULT);\n \n+    boolean shouldWrapQOP \u003d conf.getBoolean(\n+        DFS_NAMENODE_SEND_QOP_ENABLED, DFS_NAMENODE_SEND_QOP_ENABLED_DEFAULT);\n+\n     if (isHaEnabled) {\n       // figure out which index we are of the nns\n       Collection\u003cString\u003e nnIds \u003d DFSUtilClient.getNameNodeIds(conf, nsId);\n       String nnId \u003d HAUtil.getNameNodeId(conf, nsId);\n       int nnIndex \u003d 0;\n       for (String id : nnIds) {\n         if (id.equals(nnId)) {\n           break;\n         }\n         nnIndex++;\n       }\n       return new BlockTokenSecretManager(updateMin * 60 * 1000L,\n           lifetimeMin * 60 * 1000L, nnIndex, nnIds.size(), null,\n-          encryptionAlgorithm, shouldWriteProtobufToken);\n+          encryptionAlgorithm, shouldWriteProtobufToken, shouldWrapQOP);\n     } else {\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n           lifetimeMin*60*1000L, 0, 1, null, encryptionAlgorithm,\n-          shouldWriteProtobufToken);\n+          shouldWriteProtobufToken, shouldWrapQOP);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static BlockTokenSecretManager createBlockTokenSecretManager(\n      final Configuration conf) throws IOException {\n    final boolean isEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n    LOG.info(\"{} \u003d {}\", DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY,\n            isEnabled);\n\n    if (!isEnabled) {\n      if (UserGroupInformation.isSecurityEnabled()) {\n        String errMessage \u003d \"Security is enabled but block access tokens \" +\n            \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n            \"aren\u0027t enabled. This may cause issues \" +\n            \"when clients attempt to connect to a DataNode. Aborting NameNode\";\n        throw new IOException(errMessage);\n      }\n      return null;\n    }\n\n    final long updateMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n    final long lifetimeMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n    final String encryptionAlgorithm \u003d conf.get(\n        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n    LOG.info(\"{}\u003d{} min(s), {}\u003d{} min(s), {}\u003d{}\",\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, updateMin,\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, lifetimeMin,\n        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY, encryptionAlgorithm);\n    \n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n    boolean shouldWriteProtobufToken \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE,\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE_DEFAULT);\n\n    boolean shouldWrapQOP \u003d conf.getBoolean(\n        DFS_NAMENODE_SEND_QOP_ENABLED, DFS_NAMENODE_SEND_QOP_ENABLED_DEFAULT);\n\n    if (isHaEnabled) {\n      // figure out which index we are of the nns\n      Collection\u003cString\u003e nnIds \u003d DFSUtilClient.getNameNodeIds(conf, nsId);\n      String nnId \u003d HAUtil.getNameNodeId(conf, nsId);\n      int nnIndex \u003d 0;\n      for (String id : nnIds) {\n        if (id.equals(nnId)) {\n          break;\n        }\n        nnIndex++;\n      }\n      return new BlockTokenSecretManager(updateMin * 60 * 1000L,\n          lifetimeMin * 60 * 1000L, nnIndex, nnIds.size(), null,\n          encryptionAlgorithm, shouldWriteProtobufToken, shouldWrapQOP);\n    } else {\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, 0, 1, null, encryptionAlgorithm,\n          shouldWriteProtobufToken, shouldWrapQOP);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "a7f085d6bf499edf23e650a4f7211c53a442da0e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11832. Switch leftover logs to slf4j format in BlockManager.java. Contributed by Hui Xu and Chen Liang.\n",
      "commitDate": "29/05/17 1:30 AM",
      "commitName": "a7f085d6bf499edf23e650a4f7211c53a442da0e",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "25/05/17 7:35 AM",
      "commitNameOld": "2e41f8803dd46d1bab16c1b206c71be72ea260a1",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 3.75,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,58 @@\n   private static BlockTokenSecretManager createBlockTokenSecretManager(\n       final Configuration conf) throws IOException {\n     final boolean isEnabled \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n-    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n+    LOG.info(\"{} \u003d {}\", DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY,\n+            isEnabled);\n \n     if (!isEnabled) {\n       if (UserGroupInformation.isSecurityEnabled()) {\n         String errMessage \u003d \"Security is enabled but block access tokens \" +\n             \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n             \"aren\u0027t enabled. This may cause issues \" +\n             \"when clients attempt to connect to a DataNode. Aborting NameNode\";\n         throw new IOException(errMessage);\n       }\n       return null;\n     }\n \n     final long updateMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n     final long lifetimeMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n     final String encryptionAlgorithm \u003d conf.get(\n         DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n-    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n-        + \"\u003d\" + updateMin + \" min(s), \"\n-        + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n-        + \"\u003d\" + lifetimeMin + \" min(s), \"\n-        + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n-        + \"\u003d\" + encryptionAlgorithm);\n+    LOG.info(\"{}\u003d{} min(s), {}\u003d{} min(s), {}\u003d{}\",\n+        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, updateMin,\n+        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, lifetimeMin,\n+        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY, encryptionAlgorithm);\n     \n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n     boolean shouldWriteProtobufToken \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE,\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE_DEFAULT);\n \n     if (isHaEnabled) {\n       // figure out which index we are of the nns\n       Collection\u003cString\u003e nnIds \u003d DFSUtilClient.getNameNodeIds(conf, nsId);\n       String nnId \u003d HAUtil.getNameNodeId(conf, nsId);\n       int nnIndex \u003d 0;\n       for (String id : nnIds) {\n         if (id.equals(nnId)) {\n           break;\n         }\n         nnIndex++;\n       }\n       return new BlockTokenSecretManager(updateMin * 60 * 1000L,\n           lifetimeMin * 60 * 1000L, nnIndex, nnIds.size(), null,\n           encryptionAlgorithm, shouldWriteProtobufToken);\n     } else {\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n           lifetimeMin*60*1000L, 0, 1, null, encryptionAlgorithm,\n           shouldWriteProtobufToken);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static BlockTokenSecretManager createBlockTokenSecretManager(\n      final Configuration conf) throws IOException {\n    final boolean isEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n    LOG.info(\"{} \u003d {}\", DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY,\n            isEnabled);\n\n    if (!isEnabled) {\n      if (UserGroupInformation.isSecurityEnabled()) {\n        String errMessage \u003d \"Security is enabled but block access tokens \" +\n            \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n            \"aren\u0027t enabled. This may cause issues \" +\n            \"when clients attempt to connect to a DataNode. Aborting NameNode\";\n        throw new IOException(errMessage);\n      }\n      return null;\n    }\n\n    final long updateMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n    final long lifetimeMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n    final String encryptionAlgorithm \u003d conf.get(\n        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n    LOG.info(\"{}\u003d{} min(s), {}\u003d{} min(s), {}\u003d{}\",\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, updateMin,\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, lifetimeMin,\n        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY, encryptionAlgorithm);\n    \n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n    boolean shouldWriteProtobufToken \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE,\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE_DEFAULT);\n\n    if (isHaEnabled) {\n      // figure out which index we are of the nns\n      Collection\u003cString\u003e nnIds \u003d DFSUtilClient.getNameNodeIds(conf, nsId);\n      String nnId \u003d HAUtil.getNameNodeId(conf, nsId);\n      int nnIndex \u003d 0;\n      for (String id : nnIds) {\n        if (id.equals(nnId)) {\n          break;\n        }\n        nnIndex++;\n      }\n      return new BlockTokenSecretManager(updateMin * 60 * 1000L,\n          lifetimeMin * 60 * 1000L, nnIndex, nnIds.size(), null,\n          encryptionAlgorithm, shouldWriteProtobufToken);\n    } else {\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, 0, 1, null, encryptionAlgorithm,\n          shouldWriteProtobufToken);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "4ed33e9ca3d85568e3904753a3ef61a85f801838": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11026. Convert BlockTokenIdentifier to use Protobuf. Contributed by Ewan Higgs.\n",
      "commitDate": "13/02/17 11:29 AM",
      "commitName": "4ed33e9ca3d85568e3904753a3ef61a85f801838",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "25/01/17 11:16 AM",
      "commitNameOld": "b782bf2156dd9d43610c0bc47d458b2db297589f",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 19.01,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,59 @@\n   private static BlockTokenSecretManager createBlockTokenSecretManager(\n       final Configuration conf) throws IOException {\n     final boolean isEnabled \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n \n     if (!isEnabled) {\n       if (UserGroupInformation.isSecurityEnabled()) {\n         String errMessage \u003d \"Security is enabled but block access tokens \" +\n             \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n             \"aren\u0027t enabled. This may cause issues \" +\n             \"when clients attempt to connect to a DataNode. Aborting NameNode\";\n         throw new IOException(errMessage);\n       }\n       return null;\n     }\n \n     final long updateMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n     final long lifetimeMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n     final String encryptionAlgorithm \u003d conf.get(\n         DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n         + \"\u003d\" + updateMin + \" min(s), \"\n         + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n         + \"\u003d\" + lifetimeMin + \" min(s), \"\n         + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n         + \"\u003d\" + encryptionAlgorithm);\n     \n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n+    boolean shouldWriteProtobufToken \u003d conf.getBoolean(\n+        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE,\n+        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE_DEFAULT);\n \n     if (isHaEnabled) {\n       // figure out which index we are of the nns\n       Collection\u003cString\u003e nnIds \u003d DFSUtilClient.getNameNodeIds(conf, nsId);\n       String nnId \u003d HAUtil.getNameNodeId(conf, nsId);\n       int nnIndex \u003d 0;\n       for (String id : nnIds) {\n         if (id.equals(nnId)) {\n           break;\n         }\n         nnIndex++;\n       }\n       return new BlockTokenSecretManager(updateMin * 60 * 1000L,\n-          lifetimeMin * 60 * 1000L, nnIndex, nnIds.size(), null, encryptionAlgorithm);\n+          lifetimeMin * 60 * 1000L, nnIndex, nnIds.size(), null,\n+          encryptionAlgorithm, shouldWriteProtobufToken);\n     } else {\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n-          lifetimeMin*60*1000L, 0, 1, null, encryptionAlgorithm);\n+          lifetimeMin*60*1000L, 0, 1, null, encryptionAlgorithm,\n+          shouldWriteProtobufToken);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static BlockTokenSecretManager createBlockTokenSecretManager(\n      final Configuration conf) throws IOException {\n    final boolean isEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n\n    if (!isEnabled) {\n      if (UserGroupInformation.isSecurityEnabled()) {\n        String errMessage \u003d \"Security is enabled but block access tokens \" +\n            \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n            \"aren\u0027t enabled. This may cause issues \" +\n            \"when clients attempt to connect to a DataNode. Aborting NameNode\";\n        throw new IOException(errMessage);\n      }\n      return null;\n    }\n\n    final long updateMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n    final long lifetimeMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n    final String encryptionAlgorithm \u003d conf.get(\n        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n        + \"\u003d\" + updateMin + \" min(s), \"\n        + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n        + \"\u003d\" + lifetimeMin + \" min(s), \"\n        + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n        + \"\u003d\" + encryptionAlgorithm);\n    \n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n    boolean shouldWriteProtobufToken \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE,\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_PROTOBUF_ENABLE_DEFAULT);\n\n    if (isHaEnabled) {\n      // figure out which index we are of the nns\n      Collection\u003cString\u003e nnIds \u003d DFSUtilClient.getNameNodeIds(conf, nsId);\n      String nnId \u003d HAUtil.getNameNodeId(conf, nsId);\n      int nnIndex \u003d 0;\n      for (String id : nnIds) {\n        if (id.equals(nnId)) {\n          break;\n        }\n        nnIndex++;\n      }\n      return new BlockTokenSecretManager(updateMin * 60 * 1000L,\n          lifetimeMin * 60 * 1000L, nnIndex, nnIds.size(), null,\n          encryptionAlgorithm, shouldWriteProtobufToken);\n    } else {\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, 0, 1, null, encryptionAlgorithm,\n          shouldWriteProtobufToken);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "49dfad942970459297f72632ed8dfd353e0c86de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6440. Support more than 2 NameNodes. Contributed by Jesse Yates.\n",
      "commitDate": "23/06/15 5:26 PM",
      "commitName": "49dfad942970459297f72632ed8dfd353e0c86de",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "17/06/15 8:05 AM",
      "commitNameOld": "6e3fcffe291faec40fa9214f4880a35a952836c4",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 6.39,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,54 @@\n   private static BlockTokenSecretManager createBlockTokenSecretManager(\n       final Configuration conf) throws IOException {\n     final boolean isEnabled \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n \n     if (!isEnabled) {\n       if (UserGroupInformation.isSecurityEnabled()) {\n         String errMessage \u003d \"Security is enabled but block access tokens \" +\n             \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n             \"aren\u0027t enabled. This may cause issues \" +\n             \"when clients attempt to connect to a DataNode. Aborting NameNode\";\n         throw new IOException(errMessage);\n       }\n       return null;\n     }\n \n     final long updateMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n     final long lifetimeMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n     final String encryptionAlgorithm \u003d conf.get(\n         DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n         + \"\u003d\" + updateMin + \" min(s), \"\n         + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n         + \"\u003d\" + lifetimeMin + \" min(s), \"\n         + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n         + \"\u003d\" + encryptionAlgorithm);\n     \n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n \n     if (isHaEnabled) {\n-      String thisNnId \u003d HAUtil.getNameNodeId(conf, nsId);\n-      String otherNnId \u003d HAUtil.getNameNodeIdOfOtherNode(conf, nsId);\n-      return new BlockTokenSecretManager(updateMin*60*1000L,\n-          lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1, null,\n-          encryptionAlgorithm);\n+      // figure out which index we are of the nns\n+      Collection\u003cString\u003e nnIds \u003d DFSUtilClient.getNameNodeIds(conf, nsId);\n+      String nnId \u003d HAUtil.getNameNodeId(conf, nsId);\n+      int nnIndex \u003d 0;\n+      for (String id : nnIds) {\n+        if (id.equals(nnId)) {\n+          break;\n+        }\n+        nnIndex++;\n+      }\n+      return new BlockTokenSecretManager(updateMin * 60 * 1000L,\n+          lifetimeMin * 60 * 1000L, nnIndex, nnIds.size(), null, encryptionAlgorithm);\n     } else {\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n-          lifetimeMin*60*1000L, 0, null, encryptionAlgorithm);\n+          lifetimeMin*60*1000L, 0, 1, null, encryptionAlgorithm);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static BlockTokenSecretManager createBlockTokenSecretManager(\n      final Configuration conf) throws IOException {\n    final boolean isEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n\n    if (!isEnabled) {\n      if (UserGroupInformation.isSecurityEnabled()) {\n        String errMessage \u003d \"Security is enabled but block access tokens \" +\n            \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n            \"aren\u0027t enabled. This may cause issues \" +\n            \"when clients attempt to connect to a DataNode. Aborting NameNode\";\n        throw new IOException(errMessage);\n      }\n      return null;\n    }\n\n    final long updateMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n    final long lifetimeMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n    final String encryptionAlgorithm \u003d conf.get(\n        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n        + \"\u003d\" + updateMin + \" min(s), \"\n        + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n        + \"\u003d\" + lifetimeMin + \" min(s), \"\n        + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n        + \"\u003d\" + encryptionAlgorithm);\n    \n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n\n    if (isHaEnabled) {\n      // figure out which index we are of the nns\n      Collection\u003cString\u003e nnIds \u003d DFSUtilClient.getNameNodeIds(conf, nsId);\n      String nnId \u003d HAUtil.getNameNodeId(conf, nsId);\n      int nnIndex \u003d 0;\n      for (String id : nnIds) {\n        if (id.equals(nnId)) {\n          break;\n        }\n        nnIndex++;\n      }\n      return new BlockTokenSecretManager(updateMin * 60 * 1000L,\n          lifetimeMin * 60 * 1000L, nnIndex, nnIds.size(), null, encryptionAlgorithm);\n    } else {\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, 0, 1, null, encryptionAlgorithm);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "d45aa7647b1fecf81860ec7b563085be2af99a0b": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-6666. Abort NameNode and DataNode startup if security is enabled but block access token is not enabled. Contributed by Vijay Bhat.\n",
      "commitDate": "14/04/15 9:59 AM",
      "commitName": "d45aa7647b1fecf81860ec7b563085be2af99a0b",
      "commitAuthor": "cnauroth",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-6666. Abort NameNode and DataNode startup if security is enabled but block access token is not enabled. Contributed by Vijay Bhat.\n",
          "commitDate": "14/04/15 9:59 AM",
          "commitName": "d45aa7647b1fecf81860ec7b563085be2af99a0b",
          "commitAuthor": "cnauroth",
          "commitDateOld": "11/04/15 1:23 PM",
          "commitNameOld": "f8f5887209a7d8e53c0a77abef275cbcaf1f7a5b",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 2.86,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,47 @@\n   private static BlockTokenSecretManager createBlockTokenSecretManager(\n-      final Configuration conf) {\n+      final Configuration conf) throws IOException {\n     final boolean isEnabled \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n \n     if (!isEnabled) {\n       if (UserGroupInformation.isSecurityEnabled()) {\n-        LOG.error(\"Security is enabled but block access tokens \" +\n+        String errMessage \u003d \"Security is enabled but block access tokens \" +\n             \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n             \"aren\u0027t enabled. This may cause issues \" +\n-            \"when clients attempt to talk to a DataNode.\");\n+            \"when clients attempt to connect to a DataNode. Aborting NameNode\";\n+        throw new IOException(errMessage);\n       }\n       return null;\n     }\n \n     final long updateMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n     final long lifetimeMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n     final String encryptionAlgorithm \u003d conf.get(\n         DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n         + \"\u003d\" + updateMin + \" min(s), \"\n         + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n         + \"\u003d\" + lifetimeMin + \" min(s), \"\n         + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n         + \"\u003d\" + encryptionAlgorithm);\n     \n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n \n     if (isHaEnabled) {\n       String thisNnId \u003d HAUtil.getNameNodeId(conf, nsId);\n       String otherNnId \u003d HAUtil.getNameNodeIdOfOtherNode(conf, nsId);\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n           lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1, null,\n           encryptionAlgorithm);\n     } else {\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n           lifetimeMin*60*1000L, 0, null, encryptionAlgorithm);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static BlockTokenSecretManager createBlockTokenSecretManager(\n      final Configuration conf) throws IOException {\n    final boolean isEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n\n    if (!isEnabled) {\n      if (UserGroupInformation.isSecurityEnabled()) {\n        String errMessage \u003d \"Security is enabled but block access tokens \" +\n            \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n            \"aren\u0027t enabled. This may cause issues \" +\n            \"when clients attempt to connect to a DataNode. Aborting NameNode\";\n        throw new IOException(errMessage);\n      }\n      return null;\n    }\n\n    final long updateMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n    final long lifetimeMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n    final String encryptionAlgorithm \u003d conf.get(\n        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n        + \"\u003d\" + updateMin + \" min(s), \"\n        + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n        + \"\u003d\" + lifetimeMin + \" min(s), \"\n        + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n        + \"\u003d\" + encryptionAlgorithm);\n    \n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n\n    if (isHaEnabled) {\n      String thisNnId \u003d HAUtil.getNameNodeId(conf, nsId);\n      String otherNnId \u003d HAUtil.getNameNodeIdOfOtherNode(conf, nsId);\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1, null,\n          encryptionAlgorithm);\n    } else {\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, 0, null, encryptionAlgorithm);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6666. Abort NameNode and DataNode startup if security is enabled but block access token is not enabled. Contributed by Vijay Bhat.\n",
          "commitDate": "14/04/15 9:59 AM",
          "commitName": "d45aa7647b1fecf81860ec7b563085be2af99a0b",
          "commitAuthor": "cnauroth",
          "commitDateOld": "11/04/15 1:23 PM",
          "commitNameOld": "f8f5887209a7d8e53c0a77abef275cbcaf1f7a5b",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 2.86,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,47 @@\n   private static BlockTokenSecretManager createBlockTokenSecretManager(\n-      final Configuration conf) {\n+      final Configuration conf) throws IOException {\n     final boolean isEnabled \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n \n     if (!isEnabled) {\n       if (UserGroupInformation.isSecurityEnabled()) {\n-        LOG.error(\"Security is enabled but block access tokens \" +\n+        String errMessage \u003d \"Security is enabled but block access tokens \" +\n             \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n             \"aren\u0027t enabled. This may cause issues \" +\n-            \"when clients attempt to talk to a DataNode.\");\n+            \"when clients attempt to connect to a DataNode. Aborting NameNode\";\n+        throw new IOException(errMessage);\n       }\n       return null;\n     }\n \n     final long updateMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n     final long lifetimeMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n     final String encryptionAlgorithm \u003d conf.get(\n         DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n         + \"\u003d\" + updateMin + \" min(s), \"\n         + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n         + \"\u003d\" + lifetimeMin + \" min(s), \"\n         + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n         + \"\u003d\" + encryptionAlgorithm);\n     \n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n \n     if (isHaEnabled) {\n       String thisNnId \u003d HAUtil.getNameNodeId(conf, nsId);\n       String otherNnId \u003d HAUtil.getNameNodeIdOfOtherNode(conf, nsId);\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n           lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1, null,\n           encryptionAlgorithm);\n     } else {\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n           lifetimeMin*60*1000L, 0, null, encryptionAlgorithm);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static BlockTokenSecretManager createBlockTokenSecretManager(\n      final Configuration conf) throws IOException {\n    final boolean isEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n\n    if (!isEnabled) {\n      if (UserGroupInformation.isSecurityEnabled()) {\n        String errMessage \u003d \"Security is enabled but block access tokens \" +\n            \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n            \"aren\u0027t enabled. This may cause issues \" +\n            \"when clients attempt to connect to a DataNode. Aborting NameNode\";\n        throw new IOException(errMessage);\n      }\n      return null;\n    }\n\n    final long updateMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n    final long lifetimeMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n    final String encryptionAlgorithm \u003d conf.get(\n        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n        + \"\u003d\" + updateMin + \" min(s), \"\n        + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n        + \"\u003d\" + lifetimeMin + \" min(s), \"\n        + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n        + \"\u003d\" + encryptionAlgorithm);\n    \n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n\n    if (isHaEnabled) {\n      String thisNnId \u003d HAUtil.getNameNodeId(conf, nsId);\n      String otherNnId \u003d HAUtil.getNameNodeIdOfOtherNode(conf, nsId);\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1, null,\n          encryptionAlgorithm);\n    } else {\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, 0, null, encryptionAlgorithm);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "0dc5824a83716468a88bcd669ed24fc19871332a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4278. Log an ERROR when DFS_BLOCK_ACCESS_TOKEN_ENABLE config is disabled but security is turned on. Contributed by Kousuke Saruta. (harsh)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504784 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/07/13 12:00 AM",
      "commitName": "0dc5824a83716468a88bcd669ed24fc19871332a",
      "commitAuthor": "Harsh J",
      "commitDateOld": "16/07/13 1:07 PM",
      "commitNameOld": "badab7ed5e91ee2dfc8bd10dcb777c874ff4aa90",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 2.45,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,46 @@\n   private static BlockTokenSecretManager createBlockTokenSecretManager(\n       final Configuration conf) {\n     final boolean isEnabled \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n \n     if (!isEnabled) {\n+      if (UserGroupInformation.isSecurityEnabled()) {\n+\t      LOG.error(\"Security is enabled but block access tokens \" +\n+\t\t      \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n+\t\t      \"aren\u0027t enabled. This may cause issues \" +\n+\t\t      \"when clients attempt to talk to a DataNode.\");\n+      }\n       return null;\n     }\n \n     final long updateMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n     final long lifetimeMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n     final String encryptionAlgorithm \u003d conf.get(\n         DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n         + \"\u003d\" + updateMin + \" min(s), \"\n         + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n         + \"\u003d\" + lifetimeMin + \" min(s), \"\n         + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n         + \"\u003d\" + encryptionAlgorithm);\n     \n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n \n     if (isHaEnabled) {\n       String thisNnId \u003d HAUtil.getNameNodeId(conf, nsId);\n       String otherNnId \u003d HAUtil.getNameNodeIdOfOtherNode(conf, nsId);\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n           lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1, null,\n           encryptionAlgorithm);\n     } else {\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n           lifetimeMin*60*1000L, 0, null, encryptionAlgorithm);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static BlockTokenSecretManager createBlockTokenSecretManager(\n      final Configuration conf) {\n    final boolean isEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n\n    if (!isEnabled) {\n      if (UserGroupInformation.isSecurityEnabled()) {\n\t      LOG.error(\"Security is enabled but block access tokens \" +\n\t\t      \"(via \" + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \") \" +\n\t\t      \"aren\u0027t enabled. This may cause issues \" +\n\t\t      \"when clients attempt to talk to a DataNode.\");\n      }\n      return null;\n    }\n\n    final long updateMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n    final long lifetimeMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n    final String encryptionAlgorithm \u003d conf.get(\n        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n        + \"\u003d\" + updateMin + \" min(s), \"\n        + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n        + \"\u003d\" + lifetimeMin + \" min(s), \"\n        + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n        + \"\u003d\" + encryptionAlgorithm);\n    \n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n\n    if (isHaEnabled) {\n      String thisNnId \u003d HAUtil.getNameNodeId(conf, nsId);\n      String otherNnId \u003d HAUtil.getNameNodeIdOfOtherNode(conf, nsId);\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1, null,\n          encryptionAlgorithm);\n    } else {\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, 0, null, encryptionAlgorithm);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "0603447f2a9db7a5a40850de9ba85837ec4940aa": {
      "type": "Yexceptionschange",
      "commitMessage": "HDFS-4072. On file deletion remove corresponding blocks pending replications. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1399965 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/10/12 9:55 PM",
      "commitName": "0603447f2a9db7a5a40850de9ba85837ec4940aa",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "15/10/12 8:37 PM",
      "commitNameOld": "b7887f31fbe28d35005abdc439b2771b58c91225",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 3.05,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   private static BlockTokenSecretManager createBlockTokenSecretManager(\n-      final Configuration conf) throws IOException {\n+      final Configuration conf) {\n     final boolean isEnabled \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n \n     if (!isEnabled) {\n       return null;\n     }\n \n     final long updateMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n     final long lifetimeMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n     final String encryptionAlgorithm \u003d conf.get(\n         DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n         + \"\u003d\" + updateMin + \" min(s), \"\n         + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n         + \"\u003d\" + lifetimeMin + \" min(s), \"\n         + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n         + \"\u003d\" + encryptionAlgorithm);\n     \n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n \n     if (isHaEnabled) {\n       String thisNnId \u003d HAUtil.getNameNodeId(conf, nsId);\n       String otherNnId \u003d HAUtil.getNameNodeIdOfOtherNode(conf, nsId);\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n           lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1, null,\n           encryptionAlgorithm);\n     } else {\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n           lifetimeMin*60*1000L, 0, null, encryptionAlgorithm);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static BlockTokenSecretManager createBlockTokenSecretManager(\n      final Configuration conf) {\n    final boolean isEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n\n    if (!isEnabled) {\n      return null;\n    }\n\n    final long updateMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n    final long lifetimeMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n    final String encryptionAlgorithm \u003d conf.get(\n        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n        + \"\u003d\" + updateMin + \" min(s), \"\n        + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n        + \"\u003d\" + lifetimeMin + \" min(s), \"\n        + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n        + \"\u003d\" + encryptionAlgorithm);\n    \n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n\n    if (isHaEnabled) {\n      String thisNnId \u003d HAUtil.getNameNodeId(conf, nsId);\n      String otherNnId \u003d HAUtil.getNameNodeIdOfOtherNode(conf, nsId);\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1, null,\n          encryptionAlgorithm);\n    } else {\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, 0, null, encryptionAlgorithm);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {
        "oldValue": "[IOException]",
        "newValue": "[]"
      }
    },
    "9b4a7900c7dfc0590316eedaa97144f938885651": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3637. Add support for encrypting the DataTransferProtocol. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370354 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 9:40 AM",
      "commitName": "9b4a7900c7dfc0590316eedaa97144f938885651",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "18/07/12 4:42 PM",
      "commitNameOld": "23b6ed973e1ff5ace1e3a97cded008908e8daa55",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 19.71,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,40 @@\n   private static BlockTokenSecretManager createBlockTokenSecretManager(\n       final Configuration conf) throws IOException {\n     final boolean isEnabled \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n \n     if (!isEnabled) {\n       return null;\n     }\n \n     final long updateMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n     final long lifetimeMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n+    final String encryptionAlgorithm \u003d conf.get(\n+        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n         + \"\u003d\" + updateMin + \" min(s), \"\n         + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n-        + \"\u003d\" + lifetimeMin + \" min(s)\");\n+        + \"\u003d\" + lifetimeMin + \" min(s), \"\n+        + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n+        + \"\u003d\" + encryptionAlgorithm);\n     \n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n \n     if (isHaEnabled) {\n       String thisNnId \u003d HAUtil.getNameNodeId(conf, nsId);\n       String otherNnId \u003d HAUtil.getNameNodeIdOfOtherNode(conf, nsId);\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n-          lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1);\n+          lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1, null,\n+          encryptionAlgorithm);\n     } else {\n       return new BlockTokenSecretManager(updateMin*60*1000L,\n-          lifetimeMin*60*1000L, 0);\n+          lifetimeMin*60*1000L, 0, null, encryptionAlgorithm);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static BlockTokenSecretManager createBlockTokenSecretManager(\n      final Configuration conf) throws IOException {\n    final boolean isEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n\n    if (!isEnabled) {\n      return null;\n    }\n\n    final long updateMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n    final long lifetimeMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n    final String encryptionAlgorithm \u003d conf.get(\n        DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n        + \"\u003d\" + updateMin + \" min(s), \"\n        + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n        + \"\u003d\" + lifetimeMin + \" min(s), \"\n        + DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY\n        + \"\u003d\" + encryptionAlgorithm);\n    \n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n\n    if (isHaEnabled) {\n      String thisNnId \u003d HAUtil.getNameNodeId(conf, nsId);\n      String otherNnId \u003d HAUtil.getNameNodeIdOfOtherNode(conf, nsId);\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1, null,\n          encryptionAlgorithm);\n    } else {\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, 0, null, encryptionAlgorithm);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "fb95fce24056c0b0aa5b77683c684fe1b68c4f76": {
      "type": "Ybodychange",
      "commitMessage": "Fix issue with NN/DN re-registration.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1358347 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/07/12 11:59 AM",
      "commitName": "fb95fce24056c0b0aa5b77683c684fe1b68c4f76",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "02/07/12 12:26 AM",
      "commitNameOld": "28e8151ad3defc85a4ac1d19b39a9377253c718f",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 4.48,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,35 @@\n   private static BlockTokenSecretManager createBlockTokenSecretManager(\n       final Configuration conf) throws IOException {\n     final boolean isEnabled \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n \n     if (!isEnabled) {\n       return null;\n     }\n \n     final long updateMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n     final long lifetimeMin \u003d conf.getLong(\n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n         DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n     LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n         + \"\u003d\" + updateMin + \" min(s), \"\n         + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n         + \"\u003d\" + lifetimeMin + \" min(s)\");\n-    return new BlockTokenSecretManager(true,\n-        updateMin*60*1000L, lifetimeMin*60*1000L);\n+    \n+    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n+    boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n+\n+    if (isHaEnabled) {\n+      String thisNnId \u003d HAUtil.getNameNodeId(conf, nsId);\n+      String otherNnId \u003d HAUtil.getNameNodeIdOfOtherNode(conf, nsId);\n+      return new BlockTokenSecretManager(updateMin*60*1000L,\n+          lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1);\n+    } else {\n+      return new BlockTokenSecretManager(updateMin*60*1000L,\n+          lifetimeMin*60*1000L, 0);\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static BlockTokenSecretManager createBlockTokenSecretManager(\n      final Configuration conf) throws IOException {\n    final boolean isEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n\n    if (!isEnabled) {\n      return null;\n    }\n\n    final long updateMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n    final long lifetimeMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n        + \"\u003d\" + updateMin + \" min(s), \"\n        + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n        + \"\u003d\" + lifetimeMin + \" min(s)\");\n    \n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    boolean isHaEnabled \u003d HAUtil.isHAEnabled(conf, nsId);\n\n    if (isHaEnabled) {\n      String thisNnId \u003d HAUtil.getNameNodeId(conf, nsId);\n      String otherNnId \u003d HAUtil.getNameNodeIdOfOtherNode(conf, nsId);\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, thisNnId.compareTo(otherNnId) \u003c 0 ? 0 : 1);\n    } else {\n      return new BlockTokenSecretManager(updateMin*60*1000L,\n          lifetimeMin*60*1000L, 0);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private static BlockTokenSecretManager createBlockTokenSecretManager(\n      final Configuration conf) throws IOException {\n    final boolean isEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n\n    if (!isEnabled) {\n      return null;\n    }\n\n    final long updateMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n    final long lifetimeMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n        + \"\u003d\" + updateMin + \" min(s), \"\n        + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n        + \"\u003d\" + lifetimeMin + \" min(s)\");\n    return new BlockTokenSecretManager(true,\n        updateMin*60*1000L, lifetimeMin*60*1000L);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private static BlockTokenSecretManager createBlockTokenSecretManager(\n      final Configuration conf) throws IOException {\n    final boolean isEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n\n    if (!isEnabled) {\n      return null;\n    }\n\n    final long updateMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n    final long lifetimeMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n        + \"\u003d\" + updateMin + \" min(s), \"\n        + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n        + \"\u003d\" + lifetimeMin + \" min(s)\");\n    return new BlockTokenSecretManager(true,\n        updateMin*60*1000L, lifetimeMin*60*1000L);\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java"
      }
    },
    "b0944651681337e81b41250f43bd1e8eebc78125": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2265. Remove unnecessary BlockTokenSecretManager fields/methods from BlockManager.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1158743 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/08/11 7:34 AM",
      "commitName": "b0944651681337e81b41250f43bd1e8eebc78125",
      "commitAuthor": "Tsz-wo Sze",
      "diff": "@@ -0,0 +1,24 @@\n+  private static BlockTokenSecretManager createBlockTokenSecretManager(\n+      final Configuration conf) throws IOException {\n+    final boolean isEnabled \u003d conf.getBoolean(\n+        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n+        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n+    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n+\n+    if (!isEnabled) {\n+      return null;\n+    }\n+\n+    final long updateMin \u003d conf.getLong(\n+        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n+        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n+    final long lifetimeMin \u003d conf.getLong(\n+        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n+        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n+    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n+        + \"\u003d\" + updateMin + \" min(s), \"\n+        + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n+        + \"\u003d\" + lifetimeMin + \" min(s)\");\n+    return new BlockTokenSecretManager(true,\n+        updateMin*60*1000L, lifetimeMin*60*1000L);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static BlockTokenSecretManager createBlockTokenSecretManager(\n      final Configuration conf) throws IOException {\n    final boolean isEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + \"\u003d\" + isEnabled);\n\n    if (!isEnabled) {\n      return null;\n    }\n\n    final long updateMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);\n    final long lifetimeMin \u003d conf.getLong(\n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, \n        DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);\n    LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY\n        + \"\u003d\" + updateMin + \" min(s), \"\n        + DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY\n        + \"\u003d\" + lifetimeMin + \" min(s)\");\n    return new BlockTokenSecretManager(true,\n        updateMin*60*1000L, lifetimeMin*60*1000L);\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java"
    }
  }
}