{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainersMonitorImpl.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
  "functionStartLine": 461,
  "functionEndLine": 566,
  "numCommitsSeen": 77,
  "timeTaken": 17872,
  "changeHistory": [
    "67414a1a80039e70e0afc1de171831a6e981f37a",
    "221089760910743eae58eb2cbd5ac86c4ee96a17",
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "1b790f4dd1f682423d5dbb8e70c6225cbddce989",
    "06f0eb2dce2a7a098f7844682ea6c232d0ddb0be",
    "41ac190dba782a59669bd622f572f452267c808e",
    "310aa4686eb697f0700a71d33106514c404dab1b",
    "9449519a2503c55d9eac8fd7519df28aa0760059",
    "bc2656f09f857fdbc39da6b060cee453d2dec4dc",
    "bfb4d950596d6198e473045dac6eb36c685b0319",
    "6f6cc647d6e77f6cc4c66e0534f8c73bc1612a1b",
    "6934b05c7117a12286fb2ba7a47f75e227cacb22",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "477a30f536277bf95d7181bf1b2fdda52d83bf51",
    "22e7ae57715cedb1dcba736e357e8daaf5133e5c",
    "5712b8f9fd1859fe046b482889239bd164ed7dab",
    "1500a0a3009e453c9f05a93df7a78b4e185eef30",
    "fdf02d1f26cea372bf69e071f57b8bfc09c092c4",
    "c59ae4eeb17e52e8fc659b9962d20628719fc621",
    "527c40e4d664c721b8f32d7cd8df21b2666fea8a",
    "8badd82ce256e4dc8c234961120d62a88358ab39",
    "c69ba81497ae4da329ddb34ba712a64a7eec479f",
    "c358368f511963ad8e35f030b9babee541e1bd01",
    "53947f37c7a84a84ef4ab1a3cab63ff27c078385",
    "f7a77819a1e4ff394e110941c1f8dd80f47dd38f",
    "84198564ba6028d51c1fcf9cdcb87f6ae6e08513",
    "ecfd43a2f1ffe56f39ebba98ad13538e63cef6fd",
    "b15b44e722fa69191816bebf319be1396fe68f09",
    "1a49c854386d3ba4aef6f29f46e2bd5e71e86dc1",
    "a1aa1b93497034411d76906405bb6a70a441a0b7",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "237154982bd5853c6a374cb265520e0602adc52f",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "67414a1a80039e70e0afc1de171831a6e981f37a": "Ybodychange",
    "221089760910743eae58eb2cbd5ac86c4ee96a17": "Ybodychange",
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "1b790f4dd1f682423d5dbb8e70c6225cbddce989": "Ybodychange",
    "06f0eb2dce2a7a098f7844682ea6c232d0ddb0be": "Ybodychange",
    "41ac190dba782a59669bd622f572f452267c808e": "Ybodychange",
    "310aa4686eb697f0700a71d33106514c404dab1b": "Ybodychange",
    "9449519a2503c55d9eac8fd7519df28aa0760059": "Ybodychange",
    "bc2656f09f857fdbc39da6b060cee453d2dec4dc": "Ybodychange",
    "bfb4d950596d6198e473045dac6eb36c685b0319": "Ybodychange",
    "6f6cc647d6e77f6cc4c66e0534f8c73bc1612a1b": "Ybodychange",
    "6934b05c7117a12286fb2ba7a47f75e227cacb22": "Ybodychange",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "477a30f536277bf95d7181bf1b2fdda52d83bf51": "Ybodychange",
    "22e7ae57715cedb1dcba736e357e8daaf5133e5c": "Ybodychange",
    "5712b8f9fd1859fe046b482889239bd164ed7dab": "Ybodychange",
    "1500a0a3009e453c9f05a93df7a78b4e185eef30": "Ybodychange",
    "fdf02d1f26cea372bf69e071f57b8bfc09c092c4": "Ybodychange",
    "c59ae4eeb17e52e8fc659b9962d20628719fc621": "Ybodychange",
    "527c40e4d664c721b8f32d7cd8df21b2666fea8a": "Ybodychange",
    "8badd82ce256e4dc8c234961120d62a88358ab39": "Ybodychange",
    "c69ba81497ae4da329ddb34ba712a64a7eec479f": "Ybodychange",
    "c358368f511963ad8e35f030b9babee541e1bd01": "Ybodychange",
    "53947f37c7a84a84ef4ab1a3cab63ff27c078385": "Ybodychange",
    "f7a77819a1e4ff394e110941c1f8dd80f47dd38f": "Ybodychange",
    "84198564ba6028d51c1fcf9cdcb87f6ae6e08513": "Ybodychange",
    "ecfd43a2f1ffe56f39ebba98ad13538e63cef6fd": "Ybodychange",
    "b15b44e722fa69191816bebf319be1396fe68f09": "Ybodychange",
    "1a49c854386d3ba4aef6f29f46e2bd5e71e86dc1": "Ybodychange",
    "a1aa1b93497034411d76906405bb6a70a441a0b7": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "237154982bd5853c6a374cb265520e0602adc52f": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Ymultichange(Ymovefromfile,Ybodychange)",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "67414a1a80039e70e0afc1de171831a6e981f37a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9584. Should put initializeProcessTrees method call before get pid. Contributed by Wanqiang Ji.\n",
      "commitDate": "17/06/19 9:23 PM",
      "commitName": "67414a1a80039e70e0afc1de171831a6e981f37a",
      "commitAuthor": "Zhankun Tang",
      "commitDateOld": "31/05/19 5:35 PM",
      "commitNameOld": "221089760910743eae58eb2cbd5ac86c4ee96a17",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 17.16,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,106 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           tmp.append(\"]\");\n           LOG.debug(\"Current ProcessTree list : {}\", tmp);\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n-            String pId \u003d ptInfo.getPID();\n-\n             // Initialize uninitialized process trees\n             initializeProcessTrees(entry);\n \n+            String pId \u003d ptInfo.getPID();\n             if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n               continue; // processTree cannot be tracked\n             }\n             LOG.debug(\n                 \"Constructing ProcessTree for : PID \u003d {} ContainerId \u003d {}\",\n                 pId, containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n \n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             if (cpuUsagePercentPerCore \u003c 0) {\n               // CPU usage is not available likely because the container just\n               // started. Let us skip this turn and consider this container\n               // in the next iteration.\n               LOG.info(\"Skipping monitoring container {} since \"\n                   + \"CPU usage is not yet available.\", containerId);\n               continue;\n             }\n \n             recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                     currentPmemUsage, trackedContainersUtilization);\n \n             checkLimit(containerId, pId, pTree, ptInfo,\n                     currentVmemUsage, currentPmemUsage);\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             reportResourceUsage(containerId, currentPmemUsage,\n                     cpuUsagePercentPerCore);\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                 + \"while monitoring resource of {}\", containerId, e);\n           }\n         }\n         LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n             + \"Virtual Memory\u003d {}, Physical Memory\u003d {}, \"\n             + \"Total CPU usage(% per core)\u003d {}\", vmemUsageByAllContainers,\n             pmemByAllContainers, cpuUsagePercentPerCoreByAllContainers);\n \n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         // Publish the container utilization metrics to node manager\n         // metrics system.\n         NodeManagerMetrics nmMetrics \u003d context.getNodeManagerMetrics();\n         if (nmMetrics !\u003d null) {\n           nmMetrics.setContainerUsedMemGB(\n               trackedContainersUtilization.getPhysicalMemory());\n           nmMetrics.setContainerUsedVMemGB(\n               trackedContainersUtilization.getVirtualMemory());\n           nmMetrics.setContainerCpuUtilization(\n               trackedContainersUtilization.getCPU());\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(\"{} is interrupted. Exiting.\",\n               ContainersMonitorImpl.class.getName());\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          tmp.append(\"]\");\n          LOG.debug(\"Current ProcessTree list : {}\", tmp);\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            // Initialize uninitialized process trees\n            initializeProcessTrees(entry);\n\n            String pId \u003d ptInfo.getPID();\n            if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n              continue; // processTree cannot be tracked\n            }\n            LOG.debug(\n                \"Constructing ProcessTree for : PID \u003d {} ContainerId \u003d {}\",\n                pId, containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container {} since \"\n                  + \"CPU usage is not yet available.\", containerId);\n              continue;\n            }\n\n            recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                    currentPmemUsage, trackedContainersUtilization);\n\n            checkLimit(containerId, pId, pTree, ptInfo,\n                    currentVmemUsage, currentPmemUsage);\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            reportResourceUsage(containerId, currentPmemUsage,\n                    cpuUsagePercentPerCore);\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of {}\", containerId, e);\n          }\n        }\n        LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n            + \"Virtual Memory\u003d {}, Physical Memory\u003d {}, \"\n            + \"Total CPU usage(% per core)\u003d {}\", vmemUsageByAllContainers,\n            pmemByAllContainers, cpuUsagePercentPerCoreByAllContainers);\n\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        // Publish the container utilization metrics to node manager\n        // metrics system.\n        NodeManagerMetrics nmMetrics \u003d context.getNodeManagerMetrics();\n        if (nmMetrics !\u003d null) {\n          nmMetrics.setContainerUsedMemGB(\n              trackedContainersUtilization.getPhysicalMemory());\n          nmMetrics.setContainerUsedVMemGB(\n              trackedContainersUtilization.getVirtualMemory());\n          nmMetrics.setContainerCpuUtilization(\n              trackedContainersUtilization.getCPU());\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(\"{} is interrupted. Exiting.\",\n              ContainersMonitorImpl.class.getName());\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "221089760910743eae58eb2cbd5ac86c4ee96a17": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9592. Use Logger format in ContainersMonitorImpl. Contributed by Inigo Goiri.\n",
      "commitDate": "31/05/19 5:35 PM",
      "commitName": "221089760910743eae58eb2cbd5ac86c4ee96a17",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 77.05,
      "commitsBetweenForRepo": 469,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,107 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n-          LOG.debug(\"Current ProcessTree list : {}\",\n-              tmp.substring(0, tmp.length()) + \"]\");\n+          tmp.append(\"]\");\n+          LOG.debug(\"Current ProcessTree list : {}\", tmp);\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize uninitialized process trees\n             initializeProcessTrees(entry);\n \n             if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n               continue; // processTree cannot be tracked\n             }\n-            LOG.debug(\"Constructing ProcessTree for : PID \u003d {}\"\n-                +\" ContainerId \u003d {}\", pId, containerId);\n+            LOG.debug(\n+                \"Constructing ProcessTree for : PID \u003d {} ContainerId \u003d {}\",\n+                pId, containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n \n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             if (cpuUsagePercentPerCore \u003c 0) {\n               // CPU usage is not available likely because the container just\n               // started. Let us skip this turn and consider this container\n               // in the next iteration.\n-              LOG.info(\"Skipping monitoring container \" + containerId\n-                  + \" since CPU usage is not yet available.\");\n+              LOG.info(\"Skipping monitoring container {} since \"\n+                  + \"CPU usage is not yet available.\", containerId);\n               continue;\n             }\n \n             recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                     currentPmemUsage, trackedContainersUtilization);\n \n             checkLimit(containerId, pId, pTree, ptInfo,\n                     currentVmemUsage, currentPmemUsage);\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             reportResourceUsage(containerId, currentPmemUsage,\n                     cpuUsagePercentPerCore);\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                 + \"while monitoring resource of {}\", containerId, e);\n           }\n         }\n         LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n             + \"Virtual Memory\u003d {}, Physical Memory\u003d {}, \"\n             + \"Total CPU usage(% per core)\u003d {}\", vmemUsageByAllContainers,\n             pmemByAllContainers, cpuUsagePercentPerCoreByAllContainers);\n \n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         // Publish the container utilization metrics to node manager\n         // metrics system.\n         NodeManagerMetrics nmMetrics \u003d context.getNodeManagerMetrics();\n         if (nmMetrics !\u003d null) {\n           nmMetrics.setContainerUsedMemGB(\n               trackedContainersUtilization.getPhysicalMemory());\n           nmMetrics.setContainerUsedVMemGB(\n               trackedContainersUtilization.getVirtualMemory());\n           nmMetrics.setContainerCpuUtilization(\n               trackedContainersUtilization.getCPU());\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n-          LOG.warn(ContainersMonitorImpl.class.getName()\n-              + \" is interrupted. Exiting.\");\n+          LOG.warn(\"{} is interrupted. Exiting.\",\n+              ContainersMonitorImpl.class.getName());\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          tmp.append(\"]\");\n          LOG.debug(\"Current ProcessTree list : {}\", tmp);\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize uninitialized process trees\n            initializeProcessTrees(entry);\n\n            if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n              continue; // processTree cannot be tracked\n            }\n            LOG.debug(\n                \"Constructing ProcessTree for : PID \u003d {} ContainerId \u003d {}\",\n                pId, containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container {} since \"\n                  + \"CPU usage is not yet available.\", containerId);\n              continue;\n            }\n\n            recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                    currentPmemUsage, trackedContainersUtilization);\n\n            checkLimit(containerId, pId, pTree, ptInfo,\n                    currentVmemUsage, currentPmemUsage);\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            reportResourceUsage(containerId, currentPmemUsage,\n                    cpuUsagePercentPerCore);\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of {}\", containerId, e);\n          }\n        }\n        LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n            + \"Virtual Memory\u003d {}, Physical Memory\u003d {}, \"\n            + \"Total CPU usage(% per core)\u003d {}\", vmemUsageByAllContainers,\n            pmemByAllContainers, cpuUsagePercentPerCoreByAllContainers);\n\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        // Publish the container utilization metrics to node manager\n        // metrics system.\n        NodeManagerMetrics nmMetrics \u003d context.getNodeManagerMetrics();\n        if (nmMetrics !\u003d null) {\n          nmMetrics.setContainerUsedMemGB(\n              trackedContainersUtilization.getPhysicalMemory());\n          nmMetrics.setContainerUsedVMemGB(\n              trackedContainersUtilization.getVirtualMemory());\n          nmMetrics.setContainerCpuUtilization(\n              trackedContainersUtilization.getCPU());\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(\"{} is interrupted. Exiting.\",\n              ContainersMonitorImpl.class.getName());\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "21/12/18 4:44 PM",
      "commitNameOld": "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 83.94,
      "commitsBetweenForRepo": 649,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,106 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n-          LOG.debug(\"Current ProcessTree list : \"\n-              + tmp.substring(0, tmp.length()) + \"]\");\n+          LOG.debug(\"Current ProcessTree list : {}\",\n+              tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize uninitialized process trees\n             initializeProcessTrees(entry);\n \n             if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n               continue; // processTree cannot be tracked\n             }\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n-                  + \" ContainerId \u003d \" + containerId);\n-            }\n+            LOG.debug(\"Constructing ProcessTree for : PID \u003d {}\"\n+                +\" ContainerId \u003d {}\", pId, containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n \n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             if (cpuUsagePercentPerCore \u003c 0) {\n               // CPU usage is not available likely because the container just\n               // started. Let us skip this turn and consider this container\n               // in the next iteration.\n               LOG.info(\"Skipping monitoring container \" + containerId\n                   + \" since CPU usage is not yet available.\");\n               continue;\n             }\n \n             recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                     currentPmemUsage, trackedContainersUtilization);\n \n             checkLimit(containerId, pId, pTree, ptInfo,\n                     currentVmemUsage, currentPmemUsage);\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             reportResourceUsage(containerId, currentPmemUsage,\n                     cpuUsagePercentPerCore);\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                 + \"while monitoring resource of {}\", containerId, e);\n           }\n         }\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n-              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n-              + \", Physical Memory\u003d \" + pmemByAllContainers\n-              + \", Total CPU usage(% per core)\u003d \"\n-              + cpuUsagePercentPerCoreByAllContainers);\n-        }\n+        LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n+            + \"Virtual Memory\u003d {}, Physical Memory\u003d {}, \"\n+            + \"Total CPU usage(% per core)\u003d {}\", vmemUsageByAllContainers,\n+            pmemByAllContainers, cpuUsagePercentPerCoreByAllContainers);\n+\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         // Publish the container utilization metrics to node manager\n         // metrics system.\n         NodeManagerMetrics nmMetrics \u003d context.getNodeManagerMetrics();\n         if (nmMetrics !\u003d null) {\n           nmMetrics.setContainerUsedMemGB(\n               trackedContainersUtilization.getPhysicalMemory());\n           nmMetrics.setContainerUsedVMemGB(\n               trackedContainersUtilization.getVirtualMemory());\n           nmMetrics.setContainerCpuUtilization(\n               trackedContainersUtilization.getCPU());\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : {}\",\n              tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize uninitialized process trees\n            initializeProcessTrees(entry);\n\n            if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n              continue; // processTree cannot be tracked\n            }\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d {}\"\n                +\" ContainerId \u003d {}\", pId, containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container \" + containerId\n                  + \" since CPU usage is not yet available.\");\n              continue;\n            }\n\n            recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                    currentPmemUsage, trackedContainersUtilization);\n\n            checkLimit(containerId, pId, pTree, ptInfo,\n                    currentVmemUsage, currentPmemUsage);\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            reportResourceUsage(containerId, currentPmemUsage,\n                    cpuUsagePercentPerCore);\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of {}\", containerId, e);\n          }\n        }\n        LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n            + \"Virtual Memory\u003d {}, Physical Memory\u003d {}, \"\n            + \"Total CPU usage(% per core)\u003d {}\", vmemUsageByAllContainers,\n            pmemByAllContainers, cpuUsagePercentPerCoreByAllContainers);\n\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        // Publish the container utilization metrics to node manager\n        // metrics system.\n        NodeManagerMetrics nmMetrics \u003d context.getNodeManagerMetrics();\n        if (nmMetrics !\u003d null) {\n          nmMetrics.setContainerUsedMemGB(\n              trackedContainersUtilization.getPhysicalMemory());\n          nmMetrics.setContainerUsedVMemGB(\n              trackedContainersUtilization.getVirtualMemory());\n          nmMetrics.setContainerCpuUtilization(\n              trackedContainersUtilization.getCPU());\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "1b790f4dd1f682423d5dbb8e70c6225cbddce989": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9071.  Improved status update for reinitialized containers.\n            Contributed by Chandni Singh\n",
      "commitDate": "05/12/18 2:00 PM",
      "commitName": "1b790f4dd1f682423d5dbb8e70c6225cbddce989",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "25/10/18 11:09 AM",
      "commitNameOld": "f76e3c3db789dd6866fa0fef8e014cbfe8c8f80d",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 41.16,
      "commitsBetweenForRepo": 278,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize uninitialized process trees\n             initializeProcessTrees(entry);\n \n             if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n               continue; // processTree cannot be tracked\n             }\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                   + \" ContainerId \u003d \" + containerId);\n             }\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n \n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             if (cpuUsagePercentPerCore \u003c 0) {\n               // CPU usage is not available likely because the container just\n               // started. Let us skip this turn and consider this container\n               // in the next iteration.\n               LOG.info(\"Skipping monitoring container \" + containerId\n                   + \" since CPU usage is not yet available.\");\n               continue;\n             }\n \n             recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                     currentPmemUsage, trackedContainersUtilization);\n \n             checkLimit(containerId, pId, pTree, ptInfo,\n                     currentVmemUsage, currentPmemUsage);\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             reportResourceUsage(containerId, currentPmemUsage,\n                     cpuUsagePercentPerCore);\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n-                + \"while monitoring resource of \" + containerId, e);\n+                + \"while monitoring resource of {}\", containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n               + \", Total CPU usage(% per core)\u003d \"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         // Publish the container utilization metrics to node manager\n         // metrics system.\n         NodeManagerMetrics nmMetrics \u003d context.getNodeManagerMetrics();\n         if (nmMetrics !\u003d null) {\n           nmMetrics.setContainerUsedMemGB(\n               trackedContainersUtilization.getPhysicalMemory());\n           nmMetrics.setContainerUsedVMemGB(\n               trackedContainersUtilization.getVirtualMemory());\n           nmMetrics.setContainerCpuUtilization(\n               trackedContainersUtilization.getCPU());\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize uninitialized process trees\n            initializeProcessTrees(entry);\n\n            if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n              continue; // processTree cannot be tracked\n            }\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                  + \" ContainerId \u003d \" + containerId);\n            }\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container \" + containerId\n                  + \" since CPU usage is not yet available.\");\n              continue;\n            }\n\n            recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                    currentPmemUsage, trackedContainersUtilization);\n\n            checkLimit(containerId, pId, pTree, ptInfo,\n                    currentVmemUsage, currentPmemUsage);\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            reportResourceUsage(containerId, currentPmemUsage,\n                    cpuUsagePercentPerCore);\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of {}\", containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage(% per core)\u003d \"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        // Publish the container utilization metrics to node manager\n        // metrics system.\n        NodeManagerMetrics nmMetrics \u003d context.getNodeManagerMetrics();\n        if (nmMetrics !\u003d null) {\n          nmMetrics.setContainerUsedMemGB(\n              trackedContainersUtilization.getPhysicalMemory());\n          nmMetrics.setContainerUsedVMemGB(\n              trackedContainersUtilization.getVirtualMemory());\n          nmMetrics.setContainerCpuUtilization(\n              trackedContainersUtilization.getCPU());\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "06f0eb2dce2a7a098f7844682ea6c232d0ddb0be": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7625. Expose NM node/containers resource utilization in JVM metrics. Contributed by Weiwei Yang\n",
      "commitDate": "12/12/17 10:56 AM",
      "commitName": "06f0eb2dce2a7a098f7844682ea6c232d0ddb0be",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "07/09/17 2:17 PM",
      "commitNameOld": "b0b535d9d5727cd84fd6368c6d1b38363616504e",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 95.9,
      "commitsBetweenForRepo": 780,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,110 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize uninitialized process trees\n             initializeProcessTrees(entry);\n \n             if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n               continue; // processTree cannot be tracked\n             }\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                   + \" ContainerId \u003d \" + containerId);\n             }\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n \n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             if (cpuUsagePercentPerCore \u003c 0) {\n               // CPU usage is not available likely because the container just\n               // started. Let us skip this turn and consider this container\n               // in the next iteration.\n               LOG.info(\"Skipping monitoring container \" + containerId\n                   + \" since CPU usage is not yet available.\");\n               continue;\n             }\n \n             recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                     currentPmemUsage, trackedContainersUtilization);\n \n             checkLimit(containerId, pId, pTree, ptInfo,\n                     currentVmemUsage, currentPmemUsage);\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             reportResourceUsage(containerId, currentPmemUsage,\n                     cpuUsagePercentPerCore);\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                 + \"while monitoring resource of \" + containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n               + \", Total CPU usage(% per core)\u003d \"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n+        // Publish the container utilization metrics to node manager\n+        // metrics system.\n+        NodeManagerMetrics nmMetrics \u003d context.getNodeManagerMetrics();\n+        if (nmMetrics !\u003d null) {\n+          nmMetrics.setContainerUsedMemGB(\n+              trackedContainersUtilization.getPhysicalMemory());\n+          nmMetrics.setContainerUsedVMemGB(\n+              trackedContainersUtilization.getVirtualMemory());\n+          nmMetrics.setContainerCpuUtilization(\n+              trackedContainersUtilization.getCPU());\n+        }\n+\n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize uninitialized process trees\n            initializeProcessTrees(entry);\n\n            if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n              continue; // processTree cannot be tracked\n            }\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                  + \" ContainerId \u003d \" + containerId);\n            }\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container \" + containerId\n                  + \" since CPU usage is not yet available.\");\n              continue;\n            }\n\n            recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                    currentPmemUsage, trackedContainersUtilization);\n\n            checkLimit(containerId, pId, pTree, ptInfo,\n                    currentVmemUsage, currentPmemUsage);\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            reportResourceUsage(containerId, currentPmemUsage,\n                    cpuUsagePercentPerCore);\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage(% per core)\u003d \"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        // Publish the container utilization metrics to node manager\n        // metrics system.\n        NodeManagerMetrics nmMetrics \u003d context.getNodeManagerMetrics();\n        if (nmMetrics !\u003d null) {\n          nmMetrics.setContainerUsedMemGB(\n              trackedContainersUtilization.getPhysicalMemory());\n          nmMetrics.setContainerUsedVMemGB(\n              trackedContainersUtilization.getVirtualMemory());\n          nmMetrics.setContainerCpuUtilization(\n              trackedContainersUtilization.getCPU());\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "41ac190dba782a59669bd622f572f452267c808e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6438. Code can be improved in ContainersMonitorImpl.java\n(Contributed by Miklos Szegedi via Daniel Templeton)\n",
      "commitDate": "19/04/17 10:53 AM",
      "commitName": "41ac190dba782a59669bd622f572f452267c808e",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "28/11/16 3:19 PM",
      "commitNameOld": "62b42ef5dd04d516d33bf0890ac5cd49f8184a73",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 141.77,
      "commitsBetweenForRepo": 766,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,98 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n-        long cpuUsageTotalCoresByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize uninitialized process trees\n             initializeProcessTrees(entry);\n \n             if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n               continue; // processTree cannot be tracked\n             }\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                   + \" ContainerId \u003d \" + containerId);\n             }\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n \n             // if machine has 6 cores and 3 are used,\n-            // cpuUsagePercentPerCore should be 300% and\n-            // cpuUsageTotalCoresPercentage should be 50%\n+            // cpuUsagePercentPerCore should be 300%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             if (cpuUsagePercentPerCore \u003c 0) {\n               // CPU usage is not available likely because the container just\n               // started. Let us skip this turn and consider this container\n               // in the next iteration.\n               LOG.info(\"Skipping monitoring container \" + containerId\n                   + \" since CPU usage is not yet available.\");\n               continue;\n             }\n \n             recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                     currentPmemUsage, trackedContainersUtilization);\n \n             checkLimit(containerId, pId, pTree, ptInfo,\n                     currentVmemUsage, currentPmemUsage);\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n-            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             reportResourceUsage(containerId, currentPmemUsage,\n                     cpuUsagePercentPerCore);\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                 + \"while monitoring resource of \" + containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n-              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n-              + \", Total CPU(% per core) usage\"\n+              + \", Total CPU usage(% per core)\u003d \"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize uninitialized process trees\n            initializeProcessTrees(entry);\n\n            if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n              continue; // processTree cannot be tracked\n            }\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                  + \" ContainerId \u003d \" + containerId);\n            }\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container \" + containerId\n                  + \" since CPU usage is not yet available.\");\n              continue;\n            }\n\n            recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                    currentPmemUsage, trackedContainersUtilization);\n\n            checkLimit(containerId, pId, pTree, ptInfo,\n                    currentVmemUsage, currentPmemUsage);\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            reportResourceUsage(containerId, currentPmemUsage,\n                    cpuUsagePercentPerCore);\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage(% per core)\u003d \"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "310aa4686eb697f0700a71d33106514c404dab1b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5805. Add isDebugEnabled check for debug logs in nodemanager (Bibin A Chundatt via Varun Saxena)\n",
      "commitDate": "01/11/16 2:21 AM",
      "commitName": "310aa4686eb697f0700a71d33106514c404dab1b",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "27/10/16 2:36 PM",
      "commitNameOld": "9449519a2503c55d9eac8fd7519df28aa0760059",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 4.49,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,102 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         long cpuUsageTotalCoresByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize uninitialized process trees\n             initializeProcessTrees(entry);\n \n             if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n               continue; // processTree cannot be tracked\n             }\n-\n-            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n-                + \" ContainerId \u003d \" + containerId);\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n+                  + \" ContainerId \u003d \" + containerId);\n+            }\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n \n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             if (cpuUsagePercentPerCore \u003c 0) {\n               // CPU usage is not available likely because the container just\n               // started. Let us skip this turn and consider this container\n               // in the next iteration.\n               LOG.info(\"Skipping monitoring container \" + containerId\n                   + \" since CPU usage is not yet available.\");\n               continue;\n             }\n \n             recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                     currentPmemUsage, trackedContainersUtilization);\n \n             checkLimit(containerId, pId, pTree, ptInfo,\n                     currentVmemUsage, currentPmemUsage);\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n             cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             reportResourceUsage(containerId, currentPmemUsage,\n                     cpuUsagePercentPerCore);\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                 + \"while monitoring resource of \" + containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n               + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n               + \", Total CPU(% per core) usage\"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        long cpuUsageTotalCoresByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize uninitialized process trees\n            initializeProcessTrees(entry);\n\n            if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n              continue; // processTree cannot be tracked\n            }\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                  + \" ContainerId \u003d \" + containerId);\n            }\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container \" + containerId\n                  + \" since CPU usage is not yet available.\");\n              continue;\n            }\n\n            recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                    currentPmemUsage, trackedContainersUtilization);\n\n            checkLimit(containerId, pId, pTree, ptInfo,\n                    currentVmemUsage, currentPmemUsage);\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            reportResourceUsage(containerId, currentPmemUsage,\n                    cpuUsagePercentPerCore);\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n              + \", Total CPU(% per core) usage\"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "9449519a2503c55d9eac8fd7519df28aa0760059": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5776. Checkstyle: MonitoringThread.Run method length is too long (miklos.szegedi@cloudera.com via rkanter)\n",
      "commitDate": "27/10/16 2:36 PM",
      "commitName": "9449519a2503c55d9eac8fd7519df28aa0760059",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "28/09/16 2:48 AM",
      "commitNameOld": "bc2656f09f857fdbc39da6b060cee453d2dec4dc",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 29.49,
      "commitsBetweenForRepo": 249,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,223 +1,101 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         long cpuUsageTotalCoresByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n-            // Initialize any uninitialized processTrees\n-            if (pId \u003d\u003d null) {\n-              // get pid from ContainerId\n-              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n-              if (pId !\u003d null) {\n-                // pId will be null, either if the container is not spawned yet\n-                // or if the container\u0027s pid is removed from ContainerExecutor\n-                LOG.debug(\"Tracking ProcessTree \" + pId\n-                    + \" for the first time\");\n-\n-                ResourceCalculatorProcessTree pt \u003d\n-                    ResourceCalculatorProcessTree.\n-                        getResourceCalculatorProcessTree(\n-                            pId, processTreeClass, conf);\n-                ptInfo.setPid(pId);\n-                ptInfo.setProcessTree(pt);\n-\n-                if (containerMetricsEnabled) {\n-                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n-                      .forContainer(containerId, containerMetricsPeriodMs,\n-                      containerMetricsUnregisterDelayMs);\n-                  usageMetrics.recordProcessId(pId);\n-                }\n-                Container container \u003d context.getContainers().get(containerId);\n-                String[] ipAndHost \u003d containerExecutor.getIpAndHost(container);\n-                if (ipAndHost !\u003d null \u0026\u0026 ipAndHost[0] !\u003d null\n-                    \u0026\u0026 ipAndHost[1] !\u003d null) {\n-                  container.setIpAndHost(ipAndHost);\n-                  LOG.info(containerId + \"\u0027s ip \u003d \" + ipAndHost[0]\n-                      + \", and hostname \u003d \" + ipAndHost[1]);\n-                } else {\n-                  LOG.info(\"Can not get both ip and hostname: \" + Arrays\n-                      .toString(ipAndHost));\n-                }\n-              }\n-            }\n-            // End of initializing any uninitialized processTrees\n+            // Initialize uninitialized process trees\n+            initializeProcessTrees(entry);\n \n             if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n \n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             if (cpuUsagePercentPerCore \u003c 0) {\n               // CPU usage is not available likely because the container just\n               // started. Let us skip this turn and consider this container\n               // in the next iteration.\n               LOG.info(\"Skipping monitoring container \" + containerId\n                   + \" since CPU usage is not yet available.\");\n               continue;\n             }\n \n-            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n-                resourceCalculatorPlugin.getNumProcessors();\n+            recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n+                    currentPmemUsage, trackedContainersUtilization);\n \n-            // Multiply by 1000 to avoid losing data when converting to int\n-            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n-                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n-            // as processes begin with an age 1, we want to see if there\n-            // are processes more than 1 iteration old.\n-            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n-            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n-            long vmemLimit \u003d ptInfo.getVmemLimit();\n-            long pmemLimit \u003d ptInfo.getPmemLimit();\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(String.format(\n-                  \"Memory usage of ProcessTree %s for container-id %s: \",\n-                  pId, containerId.toString()) +\n-                  formatUsageString(\n-                      currentVmemUsage, vmemLimit,\n-                      currentPmemUsage, pmemLimit));\n-            }\n-\n-            // Add resource utilization for this container\n-            trackedContainersUtilization.addTo(\n-                (int) (currentPmemUsage \u003e\u003e 20),\n-                (int) (currentVmemUsage \u003e\u003e 20),\n-                milliVcoresUsed / 1000.0f);\n-\n-            // Add usage to container metrics\n-            if (containerMetricsEnabled) {\n-              ContainerMetrics.forContainer(\n-                  containerId, containerMetricsPeriodMs,\n-                  containerMetricsUnregisterDelayMs).recordMemoryUsage(\n-                  (int) (currentPmemUsage \u003e\u003e 20));\n-              ContainerMetrics.forContainer(\n-                  containerId, containerMetricsPeriodMs,\n-                  containerMetricsUnregisterDelayMs).recordCpuUsage\n-                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n-            }\n-\n-            boolean isMemoryOverLimit \u003d false;\n-            String msg \u003d \"\";\n-            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n-            if (isVmemCheckEnabled()\n-                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n-                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n-              // Container (the root process) is still alive and overflowing\n-              // memory.\n-              // Dump the process-tree and then clean it up.\n-              msg \u003d formatErrorMessage(\"virtual\",\n-                  currentVmemUsage, vmemLimit,\n-                  currentPmemUsage, pmemLimit,\n-                  pId, containerId, pTree);\n-              isMemoryOverLimit \u003d true;\n-              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n-            } else if (isPmemCheckEnabled()\n-                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n-                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n-                    pmemLimit)) {\n-              // Container (the root process) is still alive and overflowing\n-              // memory.\n-              // Dump the process-tree and then clean it up.\n-              msg \u003d formatErrorMessage(\"physical\",\n-                  currentVmemUsage, vmemLimit,\n-                  currentPmemUsage, pmemLimit,\n-                  pId, containerId, pTree);\n-              isMemoryOverLimit \u003d true;\n-              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n-            }\n+            checkLimit(containerId, pId, pTree, ptInfo,\n+                    currentVmemUsage, currentPmemUsage);\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n             cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n \n-            if (isMemoryOverLimit) {\n-              // Virtual or physical memory over limit. Fail the container and\n-              // remove\n-              // the corresponding process tree\n-              LOG.warn(msg);\n-              // warn if not a leader\n-              if (!pTree.checkPidPgrpidForMatch()) {\n-                LOG.error(\"Killed container process with PID \" + pId\n-                    + \" but it is not a process group leader.\");\n-              }\n-              // kill the container\n-              eventDispatcher.getEventHandler().handle(\n-                  new ContainerKillEvent(containerId,\n-                      containerExitStatus, msg));\n-              trackingContainers.remove(containerId);\n-              LOG.info(\"Removed ProcessTree with root \" + pId);\n-            }\n-\n-            ContainerImpl container \u003d\n-                (ContainerImpl) context.getContainers().get(containerId);\n-            NMTimelinePublisher nmMetricsPublisher \u003d\n-                container.getNMTimelinePublisher();\n-            if (nmMetricsPublisher !\u003d null) {\n-              nmMetricsPublisher.reportContainerResourceUsage(container,\n-                  currentPmemUsage, cpuUsagePercentPerCore);\n-            }\n+            reportResourceUsage(containerId, currentPmemUsage,\n+                    cpuUsagePercentPerCore);\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                 + \"while monitoring resource of \" + containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n               + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n               + \", Total CPU(% per core) usage\"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        long cpuUsageTotalCoresByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize uninitialized process trees\n            initializeProcessTrees(entry);\n\n            if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container \" + containerId\n                  + \" since CPU usage is not yet available.\");\n              continue;\n            }\n\n            recordUsage(containerId, pId, pTree, ptInfo, currentVmemUsage,\n                    currentPmemUsage, trackedContainersUtilization);\n\n            checkLimit(containerId, pId, pTree, ptInfo,\n                    currentVmemUsage, currentPmemUsage);\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            reportResourceUsage(containerId, currentPmemUsage,\n                    cpuUsagePercentPerCore);\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n              + \", Total CPU(% per core) usage\"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "bc2656f09f857fdbc39da6b060cee453d2dec4dc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5662. Provide an option to enable ContainerMonitor. Contributed by Jian He.\n",
      "commitDate": "28/09/16 2:48 AM",
      "commitName": "bc2656f09f857fdbc39da6b060cee453d2dec4dc",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "16/09/16 10:05 PM",
      "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 11.2,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,223 +1,223 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         long cpuUsageTotalCoresByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.\n                         getResourceCalculatorProcessTree(\n                             pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n \n                 if (containerMetricsEnabled) {\n                   ContainerMetrics usageMetrics \u003d ContainerMetrics\n                       .forContainer(containerId, containerMetricsPeriodMs,\n                       containerMetricsUnregisterDelayMs);\n                   usageMetrics.recordProcessId(pId);\n                 }\n                 Container container \u003d context.getContainers().get(containerId);\n                 String[] ipAndHost \u003d containerExecutor.getIpAndHost(container);\n                 if (ipAndHost !\u003d null \u0026\u0026 ipAndHost[0] !\u003d null\n                     \u0026\u0026 ipAndHost[1] !\u003d null) {\n                   container.setIpAndHost(ipAndHost);\n                   LOG.info(containerId + \"\u0027s ip \u003d \" + ipAndHost[0]\n                       + \", and hostname \u003d \" + ipAndHost[1]);\n                 } else {\n                   LOG.info(\"Can not get both ip and hostname: \" + Arrays\n                       .toString(ipAndHost));\n                 }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n-            if (pId \u003d\u003d null) {\n+            if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n \n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             if (cpuUsagePercentPerCore \u003c 0) {\n               // CPU usage is not available likely because the container just\n               // started. Let us skip this turn and consider this container\n               // in the next iteration.\n               LOG.info(\"Skipping monitoring container \" + containerId\n                   + \" since CPU usage is not yet available.\");\n               continue;\n             }\n \n             float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                 resourceCalculatorPlugin.getNumProcessors();\n \n             // Multiply by 1000 to avoid losing data when converting to int\n             int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(String.format(\n                   \"Memory usage of ProcessTree %s for container-id %s: \",\n                   pId, containerId.toString()) +\n                   formatUsageString(\n                       currentVmemUsage, vmemLimit,\n                       currentPmemUsage, pmemLimit));\n             }\n \n             // Add resource utilization for this container\n             trackedContainersUtilization.addTo(\n                 (int) (currentPmemUsage \u003e\u003e 20),\n                 (int) (currentVmemUsage \u003e\u003e 20),\n                 milliVcoresUsed / 1000.0f);\n \n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs,\n                   containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs,\n                   containerMetricsUnregisterDelayMs).recordCpuUsage\n                   ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n             }\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n             cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               trackingContainers.remove(containerId);\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             }\n \n             ContainerImpl container \u003d\n                 (ContainerImpl) context.getContainers().get(containerId);\n             NMTimelinePublisher nmMetricsPublisher \u003d\n                 container.getNMTimelinePublisher();\n             if (nmMetricsPublisher !\u003d null) {\n               nmMetricsPublisher.reportContainerResourceUsage(container,\n                   currentPmemUsage, cpuUsagePercentPerCore);\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                 + \"while monitoring resource of \" + containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n               + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n               + \", Total CPU(% per core) usage\"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        long cpuUsageTotalCoresByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.\n                        getResourceCalculatorProcessTree(\n                            pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs,\n                      containerMetricsUnregisterDelayMs);\n                  usageMetrics.recordProcessId(pId);\n                }\n                Container container \u003d context.getContainers().get(containerId);\n                String[] ipAndHost \u003d containerExecutor.getIpAndHost(container);\n                if (ipAndHost !\u003d null \u0026\u0026 ipAndHost[0] !\u003d null\n                    \u0026\u0026 ipAndHost[1] !\u003d null) {\n                  container.setIpAndHost(ipAndHost);\n                  LOG.info(containerId + \"\u0027s ip \u003d \" + ipAndHost[0]\n                      + \", and hostname \u003d \" + ipAndHost[1]);\n                } else {\n                  LOG.info(\"Can not get both ip and hostname: \" + Arrays\n                      .toString(ipAndHost));\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null || !isResourceCalculatorAvailable()) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container \" + containerId\n                  + \" since CPU usage is not yet available.\");\n              continue;\n            }\n\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n\n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(String.format(\n                  \"Memory usage of ProcessTree %s for container-id %s: \",\n                  pId, containerId.toString()) +\n                  formatUsageString(\n                      currentVmemUsage, vmemLimit,\n                      currentPmemUsage, pmemLimit));\n            }\n\n            // Add resource utilization for this container\n            trackedContainersUtilization.addTo(\n                (int) (currentPmemUsage \u003e\u003e 20),\n                (int) (currentVmemUsage \u003e\u003e 20),\n                milliVcoresUsed / 1000.0f);\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              trackingContainers.remove(containerId);\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            }\n\n            ContainerImpl container \u003d\n                (ContainerImpl) context.getContainers().get(containerId);\n            NMTimelinePublisher nmMetricsPublisher \u003d\n                container.getNMTimelinePublisher();\n            if (nmMetricsPublisher !\u003d null) {\n              nmMetricsPublisher.reportContainerResourceUsage(container,\n                  currentPmemUsage, cpuUsagePercentPerCore);\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n              + \", Total CPU(% per core) usage\"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "bfb4d950596d6198e473045dac6eb36c685b0319": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5430. Return container\u0027s ip and host from NM ContainerStatus call. Contributed by Jian He.\n",
      "commitDate": "26/08/16 4:00 AM",
      "commitName": "bfb4d950596d6198e473045dac6eb36c685b0319",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "10/07/16 8:46 AM",
      "commitNameOld": "6cf6ab7b780de2b0c2c9ea730e1f366965a0d682",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 46.8,
      "commitsBetweenForRepo": 330,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,212 +1,223 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         long cpuUsageTotalCoresByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.\n                         getResourceCalculatorProcessTree(\n                             pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n \n                 if (containerMetricsEnabled) {\n                   ContainerMetrics usageMetrics \u003d ContainerMetrics\n                       .forContainer(containerId, containerMetricsPeriodMs,\n                       containerMetricsUnregisterDelayMs);\n                   usageMetrics.recordProcessId(pId);\n                 }\n+                Container container \u003d context.getContainers().get(containerId);\n+                String[] ipAndHost \u003d containerExecutor.getIpAndHost(container);\n+                if (ipAndHost !\u003d null \u0026\u0026 ipAndHost[0] !\u003d null\n+                    \u0026\u0026 ipAndHost[1] !\u003d null) {\n+                  container.setIpAndHost(ipAndHost);\n+                  LOG.info(containerId + \"\u0027s ip \u003d \" + ipAndHost[0]\n+                      + \", and hostname \u003d \" + ipAndHost[1]);\n+                } else {\n+                  LOG.info(\"Can not get both ip and hostname: \" + Arrays\n+                      .toString(ipAndHost));\n+                }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n \n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             if (cpuUsagePercentPerCore \u003c 0) {\n               // CPU usage is not available likely because the container just\n               // started. Let us skip this turn and consider this container\n               // in the next iteration.\n               LOG.info(\"Skipping monitoring container \" + containerId\n                   + \" since CPU usage is not yet available.\");\n               continue;\n             }\n \n             float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                 resourceCalculatorPlugin.getNumProcessors();\n \n             // Multiply by 1000 to avoid losing data when converting to int\n             int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(String.format(\n                   \"Memory usage of ProcessTree %s for container-id %s: \",\n                   pId, containerId.toString()) +\n                   formatUsageString(\n                       currentVmemUsage, vmemLimit,\n                       currentPmemUsage, pmemLimit));\n             }\n \n             // Add resource utilization for this container\n             trackedContainersUtilization.addTo(\n                 (int) (currentPmemUsage \u003e\u003e 20),\n                 (int) (currentVmemUsage \u003e\u003e 20),\n                 milliVcoresUsed / 1000.0f);\n \n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs,\n                   containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs,\n                   containerMetricsUnregisterDelayMs).recordCpuUsage\n                   ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n             }\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n             cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               trackingContainers.remove(containerId);\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             }\n \n             ContainerImpl container \u003d\n                 (ContainerImpl) context.getContainers().get(containerId);\n             NMTimelinePublisher nmMetricsPublisher \u003d\n                 container.getNMTimelinePublisher();\n             if (nmMetricsPublisher !\u003d null) {\n               nmMetricsPublisher.reportContainerResourceUsage(container,\n                   currentPmemUsage, cpuUsagePercentPerCore);\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                 + \"while monitoring resource of \" + containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n               + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n               + \", Total CPU(% per core) usage\"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        long cpuUsageTotalCoresByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.\n                        getResourceCalculatorProcessTree(\n                            pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs,\n                      containerMetricsUnregisterDelayMs);\n                  usageMetrics.recordProcessId(pId);\n                }\n                Container container \u003d context.getContainers().get(containerId);\n                String[] ipAndHost \u003d containerExecutor.getIpAndHost(container);\n                if (ipAndHost !\u003d null \u0026\u0026 ipAndHost[0] !\u003d null\n                    \u0026\u0026 ipAndHost[1] !\u003d null) {\n                  container.setIpAndHost(ipAndHost);\n                  LOG.info(containerId + \"\u0027s ip \u003d \" + ipAndHost[0]\n                      + \", and hostname \u003d \" + ipAndHost[1]);\n                } else {\n                  LOG.info(\"Can not get both ip and hostname: \" + Arrays\n                      .toString(ipAndHost));\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container \" + containerId\n                  + \" since CPU usage is not yet available.\");\n              continue;\n            }\n\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n\n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(String.format(\n                  \"Memory usage of ProcessTree %s for container-id %s: \",\n                  pId, containerId.toString()) +\n                  formatUsageString(\n                      currentVmemUsage, vmemLimit,\n                      currentPmemUsage, pmemLimit));\n            }\n\n            // Add resource utilization for this container\n            trackedContainersUtilization.addTo(\n                (int) (currentPmemUsage \u003e\u003e 20),\n                (int) (currentVmemUsage \u003e\u003e 20),\n                milliVcoresUsed / 1000.0f);\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              trackingContainers.remove(containerId);\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            }\n\n            ContainerImpl container \u003d\n                (ContainerImpl) context.getContainers().get(containerId);\n            NMTimelinePublisher nmMetricsPublisher \u003d\n                container.getNMTimelinePublisher();\n            if (nmMetricsPublisher !\u003d null) {\n              nmMetricsPublisher.reportContainerResourceUsage(container,\n                  currentPmemUsage, cpuUsagePercentPerCore);\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n              + \", Total CPU(% per core) usage\"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "6f6cc647d6e77f6cc4c66e0534f8c73bc1612a1b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4712. CPU Usage Metric is not captured properly in YARN-2928. (Naganarasimha G R via Varun Saxena)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "6f6cc647d6e77f6cc4c66e0534f8c73bc1612a1b",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "6934b05c7117a12286fb2ba7a47f75e227cacb22",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,212 +1,212 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         long cpuUsageTotalCoresByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           \n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(\n                         pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n \n                 if (containerMetricsEnabled) {\n                   ContainerMetrics usageMetrics \u003d ContainerMetrics\n                       .forContainer(containerId, containerMetricsPeriodMs,\n                       containerMetricsUnregisterDelayMs);\n                   usageMetrics.recordProcessId(pId);\n                 }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n \n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             if (cpuUsagePercentPerCore \u003c 0) {\n               // CPU usage is not available likely because the container just\n               // started. Let us skip this turn and consider this container\n               // in the next iteration.\n               LOG.info(\"Skipping monitoring container \" + containerId\n                   + \" since CPU usage is not yet available.\");\n               continue;\n             }\n \n             float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                 resourceCalculatorPlugin.getNumProcessors();\n             \n             // Multiply by 1000 to avoid losing data when converting to int\n             int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(String.format(\n                   \"Memory usage of ProcessTree %s for container-id %s: \",\n                   pId, containerId.toString()) +\n                   formatUsageString(\n                       currentVmemUsage, vmemLimit,\n                       currentPmemUsage, pmemLimit));\n             }\n \n             // Add resource utilization for this container\n             trackedContainersUtilization.addTo(\n                 (int) (currentPmemUsage \u003e\u003e 20),\n                 (int) (currentVmemUsage \u003e\u003e 20),\n                 milliVcoresUsed / 1000.0f);\n \n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs,\n                   containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs,\n                   containerMetricsUnregisterDelayMs).recordCpuUsage\n                   ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n             }\n             \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n             cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               trackingContainers.remove(containerId);\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             }\n \n             ContainerImpl container \u003d\n                 (ContainerImpl) context.getContainers().get(containerId);\n             NMTimelinePublisher nmMetricsPublisher \u003d\n                 container.getNMTimelinePublisher();\n             if (nmMetricsPublisher !\u003d null) {\n-              nmMetricsPublisher.reportContainerResourceUsage(container, pId,\n-                  currentPmemUsage, cpuUsageTotalCoresPercentage);\n+              nmMetricsPublisher.reportContainerResourceUsage(container,\n+                  currentPmemUsage, cpuUsagePercentPerCore);\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                 + \"while monitoring resource of \" + containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n               + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n               + \", Total CPU(% per core) usage\"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        long cpuUsageTotalCoresByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          \n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(\n                        pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs,\n                      containerMetricsUnregisterDelayMs);\n                  usageMetrics.recordProcessId(pId);\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container \" + containerId\n                  + \" since CPU usage is not yet available.\");\n              continue;\n            }\n\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n            \n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(String.format(\n                  \"Memory usage of ProcessTree %s for container-id %s: \",\n                  pId, containerId.toString()) +\n                  formatUsageString(\n                      currentVmemUsage, vmemLimit,\n                      currentPmemUsage, pmemLimit));\n            }\n\n            // Add resource utilization for this container\n            trackedContainersUtilization.addTo(\n                (int) (currentPmemUsage \u003e\u003e 20),\n                (int) (currentVmemUsage \u003e\u003e 20),\n                milliVcoresUsed / 1000.0f);\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n            \n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              trackingContainers.remove(containerId);\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            }\n\n            ContainerImpl container \u003d\n                (ContainerImpl) context.getContainers().get(containerId);\n            NMTimelinePublisher nmMetricsPublisher \u003d\n                container.getNMTimelinePublisher();\n            if (nmMetricsPublisher !\u003d null) {\n              nmMetricsPublisher.reportContainerResourceUsage(container,\n                  currentPmemUsage, cpuUsagePercentPerCore);\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n              + \", Total CPU(% per core) usage\"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "6934b05c7117a12286fb2ba7a47f75e227cacb22": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4238. createdTime and modifiedTime is not reported while publishing entities to ATSv2. (Varun Saxena via Naganarasimha G R)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "6934b05c7117a12286fb2ba7a47f75e227cacb22",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,214 +1,212 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         long cpuUsageTotalCoresByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           \n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(\n                         pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n \n                 if (containerMetricsEnabled) {\n                   ContainerMetrics usageMetrics \u003d ContainerMetrics\n                       .forContainer(containerId, containerMetricsPeriodMs,\n                       containerMetricsUnregisterDelayMs);\n                   usageMetrics.recordProcessId(pId);\n                 }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n-            long currentTime \u003d System.currentTimeMillis();\n \n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             if (cpuUsagePercentPerCore \u003c 0) {\n               // CPU usage is not available likely because the container just\n               // started. Let us skip this turn and consider this container\n               // in the next iteration.\n               LOG.info(\"Skipping monitoring container \" + containerId\n                   + \" since CPU usage is not yet available.\");\n               continue;\n             }\n \n             float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                 resourceCalculatorPlugin.getNumProcessors();\n             \n             // Multiply by 1000 to avoid losing data when converting to int\n             int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(String.format(\n                   \"Memory usage of ProcessTree %s for container-id %s: \",\n                   pId, containerId.toString()) +\n                   formatUsageString(\n                       currentVmemUsage, vmemLimit,\n                       currentPmemUsage, pmemLimit));\n             }\n \n             // Add resource utilization for this container\n             trackedContainersUtilization.addTo(\n                 (int) (currentPmemUsage \u003e\u003e 20),\n                 (int) (currentVmemUsage \u003e\u003e 20),\n                 milliVcoresUsed / 1000.0f);\n \n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs,\n                   containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs,\n                   containerMetricsUnregisterDelayMs).recordCpuUsage\n                   ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n             }\n             \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n             cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               trackingContainers.remove(containerId);\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             }\n \n             ContainerImpl container \u003d\n                 (ContainerImpl) context.getContainers().get(containerId);\n             NMTimelinePublisher nmMetricsPublisher \u003d\n                 container.getNMTimelinePublisher();\n             if (nmMetricsPublisher !\u003d null) {\n-              nmMetricsPublisher.reportContainerResourceUsage(\n-                  container, currentTime, pId, currentPmemUsage,\n-                  cpuUsageTotalCoresPercentage);\n+              nmMetricsPublisher.reportContainerResourceUsage(container, pId,\n+                  currentPmemUsage, cpuUsageTotalCoresPercentage);\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                 + \"while monitoring resource of \" + containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n               + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n               + \", Total CPU(% per core) usage\"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        long cpuUsageTotalCoresByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          \n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(\n                        pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs,\n                      containerMetricsUnregisterDelayMs);\n                  usageMetrics.recordProcessId(pId);\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container \" + containerId\n                  + \" since CPU usage is not yet available.\");\n              continue;\n            }\n\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n            \n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(String.format(\n                  \"Memory usage of ProcessTree %s for container-id %s: \",\n                  pId, containerId.toString()) +\n                  formatUsageString(\n                      currentVmemUsage, vmemLimit,\n                      currentPmemUsage, pmemLimit));\n            }\n\n            // Add resource utilization for this container\n            trackedContainersUtilization.addTo(\n                (int) (currentPmemUsage \u003e\u003e 20),\n                (int) (currentVmemUsage \u003e\u003e 20),\n                milliVcoresUsed / 1000.0f);\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n            \n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              trackingContainers.remove(containerId);\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            }\n\n            ContainerImpl container \u003d\n                (ContainerImpl) context.getContainers().get(containerId);\n            NMTimelinePublisher nmMetricsPublisher \u003d\n                container.getNMTimelinePublisher();\n            if (nmMetricsPublisher !\u003d null) {\n              nmMetricsPublisher.reportContainerResourceUsage(container, pId,\n                  currentPmemUsage, cpuUsageTotalCoresPercentage);\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n              + \", Total CPU(% per core) usage\"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "477a30f536277bf95d7181bf1b2fdda52d83bf51",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,210 +1,214 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         long cpuUsageTotalCoresByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           \n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(\n                         pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n \n                 if (containerMetricsEnabled) {\n                   ContainerMetrics usageMetrics \u003d ContainerMetrics\n                       .forContainer(containerId, containerMetricsPeriodMs,\n                       containerMetricsUnregisterDelayMs);\n                   usageMetrics.recordProcessId(pId);\n                 }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n             long currentTime \u003d System.currentTimeMillis();\n \n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             if (cpuUsagePercentPerCore \u003c 0) {\n               // CPU usage is not available likely because the container just\n               // started. Let us skip this turn and consider this container\n               // in the next iteration.\n               LOG.info(\"Skipping monitoring container \" + containerId\n                   + \" since CPU usage is not yet available.\");\n               continue;\n             }\n \n             float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                 resourceCalculatorPlugin.getNumProcessors();\n             \n             // Multiply by 1000 to avoid losing data when converting to int\n             int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(String.format(\n                   \"Memory usage of ProcessTree %s for container-id %s: \",\n                   pId, containerId.toString()) +\n                   formatUsageString(\n                       currentVmemUsage, vmemLimit,\n                       currentPmemUsage, pmemLimit));\n             }\n \n             // Add resource utilization for this container\n             trackedContainersUtilization.addTo(\n                 (int) (currentPmemUsage \u003e\u003e 20),\n                 (int) (currentVmemUsage \u003e\u003e 20),\n                 milliVcoresUsed / 1000.0f);\n \n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs,\n                   containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs,\n                   containerMetricsUnregisterDelayMs).recordCpuUsage\n                   ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n             }\n             \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n             cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               trackingContainers.remove(containerId);\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             }\n \n             ContainerImpl container \u003d\n                 (ContainerImpl) context.getContainers().get(containerId);\n-            container.getNMTimelinePublisher().reportContainerResourceUsage(\n-                container, currentTime, pId, currentPmemUsage,\n-                cpuUsageTotalCoresPercentage);\n+            NMTimelinePublisher nmMetricsPublisher \u003d\n+                container.getNMTimelinePublisher();\n+            if (nmMetricsPublisher !\u003d null) {\n+              nmMetricsPublisher.reportContainerResourceUsage(\n+                  container, currentTime, pId, currentPmemUsage,\n+                  cpuUsageTotalCoresPercentage);\n+            }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                 + \"while monitoring resource of \" + containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n               + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n               + \", Total CPU(% per core) usage\"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        long cpuUsageTotalCoresByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          \n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(\n                        pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs,\n                      containerMetricsUnregisterDelayMs);\n                  usageMetrics.recordProcessId(pId);\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n            long currentTime \u003d System.currentTimeMillis();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container \" + containerId\n                  + \" since CPU usage is not yet available.\");\n              continue;\n            }\n\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n            \n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(String.format(\n                  \"Memory usage of ProcessTree %s for container-id %s: \",\n                  pId, containerId.toString()) +\n                  formatUsageString(\n                      currentVmemUsage, vmemLimit,\n                      currentPmemUsage, pmemLimit));\n            }\n\n            // Add resource utilization for this container\n            trackedContainersUtilization.addTo(\n                (int) (currentPmemUsage \u003e\u003e 20),\n                (int) (currentVmemUsage \u003e\u003e 20),\n                milliVcoresUsed / 1000.0f);\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n            \n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              trackingContainers.remove(containerId);\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            }\n\n            ContainerImpl container \u003d\n                (ContainerImpl) context.getContainers().get(containerId);\n            NMTimelinePublisher nmMetricsPublisher \u003d\n                container.getNMTimelinePublisher();\n            if (nmMetricsPublisher !\u003d null) {\n              nmMetricsPublisher.reportContainerResourceUsage(\n                  container, currentTime, pId, currentPmemUsage,\n                  cpuUsageTotalCoresPercentage);\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n              + \", Total CPU(% per core) usage\"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "477a30f536277bf95d7181bf1b2fdda52d83bf51": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3045. Implement NM writing container lifecycle events to Timeline Service v2. Contributed by Naganarasimha G R.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "477a30f536277bf95d7181bf1b2fdda52d83bf51",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "22e7ae57715cedb1dcba736e357e8daaf5133e5c",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,7 +1,210 @@\n-        public void run() {\n-          try {\n-            timelineClient.putEntities(entity);\n-          } catch (IOException|YarnException e) {\n-            LOG.error(\"putEntityNonBlocking get failed: \" + e);\n+    public void run() {\n+\n+      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n+        // Print the processTrees for debugging.\n+        if (LOG.isDebugEnabled()) {\n+          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n+          for (ProcessTreeInfo p : trackingContainers.values()) {\n+            tmp.append(p.getPID());\n+            tmp.append(\" \");\n           }\n-        }\n\\ No newline at end of file\n+          LOG.debug(\"Current ProcessTree list : \"\n+              + tmp.substring(0, tmp.length()) + \"]\");\n+        }\n+\n+        // Temporary structure to calculate the total resource utilization of\n+        // the containers\n+        ResourceUtilization trackedContainersUtilization  \u003d\n+            ResourceUtilization.newInstance(0, 0, 0.0f);\n+\n+        // Now do the monitoring for the trackingContainers\n+        // Check memory usage and kill any overflowing containers\n+        long vmemUsageByAllContainers \u003d 0;\n+        long pmemByAllContainers \u003d 0;\n+        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n+        long cpuUsageTotalCoresByAllContainers \u003d 0;\n+        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n+            .entrySet()) {\n+          ContainerId containerId \u003d entry.getKey();\n+          ProcessTreeInfo ptInfo \u003d entry.getValue();\n+          \n+          try {\n+            String pId \u003d ptInfo.getPID();\n+\n+            // Initialize any uninitialized processTrees\n+            if (pId \u003d\u003d null) {\n+              // get pid from ContainerId\n+              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n+              if (pId !\u003d null) {\n+                // pId will be null, either if the container is not spawned yet\n+                // or if the container\u0027s pid is removed from ContainerExecutor\n+                LOG.debug(\"Tracking ProcessTree \" + pId\n+                    + \" for the first time\");\n+\n+                ResourceCalculatorProcessTree pt \u003d\n+                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(\n+                        pId, processTreeClass, conf);\n+                ptInfo.setPid(pId);\n+                ptInfo.setProcessTree(pt);\n+\n+                if (containerMetricsEnabled) {\n+                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n+                      .forContainer(containerId, containerMetricsPeriodMs,\n+                      containerMetricsUnregisterDelayMs);\n+                  usageMetrics.recordProcessId(pId);\n+                }\n+              }\n+            }\n+            // End of initializing any uninitialized processTrees\n+\n+            if (pId \u003d\u003d null) {\n+              continue; // processTree cannot be tracked\n+            }\n+\n+            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n+                + \" ContainerId \u003d \" + containerId);\n+            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n+            pTree.updateProcessTree();    // update process-tree\n+            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n+            long currentPmemUsage \u003d pTree.getRssMemorySize();\n+            long currentTime \u003d System.currentTimeMillis();\n+\n+            // if machine has 6 cores and 3 are used,\n+            // cpuUsagePercentPerCore should be 300% and\n+            // cpuUsageTotalCoresPercentage should be 50%\n+            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n+            if (cpuUsagePercentPerCore \u003c 0) {\n+              // CPU usage is not available likely because the container just\n+              // started. Let us skip this turn and consider this container\n+              // in the next iteration.\n+              LOG.info(\"Skipping monitoring container \" + containerId\n+                  + \" since CPU usage is not yet available.\");\n+              continue;\n+            }\n+\n+            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n+                resourceCalculatorPlugin.getNumProcessors();\n+            \n+            // Multiply by 1000 to avoid losing data when converting to int\n+            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n+                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n+            // as processes begin with an age 1, we want to see if there\n+            // are processes more than 1 iteration old.\n+            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n+            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n+            long vmemLimit \u003d ptInfo.getVmemLimit();\n+            long pmemLimit \u003d ptInfo.getPmemLimit();\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(String.format(\n+                  \"Memory usage of ProcessTree %s for container-id %s: \",\n+                  pId, containerId.toString()) +\n+                  formatUsageString(\n+                      currentVmemUsage, vmemLimit,\n+                      currentPmemUsage, pmemLimit));\n+            }\n+\n+            // Add resource utilization for this container\n+            trackedContainersUtilization.addTo(\n+                (int) (currentPmemUsage \u003e\u003e 20),\n+                (int) (currentVmemUsage \u003e\u003e 20),\n+                milliVcoresUsed / 1000.0f);\n+\n+            // Add usage to container metrics\n+            if (containerMetricsEnabled) {\n+              ContainerMetrics.forContainer(\n+                  containerId, containerMetricsPeriodMs,\n+                  containerMetricsUnregisterDelayMs).recordMemoryUsage(\n+                  (int) (currentPmemUsage \u003e\u003e 20));\n+              ContainerMetrics.forContainer(\n+                  containerId, containerMetricsPeriodMs,\n+                  containerMetricsUnregisterDelayMs).recordCpuUsage\n+                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n+            }\n+            \n+            boolean isMemoryOverLimit \u003d false;\n+            String msg \u003d \"\";\n+            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n+            if (isVmemCheckEnabled()\n+                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n+                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n+              // Container (the root process) is still alive and overflowing\n+              // memory.\n+              // Dump the process-tree and then clean it up.\n+              msg \u003d formatErrorMessage(\"virtual\",\n+                  currentVmemUsage, vmemLimit,\n+                  currentPmemUsage, pmemLimit,\n+                  pId, containerId, pTree);\n+              isMemoryOverLimit \u003d true;\n+              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n+            } else if (isPmemCheckEnabled()\n+                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n+                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n+                    pmemLimit)) {\n+              // Container (the root process) is still alive and overflowing\n+              // memory.\n+              // Dump the process-tree and then clean it up.\n+              msg \u003d formatErrorMessage(\"physical\",\n+                  currentVmemUsage, vmemLimit,\n+                  currentPmemUsage, pmemLimit,\n+                  pId, containerId, pTree);\n+              isMemoryOverLimit \u003d true;\n+              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n+            }\n+\n+            // Accounting the total memory in usage for all containers\n+            vmemUsageByAllContainers +\u003d currentVmemUsage;\n+            pmemByAllContainers +\u003d currentPmemUsage;\n+            // Accounting the total cpu usage for all containers\n+            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n+            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n+\n+            if (isMemoryOverLimit) {\n+              // Virtual or physical memory over limit. Fail the container and\n+              // remove\n+              // the corresponding process tree\n+              LOG.warn(msg);\n+              // warn if not a leader\n+              if (!pTree.checkPidPgrpidForMatch()) {\n+                LOG.error(\"Killed container process with PID \" + pId\n+                    + \" but it is not a process group leader.\");\n+              }\n+              // kill the container\n+              eventDispatcher.getEventHandler().handle(\n+                  new ContainerKillEvent(containerId,\n+                      containerExitStatus, msg));\n+              trackingContainers.remove(containerId);\n+              LOG.info(\"Removed ProcessTree with root \" + pId);\n+            }\n+\n+            ContainerImpl container \u003d\n+                (ContainerImpl) context.getContainers().get(containerId);\n+            container.getNMTimelinePublisher().reportContainerResourceUsage(\n+                container, currentTime, pId, currentPmemUsage,\n+                cpuUsageTotalCoresPercentage);\n+          } catch (Exception e) {\n+            // Log the exception and proceed to the next container.\n+            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n+                + \"while monitoring resource of \" + containerId, e);\n+          }\n+        }\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n+              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n+              + \", Physical Memory\u003d \" + pmemByAllContainers\n+              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n+              + \", Total CPU(% per core) usage\"\n+              + cpuUsagePercentPerCoreByAllContainers);\n+        }\n+\n+        // Save the aggregated utilization of the containers\n+        setContainersUtilization(trackedContainersUtilization);\n+\n+        try {\n+          Thread.sleep(monitoringInterval);\n+        } catch (InterruptedException e) {\n+          LOG.warn(ContainersMonitorImpl.class.getName()\n+              + \" is interrupted. Exiting.\");\n+          break;\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        long cpuUsageTotalCoresByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          \n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(\n                        pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs,\n                      containerMetricsUnregisterDelayMs);\n                  usageMetrics.recordProcessId(pId);\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n            long currentTime \u003d System.currentTimeMillis();\n\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container \" + containerId\n                  + \" since CPU usage is not yet available.\");\n              continue;\n            }\n\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n            \n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(String.format(\n                  \"Memory usage of ProcessTree %s for container-id %s: \",\n                  pId, containerId.toString()) +\n                  formatUsageString(\n                      currentVmemUsage, vmemLimit,\n                      currentPmemUsage, pmemLimit));\n            }\n\n            // Add resource utilization for this container\n            trackedContainersUtilization.addTo(\n                (int) (currentPmemUsage \u003e\u003e 20),\n                (int) (currentVmemUsage \u003e\u003e 20),\n                milliVcoresUsed / 1000.0f);\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n            \n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              trackingContainers.remove(containerId);\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            }\n\n            ContainerImpl container \u003d\n                (ContainerImpl) context.getContainers().get(containerId);\n            container.getNMTimelinePublisher().reportContainerResourceUsage(\n                container, currentTime, pId, currentPmemUsage,\n                cpuUsageTotalCoresPercentage);\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainersMonitorImpl \"\n                + \"while monitoring resource of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n              + \", Total CPU(% per core) usage\"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "22e7ae57715cedb1dcba736e357e8daaf5133e5c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3792. Test case failures in TestDistributedShell and some issue fixes related to ATSV2 (Naganarasimha G R via sjlee)\n\n(cherry picked from commit 84f37f1c7eefec6d139cbf091c50d6c06f734323)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "22e7ae57715cedb1dcba736e357e8daaf5133e5c",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "fc8485d8934edf02bdef746d022d1125680e6efe",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,8 +1,7 @@\n         public void run() {\n           try {\n             timelineClient.putEntities(entity);\n           } catch (IOException|YarnException e) {\n             LOG.error(\"putEntityNonBlocking get failed: \" + e);\n-            throw new RuntimeException(e.toString());\n           }\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void run() {\n          try {\n            timelineClient.putEntities(entity);\n          } catch (IOException|YarnException e) {\n            LOG.error(\"putEntityNonBlocking get failed: \" + e);\n          }\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "5712b8f9fd1859fe046b482889239bd164ed7dab": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3334. NM uses timeline client to publish container metrics to new timeline service. Contributed by Junping Du.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "5712b8f9fd1859fe046b482889239bd164ed7dab",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "08/06/16 5:11 PM",
      "commitNameOld": "1500a0a3009e453c9f05a93df7a78b4e185eef30",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 31.65,
      "commitsBetweenForRepo": 217,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,200 +1,8 @@\n-    public void run() {\n-\n-      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n-        // Print the processTrees for debugging.\n-        if (LOG.isDebugEnabled()) {\n-          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n-          for (ProcessTreeInfo p : trackingContainers.values()) {\n-            tmp.append(p.getPID());\n-            tmp.append(\" \");\n-          }\n-          LOG.debug(\"Current ProcessTree list : \"\n-              + tmp.substring(0, tmp.length()) + \"]\");\n-        }\n-\n-        // Temporary structure to calculate the total resource utilization of\n-        // the containers\n-        ResourceUtilization trackedContainersUtilization  \u003d\n-            ResourceUtilization.newInstance(0, 0, 0.0f);\n-\n-        // Now do the monitoring for the trackingContainers\n-        // Check memory usage and kill any overflowing containers\n-        long vmemUsageByAllContainers \u003d 0;\n-        long pmemByAllContainers \u003d 0;\n-        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n-        long cpuUsageTotalCoresByAllContainers \u003d 0;\n-        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n-            .entrySet()) {\n-          ContainerId containerId \u003d entry.getKey();\n-          ProcessTreeInfo ptInfo \u003d entry.getValue();\n+        public void run() {\n           try {\n-            String pId \u003d ptInfo.getPID();\n-\n-            // Initialize any uninitialized processTrees\n-            if (pId \u003d\u003d null) {\n-              // get pid from ContainerId\n-              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n-              if (pId !\u003d null) {\n-                // pId will be null, either if the container is not spawned yet\n-                // or if the container\u0027s pid is removed from ContainerExecutor\n-                LOG.debug(\"Tracking ProcessTree \" + pId\n-                    + \" for the first time\");\n-\n-                ResourceCalculatorProcessTree pt \u003d\n-                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n-                ptInfo.setPid(pId);\n-                ptInfo.setProcessTree(pt);\n-\n-                if (containerMetricsEnabled) {\n-                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n-                      .forContainer(containerId, containerMetricsPeriodMs,\n-                      containerMetricsUnregisterDelayMs);\n-                  usageMetrics.recordProcessId(pId);\n-                }\n-              }\n-            }\n-            // End of initializing any uninitialized processTrees\n-\n-            if (pId \u003d\u003d null) {\n-              continue; // processTree cannot be tracked\n-            }\n-\n-            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n-                + \" ContainerId \u003d \" + containerId);\n-            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n-            pTree.updateProcessTree();    // update process-tree\n-            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n-            long currentPmemUsage \u003d pTree.getRssMemorySize();\n-            // if machine has 6 cores and 3 are used,\n-            // cpuUsagePercentPerCore should be 300% and\n-            // cpuUsageTotalCoresPercentage should be 50%\n-            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n-            if (cpuUsagePercentPerCore \u003c 0) {\n-              // CPU usage is not available likely because the container just\n-              // started. Let us skip this turn and consider this container\n-              // in the next iteration.\n-              LOG.info(\"Skipping monitoring container \" + containerId\n-                  + \" since CPU usage is not yet available.\");\n-              continue;\n-            }\n-\n-            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n-                resourceCalculatorPlugin.getNumProcessors();\n-\n-            // Multiply by 1000 to avoid losing data when converting to int\n-            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n-                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n-            // as processes begin with an age 1, we want to see if there\n-            // are processes more than 1 iteration old.\n-            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n-            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n-            long vmemLimit \u003d ptInfo.getVmemLimit();\n-            long pmemLimit \u003d ptInfo.getPmemLimit();\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(String.format(\n-                  \"Memory usage of ProcessTree %s for container-id %s: \",\n-                  pId, containerId.toString()) +\n-                  formatUsageString(\n-                      currentVmemUsage, vmemLimit,\n-                      currentPmemUsage, pmemLimit));\n-            }\n-\n-            // Add resource utilization for this container\n-            trackedContainersUtilization.addTo(\n-                (int) (currentPmemUsage \u003e\u003e 20),\n-                (int) (currentVmemUsage \u003e\u003e 20),\n-                milliVcoresUsed / 1000.0f);\n-\n-            // Add usage to container metrics\n-            if (containerMetricsEnabled) {\n-              ContainerMetrics.forContainer(\n-                  containerId, containerMetricsPeriodMs,\n-                  containerMetricsUnregisterDelayMs).recordMemoryUsage(\n-                  (int) (currentPmemUsage \u003e\u003e 20));\n-              ContainerMetrics.forContainer(\n-                  containerId, containerMetricsPeriodMs,\n-                  containerMetricsUnregisterDelayMs).recordCpuUsage\n-                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n-            }\n-\n-            boolean isMemoryOverLimit \u003d false;\n-            String msg \u003d \"\";\n-            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n-            if (isVmemCheckEnabled()\n-                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n-                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n-              // Container (the root process) is still alive and overflowing\n-              // memory.\n-              // Dump the process-tree and then clean it up.\n-              msg \u003d formatErrorMessage(\"virtual\",\n-                  currentVmemUsage, vmemLimit,\n-                  currentPmemUsage, pmemLimit,\n-                  pId, containerId, pTree);\n-              isMemoryOverLimit \u003d true;\n-              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n-            } else if (isPmemCheckEnabled()\n-                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n-                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n-                    pmemLimit)) {\n-              // Container (the root process) is still alive and overflowing\n-              // memory.\n-              // Dump the process-tree and then clean it up.\n-              msg \u003d formatErrorMessage(\"physical\",\n-                  currentVmemUsage, vmemLimit,\n-                  currentPmemUsage, pmemLimit,\n-                  pId, containerId, pTree);\n-              isMemoryOverLimit \u003d true;\n-              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n-            }\n-\n-            // Accounting the total memory in usage for all containers\n-            vmemUsageByAllContainers +\u003d currentVmemUsage;\n-            pmemByAllContainers +\u003d currentPmemUsage;\n-            // Accounting the total cpu usage for all containers\n-            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n-            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n-\n-            if (isMemoryOverLimit) {\n-              // Virtual or physical memory over limit. Fail the container and\n-              // remove\n-              // the corresponding process tree\n-              LOG.warn(msg);\n-              // warn if not a leader\n-              if (!pTree.checkPidPgrpidForMatch()) {\n-                LOG.error(\"Killed container process with PID \" + pId\n-                    + \" but it is not a process group leader.\");\n-              }\n-              // kill the container\n-              eventDispatcher.getEventHandler().handle(\n-                  new ContainerKillEvent(containerId,\n-                      containerExitStatus, msg));\n-              trackingContainers.remove(containerId);\n-              LOG.info(\"Removed ProcessTree with root \" + pId);\n-            }\n-          } catch (Exception e) {\n-            // Log the exception and proceed to the next container.\n-            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n-                + \"while managing memory of \" + containerId, e);\n+            timelineClient.putEntities(entity);\n+          } catch (IOException|YarnException e) {\n+            LOG.error(\"putEntityNonBlocking get failed: \" + e);\n+            throw new RuntimeException(e.toString());\n           }\n-        }\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n-              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n-              + \", Physical Memory\u003d \" + pmemByAllContainers\n-              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n-              + \", Total CPU(% per core) usage\"\n-              + cpuUsagePercentPerCoreByAllContainers);\n-        }\n-\n-        // Save the aggregated utilization of the containers\n-        setContainersUtilization(trackedContainersUtilization);\n-\n-        try {\n-          Thread.sleep(monitoringInterval);\n-        } catch (InterruptedException e) {\n-          LOG.warn(ContainersMonitorImpl.class.getName()\n-              + \" is interrupted. Exiting.\");\n-          break;\n-        }\n-      }\n-    }\n\\ No newline at end of file\n+        }\n\\ No newline at end of file\n",
      "actualSource": "        public void run() {\n          try {\n            timelineClient.putEntities(entity);\n          } catch (IOException|YarnException e) {\n            LOG.error(\"putEntityNonBlocking get failed: \" + e);\n            throw new RuntimeException(e.toString());\n          }\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "1500a0a3009e453c9f05a93df7a78b4e185eef30": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4308. ContainersAggregated CPU resource utilization reports negative usage in first few heartbeats. Contributed by Sunil G\n",
      "commitDate": "08/06/16 5:11 PM",
      "commitName": "1500a0a3009e453c9f05a93df7a78b4e185eef30",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "03/06/16 11:10 AM",
      "commitNameOld": "99cc439e29794f8e61bebe03b2a7ca4b6743ec92",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 5.25,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,191 +1,200 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         long cpuUsageTotalCoresByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n \n                 if (containerMetricsEnabled) {\n                   ContainerMetrics usageMetrics \u003d ContainerMetrics\n                       .forContainer(containerId, containerMetricsPeriodMs,\n                       containerMetricsUnregisterDelayMs);\n                   usageMetrics.recordProcessId(pId);\n                 }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n+            if (cpuUsagePercentPerCore \u003c 0) {\n+              // CPU usage is not available likely because the container just\n+              // started. Let us skip this turn and consider this container\n+              // in the next iteration.\n+              LOG.info(\"Skipping monitoring container \" + containerId\n+                  + \" since CPU usage is not yet available.\");\n+              continue;\n+            }\n+\n             float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                 resourceCalculatorPlugin.getNumProcessors();\n \n             // Multiply by 1000 to avoid losing data when converting to int\n             int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(String.format(\n                   \"Memory usage of ProcessTree %s for container-id %s: \",\n                   pId, containerId.toString()) +\n                   formatUsageString(\n                       currentVmemUsage, vmemLimit,\n                       currentPmemUsage, pmemLimit));\n             }\n \n             // Add resource utilization for this container\n             trackedContainersUtilization.addTo(\n                 (int) (currentPmemUsage \u003e\u003e 20),\n                 (int) (currentVmemUsage \u003e\u003e 20),\n                 milliVcoresUsed / 1000.0f);\n \n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs,\n                   containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs,\n                   containerMetricsUnregisterDelayMs).recordCpuUsage\n                   ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n             }\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n             cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               trackingContainers.remove(containerId);\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n               + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n               + \", Total CPU(% per core) usage\"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        long cpuUsageTotalCoresByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs,\n                      containerMetricsUnregisterDelayMs);\n                  usageMetrics.recordProcessId(pId);\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            if (cpuUsagePercentPerCore \u003c 0) {\n              // CPU usage is not available likely because the container just\n              // started. Let us skip this turn and consider this container\n              // in the next iteration.\n              LOG.info(\"Skipping monitoring container \" + containerId\n                  + \" since CPU usage is not yet available.\");\n              continue;\n            }\n\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n\n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(String.format(\n                  \"Memory usage of ProcessTree %s for container-id %s: \",\n                  pId, containerId.toString()) +\n                  formatUsageString(\n                      currentVmemUsage, vmemLimit,\n                      currentPmemUsage, pmemLimit));\n            }\n\n            // Add resource utilization for this container\n            trackedContainersUtilization.addTo(\n                (int) (currentPmemUsage \u003e\u003e 20),\n                (int) (currentVmemUsage \u003e\u003e 20),\n                milliVcoresUsed / 1000.0f);\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              trackingContainers.remove(containerId);\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n              + \", Total CPU(% per core) usage\"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "fdf02d1f26cea372bf69e071f57b8bfc09c092c4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3619. ContainerMetrics unregisters during getMetrics and leads to ConcurrentModificationException. Contributed by Zhihai Xu\n",
      "commitDate": "02/10/15 1:20 PM",
      "commitName": "fdf02d1f26cea372bf69e071f57b8bfc09c092c4",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "23/09/15 1:29 PM",
      "commitNameOld": "c59ae4eeb17e52e8fc659b9962d20628719fc621",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 8.99,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,188 +1,191 @@\n     public void run() {\n \n       while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         long cpuUsageTotalCoresByAllContainers \u003d 0;\n         for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n             .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n \n                 if (containerMetricsEnabled) {\n                   ContainerMetrics usageMetrics \u003d ContainerMetrics\n-                      .forContainer(containerId, containerMetricsPeriodMs);\n+                      .forContainer(containerId, containerMetricsPeriodMs,\n+                      containerMetricsUnregisterDelayMs);\n                   usageMetrics.recordProcessId(pId);\n                 }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                 resourceCalculatorPlugin.getNumProcessors();\n \n             // Multiply by 1000 to avoid losing data when converting to int\n             int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(String.format(\n                   \"Memory usage of ProcessTree %s for container-id %s: \",\n                   pId, containerId.toString()) +\n                   formatUsageString(\n                       currentVmemUsage, vmemLimit,\n                       currentPmemUsage, pmemLimit));\n             }\n \n             // Add resource utilization for this container\n             trackedContainersUtilization.addTo(\n                 (int) (currentPmemUsage \u003e\u003e 20),\n                 (int) (currentVmemUsage \u003e\u003e 20),\n                 milliVcoresUsed / 1000.0f);\n \n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n-                  containerId, containerMetricsPeriodMs).recordMemoryUsage(\n+                  containerId, containerMetricsPeriodMs,\n+                  containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n               ContainerMetrics.forContainer(\n-                  containerId, containerMetricsPeriodMs).recordCpuUsage\n+                  containerId, containerMetricsPeriodMs,\n+                  containerMetricsUnregisterDelayMs).recordCpuUsage\n                   ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n             }\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n             cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               trackingContainers.remove(containerId);\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n               + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n               + \", Total CPU(% per core) usage\"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        long cpuUsageTotalCoresByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs,\n                      containerMetricsUnregisterDelayMs);\n                  usageMetrics.recordProcessId(pId);\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n\n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(String.format(\n                  \"Memory usage of ProcessTree %s for container-id %s: \",\n                  pId, containerId.toString()) +\n                  formatUsageString(\n                      currentVmemUsage, vmemLimit,\n                      currentPmemUsage, pmemLimit));\n            }\n\n            // Add resource utilization for this container\n            trackedContainersUtilization.addTo(\n                (int) (currentPmemUsage \u003e\u003e 20),\n                (int) (currentVmemUsage \u003e\u003e 20),\n                milliVcoresUsed / 1000.0f);\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs,\n                  containerMetricsUnregisterDelayMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              trackingContainers.remove(containerId);\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n              + \", Total CPU(% per core) usage\"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "c59ae4eeb17e52e8fc659b9962d20628719fc621": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1643. Make ContainersMonitor support changing monitoring size of an allocated container. Contributed by Meng Ding and Wangda Tan\n",
      "commitDate": "23/09/15 1:29 PM",
      "commitName": "c59ae4eeb17e52e8fc659b9962d20628719fc621",
      "commitAuthor": "Jian He",
      "commitDateOld": "18/08/15 11:36 AM",
      "commitNameOld": "14215c8ef83d58b8443c52a3cb93e6d44fc87065",
      "commitAuthorOld": "Zhihai Xu",
      "daysBetweenCommits": 36.08,
      "commitsBetweenForRepo": 216,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,221 +1,188 @@\n     public void run() {\n \n-      while (true) {\n-\n+      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n-        // Add new containers\n-        synchronized (containersToBeAdded) {\n-          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n-              .entrySet()) {\n-            ContainerId containerId \u003d entry.getKey();\n-            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n-            LOG.info(\"Starting resource-monitoring for \" + containerId);\n-            trackingContainers.put(containerId, processTreeInfo);\n-          }\n-          containersToBeAdded.clear();\n-        }\n-\n-        // Remove finished containers\n-        synchronized (containersToBeRemoved) {\n-          for (ContainerId containerId : containersToBeRemoved) {\n-            if (containerMetricsEnabled) {\n-              ContainerMetrics.forContainer(\n-                  containerId, containerMetricsPeriodMs).finished();\n-            }\n-            trackingContainers.remove(containerId);\n-            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n-          }\n-          containersToBeRemoved.clear();\n-        }\n-\n         // Temporary structure to calculate the total resource utilization of\n         // the containers\n         ResourceUtilization trackedContainersUtilization  \u003d\n             ResourceUtilization.newInstance(0, 0, 0.0f);\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         long cpuUsageTotalCoresByAllContainers \u003d 0;\n-        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n-            trackingContainers.entrySet().iterator(); it.hasNext();) {\n-\n-          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n+        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n+            .entrySet()) {\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n \n                 if (containerMetricsEnabled) {\n                   ContainerMetrics usageMetrics \u003d ContainerMetrics\n                       .forContainer(containerId, containerMetricsPeriodMs);\n-                  int cpuVcores \u003d ptInfo.getCpuVcores();\n-                  final int vmemLimit \u003d (int) (ptInfo.getVmemLimit() \u003e\u003e 20);\n-                  final int pmemLimit \u003d (int) (ptInfo.getPmemLimit() \u003e\u003e 20);\n-                  usageMetrics.recordResourceLimit(\n-                      vmemLimit, pmemLimit, cpuVcores);\n                   usageMetrics.recordProcessId(pId);\n                 }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                 resourceCalculatorPlugin.getNumProcessors();\n \n             // Multiply by 1000 to avoid losing data when converting to int\n             int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(String.format(\n                   \"Memory usage of ProcessTree %s for container-id %s: \",\n                   pId, containerId.toString()) +\n                   formatUsageString(\n                       currentVmemUsage, vmemLimit,\n                       currentPmemUsage, pmemLimit));\n             }\n \n             // Add resource utilization for this container\n             trackedContainersUtilization.addTo(\n                 (int) (currentPmemUsage \u003e\u003e 20),\n                 (int) (currentVmemUsage \u003e\u003e 20),\n                 milliVcoresUsed / 1000.0f);\n \n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).recordCpuUsage\n                   ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n             }\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n             cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n-              it.remove();\n+              trackingContainers.remove(containerId);\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n               + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n               + \", Total CPU(% per core) usage\"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n         // Save the aggregated utilization of the containers\n         setContainersUtilization(trackedContainersUtilization);\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (!stopped \u0026\u0026 !Thread.currentThread().isInterrupted()) {\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        long cpuUsageTotalCoresByAllContainers \u003d 0;\n        for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : trackingContainers\n            .entrySet()) {\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs);\n                  usageMetrics.recordProcessId(pId);\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n\n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(String.format(\n                  \"Memory usage of ProcessTree %s for container-id %s: \",\n                  pId, containerId.toString()) +\n                  formatUsageString(\n                      currentVmemUsage, vmemLimit,\n                      currentPmemUsage, pmemLimit));\n            }\n\n            // Add resource utilization for this container\n            trackedContainersUtilization.addTo(\n                (int) (currentPmemUsage \u003e\u003e 20),\n                (int) (currentVmemUsage \u003e\u003e 20),\n                milliVcoresUsed / 1000.0f);\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              trackingContainers.remove(containerId);\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n              + \", Total CPU(% per core) usage\"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "527c40e4d664c721b8f32d7cd8df21b2666fea8a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1012. Report NM aggregated container resource utilization in heartbeat. (Inigo Goiri via kasha)\n",
      "commitDate": "09/07/15 9:35 AM",
      "commitName": "527c40e4d664c721b8f32d7cd8df21b2666fea8a",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "26/05/15 11:38 AM",
      "commitNameOld": "500a1d9c76ec612b4e737888f4be79951c11591d",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 43.91,
      "commitsBetweenForRepo": 312,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,207 +1,221 @@\n     public void run() {\n \n       while (true) {\n \n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Add new containers\n         synchronized (containersToBeAdded) {\n           for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n               .entrySet()) {\n             ContainerId containerId \u003d entry.getKey();\n             ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n             LOG.info(\"Starting resource-monitoring for \" + containerId);\n             trackingContainers.put(containerId, processTreeInfo);\n           }\n           containersToBeAdded.clear();\n         }\n \n         // Remove finished containers\n         synchronized (containersToBeRemoved) {\n           for (ContainerId containerId : containersToBeRemoved) {\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).finished();\n             }\n             trackingContainers.remove(containerId);\n             LOG.info(\"Stopping resource-monitoring for \" + containerId);\n           }\n           containersToBeRemoved.clear();\n         }\n \n+        // Temporary structure to calculate the total resource utilization of\n+        // the containers\n+        ResourceUtilization trackedContainersUtilization  \u003d\n+            ResourceUtilization.newInstance(0, 0, 0.0f);\n+\n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemUsageByAllContainers \u003d 0;\n         long pmemByAllContainers \u003d 0;\n         long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n         long cpuUsageTotalCoresByAllContainers \u003d 0;\n         for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n             trackingContainers.entrySet().iterator(); it.hasNext();) {\n \n           Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n \n                 if (containerMetricsEnabled) {\n                   ContainerMetrics usageMetrics \u003d ContainerMetrics\n                       .forContainer(containerId, containerMetricsPeriodMs);\n                   int cpuVcores \u003d ptInfo.getCpuVcores();\n                   final int vmemLimit \u003d (int) (ptInfo.getVmemLimit() \u003e\u003e 20);\n                   final int pmemLimit \u003d (int) (ptInfo.getPmemLimit() \u003e\u003e 20);\n                   usageMetrics.recordResourceLimit(\n                       vmemLimit, pmemLimit, cpuVcores);\n                   usageMetrics.recordProcessId(pId);\n                 }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                 resourceCalculatorPlugin.getNumProcessors();\n \n             // Multiply by 1000 to avoid losing data when converting to int\n             int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(String.format(\n                   \"Memory usage of ProcessTree %s for container-id %s: \",\n                   pId, containerId.toString()) +\n                   formatUsageString(\n                       currentVmemUsage, vmemLimit,\n                       currentPmemUsage, pmemLimit));\n             }\n \n+            // Add resource utilization for this container\n+            trackedContainersUtilization.addTo(\n+                (int) (currentPmemUsage \u003e\u003e 20),\n+                (int) (currentVmemUsage \u003e\u003e 20),\n+                milliVcoresUsed / 1000.0f);\n+\n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).recordCpuUsage\n                   ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n             }\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             // Accounting the total memory in usage for all containers\n             vmemUsageByAllContainers +\u003d currentVmemUsage;\n             pmemByAllContainers +\u003d currentPmemUsage;\n             // Accounting the total cpu usage for all containers\n             cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n             cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               it.remove();\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n               + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n               + \", Physical Memory\u003d \" + pmemByAllContainers\n               + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n               + \", Total CPU(% per core) usage\"\n               + cpuUsagePercentPerCoreByAllContainers);\n         }\n \n+        // Save the aggregated utilization of the containers\n+        setContainersUtilization(trackedContainersUtilization);\n+\n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).finished();\n            }\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Temporary structure to calculate the total resource utilization of\n        // the containers\n        ResourceUtilization trackedContainersUtilization  \u003d\n            ResourceUtilization.newInstance(0, 0, 0.0f);\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        long cpuUsageTotalCoresByAllContainers \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs);\n                  int cpuVcores \u003d ptInfo.getCpuVcores();\n                  final int vmemLimit \u003d (int) (ptInfo.getVmemLimit() \u003e\u003e 20);\n                  final int pmemLimit \u003d (int) (ptInfo.getPmemLimit() \u003e\u003e 20);\n                  usageMetrics.recordResourceLimit(\n                      vmemLimit, pmemLimit, cpuVcores);\n                  usageMetrics.recordProcessId(pId);\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n\n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(String.format(\n                  \"Memory usage of ProcessTree %s for container-id %s: \",\n                  pId, containerId.toString()) +\n                  formatUsageString(\n                      currentVmemUsage, vmemLimit,\n                      currentPmemUsage, pmemLimit));\n            }\n\n            // Add resource utilization for this container\n            trackedContainersUtilization.addTo(\n                (int) (currentPmemUsage \u003e\u003e 20),\n                (int) (currentVmemUsage \u003e\u003e 20),\n                milliVcoresUsed / 1000.0f);\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n              + \", Total CPU(% per core) usage\"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        // Save the aggregated utilization of the containers\n        setContainersUtilization(trackedContainersUtilization);\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "8badd82ce256e4dc8c234961120d62a88358ab39": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3513. Remove unused variables in ContainersMonitorImpl and add debug\nlog for overall resource usage by all containers.  Contributed by\nNaganarasimha G R.\n",
      "commitDate": "12/05/15 4:24 AM",
      "commitName": "8badd82ce256e4dc8c234961120d62a88358ab39",
      "commitAuthor": "Devaraj K",
      "commitDateOld": "01/05/15 4:39 PM",
      "commitNameOld": "ac7d152901e29b1f444507fe4e421eb6e1402b5a",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 10.49,
      "commitsBetweenForRepo": 162,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,196 +1,207 @@\n     public void run() {\n \n       while (true) {\n \n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Add new containers\n         synchronized (containersToBeAdded) {\n           for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n               .entrySet()) {\n             ContainerId containerId \u003d entry.getKey();\n             ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n             LOG.info(\"Starting resource-monitoring for \" + containerId);\n             trackingContainers.put(containerId, processTreeInfo);\n           }\n           containersToBeAdded.clear();\n         }\n \n         // Remove finished containers\n         synchronized (containersToBeRemoved) {\n           for (ContainerId containerId : containersToBeRemoved) {\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).finished();\n             }\n             trackingContainers.remove(containerId);\n             LOG.info(\"Stopping resource-monitoring for \" + containerId);\n           }\n           containersToBeRemoved.clear();\n         }\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n-        long vmemStillInUsage \u003d 0;\n-        long pmemStillInUsage \u003d 0;\n+        long vmemUsageByAllContainers \u003d 0;\n+        long pmemByAllContainers \u003d 0;\n+        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n+        long cpuUsageTotalCoresByAllContainers \u003d 0;\n         for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n             trackingContainers.entrySet().iterator(); it.hasNext();) {\n \n           Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n \n                 if (containerMetricsEnabled) {\n                   ContainerMetrics usageMetrics \u003d ContainerMetrics\n                       .forContainer(containerId, containerMetricsPeriodMs);\n                   int cpuVcores \u003d ptInfo.getCpuVcores();\n                   final int vmemLimit \u003d (int) (ptInfo.getVmemLimit() \u003e\u003e 20);\n                   final int pmemLimit \u003d (int) (ptInfo.getPmemLimit() \u003e\u003e 20);\n                   usageMetrics.recordResourceLimit(\n                       vmemLimit, pmemLimit, cpuVcores);\n                   usageMetrics.recordProcessId(pId);\n                 }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                 resourceCalculatorPlugin.getNumProcessors();\n \n             // Multiply by 1000 to avoid losing data when converting to int\n             int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(String.format(\n                   \"Memory usage of ProcessTree %s for container-id %s: \",\n                   pId, containerId.toString()) +\n                   formatUsageString(\n                       currentVmemUsage, vmemLimit,\n                       currentPmemUsage, pmemLimit));\n             }\n \n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).recordCpuUsage\n                   ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n             }\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n+            // Accounting the total memory in usage for all containers\n+            vmemUsageByAllContainers +\u003d currentVmemUsage;\n+            pmemByAllContainers +\u003d currentPmemUsage;\n+            // Accounting the total cpu usage for all containers\n+            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n+            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n+\n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               it.remove();\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n-            } else {\n-              // Accounting the total memory in usage for all containers that\n-              // are still\n-              // alive and within limits.\n-              vmemStillInUsage +\u003d currentVmemUsage;\n-              pmemStillInUsage +\u003d currentPmemUsage;\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n+              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n+              + \", Physical Memory\u003d \" + pmemByAllContainers\n+              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n+              + \", Total CPU(% per core) usage\"\n+              + cpuUsagePercentPerCoreByAllContainers);\n+        }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).finished();\n            }\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemUsageByAllContainers \u003d 0;\n        long pmemByAllContainers \u003d 0;\n        long cpuUsagePercentPerCoreByAllContainers \u003d 0;\n        long cpuUsageTotalCoresByAllContainers \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs);\n                  int cpuVcores \u003d ptInfo.getCpuVcores();\n                  final int vmemLimit \u003d (int) (ptInfo.getVmemLimit() \u003e\u003e 20);\n                  final int pmemLimit \u003d (int) (ptInfo.getPmemLimit() \u003e\u003e 20);\n                  usageMetrics.recordResourceLimit(\n                      vmemLimit, pmemLimit, cpuVcores);\n                  usageMetrics.recordProcessId(pId);\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n\n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(String.format(\n                  \"Memory usage of ProcessTree %s for container-id %s: \",\n                  pId, containerId.toString()) +\n                  formatUsageString(\n                      currentVmemUsage, vmemLimit,\n                      currentPmemUsage, pmemLimit));\n            }\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            // Accounting the total memory in usage for all containers\n            vmemUsageByAllContainers +\u003d currentVmemUsage;\n            pmemByAllContainers +\u003d currentPmemUsage;\n            // Accounting the total cpu usage for all containers\n            cpuUsagePercentPerCoreByAllContainers +\u003d cpuUsagePercentPerCore;\n            cpuUsageTotalCoresByAllContainers +\u003d cpuUsagePercentPerCore;\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Total Resource Usage stats in NM by all containers : \"\n              + \"Virtual Memory\u003d \" + vmemUsageByAllContainers\n              + \", Physical Memory\u003d \" + pmemByAllContainers\n              + \", Total CPU usage\u003d \" + cpuUsageTotalCoresByAllContainers\n              + \", Total CPU(% per core) usage\"\n              + cpuUsagePercentPerCoreByAllContainers);\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "c69ba81497ae4da329ddb34ba712a64a7eec479f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3424. Change logs for ContainerMonitorImpl\u0027s resourse monitoring from info to debug. Contributed by Anubhav Dhoot.\n",
      "commitDate": "01/04/15 1:44 AM",
      "commitName": "c69ba81497ae4da329ddb34ba712a64a7eec479f",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "30/03/15 10:09 AM",
      "commitNameOld": "c358368f511963ad8e35f030b9babee541e1bd01",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.65,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,193 +1,196 @@\n     public void run() {\n \n       while (true) {\n \n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Add new containers\n         synchronized (containersToBeAdded) {\n           for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n               .entrySet()) {\n             ContainerId containerId \u003d entry.getKey();\n             ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n             LOG.info(\"Starting resource-monitoring for \" + containerId);\n             trackingContainers.put(containerId, processTreeInfo);\n           }\n           containersToBeAdded.clear();\n         }\n \n         // Remove finished containers\n         synchronized (containersToBeRemoved) {\n           for (ContainerId containerId : containersToBeRemoved) {\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).finished();\n             }\n             trackingContainers.remove(containerId);\n             LOG.info(\"Stopping resource-monitoring for \" + containerId);\n           }\n           containersToBeRemoved.clear();\n         }\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemStillInUsage \u003d 0;\n         long pmemStillInUsage \u003d 0;\n         for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n             trackingContainers.entrySet().iterator(); it.hasNext();) {\n \n           Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n \n                 if (containerMetricsEnabled) {\n                   ContainerMetrics usageMetrics \u003d ContainerMetrics\n                       .forContainer(containerId, containerMetricsPeriodMs);\n                   int cpuVcores \u003d ptInfo.getCpuVcores();\n                   final int vmemLimit \u003d (int) (ptInfo.getVmemLimit() \u003e\u003e 20);\n                   final int pmemLimit \u003d (int) (ptInfo.getPmemLimit() \u003e\u003e 20);\n                   usageMetrics.recordResourceLimit(\n                       vmemLimit, pmemLimit, cpuVcores);\n                   usageMetrics.recordProcessId(pId);\n                 }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n             long currentPmemUsage \u003d pTree.getRssMemorySize();\n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                 resourceCalculatorPlugin.getNumProcessors();\n \n             // Multiply by 1000 to avoid losing data when converting to int\n             int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n-            LOG.info(String.format(\n-                \"Memory usage of ProcessTree %s for container-id %s: \",\n-                     pId, containerId.toString()) +\n-                formatUsageString(\n-                    currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(String.format(\n+                  \"Memory usage of ProcessTree %s for container-id %s: \",\n+                  pId, containerId.toString()) +\n+                  formatUsageString(\n+                      currentVmemUsage, vmemLimit,\n+                      currentPmemUsage, pmemLimit));\n+            }\n \n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).recordCpuUsage\n                   ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n             }\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               it.remove();\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             } else {\n               // Accounting the total memory in usage for all containers that\n               // are still\n               // alive and within limits.\n               vmemStillInUsage +\u003d currentVmemUsage;\n               pmemStillInUsage +\u003d currentPmemUsage;\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).finished();\n            }\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs);\n                  int cpuVcores \u003d ptInfo.getCpuVcores();\n                  final int vmemLimit \u003d (int) (ptInfo.getVmemLimit() \u003e\u003e 20);\n                  final int pmemLimit \u003d (int) (ptInfo.getPmemLimit() \u003e\u003e 20);\n                  usageMetrics.recordResourceLimit(\n                      vmemLimit, pmemLimit, cpuVcores);\n                  usageMetrics.recordProcessId(pId);\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n\n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(String.format(\n                  \"Memory usage of ProcessTree %s for container-id %s: \",\n                  pId, containerId.toString()) +\n                  formatUsageString(\n                      currentVmemUsage, vmemLimit,\n                      currentPmemUsage, pmemLimit));\n            }\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "c358368f511963ad8e35f030b9babee541e1bd01": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3304. Cleaning up ResourceCalculatorProcessTree APIs for public use and removing inconsistencies in the default values. Contributed by Junping Du and Karthik Kambatla.\n",
      "commitDate": "30/03/15 10:09 AM",
      "commitName": "c358368f511963ad8e35f030b9babee541e1bd01",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "04/03/15 5:33 PM",
      "commitNameOld": "53947f37c7a84a84ef4ab1a3cab63ff27c078385",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 25.65,
      "commitsBetweenForRepo": 213,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,193 +1,193 @@\n     public void run() {\n \n       while (true) {\n \n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Add new containers\n         synchronized (containersToBeAdded) {\n           for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n               .entrySet()) {\n             ContainerId containerId \u003d entry.getKey();\n             ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n             LOG.info(\"Starting resource-monitoring for \" + containerId);\n             trackingContainers.put(containerId, processTreeInfo);\n           }\n           containersToBeAdded.clear();\n         }\n \n         // Remove finished containers\n         synchronized (containersToBeRemoved) {\n           for (ContainerId containerId : containersToBeRemoved) {\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).finished();\n             }\n             trackingContainers.remove(containerId);\n             LOG.info(\"Stopping resource-monitoring for \" + containerId);\n           }\n           containersToBeRemoved.clear();\n         }\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemStillInUsage \u003d 0;\n         long pmemStillInUsage \u003d 0;\n         for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n             trackingContainers.entrySet().iterator(); it.hasNext();) {\n \n           Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n \n                 if (containerMetricsEnabled) {\n                   ContainerMetrics usageMetrics \u003d ContainerMetrics\n                       .forContainer(containerId, containerMetricsPeriodMs);\n                   int cpuVcores \u003d ptInfo.getCpuVcores();\n                   final int vmemLimit \u003d (int) (ptInfo.getVmemLimit() \u003e\u003e 20);\n                   final int pmemLimit \u003d (int) (ptInfo.getPmemLimit() \u003e\u003e 20);\n                   usageMetrics.recordResourceLimit(\n                       vmemLimit, pmemLimit, cpuVcores);\n                   usageMetrics.recordProcessId(pId);\n                 }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n-            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n-            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n+            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n+            long currentPmemUsage \u003d pTree.getRssMemorySize();\n             // if machine has 6 cores and 3 are used,\n             // cpuUsagePercentPerCore should be 300% and\n             // cpuUsageTotalCoresPercentage should be 50%\n             float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n             float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                 resourceCalculatorPlugin.getNumProcessors();\n \n             // Multiply by 1000 to avoid losing data when converting to int\n             int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                 * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n-            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n-            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n+            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n+            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             LOG.info(String.format(\n                 \"Memory usage of ProcessTree %s for container-id %s: \",\n                      pId, containerId.toString()) +\n                 formatUsageString(\n                     currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n \n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).recordCpuUsage\n                   ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n             }\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               it.remove();\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             } else {\n               // Accounting the total memory in usage for all containers that\n               // are still\n               // alive and within limits.\n               vmemStillInUsage +\u003d currentVmemUsage;\n               pmemStillInUsage +\u003d currentPmemUsage;\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).finished();\n            }\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs);\n                  int cpuVcores \u003d ptInfo.getCpuVcores();\n                  final int vmemLimit \u003d (int) (ptInfo.getVmemLimit() \u003e\u003e 20);\n                  final int pmemLimit \u003d (int) (ptInfo.getPmemLimit() \u003e\u003e 20);\n                  usageMetrics.recordResourceLimit(\n                      vmemLimit, pmemLimit, cpuVcores);\n                  usageMetrics.recordProcessId(pId);\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getVirtualMemorySize();\n            long currentPmemUsage \u003d pTree.getRssMemorySize();\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n\n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            LOG.info(String.format(\n                \"Memory usage of ProcessTree %s for container-id %s: \",\n                     pId, containerId.toString()) +\n                formatUsageString(\n                    currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "53947f37c7a84a84ef4ab1a3cab63ff27c078385": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3122. Metrics for container\u0027s actual CPU usage. (Anubhav Dhoot via kasha)\n",
      "commitDate": "04/03/15 5:33 PM",
      "commitName": "53947f37c7a84a84ef4ab1a3cab63ff27c078385",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "03/02/15 10:39 AM",
      "commitNameOld": "f7a77819a1e4ff394e110941c1f8dd80f47dd38f",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 29.29,
      "commitsBetweenForRepo": 317,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,180 +1,193 @@\n     public void run() {\n \n       while (true) {\n \n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Add new containers\n         synchronized (containersToBeAdded) {\n           for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n               .entrySet()) {\n             ContainerId containerId \u003d entry.getKey();\n             ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n             LOG.info(\"Starting resource-monitoring for \" + containerId);\n             trackingContainers.put(containerId, processTreeInfo);\n           }\n           containersToBeAdded.clear();\n         }\n \n         // Remove finished containers\n         synchronized (containersToBeRemoved) {\n           for (ContainerId containerId : containersToBeRemoved) {\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).finished();\n             }\n             trackingContainers.remove(containerId);\n             LOG.info(\"Stopping resource-monitoring for \" + containerId);\n           }\n           containersToBeRemoved.clear();\n         }\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemStillInUsage \u003d 0;\n         long pmemStillInUsage \u003d 0;\n         for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n             trackingContainers.entrySet().iterator(); it.hasNext();) {\n \n           Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n \n                 if (containerMetricsEnabled) {\n                   ContainerMetrics usageMetrics \u003d ContainerMetrics\n                       .forContainer(containerId, containerMetricsPeriodMs);\n                   int cpuVcores \u003d ptInfo.getCpuVcores();\n                   final int vmemLimit \u003d (int) (ptInfo.getVmemLimit() \u003e\u003e 20);\n                   final int pmemLimit \u003d (int) (ptInfo.getPmemLimit() \u003e\u003e 20);\n                   usageMetrics.recordResourceLimit(\n                       vmemLimit, pmemLimit, cpuVcores);\n                   usageMetrics.recordProcessId(pId);\n                 }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getCumulativeVmem();\n             long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n+            // if machine has 6 cores and 3 are used,\n+            // cpuUsagePercentPerCore should be 300% and\n+            // cpuUsageTotalCoresPercentage should be 50%\n+            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n+            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n+                resourceCalculatorPlugin.getNumProcessors();\n+\n+            // Multiply by 1000 to avoid losing data when converting to int\n+            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n+                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             LOG.info(String.format(\n                 \"Memory usage of ProcessTree %s for container-id %s: \",\n                      pId, containerId.toString()) +\n                 formatUsageString(\n                     currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n \n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n+              ContainerMetrics.forContainer(\n+                  containerId, containerMetricsPeriodMs).recordCpuUsage\n+                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n             }\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               it.remove();\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             } else {\n               // Accounting the total memory in usage for all containers that\n               // are still\n               // alive and within limits.\n               vmemStillInUsage +\u003d currentVmemUsage;\n               pmemStillInUsage +\u003d currentPmemUsage;\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).finished();\n            }\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs);\n                  int cpuVcores \u003d ptInfo.getCpuVcores();\n                  final int vmemLimit \u003d (int) (ptInfo.getVmemLimit() \u003e\u003e 20);\n                  final int pmemLimit \u003d (int) (ptInfo.getPmemLimit() \u003e\u003e 20);\n                  usageMetrics.recordResourceLimit(\n                      vmemLimit, pmemLimit, cpuVcores);\n                  usageMetrics.recordProcessId(pId);\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n            // if machine has 6 cores and 3 are used,\n            // cpuUsagePercentPerCore should be 300% and\n            // cpuUsageTotalCoresPercentage should be 50%\n            float cpuUsagePercentPerCore \u003d pTree.getCpuUsagePercent();\n            float cpuUsageTotalCoresPercentage \u003d cpuUsagePercentPerCore /\n                resourceCalculatorPlugin.getNumProcessors();\n\n            // Multiply by 1000 to avoid losing data when converting to int\n            int milliVcoresUsed \u003d (int) (cpuUsageTotalCoresPercentage * 1000\n                * maxVCoresAllottedForContainers /nodeCpuPercentageForYARN);\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            LOG.info(String.format(\n                \"Memory usage of ProcessTree %s for container-id %s: \",\n                     pId, containerId.toString()) +\n                formatUsageString(\n                    currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordCpuUsage\n                  ((int)cpuUsagePercentPerCore, milliVcoresUsed);\n            }\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "f7a77819a1e4ff394e110941c1f8dd80f47dd38f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3022. Expose Container resource information from NodeManager for monitoring (adhoot via ranter)\n",
      "commitDate": "03/02/15 10:39 AM",
      "commitName": "f7a77819a1e4ff394e110941c1f8dd80f47dd38f",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "16/01/15 4:14 PM",
      "commitNameOld": "84198564ba6028d51c1fcf9cdcb87f6ae6e08513",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 17.77,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,168 +1,180 @@\n     public void run() {\n \n       while (true) {\n \n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Add new containers\n         synchronized (containersToBeAdded) {\n           for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n               .entrySet()) {\n             ContainerId containerId \u003d entry.getKey();\n             ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n             LOG.info(\"Starting resource-monitoring for \" + containerId);\n             trackingContainers.put(containerId, processTreeInfo);\n           }\n           containersToBeAdded.clear();\n         }\n \n         // Remove finished containers\n         synchronized (containersToBeRemoved) {\n           for (ContainerId containerId : containersToBeRemoved) {\n             if (containerMetricsEnabled) {\n-              ContainerMetrics.forContainer(containerId).finished();\n+              ContainerMetrics.forContainer(\n+                  containerId, containerMetricsPeriodMs).finished();\n             }\n             trackingContainers.remove(containerId);\n             LOG.info(\"Stopping resource-monitoring for \" + containerId);\n           }\n           containersToBeRemoved.clear();\n         }\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemStillInUsage \u003d 0;\n         long pmemStillInUsage \u003d 0;\n         for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n             trackingContainers.entrySet().iterator(); it.hasNext();) {\n \n           Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n+\n+                if (containerMetricsEnabled) {\n+                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n+                      .forContainer(containerId, containerMetricsPeriodMs);\n+                  int cpuVcores \u003d ptInfo.getCpuVcores();\n+                  final int vmemLimit \u003d (int) (ptInfo.getVmemLimit() \u003e\u003e 20);\n+                  final int pmemLimit \u003d (int) (ptInfo.getPmemLimit() \u003e\u003e 20);\n+                  usageMetrics.recordResourceLimit(\n+                      vmemLimit, pmemLimit, cpuVcores);\n+                  usageMetrics.recordProcessId(pId);\n+                }\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getCumulativeVmem();\n             long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             LOG.info(String.format(\n                 \"Memory usage of ProcessTree %s for container-id %s: \",\n                      pId, containerId.toString()) +\n                 formatUsageString(\n                     currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n \n             // Add usage to container metrics\n             if (containerMetricsEnabled) {\n               ContainerMetrics.forContainer(\n                   containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                   (int) (currentPmemUsage \u003e\u003e 20));\n             }\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               it.remove();\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             } else {\n               // Accounting the total memory in usage for all containers that\n               // are still\n               // alive and within limits.\n               vmemStillInUsage +\u003d currentVmemUsage;\n               pmemStillInUsage +\u003d currentPmemUsage;\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).finished();\n            }\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n\n                if (containerMetricsEnabled) {\n                  ContainerMetrics usageMetrics \u003d ContainerMetrics\n                      .forContainer(containerId, containerMetricsPeriodMs);\n                  int cpuVcores \u003d ptInfo.getCpuVcores();\n                  final int vmemLimit \u003d (int) (ptInfo.getVmemLimit() \u003e\u003e 20);\n                  final int pmemLimit \u003d (int) (ptInfo.getPmemLimit() \u003e\u003e 20);\n                  usageMetrics.recordResourceLimit(\n                      vmemLimit, pmemLimit, cpuVcores);\n                  usageMetrics.recordProcessId(pId);\n                }\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            LOG.info(String.format(\n                \"Memory usage of ProcessTree %s for container-id %s: \",\n                     pId, containerId.toString()) +\n                formatUsageString(\n                    currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n            }\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "84198564ba6028d51c1fcf9cdcb87f6ae6e08513": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2984. Metrics for container\u0027s actual memory usage. (kasha)\n",
      "commitDate": "16/01/15 4:14 PM",
      "commitName": "84198564ba6028d51c1fcf9cdcb87f6ae6e08513",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "24/06/14 12:34 PM",
      "commitNameOld": "1f9a0fd927ab7bef13db42dd80368fd781b3d2d1",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 206.19,
      "commitsBetweenForRepo": 1736,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,157 +1,168 @@\n     public void run() {\n \n       while (true) {\n \n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Add new containers\n         synchronized (containersToBeAdded) {\n           for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n               .entrySet()) {\n             ContainerId containerId \u003d entry.getKey();\n             ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n             LOG.info(\"Starting resource-monitoring for \" + containerId);\n             trackingContainers.put(containerId, processTreeInfo);\n           }\n           containersToBeAdded.clear();\n         }\n \n         // Remove finished containers\n         synchronized (containersToBeRemoved) {\n           for (ContainerId containerId : containersToBeRemoved) {\n+            if (containerMetricsEnabled) {\n+              ContainerMetrics.forContainer(containerId).finished();\n+            }\n             trackingContainers.remove(containerId);\n             LOG.info(\"Stopping resource-monitoring for \" + containerId);\n           }\n           containersToBeRemoved.clear();\n         }\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemStillInUsage \u003d 0;\n         long pmemStillInUsage \u003d 0;\n         for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n             trackingContainers.entrySet().iterator(); it.hasNext();) {\n \n           Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getCumulativeVmem();\n             long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             LOG.info(String.format(\n                 \"Memory usage of ProcessTree %s for container-id %s: \",\n                      pId, containerId.toString()) +\n-                formatUsageString(currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n+                formatUsageString(\n+                    currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n+\n+            // Add usage to container metrics\n+            if (containerMetricsEnabled) {\n+              ContainerMetrics.forContainer(\n+                  containerId, containerMetricsPeriodMs).recordMemoryUsage(\n+                  (int) (currentPmemUsage \u003e\u003e 20));\n+            }\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n               containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n               it.remove();\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             } else {\n               // Accounting the total memory in usage for all containers that\n               // are still\n               // alive and within limits.\n               vmemStillInUsage +\u003d currentVmemUsage;\n               pmemStillInUsage +\u003d currentPmemUsage;\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(containerId).finished();\n            }\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            LOG.info(String.format(\n                \"Memory usage of ProcessTree %s for container-id %s: \",\n                     pId, containerId.toString()) +\n                formatUsageString(\n                    currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n\n            // Add usage to container metrics\n            if (containerMetricsEnabled) {\n              ContainerMetrics.forContainer(\n                  containerId, containerMetricsPeriodMs).recordMemoryUsage(\n                  (int) (currentPmemUsage \u003e\u003e 20));\n            }\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "ecfd43a2f1ffe56f39ebba98ad13538e63cef6fd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2091. Add more values to ContainerExitStatus and pass it from NM to RM and then to app masters (Tsuyoshi OZAWA via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601762 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/06/14 1:08 PM",
      "commitName": "ecfd43a2f1ffe56f39ebba98ad13538e63cef6fd",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "16/06/13 11:39 PM",
      "commitNameOld": "b9efe6bd4a1277b4067ecde715a7713a85968886",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 358.56,
      "commitsBetweenForRepo": 2338,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,153 +1,157 @@\n     public void run() {\n \n       while (true) {\n \n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Add new containers\n         synchronized (containersToBeAdded) {\n           for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n               .entrySet()) {\n             ContainerId containerId \u003d entry.getKey();\n             ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n             LOG.info(\"Starting resource-monitoring for \" + containerId);\n             trackingContainers.put(containerId, processTreeInfo);\n           }\n           containersToBeAdded.clear();\n         }\n \n         // Remove finished containers\n         synchronized (containersToBeRemoved) {\n           for (ContainerId containerId : containersToBeRemoved) {\n             trackingContainers.remove(containerId);\n             LOG.info(\"Stopping resource-monitoring for \" + containerId);\n           }\n           containersToBeRemoved.clear();\n         }\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemStillInUsage \u003d 0;\n         long pmemStillInUsage \u003d 0;\n         for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n             trackingContainers.entrySet().iterator(); it.hasNext();) {\n \n           Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getCumulativeVmem();\n             long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             LOG.info(String.format(\n                 \"Memory usage of ProcessTree %s for container-id %s: \",\n                      pId, containerId.toString()) +\n                 formatUsageString(currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n+            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n             if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n+              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n             } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n+              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n             }\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n-                  new ContainerKillEvent(containerId, msg));\n+                  new ContainerKillEvent(containerId,\n+                      containerExitStatus, msg));\n               it.remove();\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             } else {\n               // Accounting the total memory in usage for all containers that\n               // are still\n               // alive and within limits.\n               vmemStillInUsage +\u003d currentVmemUsage;\n               pmemStillInUsage +\u003d currentPmemUsage;\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            LOG.info(String.format(\n                \"Memory usage of ProcessTree %s for container-id %s: \",\n                     pId, containerId.toString()) +\n                formatUsageString(currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            int containerExitStatus \u003d ContainerExitStatus.INVALID;\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n              containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "b15b44e722fa69191816bebf319be1396fe68f09": {
      "type": "Ybodychange",
      "commitMessage": "YARN-470. Support a way to disable resource monitoring on the NodeManager. Contributed by Siddharth Seth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1460001 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/03/13 2:28 PM",
      "commitName": "b15b44e722fa69191816bebf319be1396fe68f09",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "07/02/13 3:53 PM",
      "commitNameOld": "a63d50f79a8cc348e1f5dd84545aeb7766147a4d",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 42.9,
      "commitsBetweenForRepo": 183,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,153 +1,153 @@\n     public void run() {\n \n       while (true) {\n \n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Add new containers\n         synchronized (containersToBeAdded) {\n           for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n               .entrySet()) {\n             ContainerId containerId \u003d entry.getKey();\n             ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n             LOG.info(\"Starting resource-monitoring for \" + containerId);\n             trackingContainers.put(containerId, processTreeInfo);\n           }\n           containersToBeAdded.clear();\n         }\n \n         // Remove finished containers\n         synchronized (containersToBeRemoved) {\n           for (ContainerId containerId : containersToBeRemoved) {\n             trackingContainers.remove(containerId);\n             LOG.info(\"Stopping resource-monitoring for \" + containerId);\n           }\n           containersToBeRemoved.clear();\n         }\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemStillInUsage \u003d 0;\n         long pmemStillInUsage \u003d 0;\n         for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n             trackingContainers.entrySet().iterator(); it.hasNext();) {\n \n           Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getCumulativeVmem();\n             long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             LOG.info(String.format(\n                 \"Memory usage of ProcessTree %s for container-id %s: \",\n                      pId, containerId.toString()) +\n                 formatUsageString(currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n-            if (isVirtualMemoryCheckEnabled()\n+            if (isVmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n-            } else if (isPhysicalMemoryCheckEnabled()\n+            } else if (isPmemCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n             }\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId, msg));\n               it.remove();\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             } else {\n               // Accounting the total memory in usage for all containers that\n               // are still\n               // alive and within limits.\n               vmemStillInUsage +\u003d currentVmemUsage;\n               pmemStillInUsage +\u003d currentPmemUsage;\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            LOG.info(String.format(\n                \"Memory usage of ProcessTree %s for container-id %s: \",\n                     pId, containerId.toString()) +\n                formatUsageString(currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            if (isVmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n            } else if (isPmemCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "1a49c854386d3ba4aef6f29f46e2bd5e71e86dc1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-223. Update process tree instead of getting new process trees. (Radim Kolar via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1424244 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/12/12 4:20 PM",
      "commitName": "1a49c854386d3ba4aef6f29f46e2bd5e71e86dc1",
      "commitAuthor": "Luke Lu",
      "commitDateOld": "07/09/12 8:48 AM",
      "commitNameOld": "a1aa1b93497034411d76906405bb6a70a441a0b7",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 103.36,
      "commitsBetweenForRepo": 522,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,155 +1,153 @@\n     public void run() {\n \n       while (true) {\n \n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Add new containers\n         synchronized (containersToBeAdded) {\n           for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n               .entrySet()) {\n             ContainerId containerId \u003d entry.getKey();\n             ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n             LOG.info(\"Starting resource-monitoring for \" + containerId);\n             trackingContainers.put(containerId, processTreeInfo);\n           }\n           containersToBeAdded.clear();\n         }\n \n         // Remove finished containers\n         synchronized (containersToBeRemoved) {\n           for (ContainerId containerId : containersToBeRemoved) {\n             trackingContainers.remove(containerId);\n             LOG.info(\"Stopping resource-monitoring for \" + containerId);\n           }\n           containersToBeRemoved.clear();\n         }\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemStillInUsage \u003d 0;\n         long pmemStillInUsage \u003d 0;\n         for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n             trackingContainers.entrySet().iterator(); it.hasNext();) {\n \n           Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ResourceCalculatorProcessTree pt \u003d\n                     ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n-            pTree \u003d pTree.getProcessTree(); // get the updated process-tree\n-            ptInfo.setProcessTree(pTree); // update ptInfo with proces-tree of\n-                                          // updated state\n+            pTree.updateProcessTree();    // update process-tree\n             long currentVmemUsage \u003d pTree.getCumulativeVmem();\n             long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             LOG.info(String.format(\n                 \"Memory usage of ProcessTree %s for container-id %s: \",\n                      pId, containerId.toString()) +\n                 formatUsageString(currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             if (isVirtualMemoryCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n             } else if (isPhysicalMemoryCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n             }\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId, msg));\n               it.remove();\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             } else {\n               // Accounting the total memory in usage for all containers that\n               // are still\n               // alive and within limits.\n               vmemStillInUsage +\u003d currentVmemUsage;\n               pmemStillInUsage +\u003d currentPmemUsage;\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree.updateProcessTree();    // update process-tree\n            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            LOG.info(String.format(\n                \"Memory usage of ProcessTree %s for container-id %s: \",\n                     pId, containerId.toString()) +\n                formatUsageString(currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            if (isVirtualMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n            } else if (isPhysicalMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "a1aa1b93497034411d76906405bb6a70a441a0b7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-57. Allow process-tree based resource calculation et al. to be pluggable to support it on multiple platforms. Contributed by Radim Kolar.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1382072 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/09/12 8:48 AM",
      "commitName": "a1aa1b93497034411d76906405bb6a70a441a0b7",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 30.43,
      "commitsBetweenForRepo": 200,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,156 +1,155 @@\n     public void run() {\n \n       while (true) {\n \n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Add new containers\n         synchronized (containersToBeAdded) {\n           for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n               .entrySet()) {\n             ContainerId containerId \u003d entry.getKey();\n             ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n             LOG.info(\"Starting resource-monitoring for \" + containerId);\n             trackingContainers.put(containerId, processTreeInfo);\n           }\n           containersToBeAdded.clear();\n         }\n \n         // Remove finished containers\n         synchronized (containersToBeRemoved) {\n           for (ContainerId containerId : containersToBeRemoved) {\n             trackingContainers.remove(containerId);\n             LOG.info(\"Stopping resource-monitoring for \" + containerId);\n           }\n           containersToBeRemoved.clear();\n         }\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemStillInUsage \u003d 0;\n         long pmemStillInUsage \u003d 0;\n         for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n             trackingContainers.entrySet().iterator(); it.hasNext();) {\n \n           Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n-                ProcfsBasedProcessTree pt \u003d\n-                    new ProcfsBasedProcessTree(pId,\n-                        ContainerExecutor.isSetsidAvailable);\n+                ResourceCalculatorProcessTree pt \u003d\n+                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n-            ProcfsBasedProcessTree pTree \u003d ptInfo.getProcessTree();\n+            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree \u003d pTree.getProcessTree(); // get the updated process-tree\n             ptInfo.setProcessTree(pTree); // update ptInfo with proces-tree of\n                                           // updated state\n             long currentVmemUsage \u003d pTree.getCumulativeVmem();\n             long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n             LOG.info(String.format(\n                 \"Memory usage of ProcessTree %s for container-id %s: \",\n                      pId, containerId.toString()) +\n                 formatUsageString(currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             if (isVirtualMemoryCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"virtual\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n             } else if (isPhysicalMemoryCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n               msg \u003d formatErrorMessage(\"physical\",\n                   currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit,\n                   pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n             }\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId, msg));\n               it.remove();\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             } else {\n               // Accounting the total memory in usage for all containers that\n               // are still\n               // alive and within limits.\n               vmemStillInUsage +\u003d currentVmemUsage;\n               pmemStillInUsage +\u003d currentPmemUsage;\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ResourceCalculatorProcessTree pt \u003d\n                    ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(pId, processTreeClass, conf);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ResourceCalculatorProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree \u003d pTree.getProcessTree(); // get the updated process-tree\n            ptInfo.setProcessTree(pTree); // update ptInfo with proces-tree of\n                                          // updated state\n            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            LOG.info(String.format(\n                \"Memory usage of ProcessTree %s for container-id %s: \",\n                     pId, containerId.toString()) +\n                formatUsageString(currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            if (isVirtualMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n            } else if (isPhysicalMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ProcfsBasedProcessTree pt \u003d\n                    new ProcfsBasedProcessTree(pId,\n                        ContainerExecutor.isSetsidAvailable);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ProcfsBasedProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree \u003d pTree.getProcessTree(); // get the updated process-tree\n            ptInfo.setProcessTree(pTree); // update ptInfo with proces-tree of\n                                          // updated state\n            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            LOG.info(String.format(\n                \"Memory usage of ProcessTree %s for container-id %s: \",\n                     pId, containerId.toString()) +\n                formatUsageString(currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            if (isVirtualMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n            } else if (isPhysicalMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java"
      }
    },
    "237154982bd5853c6a374cb265520e0602adc52f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3205. Fix memory specifications to be physical rather than virtual, allowing for a ratio between the two to be configurable. Contributed by Todd Lipcon. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189542 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/10/11 4:58 PM",
      "commitName": "237154982bd5853c6a374cb265520e0602adc52f",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "16/10/11 12:27 PM",
      "commitNameOld": "68328ae92632afc9cdd6e75b7a8d832723ddbe3b",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 10.19,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,171 +1,156 @@\n     public void run() {\n \n       while (true) {\n \n         // Print the processTrees for debugging.\n         if (LOG.isDebugEnabled()) {\n           StringBuilder tmp \u003d new StringBuilder(\"[ \");\n           for (ProcessTreeInfo p : trackingContainers.values()) {\n             tmp.append(p.getPID());\n             tmp.append(\" \");\n           }\n           LOG.debug(\"Current ProcessTree list : \"\n               + tmp.substring(0, tmp.length()) + \"]\");\n         }\n \n         // Add new containers\n         synchronized (containersToBeAdded) {\n           for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n               .entrySet()) {\n             ContainerId containerId \u003d entry.getKey();\n             ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n             LOG.info(\"Starting resource-monitoring for \" + containerId);\n             trackingContainers.put(containerId, processTreeInfo);\n           }\n           containersToBeAdded.clear();\n         }\n \n         // Remove finished containers\n         synchronized (containersToBeRemoved) {\n           for (ContainerId containerId : containersToBeRemoved) {\n             trackingContainers.remove(containerId);\n             LOG.info(\"Stopping resource-monitoring for \" + containerId);\n           }\n           containersToBeRemoved.clear();\n         }\n \n         // Now do the monitoring for the trackingContainers\n         // Check memory usage and kill any overflowing containers\n         long vmemStillInUsage \u003d 0;\n         long pmemStillInUsage \u003d 0;\n         for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n             trackingContainers.entrySet().iterator(); it.hasNext();) {\n \n           Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n           ContainerId containerId \u003d entry.getKey();\n           ProcessTreeInfo ptInfo \u003d entry.getValue();\n           try {\n             String pId \u003d ptInfo.getPID();\n \n             // Initialize any uninitialized processTrees\n             if (pId \u003d\u003d null) {\n               // get pid from ContainerId\n               pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n               if (pId !\u003d null) {\n                 // pId will be null, either if the container is not spawned yet\n                 // or if the container\u0027s pid is removed from ContainerExecutor\n                 LOG.debug(\"Tracking ProcessTree \" + pId\n                     + \" for the first time\");\n \n                 ProcfsBasedProcessTree pt \u003d\n                     new ProcfsBasedProcessTree(pId,\n                         ContainerExecutor.isSetsidAvailable);\n                 ptInfo.setPid(pId);\n                 ptInfo.setProcessTree(pt);\n               }\n             }\n             // End of initializing any uninitialized processTrees\n \n             if (pId \u003d\u003d null) {\n               continue; // processTree cannot be tracked\n             }\n \n             LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                 + \" ContainerId \u003d \" + containerId);\n             ProcfsBasedProcessTree pTree \u003d ptInfo.getProcessTree();\n             pTree \u003d pTree.getProcessTree(); // get the updated process-tree\n             ptInfo.setProcessTree(pTree); // update ptInfo with proces-tree of\n                                           // updated state\n             long currentVmemUsage \u003d pTree.getCumulativeVmem();\n             long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n             // as processes begin with an age 1, we want to see if there\n             // are processes more than 1 iteration old.\n             long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n             long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n             long vmemLimit \u003d ptInfo.getVmemLimit();\n             long pmemLimit \u003d ptInfo.getPmemLimit();\n-            LOG.info(String.format(MEMORY_USAGE_STRING, pId,\n-                containerId.toString(), currentVmemUsage, vmemLimit,\n-                currentPmemUsage, pmemLimit));\n+            LOG.info(String.format(\n+                \"Memory usage of ProcessTree %s for container-id %s: \",\n+                     pId, containerId.toString()) +\n+                formatUsageString(currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n \n             boolean isMemoryOverLimit \u003d false;\n             String msg \u003d \"\";\n             if (isVirtualMemoryCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n-              msg \u003d\n-                  \"Container [pid\u003d\"\n-                      + pId\n-                      + \",containerID\u003d\"\n-                      + containerId\n-                      + \"] is running beyond memory-limits. Current usage : \"\n-                      + currentVmemUsage\n-                      + \"bytes. Limit : \"\n-                      + vmemLimit\n-                      + \"bytes. Killing container. \"\n-                      + \"\\nDump of the process-tree for \" + containerId\n-                      + \" : \\n\" + pTree.getProcessTreeDump();\n+              msg \u003d formatErrorMessage(\"virtual\",\n+                  currentVmemUsage, vmemLimit,\n+                  currentPmemUsage, pmemLimit,\n+                  pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n             } else if (isPhysicalMemoryCheckEnabled()\n                 \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                     currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                     pmemLimit)) {\n               // Container (the root process) is still alive and overflowing\n               // memory.\n               // Dump the process-tree and then clean it up.\n-              msg \u003d\n-                  \"Container [pid\u003d\"\n-                      + pId\n-                      + \",tipID\u003d\"\n-                      + containerId\n-                      + \"] is running beyond physical memory-limits.\"\n-                      + \" Current usage : \"\n-                      + currentPmemUsage\n-                      + \"bytes. Limit : \"\n-                      + pmemLimit\n-                      + \"bytes. Killing container. \\nDump of the process-tree for \"\n-                      + containerId + \" : \\n\" + pTree.getProcessTreeDump();\n+              msg \u003d formatErrorMessage(\"physical\",\n+                  currentVmemUsage, vmemLimit,\n+                  currentPmemUsage, pmemLimit,\n+                  pId, containerId, pTree);\n               isMemoryOverLimit \u003d true;\n             }\n \n             if (isMemoryOverLimit) {\n               // Virtual or physical memory over limit. Fail the container and\n               // remove\n               // the corresponding process tree\n               LOG.warn(msg);\n               // warn if not a leader\n               if (!pTree.checkPidPgrpidForMatch()) {\n                 LOG.error(\"Killed container process with PID \" + pId\n                     + \" but it is not a process group leader.\");\n               }\n               // kill the container\n               eventDispatcher.getEventHandler().handle(\n                   new ContainerKillEvent(containerId, msg));\n               it.remove();\n               LOG.info(\"Removed ProcessTree with root \" + pId);\n             } else {\n               // Accounting the total memory in usage for all containers that\n               // are still\n               // alive and within limits.\n               vmemStillInUsage +\u003d currentVmemUsage;\n               pmemStillInUsage +\u003d currentPmemUsage;\n             }\n           } catch (Exception e) {\n             // Log the exception and proceed to the next container.\n             LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                 + \"while managing memory of \" + containerId, e);\n           }\n         }\n \n         try {\n           Thread.sleep(monitoringInterval);\n         } catch (InterruptedException e) {\n           LOG.warn(ContainersMonitorImpl.class.getName()\n               + \" is interrupted. Exiting.\");\n           break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ProcfsBasedProcessTree pt \u003d\n                    new ProcfsBasedProcessTree(pId,\n                        ContainerExecutor.isSetsidAvailable);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ProcfsBasedProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree \u003d pTree.getProcessTree(); // get the updated process-tree\n            ptInfo.setProcessTree(pTree); // update ptInfo with proces-tree of\n                                          // updated state\n            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            LOG.info(String.format(\n                \"Memory usage of ProcessTree %s for container-id %s: \",\n                     pId, containerId.toString()) +\n                formatUsageString(currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit));\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            if (isVirtualMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"virtual\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n            } else if (isPhysicalMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d formatErrorMessage(\"physical\",\n                  currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit,\n                  pId, containerId, pTree);\n              isMemoryOverLimit \u003d true;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ProcfsBasedProcessTree pt \u003d\n                    new ProcfsBasedProcessTree(pId,\n                        ContainerExecutor.isSetsidAvailable);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ProcfsBasedProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree \u003d pTree.getProcessTree(); // get the updated process-tree\n            ptInfo.setProcessTree(pTree); // update ptInfo with proces-tree of\n                                          // updated state\n            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            LOG.info(String.format(MEMORY_USAGE_STRING, pId,\n                containerId.toString(), currentVmemUsage, vmemLimit,\n                currentPmemUsage, pmemLimit));\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            if (isVirtualMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d\n                  \"Container [pid\u003d\"\n                      + pId\n                      + \",containerID\u003d\"\n                      + containerId\n                      + \"] is running beyond memory-limits. Current usage : \"\n                      + currentVmemUsage\n                      + \"bytes. Limit : \"\n                      + vmemLimit\n                      + \"bytes. Killing container. \"\n                      + \"\\nDump of the process-tree for \" + containerId\n                      + \" : \\n\" + pTree.getProcessTreeDump();\n              isMemoryOverLimit \u003d true;\n            } else if (isPhysicalMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d\n                  \"Container [pid\u003d\"\n                      + pId\n                      + \",tipID\u003d\"\n                      + containerId\n                      + \"] is running beyond physical memory-limits.\"\n                      + \" Current usage : \"\n                      + currentPmemUsage\n                      + \"bytes. Limit : \"\n                      + pmemLimit\n                      + \"bytes. Killing container. \\nDump of the process-tree for \"\n                      + containerId + \" : \\n\" + pTree.getProcessTreeDump();\n              isMemoryOverLimit \u003d true;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/08/11 4:07 AM",
          "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/08/11 8:02 PM",
          "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.34,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,71 +1,171 @@\n     public void run() {\n-      while (!Thread.interrupted()) {\n+\n+      while (true) {\n+\n+        // Print the processTrees for debugging.\n+        if (LOG.isDebugEnabled()) {\n+          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n+          for (ProcessTreeInfo p : trackingContainers.values()) {\n+            tmp.append(p.getPID());\n+            tmp.append(\" \");\n+          }\n+          LOG.debug(\"Current ProcessTree list : \"\n+              + tmp.substring(0, tmp.length()) + \"]\");\n+        }\n+\n+        // Add new containers\n+        synchronized (containersToBeAdded) {\n+          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n+              .entrySet()) {\n+            ContainerId containerId \u003d entry.getKey();\n+            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n+            LOG.info(\"Starting resource-monitoring for \" + containerId);\n+            trackingContainers.put(containerId, processTreeInfo);\n+          }\n+          containersToBeAdded.clear();\n+        }\n+\n+        // Remove finished containers\n+        synchronized (containersToBeRemoved) {\n+          for (ContainerId containerId : containersToBeRemoved) {\n+            trackingContainers.remove(containerId);\n+            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n+          }\n+          containersToBeRemoved.clear();\n+        }\n+\n+        // Now do the monitoring for the trackingContainers\n+        // Check memory usage and kill any overflowing containers\n+        long vmemStillInUsage \u003d 0;\n+        long pmemStillInUsage \u003d 0;\n+        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n+            trackingContainers.entrySet().iterator(); it.hasNext();) {\n+\n+          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n+          ContainerId containerId \u003d entry.getKey();\n+          ProcessTreeInfo ptInfo \u003d entry.getValue();\n+          try {\n+            String pId \u003d ptInfo.getPID();\n+\n+            // Initialize any uninitialized processTrees\n+            if (pId \u003d\u003d null) {\n+              // get pid from ContainerId\n+              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n+              if (pId !\u003d null) {\n+                // pId will be null, either if the container is not spawned yet\n+                // or if the container\u0027s pid is removed from ContainerExecutor\n+                LOG.debug(\"Tracking ProcessTree \" + pId\n+                    + \" for the first time\");\n+\n+                ProcfsBasedProcessTree pt \u003d\n+                    new ProcfsBasedProcessTree(pId,\n+                        ContainerExecutor.isSetsidAvailable);\n+                ptInfo.setPid(pId);\n+                ptInfo.setProcessTree(pt);\n+              }\n+            }\n+            // End of initializing any uninitialized processTrees\n+\n+            if (pId \u003d\u003d null) {\n+              continue; // processTree cannot be tracked\n+            }\n+\n+            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n+                + \" ContainerId \u003d \" + containerId);\n+            ProcfsBasedProcessTree pTree \u003d ptInfo.getProcessTree();\n+            pTree \u003d pTree.getProcessTree(); // get the updated process-tree\n+            ptInfo.setProcessTree(pTree); // update ptInfo with proces-tree of\n+                                          // updated state\n+            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n+            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n+            // as processes begin with an age 1, we want to see if there\n+            // are processes more than 1 iteration old.\n+            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n+            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n+            long vmemLimit \u003d ptInfo.getVmemLimit();\n+            long pmemLimit \u003d ptInfo.getPmemLimit();\n+            LOG.info(String.format(MEMORY_USAGE_STRING, pId,\n+                containerId.toString(), currentVmemUsage, vmemLimit,\n+                currentPmemUsage, pmemLimit));\n+\n+            boolean isMemoryOverLimit \u003d false;\n+            String msg \u003d \"\";\n+            if (isVirtualMemoryCheckEnabled()\n+                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n+                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n+              // Container (the root process) is still alive and overflowing\n+              // memory.\n+              // Dump the process-tree and then clean it up.\n+              msg \u003d\n+                  \"Container [pid\u003d\"\n+                      + pId\n+                      + \",containerID\u003d\"\n+                      + containerId\n+                      + \"] is running beyond memory-limits. Current usage : \"\n+                      + currentVmemUsage\n+                      + \"bytes. Limit : \"\n+                      + vmemLimit\n+                      + \"bytes. Killing container. \"\n+                      + \"\\nDump of the process-tree for \" + containerId\n+                      + \" : \\n\" + pTree.getProcessTreeDump();\n+              isMemoryOverLimit \u003d true;\n+            } else if (isPhysicalMemoryCheckEnabled()\n+                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n+                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n+                    pmemLimit)) {\n+              // Container (the root process) is still alive and overflowing\n+              // memory.\n+              // Dump the process-tree and then clean it up.\n+              msg \u003d\n+                  \"Container [pid\u003d\"\n+                      + pId\n+                      + \",tipID\u003d\"\n+                      + containerId\n+                      + \"] is running beyond physical memory-limits.\"\n+                      + \" Current usage : \"\n+                      + currentPmemUsage\n+                      + \"bytes. Limit : \"\n+                      + pmemLimit\n+                      + \"bytes. Killing container. \\nDump of the process-tree for \"\n+                      + containerId + \" : \\n\" + pTree.getProcessTreeDump();\n+              isMemoryOverLimit \u003d true;\n+            }\n+\n+            if (isMemoryOverLimit) {\n+              // Virtual or physical memory over limit. Fail the container and\n+              // remove\n+              // the corresponding process tree\n+              LOG.warn(msg);\n+              // warn if not a leader\n+              if (!pTree.checkPidPgrpidForMatch()) {\n+                LOG.error(\"Killed container process with PID \" + pId\n+                    + \" but it is not a process group leader.\");\n+              }\n+              // kill the container\n+              eventDispatcher.getEventHandler().handle(\n+                  new ContainerKillEvent(containerId, msg));\n+              it.remove();\n+              LOG.info(\"Removed ProcessTree with root \" + pId);\n+            } else {\n+              // Accounting the total memory in usage for all containers that\n+              // are still\n+              // alive and within limits.\n+              vmemStillInUsage +\u003d currentVmemUsage;\n+              pmemStillInUsage +\u003d currentPmemUsage;\n+            }\n+          } catch (Exception e) {\n+            // Log the exception and proceed to the next container.\n+            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n+                + \"while managing memory of \" + containerId, e);\n+          }\n+        }\n+\n         try {\n-          TaskInProgress tip;\n-          Task task;\n-          synchronized (tasksToLaunch) {\n-            while (tasksToLaunch.isEmpty()) {\n-              tasksToLaunch.wait();\n-            }\n-            //get the TIP\n-            tip \u003d tasksToLaunch.remove(0);\n-            task \u003d tip.getTask();\n-            LOG.info(\"Trying to launch : \" + tip.getTask().getTaskID() + \n-                     \" which needs \" + task.getNumSlotsRequired() + \" slots\");\n-          }\n-          //wait for free slots to run\n-          synchronized (numFreeSlots) {\n-            boolean canLaunch \u003d true;\n-            while (numFreeSlots.get() \u003c task.getNumSlotsRequired()) {\n-              //Make sure that there is no kill task action for this task!\n-              //We are not locking tip here, because it would reverse the\n-              //locking order!\n-              //Also, Lock for the tip is not required here! because :\n-              // 1. runState of TaskStatus is volatile\n-              // 2. Any notification is not missed because notification is\n-              // synchronized on numFreeSlots. So, while we are doing the check,\n-              // if the tip is half way through the kill(), we don\u0027t miss\n-              // notification for the following wait(). \n-              if (!tip.canBeLaunched()) {\n-                //got killed externally while still in the launcher queue\n-                LOG.info(\"Not blocking slots for \" + task.getTaskID()\n-                    + \" as it got killed externally. Task\u0027s state is \"\n-                    + tip.getRunState());\n-                canLaunch \u003d false;\n-                break;\n-              }              \n-              LOG.info(\"TaskLauncher : Waiting for \" + task.getNumSlotsRequired() + \n-                       \" to launch \" + task.getTaskID() + \", currently we have \" + \n-                       numFreeSlots.get() + \" free slots\");\n-              numFreeSlots.wait();\n-            }\n-            if (!canLaunch) {\n-              continue;\n-            }\n-            LOG.info(\"In TaskLauncher, current free slots : \" + numFreeSlots.get()+\n-                     \" and trying to launch \"+tip.getTask().getTaskID() + \n-                     \" which needs \" + task.getNumSlotsRequired() + \" slots\");\n-            numFreeSlots.set(numFreeSlots.get() - task.getNumSlotsRequired());\n-            assert (numFreeSlots.get() \u003e\u003d 0);\n-          }\n-          synchronized (tip) {\n-            //to make sure that there is no kill task action for this\n-            if (!tip.canBeLaunched()) {\n-              //got killed externally while still in the launcher queue\n-              LOG.info(\"Not launching task \" + task.getTaskID() + \" as it got\"\n-                + \" killed externally. Task\u0027s state is \" + tip.getRunState());\n-              addFreeSlots(task.getNumSlotsRequired());\n-              continue;\n-            }\n-            tip.slotTaken \u003d true;\n-          }\n-          //got a free slot. launch the task\n-          startNewTask(tip);\n-        } catch (InterruptedException e) { \n-          return; // ALL DONE\n-        } catch (Throwable th) {\n-          LOG.error(\"TaskLauncher error \" + \n-              StringUtils.stringifyException(th));\n+          Thread.sleep(monitoringInterval);\n+        } catch (InterruptedException e) {\n+          LOG.warn(ContainersMonitorImpl.class.getName()\n+              + \" is interrupted. Exiting.\");\n+          break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ProcfsBasedProcessTree pt \u003d\n                    new ProcfsBasedProcessTree(pId,\n                        ContainerExecutor.isSetsidAvailable);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ProcfsBasedProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree \u003d pTree.getProcessTree(); // get the updated process-tree\n            ptInfo.setProcessTree(pTree); // update ptInfo with proces-tree of\n                                          // updated state\n            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            LOG.info(String.format(MEMORY_USAGE_STRING, pId,\n                containerId.toString(), currentVmemUsage, vmemLimit,\n                currentPmemUsage, pmemLimit));\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            if (isVirtualMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d\n                  \"Container [pid\u003d\"\n                      + pId\n                      + \",containerID\u003d\"\n                      + containerId\n                      + \"] is running beyond memory-limits. Current usage : \"\n                      + currentVmemUsage\n                      + \"bytes. Limit : \"\n                      + vmemLimit\n                      + \"bytes. Killing container. \"\n                      + \"\\nDump of the process-tree for \" + containerId\n                      + \" : \\n\" + pTree.getProcessTreeDump();\n              isMemoryOverLimit \u003d true;\n            } else if (isPhysicalMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d\n                  \"Container [pid\u003d\"\n                      + pId\n                      + \",tipID\u003d\"\n                      + containerId\n                      + \"] is running beyond physical memory-limits.\"\n                      + \" Current usage : \"\n                      + currentPmemUsage\n                      + \"bytes. Limit : \"\n                      + pmemLimit\n                      + \"bytes. Killing container. \\nDump of the process-tree for \"\n                      + containerId + \" : \\n\" + pTree.getProcessTreeDump();\n              isMemoryOverLimit \u003d true;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
          "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
          "extendedDetails": {
            "oldPath": "mapreduce/src/java/org/apache/hadoop/mapred/TaskTracker.java",
            "newPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
            "oldMethodName": "run",
            "newMethodName": "run"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/08/11 4:07 AM",
          "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/08/11 8:02 PM",
          "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.34,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,71 +1,171 @@\n     public void run() {\n-      while (!Thread.interrupted()) {\n+\n+      while (true) {\n+\n+        // Print the processTrees for debugging.\n+        if (LOG.isDebugEnabled()) {\n+          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n+          for (ProcessTreeInfo p : trackingContainers.values()) {\n+            tmp.append(p.getPID());\n+            tmp.append(\" \");\n+          }\n+          LOG.debug(\"Current ProcessTree list : \"\n+              + tmp.substring(0, tmp.length()) + \"]\");\n+        }\n+\n+        // Add new containers\n+        synchronized (containersToBeAdded) {\n+          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n+              .entrySet()) {\n+            ContainerId containerId \u003d entry.getKey();\n+            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n+            LOG.info(\"Starting resource-monitoring for \" + containerId);\n+            trackingContainers.put(containerId, processTreeInfo);\n+          }\n+          containersToBeAdded.clear();\n+        }\n+\n+        // Remove finished containers\n+        synchronized (containersToBeRemoved) {\n+          for (ContainerId containerId : containersToBeRemoved) {\n+            trackingContainers.remove(containerId);\n+            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n+          }\n+          containersToBeRemoved.clear();\n+        }\n+\n+        // Now do the monitoring for the trackingContainers\n+        // Check memory usage and kill any overflowing containers\n+        long vmemStillInUsage \u003d 0;\n+        long pmemStillInUsage \u003d 0;\n+        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n+            trackingContainers.entrySet().iterator(); it.hasNext();) {\n+\n+          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n+          ContainerId containerId \u003d entry.getKey();\n+          ProcessTreeInfo ptInfo \u003d entry.getValue();\n+          try {\n+            String pId \u003d ptInfo.getPID();\n+\n+            // Initialize any uninitialized processTrees\n+            if (pId \u003d\u003d null) {\n+              // get pid from ContainerId\n+              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n+              if (pId !\u003d null) {\n+                // pId will be null, either if the container is not spawned yet\n+                // or if the container\u0027s pid is removed from ContainerExecutor\n+                LOG.debug(\"Tracking ProcessTree \" + pId\n+                    + \" for the first time\");\n+\n+                ProcfsBasedProcessTree pt \u003d\n+                    new ProcfsBasedProcessTree(pId,\n+                        ContainerExecutor.isSetsidAvailable);\n+                ptInfo.setPid(pId);\n+                ptInfo.setProcessTree(pt);\n+              }\n+            }\n+            // End of initializing any uninitialized processTrees\n+\n+            if (pId \u003d\u003d null) {\n+              continue; // processTree cannot be tracked\n+            }\n+\n+            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n+                + \" ContainerId \u003d \" + containerId);\n+            ProcfsBasedProcessTree pTree \u003d ptInfo.getProcessTree();\n+            pTree \u003d pTree.getProcessTree(); // get the updated process-tree\n+            ptInfo.setProcessTree(pTree); // update ptInfo with proces-tree of\n+                                          // updated state\n+            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n+            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n+            // as processes begin with an age 1, we want to see if there\n+            // are processes more than 1 iteration old.\n+            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n+            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n+            long vmemLimit \u003d ptInfo.getVmemLimit();\n+            long pmemLimit \u003d ptInfo.getPmemLimit();\n+            LOG.info(String.format(MEMORY_USAGE_STRING, pId,\n+                containerId.toString(), currentVmemUsage, vmemLimit,\n+                currentPmemUsage, pmemLimit));\n+\n+            boolean isMemoryOverLimit \u003d false;\n+            String msg \u003d \"\";\n+            if (isVirtualMemoryCheckEnabled()\n+                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n+                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n+              // Container (the root process) is still alive and overflowing\n+              // memory.\n+              // Dump the process-tree and then clean it up.\n+              msg \u003d\n+                  \"Container [pid\u003d\"\n+                      + pId\n+                      + \",containerID\u003d\"\n+                      + containerId\n+                      + \"] is running beyond memory-limits. Current usage : \"\n+                      + currentVmemUsage\n+                      + \"bytes. Limit : \"\n+                      + vmemLimit\n+                      + \"bytes. Killing container. \"\n+                      + \"\\nDump of the process-tree for \" + containerId\n+                      + \" : \\n\" + pTree.getProcessTreeDump();\n+              isMemoryOverLimit \u003d true;\n+            } else if (isPhysicalMemoryCheckEnabled()\n+                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n+                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n+                    pmemLimit)) {\n+              // Container (the root process) is still alive and overflowing\n+              // memory.\n+              // Dump the process-tree and then clean it up.\n+              msg \u003d\n+                  \"Container [pid\u003d\"\n+                      + pId\n+                      + \",tipID\u003d\"\n+                      + containerId\n+                      + \"] is running beyond physical memory-limits.\"\n+                      + \" Current usage : \"\n+                      + currentPmemUsage\n+                      + \"bytes. Limit : \"\n+                      + pmemLimit\n+                      + \"bytes. Killing container. \\nDump of the process-tree for \"\n+                      + containerId + \" : \\n\" + pTree.getProcessTreeDump();\n+              isMemoryOverLimit \u003d true;\n+            }\n+\n+            if (isMemoryOverLimit) {\n+              // Virtual or physical memory over limit. Fail the container and\n+              // remove\n+              // the corresponding process tree\n+              LOG.warn(msg);\n+              // warn if not a leader\n+              if (!pTree.checkPidPgrpidForMatch()) {\n+                LOG.error(\"Killed container process with PID \" + pId\n+                    + \" but it is not a process group leader.\");\n+              }\n+              // kill the container\n+              eventDispatcher.getEventHandler().handle(\n+                  new ContainerKillEvent(containerId, msg));\n+              it.remove();\n+              LOG.info(\"Removed ProcessTree with root \" + pId);\n+            } else {\n+              // Accounting the total memory in usage for all containers that\n+              // are still\n+              // alive and within limits.\n+              vmemStillInUsage +\u003d currentVmemUsage;\n+              pmemStillInUsage +\u003d currentPmemUsage;\n+            }\n+          } catch (Exception e) {\n+            // Log the exception and proceed to the next container.\n+            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n+                + \"while managing memory of \" + containerId, e);\n+          }\n+        }\n+\n         try {\n-          TaskInProgress tip;\n-          Task task;\n-          synchronized (tasksToLaunch) {\n-            while (tasksToLaunch.isEmpty()) {\n-              tasksToLaunch.wait();\n-            }\n-            //get the TIP\n-            tip \u003d tasksToLaunch.remove(0);\n-            task \u003d tip.getTask();\n-            LOG.info(\"Trying to launch : \" + tip.getTask().getTaskID() + \n-                     \" which needs \" + task.getNumSlotsRequired() + \" slots\");\n-          }\n-          //wait for free slots to run\n-          synchronized (numFreeSlots) {\n-            boolean canLaunch \u003d true;\n-            while (numFreeSlots.get() \u003c task.getNumSlotsRequired()) {\n-              //Make sure that there is no kill task action for this task!\n-              //We are not locking tip here, because it would reverse the\n-              //locking order!\n-              //Also, Lock for the tip is not required here! because :\n-              // 1. runState of TaskStatus is volatile\n-              // 2. Any notification is not missed because notification is\n-              // synchronized on numFreeSlots. So, while we are doing the check,\n-              // if the tip is half way through the kill(), we don\u0027t miss\n-              // notification for the following wait(). \n-              if (!tip.canBeLaunched()) {\n-                //got killed externally while still in the launcher queue\n-                LOG.info(\"Not blocking slots for \" + task.getTaskID()\n-                    + \" as it got killed externally. Task\u0027s state is \"\n-                    + tip.getRunState());\n-                canLaunch \u003d false;\n-                break;\n-              }              \n-              LOG.info(\"TaskLauncher : Waiting for \" + task.getNumSlotsRequired() + \n-                       \" to launch \" + task.getTaskID() + \", currently we have \" + \n-                       numFreeSlots.get() + \" free slots\");\n-              numFreeSlots.wait();\n-            }\n-            if (!canLaunch) {\n-              continue;\n-            }\n-            LOG.info(\"In TaskLauncher, current free slots : \" + numFreeSlots.get()+\n-                     \" and trying to launch \"+tip.getTask().getTaskID() + \n-                     \" which needs \" + task.getNumSlotsRequired() + \" slots\");\n-            numFreeSlots.set(numFreeSlots.get() - task.getNumSlotsRequired());\n-            assert (numFreeSlots.get() \u003e\u003d 0);\n-          }\n-          synchronized (tip) {\n-            //to make sure that there is no kill task action for this\n-            if (!tip.canBeLaunched()) {\n-              //got killed externally while still in the launcher queue\n-              LOG.info(\"Not launching task \" + task.getTaskID() + \" as it got\"\n-                + \" killed externally. Task\u0027s state is \" + tip.getRunState());\n-              addFreeSlots(task.getNumSlotsRequired());\n-              continue;\n-            }\n-            tip.slotTaken \u003d true;\n-          }\n-          //got a free slot. launch the task\n-          startNewTask(tip);\n-        } catch (InterruptedException e) { \n-          return; // ALL DONE\n-        } catch (Throwable th) {\n-          LOG.error(\"TaskLauncher error \" + \n-              StringUtils.stringifyException(th));\n+          Thread.sleep(monitoringInterval);\n+        } catch (InterruptedException e) {\n+          LOG.warn(ContainersMonitorImpl.class.getName()\n+              + \" is interrupted. Exiting.\");\n+          break;\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void run() {\n\n      while (true) {\n\n        // Print the processTrees for debugging.\n        if (LOG.isDebugEnabled()) {\n          StringBuilder tmp \u003d new StringBuilder(\"[ \");\n          for (ProcessTreeInfo p : trackingContainers.values()) {\n            tmp.append(p.getPID());\n            tmp.append(\" \");\n          }\n          LOG.debug(\"Current ProcessTree list : \"\n              + tmp.substring(0, tmp.length()) + \"]\");\n        }\n\n        // Add new containers\n        synchronized (containersToBeAdded) {\n          for (Entry\u003cContainerId, ProcessTreeInfo\u003e entry : containersToBeAdded\n              .entrySet()) {\n            ContainerId containerId \u003d entry.getKey();\n            ProcessTreeInfo processTreeInfo \u003d entry.getValue();\n            LOG.info(\"Starting resource-monitoring for \" + containerId);\n            trackingContainers.put(containerId, processTreeInfo);\n          }\n          containersToBeAdded.clear();\n        }\n\n        // Remove finished containers\n        synchronized (containersToBeRemoved) {\n          for (ContainerId containerId : containersToBeRemoved) {\n            trackingContainers.remove(containerId);\n            LOG.info(\"Stopping resource-monitoring for \" + containerId);\n          }\n          containersToBeRemoved.clear();\n        }\n\n        // Now do the monitoring for the trackingContainers\n        // Check memory usage and kill any overflowing containers\n        long vmemStillInUsage \u003d 0;\n        long pmemStillInUsage \u003d 0;\n        for (Iterator\u003cMap.Entry\u003cContainerId, ProcessTreeInfo\u003e\u003e it \u003d\n            trackingContainers.entrySet().iterator(); it.hasNext();) {\n\n          Map.Entry\u003cContainerId, ProcessTreeInfo\u003e entry \u003d it.next();\n          ContainerId containerId \u003d entry.getKey();\n          ProcessTreeInfo ptInfo \u003d entry.getValue();\n          try {\n            String pId \u003d ptInfo.getPID();\n\n            // Initialize any uninitialized processTrees\n            if (pId \u003d\u003d null) {\n              // get pid from ContainerId\n              pId \u003d containerExecutor.getProcessId(ptInfo.getContainerId());\n              if (pId !\u003d null) {\n                // pId will be null, either if the container is not spawned yet\n                // or if the container\u0027s pid is removed from ContainerExecutor\n                LOG.debug(\"Tracking ProcessTree \" + pId\n                    + \" for the first time\");\n\n                ProcfsBasedProcessTree pt \u003d\n                    new ProcfsBasedProcessTree(pId,\n                        ContainerExecutor.isSetsidAvailable);\n                ptInfo.setPid(pId);\n                ptInfo.setProcessTree(pt);\n              }\n            }\n            // End of initializing any uninitialized processTrees\n\n            if (pId \u003d\u003d null) {\n              continue; // processTree cannot be tracked\n            }\n\n            LOG.debug(\"Constructing ProcessTree for : PID \u003d \" + pId\n                + \" ContainerId \u003d \" + containerId);\n            ProcfsBasedProcessTree pTree \u003d ptInfo.getProcessTree();\n            pTree \u003d pTree.getProcessTree(); // get the updated process-tree\n            ptInfo.setProcessTree(pTree); // update ptInfo with proces-tree of\n                                          // updated state\n            long currentVmemUsage \u003d pTree.getCumulativeVmem();\n            long currentPmemUsage \u003d pTree.getCumulativeRssmem();\n            // as processes begin with an age 1, we want to see if there\n            // are processes more than 1 iteration old.\n            long curMemUsageOfAgedProcesses \u003d pTree.getCumulativeVmem(1);\n            long curRssMemUsageOfAgedProcesses \u003d pTree.getCumulativeRssmem(1);\n            long vmemLimit \u003d ptInfo.getVmemLimit();\n            long pmemLimit \u003d ptInfo.getPmemLimit();\n            LOG.info(String.format(MEMORY_USAGE_STRING, pId,\n                containerId.toString(), currentVmemUsage, vmemLimit,\n                currentPmemUsage, pmemLimit));\n\n            boolean isMemoryOverLimit \u003d false;\n            String msg \u003d \"\";\n            if (isVirtualMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d\n                  \"Container [pid\u003d\"\n                      + pId\n                      + \",containerID\u003d\"\n                      + containerId\n                      + \"] is running beyond memory-limits. Current usage : \"\n                      + currentVmemUsage\n                      + \"bytes. Limit : \"\n                      + vmemLimit\n                      + \"bytes. Killing container. \"\n                      + \"\\nDump of the process-tree for \" + containerId\n                      + \" : \\n\" + pTree.getProcessTreeDump();\n              isMemoryOverLimit \u003d true;\n            } else if (isPhysicalMemoryCheckEnabled()\n                \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n                    currentPmemUsage, curRssMemUsageOfAgedProcesses,\n                    pmemLimit)) {\n              // Container (the root process) is still alive and overflowing\n              // memory.\n              // Dump the process-tree and then clean it up.\n              msg \u003d\n                  \"Container [pid\u003d\"\n                      + pId\n                      + \",tipID\u003d\"\n                      + containerId\n                      + \"] is running beyond physical memory-limits.\"\n                      + \" Current usage : \"\n                      + currentPmemUsage\n                      + \"bytes. Limit : \"\n                      + pmemLimit\n                      + \"bytes. Killing container. \\nDump of the process-tree for \"\n                      + containerId + \" : \\n\" + pTree.getProcessTreeDump();\n              isMemoryOverLimit \u003d true;\n            }\n\n            if (isMemoryOverLimit) {\n              // Virtual or physical memory over limit. Fail the container and\n              // remove\n              // the corresponding process tree\n              LOG.warn(msg);\n              // warn if not a leader\n              if (!pTree.checkPidPgrpidForMatch()) {\n                LOG.error(\"Killed container process with PID \" + pId\n                    + \" but it is not a process group leader.\");\n              }\n              // kill the container\n              eventDispatcher.getEventHandler().handle(\n                  new ContainerKillEvent(containerId, msg));\n              it.remove();\n              LOG.info(\"Removed ProcessTree with root \" + pId);\n            } else {\n              // Accounting the total memory in usage for all containers that\n              // are still\n              // alive and within limits.\n              vmemStillInUsage +\u003d currentVmemUsage;\n              pmemStillInUsage +\u003d currentPmemUsage;\n            }\n          } catch (Exception e) {\n            // Log the exception and proceed to the next container.\n            LOG.warn(\"Uncaught exception in ContainerMemoryManager \"\n                + \"while managing memory of \" + containerId, e);\n          }\n        }\n\n        try {\n          Thread.sleep(monitoringInterval);\n        } catch (InterruptedException e) {\n          LOG.warn(ContainersMonitorImpl.class.getName()\n              + \" is interrupted. Exiting.\");\n          break;\n        }\n      }\n    }",
          "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,48 @@\n+  public void run() {\n+    try {\n+      startCleanupThreads();\n+      boolean denied \u003d false;\n+      while (running \u0026\u0026 !shuttingDown \u0026\u0026 !denied) {\n+        boolean staleState \u003d false;\n+        try {\n+          // This while-loop attempts reconnects if we get network errors\n+          while (running \u0026\u0026 !staleState \u0026\u0026 !shuttingDown \u0026\u0026 !denied) {\n+            try {\n+              State osState \u003d offerService();\n+              if (osState \u003d\u003d State.STALE) {\n+                staleState \u003d true;\n+              } else if (osState \u003d\u003d State.DENIED) {\n+                denied \u003d true;\n+              }\n+            } catch (Exception ex) {\n+              if (!shuttingDown) {\n+                LOG.info(\"Lost connection to JobTracker [\" +\n+                         jobTrackAddr + \"].  Retrying...\", ex);\n+                try {\n+                  Thread.sleep(5000);\n+                } catch (InterruptedException ie) {\n+                }\n+              }\n+            }\n+          }\n+        } finally {\n+          close();\n+        }\n+        if (shuttingDown) { return; }\n+        LOG.warn(\"Reinitializing local state\");\n+        initialize();\n+      }\n+      if (denied) {\n+        shutdown();\n+      }\n+    } catch (IOException iex) {\n+      LOG.error(\"Got fatal exception while reinitializing TaskTracker: \" +\n+                StringUtils.stringifyException(iex));\n+      return;\n+    }\n+    catch (InterruptedException i) {\n+      LOG.error(\"Got interrupted while reinitializing TaskTracker: \" + \n+          i.getMessage());\n+      return;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    try {\n      startCleanupThreads();\n      boolean denied \u003d false;\n      while (running \u0026\u0026 !shuttingDown \u0026\u0026 !denied) {\n        boolean staleState \u003d false;\n        try {\n          // This while-loop attempts reconnects if we get network errors\n          while (running \u0026\u0026 !staleState \u0026\u0026 !shuttingDown \u0026\u0026 !denied) {\n            try {\n              State osState \u003d offerService();\n              if (osState \u003d\u003d State.STALE) {\n                staleState \u003d true;\n              } else if (osState \u003d\u003d State.DENIED) {\n                denied \u003d true;\n              }\n            } catch (Exception ex) {\n              if (!shuttingDown) {\n                LOG.info(\"Lost connection to JobTracker [\" +\n                         jobTrackAddr + \"].  Retrying...\", ex);\n                try {\n                  Thread.sleep(5000);\n                } catch (InterruptedException ie) {\n                }\n              }\n            }\n          }\n        } finally {\n          close();\n        }\n        if (shuttingDown) { return; }\n        LOG.warn(\"Reinitializing local state\");\n        initialize();\n      }\n      if (denied) {\n        shutdown();\n      }\n    } catch (IOException iex) {\n      LOG.error(\"Got fatal exception while reinitializing TaskTracker: \" +\n                StringUtils.stringifyException(iex));\n      return;\n    }\n    catch (InterruptedException i) {\n      LOG.error(\"Got interrupted while reinitializing TaskTracker: \" + \n          i.getMessage());\n      return;\n    }\n  }",
      "path": "mapreduce/src/java/org/apache/hadoop/mapred/TaskTracker.java"
    }
  }
}