{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RenameOperation.java",
  "functionName": "recursiveDirectoryRename",
  "functionId": "recursiveDirectoryRename",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/impl/RenameOperation.java",
  "functionStartLine": 305,
  "functionEndLine": 388,
  "numCommitsSeen": 3,
  "timeTaken": 2252,
  "changeHistory": [
    "56dee667707926f3796c7757be1a133a362f05c9",
    "511df1e837b19ccb9271520589452d82d50ac69d",
    "e02eb24e0a9139418120027b694492e0738df20a"
  ],
  "changeHistoryShort": {
    "56dee667707926f3796c7757be1a133a362f05c9": "Ybodychange",
    "511df1e837b19ccb9271520589452d82d50ac69d": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "56dee667707926f3796c7757be1a133a362f05c9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16823. Large DeleteObject requests are their own Thundering Herd.\n\nContributed by Steve Loughran.\n\nDuring S3A rename() and delete() calls, the list of objects delete is\nbuilt up into batches of a thousand and then POSTed in a single large\nDeleteObjects request.\n\nBut as the IO capacity allowed on an S3 partition may only be 3500 writes\nper second *and* each entry in that POST counts as a single write, then\none of those posts alone can trigger throttling on an already loaded\nS3 directory tree. Which can trigger backoff and retry, with the same\nthousand entry post, and so recreate the exact same problem.\n\nFixes\n\n* Page size for delete object requests is set in\n  fs.s3a.bulk.delete.page.size; the default is 250.\n* The property fs.s3a.experimental.aws.s3.throttling (default\u003dtrue)\n  can be set to false to disable throttle retry logic in the AWS\n  client SDK -it is all handled in the S3A client. This\n  gives more visibility in to when operations are being throttled\n* Bulk delete throttling events are logged to the log\n  org.apache.hadoop.fs.s3a.throttled log at INFO; if this appears\n  often then choose a smaller page size.\n* The metric \"store_io_throttled\" adds the entire count of delete\n  requests when a single DeleteObjects request is throttled.\n* A new quantile, \"store_io_throttle_rate\" can track throttling\n  load over time.\n* DynamoDB metastore throttle resilience issues have also been\n  identified and fixed. Note: the fs.s3a.experimental.aws.s3.throttling\n  flag does not apply to DDB IO precisely because there may still be\n  lurking issues there and it safest to rely on the DynamoDB client\n  SDK.\n\nChange-Id: I00f85cdd94fc008864d060533f6bd4870263fd84\n",
      "commitDate": "13/02/20 11:09 AM",
      "commitName": "56dee667707926f3796c7757be1a133a362f05c9",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/09/19 6:25 AM",
      "commitNameOld": "511df1e837b19ccb9271520589452d82d50ac69d",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 161.24,
      "commitsBetweenForRepo": 741,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n   protected void recursiveDirectoryRename() throws IOException {\n     final StoreContext storeContext \u003d getStoreContext();\n \n     LOG.debug(\"rename: renaming directory {} to {}\", sourcePath, destPath);\n \n     // This is a directory-to-directory copy\n     String dstKey \u003d maybeAddTrailingSlash(destKey);\n     String srcKey \u003d maybeAddTrailingSlash(sourceKey);\n \n     // Verify dest is not a child of the source directory\n     if (dstKey.startsWith(srcKey)) {\n       throw new RenameFailedException(srcKey, dstKey,\n           \"cannot rename a directory to a subdirectory of itself \");\n     }\n \n     if (destStatus !\u003d null\n         \u0026\u0026 destStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n       // delete unnecessary fake directory at the destination.\n       // this MUST be done before anything else so that\n       // rollback code doesn\u0027t get confused and insert a tombstone\n       // marker.\n       LOG.debug(\"Deleting fake directory marker at destination {}\",\n           destStatus.getPath());\n       callbacks.deleteObjectAtPath(destStatus.getPath(), dstKey, false, null);\n     }\n \n     Path parentPath \u003d storeContext.keyToPath(srcKey);\n     final RemoteIterator\u003cS3ALocatedFileStatus\u003e iterator \u003d\n         callbacks.listFilesAndEmptyDirectories(parentPath,\n             sourceStatus,\n             true,\n             true);\n     while (iterator.hasNext()) {\n       // get the next entry in the listing.\n       S3ALocatedFileStatus child \u003d iterator.next();\n       // convert it to an S3 key.\n       String k \u003d storeContext.pathToKey(child.getPath());\n       // possibly adding a \"/\" if it represents directory and it does\n       // not have a trailing slash already.\n       String key \u003d (child.isDirectory() \u0026\u0026 !k.endsWith(\"/\"))\n           ? k + \"/\"\n           : k;\n       // the source object to copy as a path.\n       Path childSourcePath \u003d storeContext.keyToPath(key);\n \n       // mark for deletion on a successful copy.\n       queueToDelete(childSourcePath, key);\n \n       // the destination key is that of the key under the source tree,\n       // remapped under the new destination path.\n       String newDestKey \u003d\n           dstKey + key.substring(srcKey.length());\n       Path childDestPath \u003d storeContext.keyToPath(newDestKey);\n \n       // now begin the single copy\n       CompletableFuture\u003cPath\u003e copy \u003d initiateCopy(child, key,\n           childSourcePath, newDestKey, childDestPath);\n       activeCopies.add(copy);\n       bytesCopied.addAndGet(sourceStatus.getLen());\n \n       if (activeCopies.size() \u003d\u003d RENAME_PARALLEL_LIMIT) {\n         // the limit of active copies has been reached;\n         // wait for completion or errors to surface.\n         LOG.debug(\"Waiting for active copies to complete\");\n         completeActiveCopies(\"batch threshold reached\");\n       }\n-      if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n+      if (keysToDelete.size() \u003d\u003d pageSize) {\n         // finish ongoing copies then delete all queued keys.\n         // provided the parallel limit is a factor of the max entry\n         // constant, this will not need to block for the copy, and\n         // simply jump straight to the delete.\n         completeActiveCopiesAndDeleteSources(\"paged delete\");\n       }\n     } // end of iteration through the list\n \n     // await the final set of copies and their deletion\n     // This will notify the renameTracker that these objects\n     // have been deleted.\n     completeActiveCopiesAndDeleteSources(\"final copy and delete\");\n \n     // We moved all the children, now move the top-level dir\n     // Empty directory should have been added as the object summary\n     renameTracker.moveSourceDirectory();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void recursiveDirectoryRename() throws IOException {\n    final StoreContext storeContext \u003d getStoreContext();\n\n    LOG.debug(\"rename: renaming directory {} to {}\", sourcePath, destPath);\n\n    // This is a directory-to-directory copy\n    String dstKey \u003d maybeAddTrailingSlash(destKey);\n    String srcKey \u003d maybeAddTrailingSlash(sourceKey);\n\n    // Verify dest is not a child of the source directory\n    if (dstKey.startsWith(srcKey)) {\n      throw new RenameFailedException(srcKey, dstKey,\n          \"cannot rename a directory to a subdirectory of itself \");\n    }\n\n    if (destStatus !\u003d null\n        \u0026\u0026 destStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n      // delete unnecessary fake directory at the destination.\n      // this MUST be done before anything else so that\n      // rollback code doesn\u0027t get confused and insert a tombstone\n      // marker.\n      LOG.debug(\"Deleting fake directory marker at destination {}\",\n          destStatus.getPath());\n      callbacks.deleteObjectAtPath(destStatus.getPath(), dstKey, false, null);\n    }\n\n    Path parentPath \u003d storeContext.keyToPath(srcKey);\n    final RemoteIterator\u003cS3ALocatedFileStatus\u003e iterator \u003d\n        callbacks.listFilesAndEmptyDirectories(parentPath,\n            sourceStatus,\n            true,\n            true);\n    while (iterator.hasNext()) {\n      // get the next entry in the listing.\n      S3ALocatedFileStatus child \u003d iterator.next();\n      // convert it to an S3 key.\n      String k \u003d storeContext.pathToKey(child.getPath());\n      // possibly adding a \"/\" if it represents directory and it does\n      // not have a trailing slash already.\n      String key \u003d (child.isDirectory() \u0026\u0026 !k.endsWith(\"/\"))\n          ? k + \"/\"\n          : k;\n      // the source object to copy as a path.\n      Path childSourcePath \u003d storeContext.keyToPath(key);\n\n      // mark for deletion on a successful copy.\n      queueToDelete(childSourcePath, key);\n\n      // the destination key is that of the key under the source tree,\n      // remapped under the new destination path.\n      String newDestKey \u003d\n          dstKey + key.substring(srcKey.length());\n      Path childDestPath \u003d storeContext.keyToPath(newDestKey);\n\n      // now begin the single copy\n      CompletableFuture\u003cPath\u003e copy \u003d initiateCopy(child, key,\n          childSourcePath, newDestKey, childDestPath);\n      activeCopies.add(copy);\n      bytesCopied.addAndGet(sourceStatus.getLen());\n\n      if (activeCopies.size() \u003d\u003d RENAME_PARALLEL_LIMIT) {\n        // the limit of active copies has been reached;\n        // wait for completion or errors to surface.\n        LOG.debug(\"Waiting for active copies to complete\");\n        completeActiveCopies(\"batch threshold reached\");\n      }\n      if (keysToDelete.size() \u003d\u003d pageSize) {\n        // finish ongoing copies then delete all queued keys.\n        // provided the parallel limit is a factor of the max entry\n        // constant, this will not need to block for the copy, and\n        // simply jump straight to the delete.\n        completeActiveCopiesAndDeleteSources(\"paged delete\");\n      }\n    } // end of iteration through the list\n\n    // await the final set of copies and their deletion\n    // This will notify the renameTracker that these objects\n    // have been deleted.\n    completeActiveCopiesAndDeleteSources(\"final copy and delete\");\n\n    // We moved all the children, now move the top-level dir\n    // Empty directory should have been added as the object summary\n    renameTracker.moveSourceDirectory();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/impl/RenameOperation.java",
      "extendedDetails": {}
    },
    "511df1e837b19ccb9271520589452d82d50ac69d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16430. S3AFilesystem.delete to incrementally update s3guard with deletions\n\nContributed by Steve Loughran.\n\nThis overlaps the scanning for directory entries with batched calls to S3 DELETE and updates of the S3Guard tables.\nIt also uses S3Guard to list the files to delete, so find newly created files even when S3 listings are not use consistent.\n\nFor path which the client considers S3Guard to be authoritative, we also do a recursive LIST of the store and delete files; this is to find unindexed files and do guarantee that the delete(path, true) call really does delete everything underneath.\n\nChange-Id: Ice2f6e940c506e0b3a78fa534a99721b1698708e\n",
      "commitDate": "05/09/19 6:25 AM",
      "commitName": "511df1e837b19ccb9271520589452d82d50ac69d",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/06/19 1:56 AM",
      "commitNameOld": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 77.19,
      "commitsBetweenForRepo": 691,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,84 @@\n   protected void recursiveDirectoryRename() throws IOException {\n     final StoreContext storeContext \u003d getStoreContext();\n \n     LOG.debug(\"rename: renaming directory {} to {}\", sourcePath, destPath);\n \n     // This is a directory-to-directory copy\n     String dstKey \u003d maybeAddTrailingSlash(destKey);\n     String srcKey \u003d maybeAddTrailingSlash(sourceKey);\n \n     // Verify dest is not a child of the source directory\n     if (dstKey.startsWith(srcKey)) {\n       throw new RenameFailedException(srcKey, dstKey,\n           \"cannot rename a directory to a subdirectory of itself \");\n     }\n \n     if (destStatus !\u003d null\n         \u0026\u0026 destStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n       // delete unnecessary fake directory at the destination.\n       // this MUST be done before anything else so that\n       // rollback code doesn\u0027t get confused and insert a tombstone\n       // marker.\n       LOG.debug(\"Deleting fake directory marker at destination {}\",\n           destStatus.getPath());\n-      callbacks.deleteObjectAtPath(destStatus.getPath(), dstKey, false);\n+      callbacks.deleteObjectAtPath(destStatus.getPath(), dstKey, false, null);\n     }\n \n     Path parentPath \u003d storeContext.keyToPath(srcKey);\n     final RemoteIterator\u003cS3ALocatedFileStatus\u003e iterator \u003d\n-        callbacks.listFilesAndEmptyDirectories(parentPath);\n+        callbacks.listFilesAndEmptyDirectories(parentPath,\n+            sourceStatus,\n+            true,\n+            true);\n     while (iterator.hasNext()) {\n       // get the next entry in the listing.\n       S3ALocatedFileStatus child \u003d iterator.next();\n       // convert it to an S3 key.\n       String k \u003d storeContext.pathToKey(child.getPath());\n       // possibly adding a \"/\" if it represents directory and it does\n       // not have a trailing slash already.\n       String key \u003d (child.isDirectory() \u0026\u0026 !k.endsWith(\"/\"))\n           ? k + \"/\"\n           : k;\n       // the source object to copy as a path.\n       Path childSourcePath \u003d storeContext.keyToPath(key);\n \n       // mark for deletion on a successful copy.\n       queueToDelete(childSourcePath, key);\n \n       // the destination key is that of the key under the source tree,\n       // remapped under the new destination path.\n       String newDestKey \u003d\n           dstKey + key.substring(srcKey.length());\n       Path childDestPath \u003d storeContext.keyToPath(newDestKey);\n \n       // now begin the single copy\n       CompletableFuture\u003cPath\u003e copy \u003d initiateCopy(child, key,\n           childSourcePath, newDestKey, childDestPath);\n       activeCopies.add(copy);\n       bytesCopied.addAndGet(sourceStatus.getLen());\n \n       if (activeCopies.size() \u003d\u003d RENAME_PARALLEL_LIMIT) {\n         // the limit of active copies has been reached;\n         // wait for completion or errors to surface.\n         LOG.debug(\"Waiting for active copies to complete\");\n         completeActiveCopies(\"batch threshold reached\");\n       }\n       if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n         // finish ongoing copies then delete all queued keys.\n         // provided the parallel limit is a factor of the max entry\n         // constant, this will not need to block for the copy, and\n         // simply jump straight to the delete.\n         completeActiveCopiesAndDeleteSources(\"paged delete\");\n       }\n     } // end of iteration through the list\n \n     // await the final set of copies and their deletion\n     // This will notify the renameTracker that these objects\n     // have been deleted.\n     completeActiveCopiesAndDeleteSources(\"final copy and delete\");\n \n     // We moved all the children, now move the top-level dir\n     // Empty directory should have been added as the object summary\n     renameTracker.moveSourceDirectory();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void recursiveDirectoryRename() throws IOException {\n    final StoreContext storeContext \u003d getStoreContext();\n\n    LOG.debug(\"rename: renaming directory {} to {}\", sourcePath, destPath);\n\n    // This is a directory-to-directory copy\n    String dstKey \u003d maybeAddTrailingSlash(destKey);\n    String srcKey \u003d maybeAddTrailingSlash(sourceKey);\n\n    // Verify dest is not a child of the source directory\n    if (dstKey.startsWith(srcKey)) {\n      throw new RenameFailedException(srcKey, dstKey,\n          \"cannot rename a directory to a subdirectory of itself \");\n    }\n\n    if (destStatus !\u003d null\n        \u0026\u0026 destStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n      // delete unnecessary fake directory at the destination.\n      // this MUST be done before anything else so that\n      // rollback code doesn\u0027t get confused and insert a tombstone\n      // marker.\n      LOG.debug(\"Deleting fake directory marker at destination {}\",\n          destStatus.getPath());\n      callbacks.deleteObjectAtPath(destStatus.getPath(), dstKey, false, null);\n    }\n\n    Path parentPath \u003d storeContext.keyToPath(srcKey);\n    final RemoteIterator\u003cS3ALocatedFileStatus\u003e iterator \u003d\n        callbacks.listFilesAndEmptyDirectories(parentPath,\n            sourceStatus,\n            true,\n            true);\n    while (iterator.hasNext()) {\n      // get the next entry in the listing.\n      S3ALocatedFileStatus child \u003d iterator.next();\n      // convert it to an S3 key.\n      String k \u003d storeContext.pathToKey(child.getPath());\n      // possibly adding a \"/\" if it represents directory and it does\n      // not have a trailing slash already.\n      String key \u003d (child.isDirectory() \u0026\u0026 !k.endsWith(\"/\"))\n          ? k + \"/\"\n          : k;\n      // the source object to copy as a path.\n      Path childSourcePath \u003d storeContext.keyToPath(key);\n\n      // mark for deletion on a successful copy.\n      queueToDelete(childSourcePath, key);\n\n      // the destination key is that of the key under the source tree,\n      // remapped under the new destination path.\n      String newDestKey \u003d\n          dstKey + key.substring(srcKey.length());\n      Path childDestPath \u003d storeContext.keyToPath(newDestKey);\n\n      // now begin the single copy\n      CompletableFuture\u003cPath\u003e copy \u003d initiateCopy(child, key,\n          childSourcePath, newDestKey, childDestPath);\n      activeCopies.add(copy);\n      bytesCopied.addAndGet(sourceStatus.getLen());\n\n      if (activeCopies.size() \u003d\u003d RENAME_PARALLEL_LIMIT) {\n        // the limit of active copies has been reached;\n        // wait for completion or errors to surface.\n        LOG.debug(\"Waiting for active copies to complete\");\n        completeActiveCopies(\"batch threshold reached\");\n      }\n      if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n        // finish ongoing copies then delete all queued keys.\n        // provided the parallel limit is a factor of the max entry\n        // constant, this will not need to block for the copy, and\n        // simply jump straight to the delete.\n        completeActiveCopiesAndDeleteSources(\"paged delete\");\n      }\n    } // end of iteration through the list\n\n    // await the final set of copies and their deletion\n    // This will notify the renameTracker that these objects\n    // have been deleted.\n    completeActiveCopiesAndDeleteSources(\"final copy and delete\");\n\n    // We moved all the children, now move the top-level dir\n    // Empty directory should have been added as the object summary\n    renameTracker.moveSourceDirectory();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/impl/RenameOperation.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,81 @@\n+  protected void recursiveDirectoryRename() throws IOException {\n+    final StoreContext storeContext \u003d getStoreContext();\n+\n+    LOG.debug(\"rename: renaming directory {} to {}\", sourcePath, destPath);\n+\n+    // This is a directory-to-directory copy\n+    String dstKey \u003d maybeAddTrailingSlash(destKey);\n+    String srcKey \u003d maybeAddTrailingSlash(sourceKey);\n+\n+    // Verify dest is not a child of the source directory\n+    if (dstKey.startsWith(srcKey)) {\n+      throw new RenameFailedException(srcKey, dstKey,\n+          \"cannot rename a directory to a subdirectory of itself \");\n+    }\n+\n+    if (destStatus !\u003d null\n+        \u0026\u0026 destStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n+      // delete unnecessary fake directory at the destination.\n+      // this MUST be done before anything else so that\n+      // rollback code doesn\u0027t get confused and insert a tombstone\n+      // marker.\n+      LOG.debug(\"Deleting fake directory marker at destination {}\",\n+          destStatus.getPath());\n+      callbacks.deleteObjectAtPath(destStatus.getPath(), dstKey, false);\n+    }\n+\n+    Path parentPath \u003d storeContext.keyToPath(srcKey);\n+    final RemoteIterator\u003cS3ALocatedFileStatus\u003e iterator \u003d\n+        callbacks.listFilesAndEmptyDirectories(parentPath);\n+    while (iterator.hasNext()) {\n+      // get the next entry in the listing.\n+      S3ALocatedFileStatus child \u003d iterator.next();\n+      // convert it to an S3 key.\n+      String k \u003d storeContext.pathToKey(child.getPath());\n+      // possibly adding a \"/\" if it represents directory and it does\n+      // not have a trailing slash already.\n+      String key \u003d (child.isDirectory() \u0026\u0026 !k.endsWith(\"/\"))\n+          ? k + \"/\"\n+          : k;\n+      // the source object to copy as a path.\n+      Path childSourcePath \u003d storeContext.keyToPath(key);\n+\n+      // mark for deletion on a successful copy.\n+      queueToDelete(childSourcePath, key);\n+\n+      // the destination key is that of the key under the source tree,\n+      // remapped under the new destination path.\n+      String newDestKey \u003d\n+          dstKey + key.substring(srcKey.length());\n+      Path childDestPath \u003d storeContext.keyToPath(newDestKey);\n+\n+      // now begin the single copy\n+      CompletableFuture\u003cPath\u003e copy \u003d initiateCopy(child, key,\n+          childSourcePath, newDestKey, childDestPath);\n+      activeCopies.add(copy);\n+      bytesCopied.addAndGet(sourceStatus.getLen());\n+\n+      if (activeCopies.size() \u003d\u003d RENAME_PARALLEL_LIMIT) {\n+        // the limit of active copies has been reached;\n+        // wait for completion or errors to surface.\n+        LOG.debug(\"Waiting for active copies to complete\");\n+        completeActiveCopies(\"batch threshold reached\");\n+      }\n+      if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n+        // finish ongoing copies then delete all queued keys.\n+        // provided the parallel limit is a factor of the max entry\n+        // constant, this will not need to block for the copy, and\n+        // simply jump straight to the delete.\n+        completeActiveCopiesAndDeleteSources(\"paged delete\");\n+      }\n+    } // end of iteration through the list\n+\n+    // await the final set of copies and their deletion\n+    // This will notify the renameTracker that these objects\n+    // have been deleted.\n+    completeActiveCopiesAndDeleteSources(\"final copy and delete\");\n+\n+    // We moved all the children, now move the top-level dir\n+    // Empty directory should have been added as the object summary\n+    renameTracker.moveSourceDirectory();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void recursiveDirectoryRename() throws IOException {\n    final StoreContext storeContext \u003d getStoreContext();\n\n    LOG.debug(\"rename: renaming directory {} to {}\", sourcePath, destPath);\n\n    // This is a directory-to-directory copy\n    String dstKey \u003d maybeAddTrailingSlash(destKey);\n    String srcKey \u003d maybeAddTrailingSlash(sourceKey);\n\n    // Verify dest is not a child of the source directory\n    if (dstKey.startsWith(srcKey)) {\n      throw new RenameFailedException(srcKey, dstKey,\n          \"cannot rename a directory to a subdirectory of itself \");\n    }\n\n    if (destStatus !\u003d null\n        \u0026\u0026 destStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n      // delete unnecessary fake directory at the destination.\n      // this MUST be done before anything else so that\n      // rollback code doesn\u0027t get confused and insert a tombstone\n      // marker.\n      LOG.debug(\"Deleting fake directory marker at destination {}\",\n          destStatus.getPath());\n      callbacks.deleteObjectAtPath(destStatus.getPath(), dstKey, false);\n    }\n\n    Path parentPath \u003d storeContext.keyToPath(srcKey);\n    final RemoteIterator\u003cS3ALocatedFileStatus\u003e iterator \u003d\n        callbacks.listFilesAndEmptyDirectories(parentPath);\n    while (iterator.hasNext()) {\n      // get the next entry in the listing.\n      S3ALocatedFileStatus child \u003d iterator.next();\n      // convert it to an S3 key.\n      String k \u003d storeContext.pathToKey(child.getPath());\n      // possibly adding a \"/\" if it represents directory and it does\n      // not have a trailing slash already.\n      String key \u003d (child.isDirectory() \u0026\u0026 !k.endsWith(\"/\"))\n          ? k + \"/\"\n          : k;\n      // the source object to copy as a path.\n      Path childSourcePath \u003d storeContext.keyToPath(key);\n\n      // mark for deletion on a successful copy.\n      queueToDelete(childSourcePath, key);\n\n      // the destination key is that of the key under the source tree,\n      // remapped under the new destination path.\n      String newDestKey \u003d\n          dstKey + key.substring(srcKey.length());\n      Path childDestPath \u003d storeContext.keyToPath(newDestKey);\n\n      // now begin the single copy\n      CompletableFuture\u003cPath\u003e copy \u003d initiateCopy(child, key,\n          childSourcePath, newDestKey, childDestPath);\n      activeCopies.add(copy);\n      bytesCopied.addAndGet(sourceStatus.getLen());\n\n      if (activeCopies.size() \u003d\u003d RENAME_PARALLEL_LIMIT) {\n        // the limit of active copies has been reached;\n        // wait for completion or errors to surface.\n        LOG.debug(\"Waiting for active copies to complete\");\n        completeActiveCopies(\"batch threshold reached\");\n      }\n      if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n        // finish ongoing copies then delete all queued keys.\n        // provided the parallel limit is a factor of the max entry\n        // constant, this will not need to block for the copy, and\n        // simply jump straight to the delete.\n        completeActiveCopiesAndDeleteSources(\"paged delete\");\n      }\n    } // end of iteration through the list\n\n    // await the final set of copies and their deletion\n    // This will notify the renameTracker that these objects\n    // have been deleted.\n    completeActiveCopiesAndDeleteSources(\"final copy and delete\");\n\n    // We moved all the children, now move the top-level dir\n    // Empty directory should have been added as the object summary\n    renameTracker.moveSourceDirectory();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/impl/RenameOperation.java"
    }
  }
}