{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PmemVolumeManager.java",
  "functionName": "loadVolumes",
  "functionId": "loadVolumes___volumes-String[]",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/PmemVolumeManager.java",
  "functionStartLine": 230,
  "functionEndLine": 265,
  "numCommitsSeen": 4,
  "timeTaken": 3005,
  "changeHistory": [
    "d79cce20abbbf321f6dcce03f4087544124a7cd2",
    "f6fa865d6fcb0ef0a25a00615f16f383e5032373",
    "9b0aace1e6c54f201784912c0b623707aa82b761",
    "35ff31dd9462cf4fb4ebf5556ee8ae6bcd7c5c3a"
  ],
  "changeHistoryShort": {
    "d79cce20abbbf321f6dcce03f4087544124a7cd2": "Ybodychange",
    "f6fa865d6fcb0ef0a25a00615f16f383e5032373": "Ybodychange",
    "9b0aace1e6c54f201784912c0b623707aa82b761": "Ybodychange",
    "35ff31dd9462cf4fb4ebf5556ee8ae6bcd7c5c3a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d79cce20abbbf321f6dcce03f4087544124a7cd2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14740. Recover data blocks from persistent memory read cache during datanode restarts. Contributed by Feilong He.\n",
      "commitDate": "01/01/20 10:14 PM",
      "commitName": "d79cce20abbbf321f6dcce03f4087544124a7cd2",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "09/08/19 1:37 AM",
      "commitNameOld": "f6fa865d6fcb0ef0a25a00615f16f383e5032373",
      "commitAuthorOld": "Rakesh Radhakrishnan",
      "daysBetweenCommits": 145.9,
      "commitsBetweenForRepo": 853,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,36 @@\n   private void loadVolumes(String[] volumes)\n       throws IOException {\n     // Check whether the volume exists\n     for (byte n \u003d 0; n \u003c volumes.length; n++) {\n       try {\n         File pmemDir \u003d new File(volumes[n]);\n         File realPmemDir \u003d verifyIfValidPmemVolume(pmemDir);\n-        // Clean up the cache left before, if any.\n-        cleanup(realPmemDir);\n+        if (!cacheRecoveryEnabled) {\n+          // Clean up the cache left before, if any.\n+          cleanup(realPmemDir);\n+        }\n         this.pmemVolumes.add(realPmemDir.getPath());\n         long maxBytes;\n         if (maxBytesPerPmem \u003d\u003d -1) {\n           maxBytes \u003d realPmemDir.getUsableSpace();\n         } else {\n           maxBytes \u003d maxBytesPerPmem;\n         }\n         UsedBytesCount usedBytesCount \u003d new UsedBytesCount(maxBytes);\n         this.usedBytesCounts.add(usedBytesCount);\n         LOG.info(\"Added persistent memory - {} with size\u003d{}\",\n             volumes[n], maxBytes);\n       } catch (IllegalArgumentException e) {\n         LOG.error(\"Failed to parse persistent memory volume \" + volumes[n], e);\n         continue;\n       } catch (IOException e) {\n         LOG.error(\"Bad persistent memory volume: \" + volumes[n], e);\n         continue;\n       }\n     }\n     count \u003d pmemVolumes.size();\n     if (count \u003d\u003d 0) {\n       throw new IOException(\n           \"At least one valid persistent memory volume is required!\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadVolumes(String[] volumes)\n      throws IOException {\n    // Check whether the volume exists\n    for (byte n \u003d 0; n \u003c volumes.length; n++) {\n      try {\n        File pmemDir \u003d new File(volumes[n]);\n        File realPmemDir \u003d verifyIfValidPmemVolume(pmemDir);\n        if (!cacheRecoveryEnabled) {\n          // Clean up the cache left before, if any.\n          cleanup(realPmemDir);\n        }\n        this.pmemVolumes.add(realPmemDir.getPath());\n        long maxBytes;\n        if (maxBytesPerPmem \u003d\u003d -1) {\n          maxBytes \u003d realPmemDir.getUsableSpace();\n        } else {\n          maxBytes \u003d maxBytesPerPmem;\n        }\n        UsedBytesCount usedBytesCount \u003d new UsedBytesCount(maxBytes);\n        this.usedBytesCounts.add(usedBytesCount);\n        LOG.info(\"Added persistent memory - {} with size\u003d{}\",\n            volumes[n], maxBytes);\n      } catch (IllegalArgumentException e) {\n        LOG.error(\"Failed to parse persistent memory volume \" + volumes[n], e);\n        continue;\n      } catch (IOException e) {\n        LOG.error(\"Bad persistent memory volume: \" + volumes[n], e);\n        continue;\n      }\n    }\n    count \u003d pmemVolumes.size();\n    if (count \u003d\u003d 0) {\n      throw new IOException(\n          \"At least one valid persistent memory volume is required!\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/PmemVolumeManager.java",
      "extendedDetails": {}
    },
    "f6fa865d6fcb0ef0a25a00615f16f383e5032373": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14700. Clean up pmem cache before setting pmem cache capacity. Contributed by Feilong He.\n",
      "commitDate": "09/08/19 1:37 AM",
      "commitName": "f6fa865d6fcb0ef0a25a00615f16f383e5032373",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "08/05/19 4:50 AM",
      "commitNameOld": "9b0aace1e6c54f201784912c0b623707aa82b761",
      "commitAuthorOld": "Rakesh Radhakrishnan",
      "daysBetweenCommits": 92.87,
      "commitsBetweenForRepo": 716,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,34 @@\n   private void loadVolumes(String[] volumes)\n       throws IOException {\n     // Check whether the volume exists\n     for (byte n \u003d 0; n \u003c volumes.length; n++) {\n       try {\n         File pmemDir \u003d new File(volumes[n]);\n         File realPmemDir \u003d verifyIfValidPmemVolume(pmemDir);\n+        // Clean up the cache left before, if any.\n+        cleanup(realPmemDir);\n         this.pmemVolumes.add(realPmemDir.getPath());\n         long maxBytes;\n         if (maxBytesPerPmem \u003d\u003d -1) {\n           maxBytes \u003d realPmemDir.getUsableSpace();\n         } else {\n           maxBytes \u003d maxBytesPerPmem;\n         }\n         UsedBytesCount usedBytesCount \u003d new UsedBytesCount(maxBytes);\n         this.usedBytesCounts.add(usedBytesCount);\n         LOG.info(\"Added persistent memory - {} with size\u003d{}\",\n             volumes[n], maxBytes);\n       } catch (IllegalArgumentException e) {\n         LOG.error(\"Failed to parse persistent memory volume \" + volumes[n], e);\n         continue;\n       } catch (IOException e) {\n         LOG.error(\"Bad persistent memory volume: \" + volumes[n], e);\n         continue;\n       }\n     }\n     count \u003d pmemVolumes.size();\n     if (count \u003d\u003d 0) {\n       throw new IOException(\n           \"At least one valid persistent memory volume is required!\");\n     }\n-    cleanup();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadVolumes(String[] volumes)\n      throws IOException {\n    // Check whether the volume exists\n    for (byte n \u003d 0; n \u003c volumes.length; n++) {\n      try {\n        File pmemDir \u003d new File(volumes[n]);\n        File realPmemDir \u003d verifyIfValidPmemVolume(pmemDir);\n        // Clean up the cache left before, if any.\n        cleanup(realPmemDir);\n        this.pmemVolumes.add(realPmemDir.getPath());\n        long maxBytes;\n        if (maxBytesPerPmem \u003d\u003d -1) {\n          maxBytes \u003d realPmemDir.getUsableSpace();\n        } else {\n          maxBytes \u003d maxBytesPerPmem;\n        }\n        UsedBytesCount usedBytesCount \u003d new UsedBytesCount(maxBytes);\n        this.usedBytesCounts.add(usedBytesCount);\n        LOG.info(\"Added persistent memory - {} with size\u003d{}\",\n            volumes[n], maxBytes);\n      } catch (IllegalArgumentException e) {\n        LOG.error(\"Failed to parse persistent memory volume \" + volumes[n], e);\n        continue;\n      } catch (IOException e) {\n        LOG.error(\"Bad persistent memory volume: \" + volumes[n], e);\n        continue;\n      }\n    }\n    count \u003d pmemVolumes.size();\n    if (count \u003d\u003d 0) {\n      throw new IOException(\n          \"At least one valid persistent memory volume is required!\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/PmemVolumeManager.java",
      "extendedDetails": {}
    },
    "9b0aace1e6c54f201784912c0b623707aa82b761": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14401. Refine the implementation for HDFS cache on SCM. Contributed by Feilong He.\n",
      "commitDate": "08/05/19 4:50 AM",
      "commitName": "9b0aace1e6c54f201784912c0b623707aa82b761",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "30/03/19 11:33 PM",
      "commitNameOld": "35ff31dd9462cf4fb4ebf5556ee8ae6bcd7c5c3a",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 38.22,
      "commitsBetweenForRepo": 236,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,33 @@\n-  private void loadVolumes(String[] volumes) throws IOException {\n+  private void loadVolumes(String[] volumes)\n+      throws IOException {\n     // Check whether the volume exists\n-    for (String volume: volumes) {\n+    for (byte n \u003d 0; n \u003c volumes.length; n++) {\n       try {\n-        File pmemDir \u003d new File(volume);\n-        verifyIfValidPmemVolume(pmemDir);\n-        // Remove all files under the volume.\n-        FileUtils.cleanDirectory(pmemDir);\n+        File pmemDir \u003d new File(volumes[n]);\n+        File realPmemDir \u003d verifyIfValidPmemVolume(pmemDir);\n+        this.pmemVolumes.add(realPmemDir.getPath());\n+        long maxBytes;\n+        if (maxBytesPerPmem \u003d\u003d -1) {\n+          maxBytes \u003d realPmemDir.getUsableSpace();\n+        } else {\n+          maxBytes \u003d maxBytesPerPmem;\n+        }\n+        UsedBytesCount usedBytesCount \u003d new UsedBytesCount(maxBytes);\n+        this.usedBytesCounts.add(usedBytesCount);\n+        LOG.info(\"Added persistent memory - {} with size\u003d{}\",\n+            volumes[n], maxBytes);\n       } catch (IllegalArgumentException e) {\n-        LOG.error(\"Failed to parse persistent memory volume \" + volume, e);\n+        LOG.error(\"Failed to parse persistent memory volume \" + volumes[n], e);\n         continue;\n       } catch (IOException e) {\n-        LOG.error(\"Bad persistent memory volume: \" + volume, e);\n+        LOG.error(\"Bad persistent memory volume: \" + volumes[n], e);\n         continue;\n       }\n-      pmemVolumes.add(volume);\n-      LOG.info(\"Added persistent memory - \" + volume);\n     }\n     count \u003d pmemVolumes.size();\n     if (count \u003d\u003d 0) {\n       throw new IOException(\n           \"At least one valid persistent memory volume is required!\");\n     }\n+    cleanup();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadVolumes(String[] volumes)\n      throws IOException {\n    // Check whether the volume exists\n    for (byte n \u003d 0; n \u003c volumes.length; n++) {\n      try {\n        File pmemDir \u003d new File(volumes[n]);\n        File realPmemDir \u003d verifyIfValidPmemVolume(pmemDir);\n        this.pmemVolumes.add(realPmemDir.getPath());\n        long maxBytes;\n        if (maxBytesPerPmem \u003d\u003d -1) {\n          maxBytes \u003d realPmemDir.getUsableSpace();\n        } else {\n          maxBytes \u003d maxBytesPerPmem;\n        }\n        UsedBytesCount usedBytesCount \u003d new UsedBytesCount(maxBytes);\n        this.usedBytesCounts.add(usedBytesCount);\n        LOG.info(\"Added persistent memory - {} with size\u003d{}\",\n            volumes[n], maxBytes);\n      } catch (IllegalArgumentException e) {\n        LOG.error(\"Failed to parse persistent memory volume \" + volumes[n], e);\n        continue;\n      } catch (IOException e) {\n        LOG.error(\"Bad persistent memory volume: \" + volumes[n], e);\n        continue;\n      }\n    }\n    count \u003d pmemVolumes.size();\n    if (count \u003d\u003d 0) {\n      throw new IOException(\n          \"At least one valid persistent memory volume is required!\");\n    }\n    cleanup();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/PmemVolumeManager.java",
      "extendedDetails": {}
    },
    "35ff31dd9462cf4fb4ebf5556ee8ae6bcd7c5c3a": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-14355 : Implement HDFS cache on SCM by using pure java mapped byte buffer. Contributed by Feilong He.\n",
      "commitDate": "30/03/19 11:33 PM",
      "commitName": "35ff31dd9462cf4fb4ebf5556ee8ae6bcd7c5c3a",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,24 @@\n+  private void loadVolumes(String[] volumes) throws IOException {\n+    // Check whether the volume exists\n+    for (String volume: volumes) {\n+      try {\n+        File pmemDir \u003d new File(volume);\n+        verifyIfValidPmemVolume(pmemDir);\n+        // Remove all files under the volume.\n+        FileUtils.cleanDirectory(pmemDir);\n+      } catch (IllegalArgumentException e) {\n+        LOG.error(\"Failed to parse persistent memory volume \" + volume, e);\n+        continue;\n+      } catch (IOException e) {\n+        LOG.error(\"Bad persistent memory volume: \" + volume, e);\n+        continue;\n+      }\n+      pmemVolumes.add(volume);\n+      LOG.info(\"Added persistent memory - \" + volume);\n+    }\n+    count \u003d pmemVolumes.size();\n+    if (count \u003d\u003d 0) {\n+      throw new IOException(\n+          \"At least one valid persistent memory volume is required!\");\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadVolumes(String[] volumes) throws IOException {\n    // Check whether the volume exists\n    for (String volume: volumes) {\n      try {\n        File pmemDir \u003d new File(volume);\n        verifyIfValidPmemVolume(pmemDir);\n        // Remove all files under the volume.\n        FileUtils.cleanDirectory(pmemDir);\n      } catch (IllegalArgumentException e) {\n        LOG.error(\"Failed to parse persistent memory volume \" + volume, e);\n        continue;\n      } catch (IOException e) {\n        LOG.error(\"Bad persistent memory volume: \" + volume, e);\n        continue;\n      }\n      pmemVolumes.add(volume);\n      LOG.info(\"Added persistent memory - \" + volume);\n    }\n    count \u003d pmemVolumes.size();\n    if (count \u003d\u003d 0) {\n      throw new IOException(\n          \"At least one valid persistent memory volume is required!\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/PmemVolumeManager.java"
    }
  }
}