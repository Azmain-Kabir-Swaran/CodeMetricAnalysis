{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InMemoryPlan.java",
  "functionName": "getAvailableResourceOverTime",
  "functionId": "getAvailableResourceOverTime___user-String__oldId-ReservationId__start-long__end-long__period-long",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
  "functionStartLine": 704,
  "functionEndLine": 790,
  "numCommitsSeen": 61,
  "timeTaken": 6181,
  "changeHistory": [
    "25932da6d1ee56299c8f9911576a42792c435407",
    "e6e614e380ed1d746973b50f666a9c40d272073e",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
    "e3345e985bff93c6c74a76747e45376c6027f42c",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
    "742632e346604fd2b263bd42367165638fcf2416"
  ],
  "changeHistoryShort": {
    "25932da6d1ee56299c8f9911576a42792c435407": "Ybodychange",
    "e6e614e380ed1d746973b50f666a9c40d272073e": "Ybodychange",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": "Ymultichange(Yparameterchange,Ybodychange)",
    "e3345e985bff93c6c74a76747e45376c6027f42c": "Ymultichange(Yparameterchange,Ybodychange)",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": "Ymultichange(Yparameterchange,Ybodychange)",
    "742632e346604fd2b263bd42367165638fcf2416": "Yintroduced"
  },
  "changeHistoryDetails": {
    "25932da6d1ee56299c8f9911576a42792c435407": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5516. Add REST API for supporting recurring reservations. (Sean Po via Subru).\n",
      "commitDate": "26/10/17 12:10 PM",
      "commitName": "25932da6d1ee56299c8f9911576a42792c435407",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "04/10/17 7:28 PM",
      "commitNameOld": "e6e614e380ed1d746973b50f666a9c40d272073e",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 21.7,
      "commitsBetweenForRepo": 163,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,87 @@\n   public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n       ReservationId oldId, long start, long end, long period)\n       throws PlanningException {\n     readLock.lock();\n     try {\n \n       // for non-periodic return simple available resources\n       if (period \u003d\u003d 0) {\n \n         // create RLE of totCapacity\n         TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n         totAvailable.put(start, Resources.clone(totalCapacity));\n         RLESparseResourceAllocation totRLEAvail \u003d\n             new RLESparseResourceAllocation(totAvailable, resCalc);\n \n         // subtract used from available\n         RLESparseResourceAllocation netAvailable;\n \n         netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n             Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n             RLEOperator.subtractTestNonNegative, start, end);\n \n         // remove periodic component\n         netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n             Resources.clone(totalCapacity), netAvailable, periodicRle,\n             RLEOperator.subtractTestNonNegative, start, end);\n \n         // add back in old reservation used resources if any\n         ReservationAllocation old \u003d reservationTable.get(oldId);\n         if (old !\u003d null) {\n \n           RLESparseResourceAllocation addBackPrevious \u003d\n               old.getResourcesOverTime(start, end);\n           netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n               Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n               RLEOperator.add, start, end);\n         }\n         // lower it if this is needed by the sharing policy\n         netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n             user, oldId, start, end);\n         return netAvailable;\n       } else {\n \n         if (periodicRle.getTimePeriod() % period !\u003d 0) {\n           throw new PlanningException(\"The reservation periodicity (\" + period\n-              + \") must be\" + \"an exact divider of the system maxPeriod (\"\n+              + \") must be\" + \" an exact divider of the system maxPeriod (\"\n               + periodicRle.getTimePeriod() + \")\");\n         }\n \n         if (period \u003c (end - start)) {\n           throw new PlanningException(\n               \"Invalid input: (end - start) \u003d (\" + end + \" - \" + start + \") \u003d \"\n                   + (end - start) + \" \u003e period \u003d \" + period);\n         }\n \n         // find the minimum resources available among all the instances that fit\n         // in the LCM\n         long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n \n         RLESparseResourceAllocation minOverLCM \u003d\n             getAvailableResourceOverTime(user, oldId, start, end, 0);\n         for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n \n           long rStart \u003d start + i * period;\n           long rEnd \u003d end + i * period;\n \n           // recursive invocation of non-periodic range (to pick raw-info)\n           RLESparseResourceAllocation snapShot \u003d\n               getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n \n           // time-align on start\n           snapShot.shift(-(i * period));\n \n           // pick the minimum amount of resources in each time interval\n           minOverLCM \u003d\n               RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n                   minOverLCM, snapShot, RLEOperator.min, start, end);\n \n         }\n \n         return minOverLCM;\n \n       }\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n      ReservationId oldId, long start, long end, long period)\n      throws PlanningException {\n    readLock.lock();\n    try {\n\n      // for non-periodic return simple available resources\n      if (period \u003d\u003d 0) {\n\n        // create RLE of totCapacity\n        TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n        totAvailable.put(start, Resources.clone(totalCapacity));\n        RLESparseResourceAllocation totRLEAvail \u003d\n            new RLESparseResourceAllocation(totAvailable, resCalc);\n\n        // subtract used from available\n        RLESparseResourceAllocation netAvailable;\n\n        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n            Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n            RLEOperator.subtractTestNonNegative, start, end);\n\n        // remove periodic component\n        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n            Resources.clone(totalCapacity), netAvailable, periodicRle,\n            RLEOperator.subtractTestNonNegative, start, end);\n\n        // add back in old reservation used resources if any\n        ReservationAllocation old \u003d reservationTable.get(oldId);\n        if (old !\u003d null) {\n\n          RLESparseResourceAllocation addBackPrevious \u003d\n              old.getResourcesOverTime(start, end);\n          netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n              Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n              RLEOperator.add, start, end);\n        }\n        // lower it if this is needed by the sharing policy\n        netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n            user, oldId, start, end);\n        return netAvailable;\n      } else {\n\n        if (periodicRle.getTimePeriod() % period !\u003d 0) {\n          throw new PlanningException(\"The reservation periodicity (\" + period\n              + \") must be\" + \" an exact divider of the system maxPeriod (\"\n              + periodicRle.getTimePeriod() + \")\");\n        }\n\n        if (period \u003c (end - start)) {\n          throw new PlanningException(\n              \"Invalid input: (end - start) \u003d (\" + end + \" - \" + start + \") \u003d \"\n                  + (end - start) + \" \u003e period \u003d \" + period);\n        }\n\n        // find the minimum resources available among all the instances that fit\n        // in the LCM\n        long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n\n        RLESparseResourceAllocation minOverLCM \u003d\n            getAvailableResourceOverTime(user, oldId, start, end, 0);\n        for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n\n          long rStart \u003d start + i * period;\n          long rEnd \u003d end + i * period;\n\n          // recursive invocation of non-periodic range (to pick raw-info)\n          RLESparseResourceAllocation snapShot \u003d\n              getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n\n          // time-align on start\n          snapShot.shift(-(i * period));\n\n          // pick the minimum amount of resources in each time interval\n          minOverLCM \u003d\n              RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n                  minOverLCM, snapShot, RLEOperator.min, start, end);\n\n        }\n\n        return minOverLCM;\n\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "e6e614e380ed1d746973b50f666a9c40d272073e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
      "commitDate": "04/10/17 7:28 PM",
      "commitName": "e6e614e380ed1d746973b50f666a9c40d272073e",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "06/09/17 4:46 PM",
      "commitNameOld": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 28.11,
      "commitsBetweenForRepo": 262,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,87 @@\n   public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n       ReservationId oldId, long start, long end, long period)\n       throws PlanningException {\n     readLock.lock();\n     try {\n \n       // for non-periodic return simple available resources\n       if (period \u003d\u003d 0) {\n \n         // create RLE of totCapacity\n         TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n         totAvailable.put(start, Resources.clone(totalCapacity));\n         RLESparseResourceAllocation totRLEAvail \u003d\n             new RLESparseResourceAllocation(totAvailable, resCalc);\n \n         // subtract used from available\n         RLESparseResourceAllocation netAvailable;\n \n         netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n             Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n             RLEOperator.subtractTestNonNegative, start, end);\n \n         // remove periodic component\n         netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n             Resources.clone(totalCapacity), netAvailable, periodicRle,\n             RLEOperator.subtractTestNonNegative, start, end);\n \n         // add back in old reservation used resources if any\n         ReservationAllocation old \u003d reservationTable.get(oldId);\n         if (old !\u003d null) {\n \n           RLESparseResourceAllocation addBackPrevious \u003d\n               old.getResourcesOverTime(start, end);\n           netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n               Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n               RLEOperator.add, start, end);\n         }\n         // lower it if this is needed by the sharing policy\n         netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n             user, oldId, start, end);\n         return netAvailable;\n       } else {\n \n         if (periodicRle.getTimePeriod() % period !\u003d 0) {\n           throw new PlanningException(\"The reservation periodicity (\" + period\n               + \") must be\" + \"an exact divider of the system maxPeriod (\"\n               + periodicRle.getTimePeriod() + \")\");\n         }\n \n+        if (period \u003c (end - start)) {\n+          throw new PlanningException(\n+              \"Invalid input: (end - start) \u003d (\" + end + \" - \" + start + \") \u003d \"\n+                  + (end - start) + \" \u003e period \u003d \" + period);\n+        }\n+\n         // find the minimum resources available among all the instances that fit\n         // in the LCM\n         long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n \n         RLESparseResourceAllocation minOverLCM \u003d\n             getAvailableResourceOverTime(user, oldId, start, end, 0);\n         for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n \n           long rStart \u003d start + i * period;\n           long rEnd \u003d end + i * period;\n \n           // recursive invocation of non-periodic range (to pick raw-info)\n           RLESparseResourceAllocation snapShot \u003d\n               getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n \n           // time-align on start\n           snapShot.shift(-(i * period));\n \n           // pick the minimum amount of resources in each time interval\n           minOverLCM \u003d\n               RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n                   minOverLCM, snapShot, RLEOperator.min, start, end);\n \n         }\n \n         return minOverLCM;\n \n       }\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n      ReservationId oldId, long start, long end, long period)\n      throws PlanningException {\n    readLock.lock();\n    try {\n\n      // for non-periodic return simple available resources\n      if (period \u003d\u003d 0) {\n\n        // create RLE of totCapacity\n        TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n        totAvailable.put(start, Resources.clone(totalCapacity));\n        RLESparseResourceAllocation totRLEAvail \u003d\n            new RLESparseResourceAllocation(totAvailable, resCalc);\n\n        // subtract used from available\n        RLESparseResourceAllocation netAvailable;\n\n        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n            Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n            RLEOperator.subtractTestNonNegative, start, end);\n\n        // remove periodic component\n        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n            Resources.clone(totalCapacity), netAvailable, periodicRle,\n            RLEOperator.subtractTestNonNegative, start, end);\n\n        // add back in old reservation used resources if any\n        ReservationAllocation old \u003d reservationTable.get(oldId);\n        if (old !\u003d null) {\n\n          RLESparseResourceAllocation addBackPrevious \u003d\n              old.getResourcesOverTime(start, end);\n          netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n              Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n              RLEOperator.add, start, end);\n        }\n        // lower it if this is needed by the sharing policy\n        netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n            user, oldId, start, end);\n        return netAvailable;\n      } else {\n\n        if (periodicRle.getTimePeriod() % period !\u003d 0) {\n          throw new PlanningException(\"The reservation periodicity (\" + period\n              + \") must be\" + \"an exact divider of the system maxPeriod (\"\n              + periodicRle.getTimePeriod() + \")\");\n        }\n\n        if (period \u003c (end - start)) {\n          throw new PlanningException(\n              \"Invalid input: (end - start) \u003d (\" + end + \" - \" + start + \") \u003d \"\n                  + (end - start) + \" \u003e period \u003d \" + period);\n        }\n\n        // find the minimum resources available among all the instances that fit\n        // in the LCM\n        long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n\n        RLESparseResourceAllocation minOverLCM \u003d\n            getAvailableResourceOverTime(user, oldId, start, end, 0);\n        for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n\n          long rStart \u003d start + i * period;\n          long rEnd \u003d end + i * period;\n\n          // recursive invocation of non-periodic range (to pick raw-info)\n          RLESparseResourceAllocation snapShot \u003d\n              getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n\n          // time-align on start\n          snapShot.shift(-(i * period));\n\n          // pick the minimum amount of resources in each time interval\n          minOverLCM \u003d\n              RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n                  minOverLCM, snapShot, RLEOperator.min, start, end);\n\n        }\n\n        return minOverLCM;\n\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5328. Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "06/09/17 4:46 PM",
      "commitName": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
      "commitAuthor": "Subru Krishnan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5328. Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
          "commitDate": "06/09/17 4:46 PM",
          "commitName": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "06/09/17 4:39 PM",
          "commitNameOld": "e3345e985bff93c6c74a76747e45376c6027f42c",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,81 @@\n   public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n-      ReservationId oldId, long start, long end) throws PlanningException {\n+      ReservationId oldId, long start, long end, long period)\n+      throws PlanningException {\n     readLock.lock();\n     try {\n-      // create RLE of totCapacity\n-      TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n-      totAvailable.put(start, Resources.clone(totalCapacity));\n-      RLESparseResourceAllocation totRLEAvail \u003d\n-          new RLESparseResourceAllocation(totAvailable, resCalc);\n \n-      // subtract used from available\n-      RLESparseResourceAllocation netAvailable;\n+      // for non-periodic return simple available resources\n+      if (period \u003d\u003d 0) {\n \n-      netAvailable \u003d\n-          RLESparseResourceAllocation.merge(resCalc,\n-              Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n-              RLEOperator.subtractTestNonNegative, start, end);\n+        // create RLE of totCapacity\n+        TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n+        totAvailable.put(start, Resources.clone(totalCapacity));\n+        RLESparseResourceAllocation totRLEAvail \u003d\n+            new RLESparseResourceAllocation(totAvailable, resCalc);\n \n-      // add back in old reservation used resources if any\n-      ReservationAllocation old \u003d reservationTable.get(oldId);\n-      if (old !\u003d null) {\n-        netAvailable \u003d\n-            RLESparseResourceAllocation.merge(resCalc,\n-                Resources.clone(totalCapacity), netAvailable,\n-                old.getResourcesOverTime(), RLEOperator.add, start, end);\n+        // subtract used from available\n+        RLESparseResourceAllocation netAvailable;\n+\n+        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n+            Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n+            RLEOperator.subtractTestNonNegative, start, end);\n+\n+        // remove periodic component\n+        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n+            Resources.clone(totalCapacity), netAvailable, periodicRle,\n+            RLEOperator.subtractTestNonNegative, start, end);\n+\n+        // add back in old reservation used resources if any\n+        ReservationAllocation old \u003d reservationTable.get(oldId);\n+        if (old !\u003d null) {\n+\n+          RLESparseResourceAllocation addBackPrevious \u003d\n+              old.getResourcesOverTime(start, end);\n+          netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n+              Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n+              RLEOperator.add, start, end);\n+        }\n+        // lower it if this is needed by the sharing policy\n+        netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n+            user, oldId, start, end);\n+        return netAvailable;\n+      } else {\n+\n+        if (periodicRle.getTimePeriod() % period !\u003d 0) {\n+          throw new PlanningException(\"The reservation periodicity (\" + period\n+              + \") must be\" + \"an exact divider of the system maxPeriod (\"\n+              + periodicRle.getTimePeriod() + \")\");\n+        }\n+\n+        // find the minimum resources available among all the instances that fit\n+        // in the LCM\n+        long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n+\n+        RLESparseResourceAllocation minOverLCM \u003d\n+            getAvailableResourceOverTime(user, oldId, start, end, 0);\n+        for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n+\n+          long rStart \u003d start + i * period;\n+          long rEnd \u003d end + i * period;\n+\n+          // recursive invocation of non-periodic range (to pick raw-info)\n+          RLESparseResourceAllocation snapShot \u003d\n+              getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n+\n+          // time-align on start\n+          snapShot.shift(-(i * period));\n+\n+          // pick the minimum amount of resources in each time interval\n+          minOverLCM \u003d\n+              RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n+                  minOverLCM, snapShot, RLEOperator.min, start, end);\n+\n+        }\n+\n+        return minOverLCM;\n+\n       }\n-      // lower it if this is needed by the sharing policy\n-      netAvailable \u003d\n-          getSharingPolicy().availableResources(netAvailable, this, user,\n-              oldId, start, end);\n-      return netAvailable;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n      ReservationId oldId, long start, long end, long period)\n      throws PlanningException {\n    readLock.lock();\n    try {\n\n      // for non-periodic return simple available resources\n      if (period \u003d\u003d 0) {\n\n        // create RLE of totCapacity\n        TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n        totAvailable.put(start, Resources.clone(totalCapacity));\n        RLESparseResourceAllocation totRLEAvail \u003d\n            new RLESparseResourceAllocation(totAvailable, resCalc);\n\n        // subtract used from available\n        RLESparseResourceAllocation netAvailable;\n\n        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n            Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n            RLEOperator.subtractTestNonNegative, start, end);\n\n        // remove periodic component\n        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n            Resources.clone(totalCapacity), netAvailable, periodicRle,\n            RLEOperator.subtractTestNonNegative, start, end);\n\n        // add back in old reservation used resources if any\n        ReservationAllocation old \u003d reservationTable.get(oldId);\n        if (old !\u003d null) {\n\n          RLESparseResourceAllocation addBackPrevious \u003d\n              old.getResourcesOverTime(start, end);\n          netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n              Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n              RLEOperator.add, start, end);\n        }\n        // lower it if this is needed by the sharing policy\n        netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n            user, oldId, start, end);\n        return netAvailable;\n      } else {\n\n        if (periodicRle.getTimePeriod() % period !\u003d 0) {\n          throw new PlanningException(\"The reservation periodicity (\" + period\n              + \") must be\" + \"an exact divider of the system maxPeriod (\"\n              + periodicRle.getTimePeriod() + \")\");\n        }\n\n        // find the minimum resources available among all the instances that fit\n        // in the LCM\n        long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n\n        RLESparseResourceAllocation minOverLCM \u003d\n            getAvailableResourceOverTime(user, oldId, start, end, 0);\n        for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n\n          long rStart \u003d start + i * period;\n          long rEnd \u003d end + i * period;\n\n          // recursive invocation of non-periodic range (to pick raw-info)\n          RLESparseResourceAllocation snapShot \u003d\n              getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n\n          // time-align on start\n          snapShot.shift(-(i * period));\n\n          // pick the minimum amount of resources in each time interval\n          minOverLCM \u003d\n              RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n                  minOverLCM, snapShot, RLEOperator.min, start, end);\n\n        }\n\n        return minOverLCM;\n\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
          "extendedDetails": {
            "oldValue": "[user-String, oldId-ReservationId, start-long, end-long]",
            "newValue": "[user-String, oldId-ReservationId, start-long, end-long, period-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5328. Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
          "commitDate": "06/09/17 4:46 PM",
          "commitName": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "06/09/17 4:39 PM",
          "commitNameOld": "e3345e985bff93c6c74a76747e45376c6027f42c",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,81 @@\n   public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n-      ReservationId oldId, long start, long end) throws PlanningException {\n+      ReservationId oldId, long start, long end, long period)\n+      throws PlanningException {\n     readLock.lock();\n     try {\n-      // create RLE of totCapacity\n-      TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n-      totAvailable.put(start, Resources.clone(totalCapacity));\n-      RLESparseResourceAllocation totRLEAvail \u003d\n-          new RLESparseResourceAllocation(totAvailable, resCalc);\n \n-      // subtract used from available\n-      RLESparseResourceAllocation netAvailable;\n+      // for non-periodic return simple available resources\n+      if (period \u003d\u003d 0) {\n \n-      netAvailable \u003d\n-          RLESparseResourceAllocation.merge(resCalc,\n-              Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n-              RLEOperator.subtractTestNonNegative, start, end);\n+        // create RLE of totCapacity\n+        TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n+        totAvailable.put(start, Resources.clone(totalCapacity));\n+        RLESparseResourceAllocation totRLEAvail \u003d\n+            new RLESparseResourceAllocation(totAvailable, resCalc);\n \n-      // add back in old reservation used resources if any\n-      ReservationAllocation old \u003d reservationTable.get(oldId);\n-      if (old !\u003d null) {\n-        netAvailable \u003d\n-            RLESparseResourceAllocation.merge(resCalc,\n-                Resources.clone(totalCapacity), netAvailable,\n-                old.getResourcesOverTime(), RLEOperator.add, start, end);\n+        // subtract used from available\n+        RLESparseResourceAllocation netAvailable;\n+\n+        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n+            Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n+            RLEOperator.subtractTestNonNegative, start, end);\n+\n+        // remove periodic component\n+        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n+            Resources.clone(totalCapacity), netAvailable, periodicRle,\n+            RLEOperator.subtractTestNonNegative, start, end);\n+\n+        // add back in old reservation used resources if any\n+        ReservationAllocation old \u003d reservationTable.get(oldId);\n+        if (old !\u003d null) {\n+\n+          RLESparseResourceAllocation addBackPrevious \u003d\n+              old.getResourcesOverTime(start, end);\n+          netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n+              Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n+              RLEOperator.add, start, end);\n+        }\n+        // lower it if this is needed by the sharing policy\n+        netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n+            user, oldId, start, end);\n+        return netAvailable;\n+      } else {\n+\n+        if (periodicRle.getTimePeriod() % period !\u003d 0) {\n+          throw new PlanningException(\"The reservation periodicity (\" + period\n+              + \") must be\" + \"an exact divider of the system maxPeriod (\"\n+              + periodicRle.getTimePeriod() + \")\");\n+        }\n+\n+        // find the minimum resources available among all the instances that fit\n+        // in the LCM\n+        long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n+\n+        RLESparseResourceAllocation minOverLCM \u003d\n+            getAvailableResourceOverTime(user, oldId, start, end, 0);\n+        for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n+\n+          long rStart \u003d start + i * period;\n+          long rEnd \u003d end + i * period;\n+\n+          // recursive invocation of non-periodic range (to pick raw-info)\n+          RLESparseResourceAllocation snapShot \u003d\n+              getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n+\n+          // time-align on start\n+          snapShot.shift(-(i * period));\n+\n+          // pick the minimum amount of resources in each time interval\n+          minOverLCM \u003d\n+              RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n+                  minOverLCM, snapShot, RLEOperator.min, start, end);\n+\n+        }\n+\n+        return minOverLCM;\n+\n       }\n-      // lower it if this is needed by the sharing policy\n-      netAvailable \u003d\n-          getSharingPolicy().availableResources(netAvailable, this, user,\n-              oldId, start, end);\n-      return netAvailable;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n      ReservationId oldId, long start, long end, long period)\n      throws PlanningException {\n    readLock.lock();\n    try {\n\n      // for non-periodic return simple available resources\n      if (period \u003d\u003d 0) {\n\n        // create RLE of totCapacity\n        TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n        totAvailable.put(start, Resources.clone(totalCapacity));\n        RLESparseResourceAllocation totRLEAvail \u003d\n            new RLESparseResourceAllocation(totAvailable, resCalc);\n\n        // subtract used from available\n        RLESparseResourceAllocation netAvailable;\n\n        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n            Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n            RLEOperator.subtractTestNonNegative, start, end);\n\n        // remove periodic component\n        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n            Resources.clone(totalCapacity), netAvailable, periodicRle,\n            RLEOperator.subtractTestNonNegative, start, end);\n\n        // add back in old reservation used resources if any\n        ReservationAllocation old \u003d reservationTable.get(oldId);\n        if (old !\u003d null) {\n\n          RLESparseResourceAllocation addBackPrevious \u003d\n              old.getResourcesOverTime(start, end);\n          netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n              Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n              RLEOperator.add, start, end);\n        }\n        // lower it if this is needed by the sharing policy\n        netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n            user, oldId, start, end);\n        return netAvailable;\n      } else {\n\n        if (periodicRle.getTimePeriod() % period !\u003d 0) {\n          throw new PlanningException(\"The reservation periodicity (\" + period\n              + \") must be\" + \"an exact divider of the system maxPeriod (\"\n              + periodicRle.getTimePeriod() + \")\");\n        }\n\n        // find the minimum resources available among all the instances that fit\n        // in the LCM\n        long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n\n        RLESparseResourceAllocation minOverLCM \u003d\n            getAvailableResourceOverTime(user, oldId, start, end, 0);\n        for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n\n          long rStart \u003d start + i * period;\n          long rEnd \u003d end + i * period;\n\n          // recursive invocation of non-periodic range (to pick raw-info)\n          RLESparseResourceAllocation snapShot \u003d\n              getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n\n          // time-align on start\n          snapShot.shift(-(i * period));\n\n          // pick the minimum amount of resources in each time interval\n          minOverLCM \u003d\n              RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n                  minOverLCM, snapShot, RLEOperator.min, start, end);\n\n        }\n\n        return minOverLCM;\n\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
          "extendedDetails": {}
        }
      ]
    },
    "e3345e985bff93c6c74a76747e45376c6027f42c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Revert \"Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\"\n\nThis reverts commit 7996eca7dcfaa1bdf970e32022274f2699bef8a1.\n",
      "commitDate": "06/09/17 4:39 PM",
      "commitName": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthor": "Subru Krishnan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Revert \"Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\"\n\nThis reverts commit 7996eca7dcfaa1bdf970e32022274f2699bef8a1.\n",
          "commitDate": "06/09/17 4:39 PM",
          "commitName": "e3345e985bff93c6c74a76747e45376c6027f42c",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "01/09/17 3:16 PM",
          "commitNameOld": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 5.06,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,35 @@\n   public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n-      ReservationId oldId, long start, long end, long period)\n-      throws PlanningException {\n+      ReservationId oldId, long start, long end) throws PlanningException {\n     readLock.lock();\n     try {\n+      // create RLE of totCapacity\n+      TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n+      totAvailable.put(start, Resources.clone(totalCapacity));\n+      RLESparseResourceAllocation totRLEAvail \u003d\n+          new RLESparseResourceAllocation(totAvailable, resCalc);\n \n-      // for non-periodic return simple available resources\n-      if (period \u003d\u003d 0) {\n+      // subtract used from available\n+      RLESparseResourceAllocation netAvailable;\n \n-        // create RLE of totCapacity\n-        TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n-        totAvailable.put(start, Resources.clone(totalCapacity));\n-        RLESparseResourceAllocation totRLEAvail \u003d\n-            new RLESparseResourceAllocation(totAvailable, resCalc);\n+      netAvailable \u003d\n+          RLESparseResourceAllocation.merge(resCalc,\n+              Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n+              RLEOperator.subtractTestNonNegative, start, end);\n \n-        // subtract used from available\n-        RLESparseResourceAllocation netAvailable;\n-\n-        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n-            Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n-            RLEOperator.subtractTestNonNegative, start, end);\n-\n-        // remove periodic component\n-        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n-            Resources.clone(totalCapacity), netAvailable, periodicRle,\n-            RLEOperator.subtractTestNonNegative, start, end);\n-\n-        // add back in old reservation used resources if any\n-        ReservationAllocation old \u003d reservationTable.get(oldId);\n-        if (old !\u003d null) {\n-\n-          RLESparseResourceAllocation addBackPrevious \u003d\n-              old.getResourcesOverTime(start, end);\n-          netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n-              Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n-              RLEOperator.add, start, end);\n-        }\n-        // lower it if this is needed by the sharing policy\n-        netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n-            user, oldId, start, end);\n-        return netAvailable;\n-      } else {\n-\n-        if (periodicRle.getTimePeriod() % period !\u003d 0) {\n-          throw new PlanningException(\"The reservation periodicity (\" + period\n-              + \") must be\" + \"an exact divider of the system maxPeriod (\"\n-              + periodicRle.getTimePeriod() + \")\");\n-        }\n-\n-        // find the minimum resources available among all the instances that fit\n-        // in the LCM\n-        long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n-\n-        RLESparseResourceAllocation minOverLCM \u003d\n-            getAvailableResourceOverTime(user, oldId, start, end, 0);\n-        for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n-\n-          long rStart \u003d start + i * period;\n-          long rEnd \u003d end + i * period;\n-\n-          // recursive invocation of non-periodic range (to pick raw-info)\n-          RLESparseResourceAllocation snapShot \u003d\n-              getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n-\n-          // time-align on start\n-          snapShot.shift(-(i * period));\n-\n-          // pick the minimum amount of resources in each time interval\n-          minOverLCM \u003d\n-              RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n-                  minOverLCM, snapShot, RLEOperator.min, start, end);\n-\n-        }\n-\n-        return minOverLCM;\n-\n+      // add back in old reservation used resources if any\n+      ReservationAllocation old \u003d reservationTable.get(oldId);\n+      if (old !\u003d null) {\n+        netAvailable \u003d\n+            RLESparseResourceAllocation.merge(resCalc,\n+                Resources.clone(totalCapacity), netAvailable,\n+                old.getResourcesOverTime(), RLEOperator.add, start, end);\n       }\n+      // lower it if this is needed by the sharing policy\n+      netAvailable \u003d\n+          getSharingPolicy().availableResources(netAvailable, this, user,\n+              oldId, start, end);\n+      return netAvailable;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n      ReservationId oldId, long start, long end) throws PlanningException {\n    readLock.lock();\n    try {\n      // create RLE of totCapacity\n      TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n      totAvailable.put(start, Resources.clone(totalCapacity));\n      RLESparseResourceAllocation totRLEAvail \u003d\n          new RLESparseResourceAllocation(totAvailable, resCalc);\n\n      // subtract used from available\n      RLESparseResourceAllocation netAvailable;\n\n      netAvailable \u003d\n          RLESparseResourceAllocation.merge(resCalc,\n              Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n              RLEOperator.subtractTestNonNegative, start, end);\n\n      // add back in old reservation used resources if any\n      ReservationAllocation old \u003d reservationTable.get(oldId);\n      if (old !\u003d null) {\n        netAvailable \u003d\n            RLESparseResourceAllocation.merge(resCalc,\n                Resources.clone(totalCapacity), netAvailable,\n                old.getResourcesOverTime(), RLEOperator.add, start, end);\n      }\n      // lower it if this is needed by the sharing policy\n      netAvailable \u003d\n          getSharingPolicy().availableResources(netAvailable, this, user,\n              oldId, start, end);\n      return netAvailable;\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
          "extendedDetails": {
            "oldValue": "[user-String, oldId-ReservationId, start-long, end-long, period-long]",
            "newValue": "[user-String, oldId-ReservationId, start-long, end-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Revert \"Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\"\n\nThis reverts commit 7996eca7dcfaa1bdf970e32022274f2699bef8a1.\n",
          "commitDate": "06/09/17 4:39 PM",
          "commitName": "e3345e985bff93c6c74a76747e45376c6027f42c",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "01/09/17 3:16 PM",
          "commitNameOld": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 5.06,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,35 @@\n   public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n-      ReservationId oldId, long start, long end, long period)\n-      throws PlanningException {\n+      ReservationId oldId, long start, long end) throws PlanningException {\n     readLock.lock();\n     try {\n+      // create RLE of totCapacity\n+      TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n+      totAvailable.put(start, Resources.clone(totalCapacity));\n+      RLESparseResourceAllocation totRLEAvail \u003d\n+          new RLESparseResourceAllocation(totAvailable, resCalc);\n \n-      // for non-periodic return simple available resources\n-      if (period \u003d\u003d 0) {\n+      // subtract used from available\n+      RLESparseResourceAllocation netAvailable;\n \n-        // create RLE of totCapacity\n-        TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n-        totAvailable.put(start, Resources.clone(totalCapacity));\n-        RLESparseResourceAllocation totRLEAvail \u003d\n-            new RLESparseResourceAllocation(totAvailable, resCalc);\n+      netAvailable \u003d\n+          RLESparseResourceAllocation.merge(resCalc,\n+              Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n+              RLEOperator.subtractTestNonNegative, start, end);\n \n-        // subtract used from available\n-        RLESparseResourceAllocation netAvailable;\n-\n-        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n-            Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n-            RLEOperator.subtractTestNonNegative, start, end);\n-\n-        // remove periodic component\n-        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n-            Resources.clone(totalCapacity), netAvailable, periodicRle,\n-            RLEOperator.subtractTestNonNegative, start, end);\n-\n-        // add back in old reservation used resources if any\n-        ReservationAllocation old \u003d reservationTable.get(oldId);\n-        if (old !\u003d null) {\n-\n-          RLESparseResourceAllocation addBackPrevious \u003d\n-              old.getResourcesOverTime(start, end);\n-          netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n-              Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n-              RLEOperator.add, start, end);\n-        }\n-        // lower it if this is needed by the sharing policy\n-        netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n-            user, oldId, start, end);\n-        return netAvailable;\n-      } else {\n-\n-        if (periodicRle.getTimePeriod() % period !\u003d 0) {\n-          throw new PlanningException(\"The reservation periodicity (\" + period\n-              + \") must be\" + \"an exact divider of the system maxPeriod (\"\n-              + periodicRle.getTimePeriod() + \")\");\n-        }\n-\n-        // find the minimum resources available among all the instances that fit\n-        // in the LCM\n-        long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n-\n-        RLESparseResourceAllocation minOverLCM \u003d\n-            getAvailableResourceOverTime(user, oldId, start, end, 0);\n-        for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n-\n-          long rStart \u003d start + i * period;\n-          long rEnd \u003d end + i * period;\n-\n-          // recursive invocation of non-periodic range (to pick raw-info)\n-          RLESparseResourceAllocation snapShot \u003d\n-              getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n-\n-          // time-align on start\n-          snapShot.shift(-(i * period));\n-\n-          // pick the minimum amount of resources in each time interval\n-          minOverLCM \u003d\n-              RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n-                  minOverLCM, snapShot, RLEOperator.min, start, end);\n-\n-        }\n-\n-        return minOverLCM;\n-\n+      // add back in old reservation used resources if any\n+      ReservationAllocation old \u003d reservationTable.get(oldId);\n+      if (old !\u003d null) {\n+        netAvailable \u003d\n+            RLESparseResourceAllocation.merge(resCalc,\n+                Resources.clone(totalCapacity), netAvailable,\n+                old.getResourcesOverTime(), RLEOperator.add, start, end);\n       }\n+      // lower it if this is needed by the sharing policy\n+      netAvailable \u003d\n+          getSharingPolicy().availableResources(netAvailable, this, user,\n+              oldId, start, end);\n+      return netAvailable;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n      ReservationId oldId, long start, long end) throws PlanningException {\n    readLock.lock();\n    try {\n      // create RLE of totCapacity\n      TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n      totAvailable.put(start, Resources.clone(totalCapacity));\n      RLESparseResourceAllocation totRLEAvail \u003d\n          new RLESparseResourceAllocation(totAvailable, resCalc);\n\n      // subtract used from available\n      RLESparseResourceAllocation netAvailable;\n\n      netAvailable \u003d\n          RLESparseResourceAllocation.merge(resCalc,\n              Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n              RLEOperator.subtractTestNonNegative, start, end);\n\n      // add back in old reservation used resources if any\n      ReservationAllocation old \u003d reservationTable.get(oldId);\n      if (old !\u003d null) {\n        netAvailable \u003d\n            RLESparseResourceAllocation.merge(resCalc,\n                Resources.clone(totalCapacity), netAvailable,\n                old.getResourcesOverTime(), RLEOperator.add, start, end);\n      }\n      // lower it if this is needed by the sharing policy\n      netAvailable \u003d\n          getSharingPolicy().availableResources(netAvailable, this, user,\n              oldId, start, end);\n      return netAvailable;\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
          "extendedDetails": {}
        }
      ]
    },
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "01/09/17 3:16 PM",
      "commitName": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthor": "Subru Krishnan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
          "commitDate": "01/09/17 3:16 PM",
          "commitName": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "01/05/17 4:01 PM",
          "commitNameOld": "a3a615eeab8c14ccdc548311097e62a916963dc5",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 122.97,
          "commitsBetweenForRepo": 775,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,81 @@\n   public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n-      ReservationId oldId, long start, long end) throws PlanningException {\n+      ReservationId oldId, long start, long end, long period)\n+      throws PlanningException {\n     readLock.lock();\n     try {\n-      // create RLE of totCapacity\n-      TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n-      totAvailable.put(start, Resources.clone(totalCapacity));\n-      RLESparseResourceAllocation totRLEAvail \u003d\n-          new RLESparseResourceAllocation(totAvailable, resCalc);\n \n-      // subtract used from available\n-      RLESparseResourceAllocation netAvailable;\n+      // for non-periodic return simple available resources\n+      if (period \u003d\u003d 0) {\n \n-      netAvailable \u003d\n-          RLESparseResourceAllocation.merge(resCalc,\n-              Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n-              RLEOperator.subtractTestNonNegative, start, end);\n+        // create RLE of totCapacity\n+        TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n+        totAvailable.put(start, Resources.clone(totalCapacity));\n+        RLESparseResourceAllocation totRLEAvail \u003d\n+            new RLESparseResourceAllocation(totAvailable, resCalc);\n \n-      // add back in old reservation used resources if any\n-      ReservationAllocation old \u003d reservationTable.get(oldId);\n-      if (old !\u003d null) {\n-        netAvailable \u003d\n-            RLESparseResourceAllocation.merge(resCalc,\n-                Resources.clone(totalCapacity), netAvailable,\n-                old.getResourcesOverTime(), RLEOperator.add, start, end);\n+        // subtract used from available\n+        RLESparseResourceAllocation netAvailable;\n+\n+        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n+            Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n+            RLEOperator.subtractTestNonNegative, start, end);\n+\n+        // remove periodic component\n+        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n+            Resources.clone(totalCapacity), netAvailable, periodicRle,\n+            RLEOperator.subtractTestNonNegative, start, end);\n+\n+        // add back in old reservation used resources if any\n+        ReservationAllocation old \u003d reservationTable.get(oldId);\n+        if (old !\u003d null) {\n+\n+          RLESparseResourceAllocation addBackPrevious \u003d\n+              old.getResourcesOverTime(start, end);\n+          netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n+              Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n+              RLEOperator.add, start, end);\n+        }\n+        // lower it if this is needed by the sharing policy\n+        netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n+            user, oldId, start, end);\n+        return netAvailable;\n+      } else {\n+\n+        if (periodicRle.getTimePeriod() % period !\u003d 0) {\n+          throw new PlanningException(\"The reservation periodicity (\" + period\n+              + \") must be\" + \"an exact divider of the system maxPeriod (\"\n+              + periodicRle.getTimePeriod() + \")\");\n+        }\n+\n+        // find the minimum resources available among all the instances that fit\n+        // in the LCM\n+        long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n+\n+        RLESparseResourceAllocation minOverLCM \u003d\n+            getAvailableResourceOverTime(user, oldId, start, end, 0);\n+        for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n+\n+          long rStart \u003d start + i * period;\n+          long rEnd \u003d end + i * period;\n+\n+          // recursive invocation of non-periodic range (to pick raw-info)\n+          RLESparseResourceAllocation snapShot \u003d\n+              getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n+\n+          // time-align on start\n+          snapShot.shift(-(i * period));\n+\n+          // pick the minimum amount of resources in each time interval\n+          minOverLCM \u003d\n+              RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n+                  minOverLCM, snapShot, RLEOperator.min, start, end);\n+\n+        }\n+\n+        return minOverLCM;\n+\n       }\n-      // lower it if this is needed by the sharing policy\n-      netAvailable \u003d\n-          getSharingPolicy().availableResources(netAvailable, this, user,\n-              oldId, start, end);\n-      return netAvailable;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n      ReservationId oldId, long start, long end, long period)\n      throws PlanningException {\n    readLock.lock();\n    try {\n\n      // for non-periodic return simple available resources\n      if (period \u003d\u003d 0) {\n\n        // create RLE of totCapacity\n        TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n        totAvailable.put(start, Resources.clone(totalCapacity));\n        RLESparseResourceAllocation totRLEAvail \u003d\n            new RLESparseResourceAllocation(totAvailable, resCalc);\n\n        // subtract used from available\n        RLESparseResourceAllocation netAvailable;\n\n        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n            Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n            RLEOperator.subtractTestNonNegative, start, end);\n\n        // remove periodic component\n        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n            Resources.clone(totalCapacity), netAvailable, periodicRle,\n            RLEOperator.subtractTestNonNegative, start, end);\n\n        // add back in old reservation used resources if any\n        ReservationAllocation old \u003d reservationTable.get(oldId);\n        if (old !\u003d null) {\n\n          RLESparseResourceAllocation addBackPrevious \u003d\n              old.getResourcesOverTime(start, end);\n          netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n              Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n              RLEOperator.add, start, end);\n        }\n        // lower it if this is needed by the sharing policy\n        netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n            user, oldId, start, end);\n        return netAvailable;\n      } else {\n\n        if (periodicRle.getTimePeriod() % period !\u003d 0) {\n          throw new PlanningException(\"The reservation periodicity (\" + period\n              + \") must be\" + \"an exact divider of the system maxPeriod (\"\n              + periodicRle.getTimePeriod() + \")\");\n        }\n\n        // find the minimum resources available among all the instances that fit\n        // in the LCM\n        long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n\n        RLESparseResourceAllocation minOverLCM \u003d\n            getAvailableResourceOverTime(user, oldId, start, end, 0);\n        for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n\n          long rStart \u003d start + i * period;\n          long rEnd \u003d end + i * period;\n\n          // recursive invocation of non-periodic range (to pick raw-info)\n          RLESparseResourceAllocation snapShot \u003d\n              getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n\n          // time-align on start\n          snapShot.shift(-(i * period));\n\n          // pick the minimum amount of resources in each time interval\n          minOverLCM \u003d\n              RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n                  minOverLCM, snapShot, RLEOperator.min, start, end);\n\n        }\n\n        return minOverLCM;\n\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
          "extendedDetails": {
            "oldValue": "[user-String, oldId-ReservationId, start-long, end-long]",
            "newValue": "[user-String, oldId-ReservationId, start-long, end-long, period-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
          "commitDate": "01/09/17 3:16 PM",
          "commitName": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "01/05/17 4:01 PM",
          "commitNameOld": "a3a615eeab8c14ccdc548311097e62a916963dc5",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 122.97,
          "commitsBetweenForRepo": 775,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,81 @@\n   public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n-      ReservationId oldId, long start, long end) throws PlanningException {\n+      ReservationId oldId, long start, long end, long period)\n+      throws PlanningException {\n     readLock.lock();\n     try {\n-      // create RLE of totCapacity\n-      TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n-      totAvailable.put(start, Resources.clone(totalCapacity));\n-      RLESparseResourceAllocation totRLEAvail \u003d\n-          new RLESparseResourceAllocation(totAvailable, resCalc);\n \n-      // subtract used from available\n-      RLESparseResourceAllocation netAvailable;\n+      // for non-periodic return simple available resources\n+      if (period \u003d\u003d 0) {\n \n-      netAvailable \u003d\n-          RLESparseResourceAllocation.merge(resCalc,\n-              Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n-              RLEOperator.subtractTestNonNegative, start, end);\n+        // create RLE of totCapacity\n+        TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n+        totAvailable.put(start, Resources.clone(totalCapacity));\n+        RLESparseResourceAllocation totRLEAvail \u003d\n+            new RLESparseResourceAllocation(totAvailable, resCalc);\n \n-      // add back in old reservation used resources if any\n-      ReservationAllocation old \u003d reservationTable.get(oldId);\n-      if (old !\u003d null) {\n-        netAvailable \u003d\n-            RLESparseResourceAllocation.merge(resCalc,\n-                Resources.clone(totalCapacity), netAvailable,\n-                old.getResourcesOverTime(), RLEOperator.add, start, end);\n+        // subtract used from available\n+        RLESparseResourceAllocation netAvailable;\n+\n+        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n+            Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n+            RLEOperator.subtractTestNonNegative, start, end);\n+\n+        // remove periodic component\n+        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n+            Resources.clone(totalCapacity), netAvailable, periodicRle,\n+            RLEOperator.subtractTestNonNegative, start, end);\n+\n+        // add back in old reservation used resources if any\n+        ReservationAllocation old \u003d reservationTable.get(oldId);\n+        if (old !\u003d null) {\n+\n+          RLESparseResourceAllocation addBackPrevious \u003d\n+              old.getResourcesOverTime(start, end);\n+          netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n+              Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n+              RLEOperator.add, start, end);\n+        }\n+        // lower it if this is needed by the sharing policy\n+        netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n+            user, oldId, start, end);\n+        return netAvailable;\n+      } else {\n+\n+        if (periodicRle.getTimePeriod() % period !\u003d 0) {\n+          throw new PlanningException(\"The reservation periodicity (\" + period\n+              + \") must be\" + \"an exact divider of the system maxPeriod (\"\n+              + periodicRle.getTimePeriod() + \")\");\n+        }\n+\n+        // find the minimum resources available among all the instances that fit\n+        // in the LCM\n+        long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n+\n+        RLESparseResourceAllocation minOverLCM \u003d\n+            getAvailableResourceOverTime(user, oldId, start, end, 0);\n+        for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n+\n+          long rStart \u003d start + i * period;\n+          long rEnd \u003d end + i * period;\n+\n+          // recursive invocation of non-periodic range (to pick raw-info)\n+          RLESparseResourceAllocation snapShot \u003d\n+              getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n+\n+          // time-align on start\n+          snapShot.shift(-(i * period));\n+\n+          // pick the minimum amount of resources in each time interval\n+          minOverLCM \u003d\n+              RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n+                  minOverLCM, snapShot, RLEOperator.min, start, end);\n+\n+        }\n+\n+        return minOverLCM;\n+\n       }\n-      // lower it if this is needed by the sharing policy\n-      netAvailable \u003d\n-          getSharingPolicy().availableResources(netAvailable, this, user,\n-              oldId, start, end);\n-      return netAvailable;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n      ReservationId oldId, long start, long end, long period)\n      throws PlanningException {\n    readLock.lock();\n    try {\n\n      // for non-periodic return simple available resources\n      if (period \u003d\u003d 0) {\n\n        // create RLE of totCapacity\n        TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n        totAvailable.put(start, Resources.clone(totalCapacity));\n        RLESparseResourceAllocation totRLEAvail \u003d\n            new RLESparseResourceAllocation(totAvailable, resCalc);\n\n        // subtract used from available\n        RLESparseResourceAllocation netAvailable;\n\n        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n            Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n            RLEOperator.subtractTestNonNegative, start, end);\n\n        // remove periodic component\n        netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n            Resources.clone(totalCapacity), netAvailable, periodicRle,\n            RLEOperator.subtractTestNonNegative, start, end);\n\n        // add back in old reservation used resources if any\n        ReservationAllocation old \u003d reservationTable.get(oldId);\n        if (old !\u003d null) {\n\n          RLESparseResourceAllocation addBackPrevious \u003d\n              old.getResourcesOverTime(start, end);\n          netAvailable \u003d RLESparseResourceAllocation.merge(resCalc,\n              Resources.clone(totalCapacity), netAvailable, addBackPrevious,\n              RLEOperator.add, start, end);\n        }\n        // lower it if this is needed by the sharing policy\n        netAvailable \u003d getSharingPolicy().availableResources(netAvailable, this,\n            user, oldId, start, end);\n        return netAvailable;\n      } else {\n\n        if (periodicRle.getTimePeriod() % period !\u003d 0) {\n          throw new PlanningException(\"The reservation periodicity (\" + period\n              + \") must be\" + \"an exact divider of the system maxPeriod (\"\n              + periodicRle.getTimePeriod() + \")\");\n        }\n\n        // find the minimum resources available among all the instances that fit\n        // in the LCM\n        long numInstInLCM \u003d periodicRle.getTimePeriod() / period;\n\n        RLESparseResourceAllocation minOverLCM \u003d\n            getAvailableResourceOverTime(user, oldId, start, end, 0);\n        for (int i \u003d 1; i \u003c numInstInLCM; i++) {\n\n          long rStart \u003d start + i * period;\n          long rEnd \u003d end + i * period;\n\n          // recursive invocation of non-periodic range (to pick raw-info)\n          RLESparseResourceAllocation snapShot \u003d\n              getAvailableResourceOverTime(user, oldId, rStart, rEnd, 0);\n\n          // time-align on start\n          snapShot.shift(-(i * period));\n\n          // pick the minimum amount of resources in each time interval\n          minOverLCM \u003d\n              RLESparseResourceAllocation.merge(resCalc, getTotalCapacity(),\n                  minOverLCM, snapShot, RLEOperator.min, start, end);\n\n        }\n\n        return minOverLCM;\n\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
          "extendedDetails": {}
        }
      ]
    },
    "742632e346604fd2b263bd42367165638fcf2416": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
      "commitDate": "05/12/15 9:26 PM",
      "commitName": "742632e346604fd2b263bd42367165638fcf2416",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,35 @@\n+  public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n+      ReservationId oldId, long start, long end) throws PlanningException {\n+    readLock.lock();\n+    try {\n+      // create RLE of totCapacity\n+      TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n+      totAvailable.put(start, Resources.clone(totalCapacity));\n+      RLESparseResourceAllocation totRLEAvail \u003d\n+          new RLESparseResourceAllocation(totAvailable, resCalc);\n+\n+      // subtract used from available\n+      RLESparseResourceAllocation netAvailable;\n+\n+      netAvailable \u003d\n+          RLESparseResourceAllocation.merge(resCalc,\n+              Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n+              RLEOperator.subtractTestNonNegative, start, end);\n+\n+      // add back in old reservation used resources if any\n+      ReservationAllocation old \u003d reservationTable.get(oldId);\n+      if (old !\u003d null) {\n+        netAvailable \u003d\n+            RLESparseResourceAllocation.merge(resCalc,\n+                Resources.clone(totalCapacity), netAvailable,\n+                old.getResourcesOverTime(), RLEOperator.add, start, end);\n+      }\n+      // lower it if this is needed by the sharing policy\n+      netAvailable \u003d\n+          getSharingPolicy().availableResources(netAvailable, this, user,\n+              oldId, start, end);\n+      return netAvailable;\n+    } finally {\n+      readLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public RLESparseResourceAllocation getAvailableResourceOverTime(String user,\n      ReservationId oldId, long start, long end) throws PlanningException {\n    readLock.lock();\n    try {\n      // create RLE of totCapacity\n      TreeMap\u003cLong, Resource\u003e totAvailable \u003d new TreeMap\u003cLong, Resource\u003e();\n      totAvailable.put(start, Resources.clone(totalCapacity));\n      RLESparseResourceAllocation totRLEAvail \u003d\n          new RLESparseResourceAllocation(totAvailable, resCalc);\n\n      // subtract used from available\n      RLESparseResourceAllocation netAvailable;\n\n      netAvailable \u003d\n          RLESparseResourceAllocation.merge(resCalc,\n              Resources.clone(totalCapacity), totRLEAvail, rleSparseVector,\n              RLEOperator.subtractTestNonNegative, start, end);\n\n      // add back in old reservation used resources if any\n      ReservationAllocation old \u003d reservationTable.get(oldId);\n      if (old !\u003d null) {\n        netAvailable \u003d\n            RLESparseResourceAllocation.merge(resCalc,\n                Resources.clone(totalCapacity), netAvailable,\n                old.getResourcesOverTime(), RLEOperator.add, start, end);\n      }\n      // lower it if this is needed by the sharing policy\n      netAvailable \u003d\n          getSharingPolicy().availableResources(netAvailable, this, user,\n              oldId, start, end);\n      return netAvailable;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java"
    }
  }
}