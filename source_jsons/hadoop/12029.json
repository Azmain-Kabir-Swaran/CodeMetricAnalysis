{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FsDatasetImpl.java",
  "functionName": "updateReplicaUnderRecovery",
  "functionId": "updateReplicaUnderRecovery___bpid-String__rur-ReplicaInfo__recoveryId-long__newBlockId-long__newlength-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
  "functionStartLine": 2831,
  "functionEndLine": 2880,
  "numCommitsSeen": 436,
  "timeTaken": 15048,
  "changeHistory": [
    "69afa26f19adad4c630a307c274130eb8b697141",
    "1543d0f5be6a02ad00e7a33e35d78af8516043e3",
    "86c9862bec0248d671e657aa56094a2919b8ac14",
    "bb540ba85aa37d9fe31e640665158afe8a936230",
    "96d307e1e320eafb470faf7bd47af3341c399d55",
    "de522d2cd46be13806d13aa5f373b310e0ad6693",
    "7f393a6f61f5a34a1de11481ad321c6a941d5d27",
    "a153b9601ad8628fdd608d8696310ca8c1f58ff0",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f",
    "bc13dfb1426944ce45293cb8f444239a7406762c",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "69afa26f19adad4c630a307c274130eb8b697141": "Ybodychange",
    "1543d0f5be6a02ad00e7a33e35d78af8516043e3": "Ybodychange",
    "86c9862bec0248d671e657aa56094a2919b8ac14": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "bb540ba85aa37d9fe31e640665158afe8a936230": "Ybodychange",
    "96d307e1e320eafb470faf7bd47af3341c399d55": "Ybodychange",
    "de522d2cd46be13806d13aa5f373b310e0ad6693": "Ybodychange",
    "7f393a6f61f5a34a1de11481ad321c6a941d5d27": "Ybodychange",
    "a153b9601ad8628fdd608d8696310ca8c1f58ff0": "Ybodychange",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": "Ymultichange(Yparameterchange,Ybodychange)",
    "bc13dfb1426944ce45293cb8f444239a7406762c": "Ymovefromfile",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "69afa26f19adad4c630a307c274130eb8b697141": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12157. Do fsyncDirectory(..) outside of FSDataset lock. Contributed by inayakumar B.\n",
      "commitDate": "09/08/17 7:03 AM",
      "commitName": "69afa26f19adad4c630a307c274130eb8b697141",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "01/08/17 6:34 PM",
      "commitNameOld": "6814324c332a7d780f3b844fd6f1c62db2f6c88e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 7.52,
      "commitsBetweenForRepo": 54,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   private ReplicaInfo updateReplicaUnderRecovery(\n                                           String bpid,\n                                           ReplicaInfo rur,\n                                           long recoveryId,\n                                           long newBlockId,\n                                           long newlength) throws IOException {\n     //check recovery id\n     if (rur.getRecoveryID() !\u003d recoveryId) {\n       throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n           + \", rur\u003d\" + rur);\n     }\n \n     boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n     // bump rur\u0027s GS to be recovery id\n     if(!copyOnTruncate) {\n       rur.bumpReplicaGS(recoveryId);\n     }\n \n     //update length\n     if (rur.getNumBytes() \u003c newlength) {\n       throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n           + \", rur\u003d\" + rur);\n     }\n \n     if (rur.getNumBytes() \u003e newlength) {\n       if(!copyOnTruncate) {\n         rur.breakHardLinksIfNeeded();\n         rur.truncateBlock(newlength);\n         // update RUR with the new length\n         rur.setNumBytes(newlength);\n       } else {\n         // Copying block to a new block with new blockId.\n         // Not truncating original block.\n         FsVolumeImpl volume \u003d (FsVolumeImpl) rur.getVolume();\n         ReplicaInPipeline newReplicaInfo \u003d volume.updateRURCopyOnTruncate(\n             rur, bpid, newBlockId, recoveryId, newlength);\n         if (newReplicaInfo.getState() !\u003d ReplicaState.RBW) {\n           throw new IOException(\"Append on block \" + rur.getBlockId()\n               + \" returned a replica of state \" + newReplicaInfo.getState()\n               + \"; expected RBW\");\n         }\n \n         newReplicaInfo.setNumBytes(newlength);\n         volumeMap.add(bpid, newReplicaInfo.getReplicaInfo());\n-        finalizeReplica(bpid, newReplicaInfo.getReplicaInfo(), false);\n+        finalizeReplica(bpid, newReplicaInfo.getReplicaInfo());\n       }\n     }\n     // finalize the block\n-    return finalizeReplica(bpid, rur, false);\n+    return finalizeReplica(bpid, rur);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ReplicaInfo updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaInfo rur,\n                                          long recoveryId,\n                                          long newBlockId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n    // bump rur\u0027s GS to be recovery id\n    if(!copyOnTruncate) {\n      rur.bumpReplicaGS(recoveryId);\n    }\n\n    //update length\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n\n    if (rur.getNumBytes() \u003e newlength) {\n      if(!copyOnTruncate) {\n        rur.breakHardLinksIfNeeded();\n        rur.truncateBlock(newlength);\n        // update RUR with the new length\n        rur.setNumBytes(newlength);\n      } else {\n        // Copying block to a new block with new blockId.\n        // Not truncating original block.\n        FsVolumeImpl volume \u003d (FsVolumeImpl) rur.getVolume();\n        ReplicaInPipeline newReplicaInfo \u003d volume.updateRURCopyOnTruncate(\n            rur, bpid, newBlockId, recoveryId, newlength);\n        if (newReplicaInfo.getState() !\u003d ReplicaState.RBW) {\n          throw new IOException(\"Append on block \" + rur.getBlockId()\n              + \" returned a replica of state \" + newReplicaInfo.getState()\n              + \"; expected RBW\");\n        }\n\n        newReplicaInfo.setNumBytes(newlength);\n        volumeMap.add(bpid, newReplicaInfo.getReplicaInfo());\n        finalizeReplica(bpid, newReplicaInfo.getReplicaInfo());\n      }\n    }\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "1543d0f5be6a02ad00e7a33e35d78af8516043e3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5042. Completed files lost after power failure. Contributed by Vinayakumar B.\n",
      "commitDate": "31/05/17 8:55 AM",
      "commitName": "1543d0f5be6a02ad00e7a33e35d78af8516043e3",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "25/05/17 11:05 AM",
      "commitNameOld": "29b7df960fc3d0a7d1416225c3106c7d4222f0ca",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 5.91,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   private ReplicaInfo updateReplicaUnderRecovery(\n                                           String bpid,\n                                           ReplicaInfo rur,\n                                           long recoveryId,\n                                           long newBlockId,\n                                           long newlength) throws IOException {\n     //check recovery id\n     if (rur.getRecoveryID() !\u003d recoveryId) {\n       throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n           + \", rur\u003d\" + rur);\n     }\n \n     boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n     // bump rur\u0027s GS to be recovery id\n     if(!copyOnTruncate) {\n       rur.bumpReplicaGS(recoveryId);\n     }\n \n     //update length\n     if (rur.getNumBytes() \u003c newlength) {\n       throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n           + \", rur\u003d\" + rur);\n     }\n \n     if (rur.getNumBytes() \u003e newlength) {\n       if(!copyOnTruncate) {\n         rur.breakHardLinksIfNeeded();\n         rur.truncateBlock(newlength);\n         // update RUR with the new length\n         rur.setNumBytes(newlength);\n       } else {\n         // Copying block to a new block with new blockId.\n         // Not truncating original block.\n         FsVolumeImpl volume \u003d (FsVolumeImpl) rur.getVolume();\n         ReplicaInPipeline newReplicaInfo \u003d volume.updateRURCopyOnTruncate(\n             rur, bpid, newBlockId, recoveryId, newlength);\n         if (newReplicaInfo.getState() !\u003d ReplicaState.RBW) {\n           throw new IOException(\"Append on block \" + rur.getBlockId()\n               + \" returned a replica of state \" + newReplicaInfo.getState()\n               + \"; expected RBW\");\n         }\n \n         newReplicaInfo.setNumBytes(newlength);\n         volumeMap.add(bpid, newReplicaInfo.getReplicaInfo());\n-        finalizeReplica(bpid, newReplicaInfo.getReplicaInfo());\n+        finalizeReplica(bpid, newReplicaInfo.getReplicaInfo(), false);\n       }\n     }\n     // finalize the block\n-    return finalizeReplica(bpid, rur);\n+    return finalizeReplica(bpid, rur, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ReplicaInfo updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaInfo rur,\n                                          long recoveryId,\n                                          long newBlockId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n    // bump rur\u0027s GS to be recovery id\n    if(!copyOnTruncate) {\n      rur.bumpReplicaGS(recoveryId);\n    }\n\n    //update length\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n\n    if (rur.getNumBytes() \u003e newlength) {\n      if(!copyOnTruncate) {\n        rur.breakHardLinksIfNeeded();\n        rur.truncateBlock(newlength);\n        // update RUR with the new length\n        rur.setNumBytes(newlength);\n      } else {\n        // Copying block to a new block with new blockId.\n        // Not truncating original block.\n        FsVolumeImpl volume \u003d (FsVolumeImpl) rur.getVolume();\n        ReplicaInPipeline newReplicaInfo \u003d volume.updateRURCopyOnTruncate(\n            rur, bpid, newBlockId, recoveryId, newlength);\n        if (newReplicaInfo.getState() !\u003d ReplicaState.RBW) {\n          throw new IOException(\"Append on block \" + rur.getBlockId()\n              + \" returned a replica of state \" + newReplicaInfo.getState()\n              + \"; expected RBW\");\n        }\n\n        newReplicaInfo.setNumBytes(newlength);\n        volumeMap.add(bpid, newReplicaInfo.getReplicaInfo());\n        finalizeReplica(bpid, newReplicaInfo.getReplicaInfo(), false);\n      }\n    }\n    // finalize the block\n    return finalizeReplica(bpid, rur, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "86c9862bec0248d671e657aa56094a2919b8ac14": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-10636. Modify ReplicaInfo to remove the assumption that replica metadata and data are stored in java.io.File. (Virajith Jalaparti via lei)\n",
      "commitDate": "13/09/16 12:54 PM",
      "commitName": "86c9862bec0248d671e657aa56094a2919b8ac14",
      "commitAuthor": "Lei Xu",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10636. Modify ReplicaInfo to remove the assumption that replica metadata and data are stored in java.io.File. (Virajith Jalaparti via lei)\n",
          "commitDate": "13/09/16 12:54 PM",
          "commitName": "86c9862bec0248d671e657aa56094a2919b8ac14",
          "commitAuthor": "Lei Xu",
          "commitDateOld": "10/09/16 6:22 PM",
          "commitNameOld": "a99bf26a0899bcc4307c3a242c8414eaef555aa7",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 2.77,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,50 @@\n-  private FinalizedReplica updateReplicaUnderRecovery(\n+  private ReplicaInfo updateReplicaUnderRecovery(\n                                           String bpid,\n-                                          ReplicaUnderRecovery rur,\n+                                          ReplicaInfo rur,\n                                           long recoveryId,\n                                           long newBlockId,\n                                           long newlength) throws IOException {\n     //check recovery id\n     if (rur.getRecoveryID() !\u003d recoveryId) {\n       throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n           + \", rur\u003d\" + rur);\n     }\n \n     boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n-    File blockFile;\n-    File metaFile;\n     // bump rur\u0027s GS to be recovery id\n     if(!copyOnTruncate) {\n-      bumpReplicaGS(rur, recoveryId);\n-      blockFile \u003d rur.getBlockFile();\n-      metaFile \u003d rur.getMetaFile();\n-    } else {\n-      File[] copiedReplicaFiles \u003d\n-          copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n-      blockFile \u003d copiedReplicaFiles[1];\n-      metaFile \u003d copiedReplicaFiles[0];\n+      rur.bumpReplicaGS(recoveryId);\n     }\n \n     //update length\n     if (rur.getNumBytes() \u003c newlength) {\n       throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n           + \", rur\u003d\" + rur);\n     }\n+\n     if (rur.getNumBytes() \u003e newlength) {\n-      rur.breakHardLinksIfNeeded();\n-      truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n       if(!copyOnTruncate) {\n+        rur.breakHardLinksIfNeeded();\n+        rur.truncateBlock(newlength);\n         // update RUR with the new length\n         rur.setNumBytes(newlength);\n       } else {\n         // Copying block to a new block with new blockId.\n         // Not truncating original block.\n-        FsVolumeSpi volume \u003d rur.getVolume();\n-        String blockPath \u003d blockFile.getAbsolutePath();\n-        String volumePath \u003d volume.getBasePath();\n-        assert blockPath.startsWith(volumePath) :\n-            \"New block file: \" + blockPath + \" must be on \" +\n-                \"same volume as recovery replica: \" + volumePath;\n-        ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n-            newBlockId, recoveryId, volume, blockFile.getParentFile(),\n-            newlength);\n-        newReplicaInfo.setNumBytes(newlength);\n-        volumeMap.add(bpid, newReplicaInfo);\n-        finalizeReplica(bpid, newReplicaInfo);\n-      }\n-   }\n+        FsVolumeImpl volume \u003d (FsVolumeImpl) rur.getVolume();\n+        ReplicaInPipeline newReplicaInfo \u003d volume.updateRURCopyOnTruncate(\n+            rur, bpid, newBlockId, recoveryId, newlength);\n+        if (newReplicaInfo.getState() !\u003d ReplicaState.RBW) {\n+          throw new IOException(\"Append on block \" + rur.getBlockId()\n+              + \" returned a replica of state \" + newReplicaInfo.getState()\n+              + \"; expected RBW\");\n+        }\n \n+        newReplicaInfo.setNumBytes(newlength);\n+        volumeMap.add(bpid, newReplicaInfo.getReplicaInfo());\n+        finalizeReplica(bpid, newReplicaInfo.getReplicaInfo());\n+      }\n+    }\n     // finalize the block\n     return finalizeReplica(bpid, rur);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ReplicaInfo updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaInfo rur,\n                                          long recoveryId,\n                                          long newBlockId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n    // bump rur\u0027s GS to be recovery id\n    if(!copyOnTruncate) {\n      rur.bumpReplicaGS(recoveryId);\n    }\n\n    //update length\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n\n    if (rur.getNumBytes() \u003e newlength) {\n      if(!copyOnTruncate) {\n        rur.breakHardLinksIfNeeded();\n        rur.truncateBlock(newlength);\n        // update RUR with the new length\n        rur.setNumBytes(newlength);\n      } else {\n        // Copying block to a new block with new blockId.\n        // Not truncating original block.\n        FsVolumeImpl volume \u003d (FsVolumeImpl) rur.getVolume();\n        ReplicaInPipeline newReplicaInfo \u003d volume.updateRURCopyOnTruncate(\n            rur, bpid, newBlockId, recoveryId, newlength);\n        if (newReplicaInfo.getState() !\u003d ReplicaState.RBW) {\n          throw new IOException(\"Append on block \" + rur.getBlockId()\n              + \" returned a replica of state \" + newReplicaInfo.getState()\n              + \"; expected RBW\");\n        }\n\n        newReplicaInfo.setNumBytes(newlength);\n        volumeMap.add(bpid, newReplicaInfo.getReplicaInfo());\n        finalizeReplica(bpid, newReplicaInfo.getReplicaInfo());\n      }\n    }\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldValue": "[bpid-String, rur-ReplicaUnderRecovery, recoveryId-long, newBlockId-long, newlength-long]",
            "newValue": "[bpid-String, rur-ReplicaInfo, recoveryId-long, newBlockId-long, newlength-long]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-10636. Modify ReplicaInfo to remove the assumption that replica metadata and data are stored in java.io.File. (Virajith Jalaparti via lei)\n",
          "commitDate": "13/09/16 12:54 PM",
          "commitName": "86c9862bec0248d671e657aa56094a2919b8ac14",
          "commitAuthor": "Lei Xu",
          "commitDateOld": "10/09/16 6:22 PM",
          "commitNameOld": "a99bf26a0899bcc4307c3a242c8414eaef555aa7",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 2.77,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,50 @@\n-  private FinalizedReplica updateReplicaUnderRecovery(\n+  private ReplicaInfo updateReplicaUnderRecovery(\n                                           String bpid,\n-                                          ReplicaUnderRecovery rur,\n+                                          ReplicaInfo rur,\n                                           long recoveryId,\n                                           long newBlockId,\n                                           long newlength) throws IOException {\n     //check recovery id\n     if (rur.getRecoveryID() !\u003d recoveryId) {\n       throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n           + \", rur\u003d\" + rur);\n     }\n \n     boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n-    File blockFile;\n-    File metaFile;\n     // bump rur\u0027s GS to be recovery id\n     if(!copyOnTruncate) {\n-      bumpReplicaGS(rur, recoveryId);\n-      blockFile \u003d rur.getBlockFile();\n-      metaFile \u003d rur.getMetaFile();\n-    } else {\n-      File[] copiedReplicaFiles \u003d\n-          copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n-      blockFile \u003d copiedReplicaFiles[1];\n-      metaFile \u003d copiedReplicaFiles[0];\n+      rur.bumpReplicaGS(recoveryId);\n     }\n \n     //update length\n     if (rur.getNumBytes() \u003c newlength) {\n       throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n           + \", rur\u003d\" + rur);\n     }\n+\n     if (rur.getNumBytes() \u003e newlength) {\n-      rur.breakHardLinksIfNeeded();\n-      truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n       if(!copyOnTruncate) {\n+        rur.breakHardLinksIfNeeded();\n+        rur.truncateBlock(newlength);\n         // update RUR with the new length\n         rur.setNumBytes(newlength);\n       } else {\n         // Copying block to a new block with new blockId.\n         // Not truncating original block.\n-        FsVolumeSpi volume \u003d rur.getVolume();\n-        String blockPath \u003d blockFile.getAbsolutePath();\n-        String volumePath \u003d volume.getBasePath();\n-        assert blockPath.startsWith(volumePath) :\n-            \"New block file: \" + blockPath + \" must be on \" +\n-                \"same volume as recovery replica: \" + volumePath;\n-        ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n-            newBlockId, recoveryId, volume, blockFile.getParentFile(),\n-            newlength);\n-        newReplicaInfo.setNumBytes(newlength);\n-        volumeMap.add(bpid, newReplicaInfo);\n-        finalizeReplica(bpid, newReplicaInfo);\n-      }\n-   }\n+        FsVolumeImpl volume \u003d (FsVolumeImpl) rur.getVolume();\n+        ReplicaInPipeline newReplicaInfo \u003d volume.updateRURCopyOnTruncate(\n+            rur, bpid, newBlockId, recoveryId, newlength);\n+        if (newReplicaInfo.getState() !\u003d ReplicaState.RBW) {\n+          throw new IOException(\"Append on block \" + rur.getBlockId()\n+              + \" returned a replica of state \" + newReplicaInfo.getState()\n+              + \"; expected RBW\");\n+        }\n \n+        newReplicaInfo.setNumBytes(newlength);\n+        volumeMap.add(bpid, newReplicaInfo.getReplicaInfo());\n+        finalizeReplica(bpid, newReplicaInfo.getReplicaInfo());\n+      }\n+    }\n     // finalize the block\n     return finalizeReplica(bpid, rur);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ReplicaInfo updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaInfo rur,\n                                          long recoveryId,\n                                          long newBlockId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n    // bump rur\u0027s GS to be recovery id\n    if(!copyOnTruncate) {\n      rur.bumpReplicaGS(recoveryId);\n    }\n\n    //update length\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n\n    if (rur.getNumBytes() \u003e newlength) {\n      if(!copyOnTruncate) {\n        rur.breakHardLinksIfNeeded();\n        rur.truncateBlock(newlength);\n        // update RUR with the new length\n        rur.setNumBytes(newlength);\n      } else {\n        // Copying block to a new block with new blockId.\n        // Not truncating original block.\n        FsVolumeImpl volume \u003d (FsVolumeImpl) rur.getVolume();\n        ReplicaInPipeline newReplicaInfo \u003d volume.updateRURCopyOnTruncate(\n            rur, bpid, newBlockId, recoveryId, newlength);\n        if (newReplicaInfo.getState() !\u003d ReplicaState.RBW) {\n          throw new IOException(\"Append on block \" + rur.getBlockId()\n              + \" returned a replica of state \" + newReplicaInfo.getState()\n              + \"; expected RBW\");\n        }\n\n        newReplicaInfo.setNumBytes(newlength);\n        volumeMap.add(bpid, newReplicaInfo.getReplicaInfo());\n        finalizeReplica(bpid, newReplicaInfo.getReplicaInfo());\n      }\n    }\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldValue": "FinalizedReplica",
            "newValue": "ReplicaInfo"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10636. Modify ReplicaInfo to remove the assumption that replica metadata and data are stored in java.io.File. (Virajith Jalaparti via lei)\n",
          "commitDate": "13/09/16 12:54 PM",
          "commitName": "86c9862bec0248d671e657aa56094a2919b8ac14",
          "commitAuthor": "Lei Xu",
          "commitDateOld": "10/09/16 6:22 PM",
          "commitNameOld": "a99bf26a0899bcc4307c3a242c8414eaef555aa7",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 2.77,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,50 @@\n-  private FinalizedReplica updateReplicaUnderRecovery(\n+  private ReplicaInfo updateReplicaUnderRecovery(\n                                           String bpid,\n-                                          ReplicaUnderRecovery rur,\n+                                          ReplicaInfo rur,\n                                           long recoveryId,\n                                           long newBlockId,\n                                           long newlength) throws IOException {\n     //check recovery id\n     if (rur.getRecoveryID() !\u003d recoveryId) {\n       throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n           + \", rur\u003d\" + rur);\n     }\n \n     boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n-    File blockFile;\n-    File metaFile;\n     // bump rur\u0027s GS to be recovery id\n     if(!copyOnTruncate) {\n-      bumpReplicaGS(rur, recoveryId);\n-      blockFile \u003d rur.getBlockFile();\n-      metaFile \u003d rur.getMetaFile();\n-    } else {\n-      File[] copiedReplicaFiles \u003d\n-          copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n-      blockFile \u003d copiedReplicaFiles[1];\n-      metaFile \u003d copiedReplicaFiles[0];\n+      rur.bumpReplicaGS(recoveryId);\n     }\n \n     //update length\n     if (rur.getNumBytes() \u003c newlength) {\n       throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n           + \", rur\u003d\" + rur);\n     }\n+\n     if (rur.getNumBytes() \u003e newlength) {\n-      rur.breakHardLinksIfNeeded();\n-      truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n       if(!copyOnTruncate) {\n+        rur.breakHardLinksIfNeeded();\n+        rur.truncateBlock(newlength);\n         // update RUR with the new length\n         rur.setNumBytes(newlength);\n       } else {\n         // Copying block to a new block with new blockId.\n         // Not truncating original block.\n-        FsVolumeSpi volume \u003d rur.getVolume();\n-        String blockPath \u003d blockFile.getAbsolutePath();\n-        String volumePath \u003d volume.getBasePath();\n-        assert blockPath.startsWith(volumePath) :\n-            \"New block file: \" + blockPath + \" must be on \" +\n-                \"same volume as recovery replica: \" + volumePath;\n-        ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n-            newBlockId, recoveryId, volume, blockFile.getParentFile(),\n-            newlength);\n-        newReplicaInfo.setNumBytes(newlength);\n-        volumeMap.add(bpid, newReplicaInfo);\n-        finalizeReplica(bpid, newReplicaInfo);\n-      }\n-   }\n+        FsVolumeImpl volume \u003d (FsVolumeImpl) rur.getVolume();\n+        ReplicaInPipeline newReplicaInfo \u003d volume.updateRURCopyOnTruncate(\n+            rur, bpid, newBlockId, recoveryId, newlength);\n+        if (newReplicaInfo.getState() !\u003d ReplicaState.RBW) {\n+          throw new IOException(\"Append on block \" + rur.getBlockId()\n+              + \" returned a replica of state \" + newReplicaInfo.getState()\n+              + \"; expected RBW\");\n+        }\n \n+        newReplicaInfo.setNumBytes(newlength);\n+        volumeMap.add(bpid, newReplicaInfo.getReplicaInfo());\n+        finalizeReplica(bpid, newReplicaInfo.getReplicaInfo());\n+      }\n+    }\n     // finalize the block\n     return finalizeReplica(bpid, rur);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ReplicaInfo updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaInfo rur,\n                                          long recoveryId,\n                                          long newBlockId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n    // bump rur\u0027s GS to be recovery id\n    if(!copyOnTruncate) {\n      rur.bumpReplicaGS(recoveryId);\n    }\n\n    //update length\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n\n    if (rur.getNumBytes() \u003e newlength) {\n      if(!copyOnTruncate) {\n        rur.breakHardLinksIfNeeded();\n        rur.truncateBlock(newlength);\n        // update RUR with the new length\n        rur.setNumBytes(newlength);\n      } else {\n        // Copying block to a new block with new blockId.\n        // Not truncating original block.\n        FsVolumeImpl volume \u003d (FsVolumeImpl) rur.getVolume();\n        ReplicaInPipeline newReplicaInfo \u003d volume.updateRURCopyOnTruncate(\n            rur, bpid, newBlockId, recoveryId, newlength);\n        if (newReplicaInfo.getState() !\u003d ReplicaState.RBW) {\n          throw new IOException(\"Append on block \" + rur.getBlockId()\n              + \" returned a replica of state \" + newReplicaInfo.getState()\n              + \"; expected RBW\");\n        }\n\n        newReplicaInfo.setNumBytes(newlength);\n        volumeMap.add(bpid, newReplicaInfo.getReplicaInfo());\n        finalizeReplica(bpid, newReplicaInfo.getReplicaInfo());\n      }\n    }\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "bb540ba85aa37d9fe31e640665158afe8a936230": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9589. Block files which have been hardlinked should be duplicated before the DataNode appends to the them (cmccabe)\n",
      "commitDate": "22/12/15 9:36 AM",
      "commitName": "bb540ba85aa37d9fe31e640665158afe8a936230",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "15/12/15 12:32 AM",
      "commitNameOld": "96d307e1e320eafb470faf7bd47af3341c399d55",
      "commitAuthorOld": "Plamen Jeliazkov",
      "daysBetweenCommits": 7.38,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,59 @@\n   private FinalizedReplica updateReplicaUnderRecovery(\n                                           String bpid,\n                                           ReplicaUnderRecovery rur,\n                                           long recoveryId,\n                                           long newBlockId,\n                                           long newlength) throws IOException {\n     //check recovery id\n     if (rur.getRecoveryID() !\u003d recoveryId) {\n       throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n           + \", rur\u003d\" + rur);\n     }\n \n     boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n     File blockFile;\n     File metaFile;\n     // bump rur\u0027s GS to be recovery id\n     if(!copyOnTruncate) {\n       bumpReplicaGS(rur, recoveryId);\n       blockFile \u003d rur.getBlockFile();\n       metaFile \u003d rur.getMetaFile();\n     } else {\n       File[] copiedReplicaFiles \u003d\n           copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n       blockFile \u003d copiedReplicaFiles[1];\n       metaFile \u003d copiedReplicaFiles[0];\n     }\n \n     //update length\n     if (rur.getNumBytes() \u003c newlength) {\n       throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n           + \", rur\u003d\" + rur);\n     }\n     if (rur.getNumBytes() \u003e newlength) {\n+      rur.breakHardLinksIfNeeded();\n       truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n       if(!copyOnTruncate) {\n         // update RUR with the new length\n         rur.setNumBytes(newlength);\n       } else {\n         // Copying block to a new block with new blockId.\n         // Not truncating original block.\n         FsVolumeSpi volume \u003d rur.getVolume();\n         String blockPath \u003d blockFile.getAbsolutePath();\n         String volumePath \u003d volume.getBasePath();\n         assert blockPath.startsWith(volumePath) :\n             \"New block file: \" + blockPath + \" must be on \" +\n                 \"same volume as recovery replica: \" + volumePath;\n         ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n             newBlockId, recoveryId, volume, blockFile.getParentFile(),\n             newlength);\n         newReplicaInfo.setNumBytes(newlength);\n         volumeMap.add(bpid, newReplicaInfo);\n         finalizeReplica(bpid, newReplicaInfo);\n       }\n    }\n \n     // finalize the block\n     return finalizeReplica(bpid, rur);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FinalizedReplica updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaUnderRecovery rur,\n                                          long recoveryId,\n                                          long newBlockId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n    File blockFile;\n    File metaFile;\n    // bump rur\u0027s GS to be recovery id\n    if(!copyOnTruncate) {\n      bumpReplicaGS(rur, recoveryId);\n      blockFile \u003d rur.getBlockFile();\n      metaFile \u003d rur.getMetaFile();\n    } else {\n      File[] copiedReplicaFiles \u003d\n          copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n      blockFile \u003d copiedReplicaFiles[1];\n      metaFile \u003d copiedReplicaFiles[0];\n    }\n\n    //update length\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n    if (rur.getNumBytes() \u003e newlength) {\n      rur.breakHardLinksIfNeeded();\n      truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n      if(!copyOnTruncate) {\n        // update RUR with the new length\n        rur.setNumBytes(newlength);\n      } else {\n        // Copying block to a new block with new blockId.\n        // Not truncating original block.\n        FsVolumeSpi volume \u003d rur.getVolume();\n        String blockPath \u003d blockFile.getAbsolutePath();\n        String volumePath \u003d volume.getBasePath();\n        assert blockPath.startsWith(volumePath) :\n            \"New block file: \" + blockPath + \" must be on \" +\n                \"same volume as recovery replica: \" + volumePath;\n        ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n            newBlockId, recoveryId, volume, blockFile.getParentFile(),\n            newlength);\n        newReplicaInfo.setNumBytes(newlength);\n        volumeMap.add(bpid, newReplicaInfo);\n        finalizeReplica(bpid, newReplicaInfo);\n      }\n   }\n\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "96d307e1e320eafb470faf7bd47af3341c399d55": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9516. Truncate file fails with data dirs on multiple disks. Contributed by Plamen Jeliazkov.\n",
      "commitDate": "15/12/15 12:32 AM",
      "commitName": "96d307e1e320eafb470faf7bd47af3341c399d55",
      "commitAuthor": "Plamen Jeliazkov",
      "commitDateOld": "14/12/15 11:25 AM",
      "commitNameOld": "de522d2cd46be13806d13aa5f373b310e0ad6693",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 0.55,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,58 @@\n   private FinalizedReplica updateReplicaUnderRecovery(\n                                           String bpid,\n                                           ReplicaUnderRecovery rur,\n                                           long recoveryId,\n                                           long newBlockId,\n                                           long newlength) throws IOException {\n     //check recovery id\n     if (rur.getRecoveryID() !\u003d recoveryId) {\n       throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n           + \", rur\u003d\" + rur);\n     }\n \n     boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n     File blockFile;\n     File metaFile;\n     // bump rur\u0027s GS to be recovery id\n     if(!copyOnTruncate) {\n       bumpReplicaGS(rur, recoveryId);\n       blockFile \u003d rur.getBlockFile();\n       metaFile \u003d rur.getMetaFile();\n     } else {\n       File[] copiedReplicaFiles \u003d\n           copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n       blockFile \u003d copiedReplicaFiles[1];\n       metaFile \u003d copiedReplicaFiles[0];\n     }\n \n     //update length\n     if (rur.getNumBytes() \u003c newlength) {\n       throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n           + \", rur\u003d\" + rur);\n     }\n     if (rur.getNumBytes() \u003e newlength) {\n       truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n       if(!copyOnTruncate) {\n         // update RUR with the new length\n         rur.setNumBytes(newlength);\n       } else {\n         // Copying block to a new block with new blockId.\n         // Not truncating original block.\n+        FsVolumeSpi volume \u003d rur.getVolume();\n+        String blockPath \u003d blockFile.getAbsolutePath();\n+        String volumePath \u003d volume.getBasePath();\n+        assert blockPath.startsWith(volumePath) :\n+            \"New block file: \" + blockPath + \" must be on \" +\n+                \"same volume as recovery replica: \" + volumePath;\n         ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n-            newBlockId, recoveryId, rur.getVolume(), blockFile.getParentFile(),\n+            newBlockId, recoveryId, volume, blockFile.getParentFile(),\n             newlength);\n         newReplicaInfo.setNumBytes(newlength);\n         volumeMap.add(bpid, newReplicaInfo);\n         finalizeReplica(bpid, newReplicaInfo);\n       }\n    }\n \n     // finalize the block\n     return finalizeReplica(bpid, rur);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FinalizedReplica updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaUnderRecovery rur,\n                                          long recoveryId,\n                                          long newBlockId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n    File blockFile;\n    File metaFile;\n    // bump rur\u0027s GS to be recovery id\n    if(!copyOnTruncate) {\n      bumpReplicaGS(rur, recoveryId);\n      blockFile \u003d rur.getBlockFile();\n      metaFile \u003d rur.getMetaFile();\n    } else {\n      File[] copiedReplicaFiles \u003d\n          copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n      blockFile \u003d copiedReplicaFiles[1];\n      metaFile \u003d copiedReplicaFiles[0];\n    }\n\n    //update length\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n    if (rur.getNumBytes() \u003e newlength) {\n      truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n      if(!copyOnTruncate) {\n        // update RUR with the new length\n        rur.setNumBytes(newlength);\n      } else {\n        // Copying block to a new block with new blockId.\n        // Not truncating original block.\n        FsVolumeSpi volume \u003d rur.getVolume();\n        String blockPath \u003d blockFile.getAbsolutePath();\n        String volumePath \u003d volume.getBasePath();\n        assert blockPath.startsWith(volumePath) :\n            \"New block file: \" + blockPath + \" must be on \" +\n                \"same volume as recovery replica: \" + volumePath;\n        ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n            newBlockId, recoveryId, volume, blockFile.getParentFile(),\n            newlength);\n        newReplicaInfo.setNumBytes(newlength);\n        volumeMap.add(bpid, newReplicaInfo);\n        finalizeReplica(bpid, newReplicaInfo);\n      }\n   }\n\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "de522d2cd46be13806d13aa5f373b310e0ad6693": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Revert \"HDFS-8860. Remove unused Replica copyOnWrite code (Lei (Eddy) Xu via Colin P. McCabe)\"\"\n\nThis reverts commit 7f393a6f61f5a34a1de11481ad321c6a941d5d27.\n",
      "commitDate": "14/12/15 11:25 AM",
      "commitName": "de522d2cd46be13806d13aa5f373b310e0ad6693",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "11/12/15 6:44 AM",
      "commitNameOld": "a48301791e9564363bc2abad4e89e344b0d7a5ff",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 3.19,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,52 @@\n   private FinalizedReplica updateReplicaUnderRecovery(\n                                           String bpid,\n                                           ReplicaUnderRecovery rur,\n                                           long recoveryId,\n                                           long newBlockId,\n                                           long newlength) throws IOException {\n     //check recovery id\n     if (rur.getRecoveryID() !\u003d recoveryId) {\n       throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n           + \", rur\u003d\" + rur);\n     }\n \n     boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n     File blockFile;\n     File metaFile;\n     // bump rur\u0027s GS to be recovery id\n     if(!copyOnTruncate) {\n       bumpReplicaGS(rur, recoveryId);\n       blockFile \u003d rur.getBlockFile();\n       metaFile \u003d rur.getMetaFile();\n     } else {\n       File[] copiedReplicaFiles \u003d\n           copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n       blockFile \u003d copiedReplicaFiles[1];\n       metaFile \u003d copiedReplicaFiles[0];\n     }\n \n     //update length\n     if (rur.getNumBytes() \u003c newlength) {\n       throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n           + \", rur\u003d\" + rur);\n     }\n     if (rur.getNumBytes() \u003e newlength) {\n-      rur.unlinkBlock(1);\n       truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n       if(!copyOnTruncate) {\n         // update RUR with the new length\n         rur.setNumBytes(newlength);\n       } else {\n         // Copying block to a new block with new blockId.\n         // Not truncating original block.\n         ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n             newBlockId, recoveryId, rur.getVolume(), blockFile.getParentFile(),\n             newlength);\n         newReplicaInfo.setNumBytes(newlength);\n         volumeMap.add(bpid, newReplicaInfo);\n         finalizeReplica(bpid, newReplicaInfo);\n       }\n    }\n \n     // finalize the block\n     return finalizeReplica(bpid, rur);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FinalizedReplica updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaUnderRecovery rur,\n                                          long recoveryId,\n                                          long newBlockId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n    File blockFile;\n    File metaFile;\n    // bump rur\u0027s GS to be recovery id\n    if(!copyOnTruncate) {\n      bumpReplicaGS(rur, recoveryId);\n      blockFile \u003d rur.getBlockFile();\n      metaFile \u003d rur.getMetaFile();\n    } else {\n      File[] copiedReplicaFiles \u003d\n          copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n      blockFile \u003d copiedReplicaFiles[1];\n      metaFile \u003d copiedReplicaFiles[0];\n    }\n\n    //update length\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n    if (rur.getNumBytes() \u003e newlength) {\n      truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n      if(!copyOnTruncate) {\n        // update RUR with the new length\n        rur.setNumBytes(newlength);\n      } else {\n        // Copying block to a new block with new blockId.\n        // Not truncating original block.\n        ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n            newBlockId, recoveryId, rur.getVolume(), blockFile.getParentFile(),\n            newlength);\n        newReplicaInfo.setNumBytes(newlength);\n        volumeMap.add(bpid, newReplicaInfo);\n        finalizeReplica(bpid, newReplicaInfo);\n      }\n   }\n\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "7f393a6f61f5a34a1de11481ad321c6a941d5d27": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8860. Remove unused Replica copyOnWrite code (Lei (Eddy) Xu via Colin P. McCabe)\"\n\nThis reverts commit a153b9601ad8628fdd608d8696310ca8c1f58ff0.\n\nConflicts:\n\thadoop-hdfs-project/hadoop-hdfs/CHANGES.txt\n\thadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/datanode/DataNodeTestUtils.java\n",
      "commitDate": "10/12/15 12:57 PM",
      "commitName": "7f393a6f61f5a34a1de11481ad321c6a941d5d27",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "26/09/15 11:08 AM",
      "commitNameOld": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 75.12,
      "commitsBetweenForRepo": 551,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,53 @@\n   private FinalizedReplica updateReplicaUnderRecovery(\n                                           String bpid,\n                                           ReplicaUnderRecovery rur,\n                                           long recoveryId,\n                                           long newBlockId,\n                                           long newlength) throws IOException {\n     //check recovery id\n     if (rur.getRecoveryID() !\u003d recoveryId) {\n       throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n           + \", rur\u003d\" + rur);\n     }\n \n     boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n     File blockFile;\n     File metaFile;\n     // bump rur\u0027s GS to be recovery id\n     if(!copyOnTruncate) {\n       bumpReplicaGS(rur, recoveryId);\n       blockFile \u003d rur.getBlockFile();\n       metaFile \u003d rur.getMetaFile();\n     } else {\n       File[] copiedReplicaFiles \u003d\n           copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n       blockFile \u003d copiedReplicaFiles[1];\n       metaFile \u003d copiedReplicaFiles[0];\n     }\n \n     //update length\n     if (rur.getNumBytes() \u003c newlength) {\n       throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n           + \", rur\u003d\" + rur);\n     }\n     if (rur.getNumBytes() \u003e newlength) {\n+      rur.unlinkBlock(1);\n       truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n       if(!copyOnTruncate) {\n         // update RUR with the new length\n         rur.setNumBytes(newlength);\n       } else {\n         // Copying block to a new block with new blockId.\n         // Not truncating original block.\n         ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n             newBlockId, recoveryId, rur.getVolume(), blockFile.getParentFile(),\n             newlength);\n         newReplicaInfo.setNumBytes(newlength);\n         volumeMap.add(bpid, newReplicaInfo);\n         finalizeReplica(bpid, newReplicaInfo);\n       }\n    }\n \n     // finalize the block\n     return finalizeReplica(bpid, rur);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FinalizedReplica updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaUnderRecovery rur,\n                                          long recoveryId,\n                                          long newBlockId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n    File blockFile;\n    File metaFile;\n    // bump rur\u0027s GS to be recovery id\n    if(!copyOnTruncate) {\n      bumpReplicaGS(rur, recoveryId);\n      blockFile \u003d rur.getBlockFile();\n      metaFile \u003d rur.getMetaFile();\n    } else {\n      File[] copiedReplicaFiles \u003d\n          copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n      blockFile \u003d copiedReplicaFiles[1];\n      metaFile \u003d copiedReplicaFiles[0];\n    }\n\n    //update length\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n    if (rur.getNumBytes() \u003e newlength) {\n      rur.unlinkBlock(1);\n      truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n      if(!copyOnTruncate) {\n        // update RUR with the new length\n        rur.setNumBytes(newlength);\n      } else {\n        // Copying block to a new block with new blockId.\n        // Not truncating original block.\n        ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n            newBlockId, recoveryId, rur.getVolume(), blockFile.getParentFile(),\n            newlength);\n        newReplicaInfo.setNumBytes(newlength);\n        volumeMap.add(bpid, newReplicaInfo);\n        finalizeReplica(bpid, newReplicaInfo);\n      }\n   }\n\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "a153b9601ad8628fdd608d8696310ca8c1f58ff0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8860. Remove unused Replica copyOnWrite code (Lei (Eddy) Xu via Colin P. McCabe)\n",
      "commitDate": "08/09/15 6:37 PM",
      "commitName": "a153b9601ad8628fdd608d8696310ca8c1f58ff0",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "26/08/15 2:02 PM",
      "commitNameOld": "c992bcf9c136d3df686655a80e636bb7bb0664da",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 13.19,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,52 @@\n   private FinalizedReplica updateReplicaUnderRecovery(\n                                           String bpid,\n                                           ReplicaUnderRecovery rur,\n                                           long recoveryId,\n                                           long newBlockId,\n                                           long newlength) throws IOException {\n     //check recovery id\n     if (rur.getRecoveryID() !\u003d recoveryId) {\n       throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n           + \", rur\u003d\" + rur);\n     }\n \n     boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n     File blockFile;\n     File metaFile;\n     // bump rur\u0027s GS to be recovery id\n     if(!copyOnTruncate) {\n       bumpReplicaGS(rur, recoveryId);\n       blockFile \u003d rur.getBlockFile();\n       metaFile \u003d rur.getMetaFile();\n     } else {\n       File[] copiedReplicaFiles \u003d\n           copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n       blockFile \u003d copiedReplicaFiles[1];\n       metaFile \u003d copiedReplicaFiles[0];\n     }\n \n     //update length\n     if (rur.getNumBytes() \u003c newlength) {\n       throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n           + \", rur\u003d\" + rur);\n     }\n     if (rur.getNumBytes() \u003e newlength) {\n-      rur.unlinkBlock(1);\n       truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n       if(!copyOnTruncate) {\n         // update RUR with the new length\n         rur.setNumBytes(newlength);\n       } else {\n         // Copying block to a new block with new blockId.\n         // Not truncating original block.\n         ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n             newBlockId, recoveryId, rur.getVolume(), blockFile.getParentFile(),\n             newlength);\n         newReplicaInfo.setNumBytes(newlength);\n         volumeMap.add(bpid, newReplicaInfo);\n         finalizeReplica(bpid, newReplicaInfo);\n       }\n    }\n \n     // finalize the block\n     return finalizeReplica(bpid, rur);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FinalizedReplica updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaUnderRecovery rur,\n                                          long recoveryId,\n                                          long newBlockId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n    File blockFile;\n    File metaFile;\n    // bump rur\u0027s GS to be recovery id\n    if(!copyOnTruncate) {\n      bumpReplicaGS(rur, recoveryId);\n      blockFile \u003d rur.getBlockFile();\n      metaFile \u003d rur.getMetaFile();\n    } else {\n      File[] copiedReplicaFiles \u003d\n          copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n      blockFile \u003d copiedReplicaFiles[1];\n      metaFile \u003d copiedReplicaFiles[0];\n    }\n\n    //update length\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n    if (rur.getNumBytes() \u003e newlength) {\n      truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n      if(!copyOnTruncate) {\n        // update RUR with the new length\n        rur.setNumBytes(newlength);\n      } else {\n        // Copying block to a new block with new blockId.\n        // Not truncating original block.\n        ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n            newBlockId, recoveryId, rur.getVolume(), blockFile.getParentFile(),\n            newlength);\n        newReplicaInfo.setNumBytes(newlength);\n        volumeMap.add(bpid, newReplicaInfo);\n        finalizeReplica(bpid, newReplicaInfo);\n      }\n   }\n\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7056. Snapshot support for truncate. Contributed by Konstantin Shvachko and Plamen Jeliazkov.",
      "commitDate": "13/01/15 12:24 AM",
      "commitName": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
      "commitAuthor": "Konstantin V Shvachko",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7056. Snapshot support for truncate. Contributed by Konstantin Shvachko and Plamen Jeliazkov.",
          "commitDate": "13/01/15 12:24 AM",
          "commitName": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
          "commitAuthor": "Konstantin V Shvachko",
          "commitDateOld": "17/12/14 4:41 PM",
          "commitNameOld": "3b173d95171d01ab55042b1162569d1cf14a8d43",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 26.32,
          "commitsBetweenForRepo": 116,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,53 @@\n   private FinalizedReplica updateReplicaUnderRecovery(\n                                           String bpid,\n                                           ReplicaUnderRecovery rur,\n                                           long recoveryId,\n+                                          long newBlockId,\n                                           long newlength) throws IOException {\n     //check recovery id\n     if (rur.getRecoveryID() !\u003d recoveryId) {\n       throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n           + \", rur\u003d\" + rur);\n     }\n \n+    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n+    File blockFile;\n+    File metaFile;\n     // bump rur\u0027s GS to be recovery id\n-    bumpReplicaGS(rur, recoveryId);\n+    if(!copyOnTruncate) {\n+      bumpReplicaGS(rur, recoveryId);\n+      blockFile \u003d rur.getBlockFile();\n+      metaFile \u003d rur.getMetaFile();\n+    } else {\n+      File[] copiedReplicaFiles \u003d\n+          copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n+      blockFile \u003d copiedReplicaFiles[1];\n+      metaFile \u003d copiedReplicaFiles[0];\n+    }\n \n     //update length\n-    final File replicafile \u003d rur.getBlockFile();\n     if (rur.getNumBytes() \u003c newlength) {\n       throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n           + \", rur\u003d\" + rur);\n     }\n     if (rur.getNumBytes() \u003e newlength) {\n       rur.unlinkBlock(1);\n-      truncateBlock(replicafile, rur.getMetaFile(), rur.getNumBytes(), newlength);\n-      // update RUR with the new length\n-      rur.setNumBytes(newlength);\n+      truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n+      if(!copyOnTruncate) {\n+        // update RUR with the new length\n+        rur.setNumBytes(newlength);\n+      } else {\n+        // Copying block to a new block with new blockId.\n+        // Not truncating original block.\n+        ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n+            newBlockId, recoveryId, rur.getVolume(), blockFile.getParentFile(),\n+            newlength);\n+        newReplicaInfo.setNumBytes(newlength);\n+        volumeMap.add(bpid, newReplicaInfo);\n+        finalizeReplica(bpid, newReplicaInfo);\n+      }\n    }\n \n     // finalize the block\n     return finalizeReplica(bpid, rur);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private FinalizedReplica updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaUnderRecovery rur,\n                                          long recoveryId,\n                                          long newBlockId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n    File blockFile;\n    File metaFile;\n    // bump rur\u0027s GS to be recovery id\n    if(!copyOnTruncate) {\n      bumpReplicaGS(rur, recoveryId);\n      blockFile \u003d rur.getBlockFile();\n      metaFile \u003d rur.getMetaFile();\n    } else {\n      File[] copiedReplicaFiles \u003d\n          copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n      blockFile \u003d copiedReplicaFiles[1];\n      metaFile \u003d copiedReplicaFiles[0];\n    }\n\n    //update length\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n    if (rur.getNumBytes() \u003e newlength) {\n      rur.unlinkBlock(1);\n      truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n      if(!copyOnTruncate) {\n        // update RUR with the new length\n        rur.setNumBytes(newlength);\n      } else {\n        // Copying block to a new block with new blockId.\n        // Not truncating original block.\n        ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n            newBlockId, recoveryId, rur.getVolume(), blockFile.getParentFile(),\n            newlength);\n        newReplicaInfo.setNumBytes(newlength);\n        volumeMap.add(bpid, newReplicaInfo);\n        finalizeReplica(bpid, newReplicaInfo);\n      }\n   }\n\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldValue": "[bpid-String, rur-ReplicaUnderRecovery, recoveryId-long, newlength-long]",
            "newValue": "[bpid-String, rur-ReplicaUnderRecovery, recoveryId-long, newBlockId-long, newlength-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7056. Snapshot support for truncate. Contributed by Konstantin Shvachko and Plamen Jeliazkov.",
          "commitDate": "13/01/15 12:24 AM",
          "commitName": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
          "commitAuthor": "Konstantin V Shvachko",
          "commitDateOld": "17/12/14 4:41 PM",
          "commitNameOld": "3b173d95171d01ab55042b1162569d1cf14a8d43",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 26.32,
          "commitsBetweenForRepo": 116,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,53 @@\n   private FinalizedReplica updateReplicaUnderRecovery(\n                                           String bpid,\n                                           ReplicaUnderRecovery rur,\n                                           long recoveryId,\n+                                          long newBlockId,\n                                           long newlength) throws IOException {\n     //check recovery id\n     if (rur.getRecoveryID() !\u003d recoveryId) {\n       throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n           + \", rur\u003d\" + rur);\n     }\n \n+    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n+    File blockFile;\n+    File metaFile;\n     // bump rur\u0027s GS to be recovery id\n-    bumpReplicaGS(rur, recoveryId);\n+    if(!copyOnTruncate) {\n+      bumpReplicaGS(rur, recoveryId);\n+      blockFile \u003d rur.getBlockFile();\n+      metaFile \u003d rur.getMetaFile();\n+    } else {\n+      File[] copiedReplicaFiles \u003d\n+          copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n+      blockFile \u003d copiedReplicaFiles[1];\n+      metaFile \u003d copiedReplicaFiles[0];\n+    }\n \n     //update length\n-    final File replicafile \u003d rur.getBlockFile();\n     if (rur.getNumBytes() \u003c newlength) {\n       throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n           + \", rur\u003d\" + rur);\n     }\n     if (rur.getNumBytes() \u003e newlength) {\n       rur.unlinkBlock(1);\n-      truncateBlock(replicafile, rur.getMetaFile(), rur.getNumBytes(), newlength);\n-      // update RUR with the new length\n-      rur.setNumBytes(newlength);\n+      truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n+      if(!copyOnTruncate) {\n+        // update RUR with the new length\n+        rur.setNumBytes(newlength);\n+      } else {\n+        // Copying block to a new block with new blockId.\n+        // Not truncating original block.\n+        ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n+            newBlockId, recoveryId, rur.getVolume(), blockFile.getParentFile(),\n+            newlength);\n+        newReplicaInfo.setNumBytes(newlength);\n+        volumeMap.add(bpid, newReplicaInfo);\n+        finalizeReplica(bpid, newReplicaInfo);\n+      }\n    }\n \n     // finalize the block\n     return finalizeReplica(bpid, rur);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private FinalizedReplica updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaUnderRecovery rur,\n                                          long recoveryId,\n                                          long newBlockId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    boolean copyOnTruncate \u003d newBlockId \u003e 0L \u0026\u0026 rur.getBlockId() !\u003d newBlockId;\n    File blockFile;\n    File metaFile;\n    // bump rur\u0027s GS to be recovery id\n    if(!copyOnTruncate) {\n      bumpReplicaGS(rur, recoveryId);\n      blockFile \u003d rur.getBlockFile();\n      metaFile \u003d rur.getMetaFile();\n    } else {\n      File[] copiedReplicaFiles \u003d\n          copyReplicaWithNewBlockIdAndGS(rur, bpid, newBlockId, recoveryId);\n      blockFile \u003d copiedReplicaFiles[1];\n      metaFile \u003d copiedReplicaFiles[0];\n    }\n\n    //update length\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n    if (rur.getNumBytes() \u003e newlength) {\n      rur.unlinkBlock(1);\n      truncateBlock(blockFile, metaFile, rur.getNumBytes(), newlength);\n      if(!copyOnTruncate) {\n        // update RUR with the new length\n        rur.setNumBytes(newlength);\n      } else {\n        // Copying block to a new block with new blockId.\n        // Not truncating original block.\n        ReplicaBeingWritten newReplicaInfo \u003d new ReplicaBeingWritten(\n            newBlockId, recoveryId, rur.getVolume(), blockFile.getParentFile(),\n            newlength);\n        newReplicaInfo.setNumBytes(newlength);\n        volumeMap.add(bpid, newReplicaInfo);\n        finalizeReplica(bpid, newReplicaInfo);\n      }\n   }\n\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "bc13dfb1426944ce45293cb8f444239a7406762c": {
      "type": "Ymovefromfile",
      "commitMessage": "HDFS-3130. Move fsdataset implementation to a package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308437 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/04/12 10:38 AM",
      "commitName": "bc13dfb1426944ce45293cb8f444239a7406762c",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "01/04/12 8:48 PM",
      "commitNameOld": "a4ccb8f504e79802f1b3c69acbcbb00b2343c529",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.58,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private FinalizedReplica updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaUnderRecovery rur,\n                                          long recoveryId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    // bump rur\u0027s GS to be recovery id\n    bumpReplicaGS(rur, recoveryId);\n\n    //update length\n    final File replicafile \u003d rur.getBlockFile();\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n    if (rur.getNumBytes() \u003e newlength) {\n      rur.unlinkBlock(1);\n      truncateBlock(replicafile, rur.getMetaFile(), rur.getNumBytes(), newlength);\n      // update RUR with the new length\n      rur.setNumBytes(newlength);\n   }\n\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
        "oldMethodName": "updateReplicaUnderRecovery",
        "newMethodName": "updateReplicaUnderRecovery"
      }
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private FinalizedReplica updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaUnderRecovery rur,\n                                          long recoveryId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    // bump rur\u0027s GS to be recovery id\n    bumpReplicaGS(rur, recoveryId);\n\n    //update length\n    final File replicafile \u003d rur.getBlockFile();\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n    if (rur.getNumBytes() \u003e newlength) {\n      rur.unlinkBlock(1);\n      truncateBlock(replicafile, rur.getMetaFile(), rur.getNumBytes(), newlength);\n      // update RUR with the new length\n      rur.setNumBytes(newlength);\n   }\n\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private FinalizedReplica updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaUnderRecovery rur,\n                                          long recoveryId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    // bump rur\u0027s GS to be recovery id\n    bumpReplicaGS(rur, recoveryId);\n\n    //update length\n    final File replicafile \u003d rur.getBlockFile();\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n    if (rur.getNumBytes() \u003e newlength) {\n      rur.unlinkBlock(1);\n      truncateBlock(replicafile, rur.getMetaFile(), rur.getNumBytes(), newlength);\n      // update RUR with the new length\n      rur.setNumBytes(newlength);\n   }\n\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,30 @@\n+  private FinalizedReplica updateReplicaUnderRecovery(\n+                                          String bpid,\n+                                          ReplicaUnderRecovery rur,\n+                                          long recoveryId,\n+                                          long newlength) throws IOException {\n+    //check recovery id\n+    if (rur.getRecoveryID() !\u003d recoveryId) {\n+      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n+          + \", rur\u003d\" + rur);\n+    }\n+\n+    // bump rur\u0027s GS to be recovery id\n+    bumpReplicaGS(rur, recoveryId);\n+\n+    //update length\n+    final File replicafile \u003d rur.getBlockFile();\n+    if (rur.getNumBytes() \u003c newlength) {\n+      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n+          + \", rur\u003d\" + rur);\n+    }\n+    if (rur.getNumBytes() \u003e newlength) {\n+      rur.unlinkBlock(1);\n+      truncateBlock(replicafile, rur.getMetaFile(), rur.getNumBytes(), newlength);\n+      // update RUR with the new length\n+      rur.setNumBytes(newlength);\n+   }\n+\n+    // finalize the block\n+    return finalizeReplica(bpid, rur);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private FinalizedReplica updateReplicaUnderRecovery(\n                                          String bpid,\n                                          ReplicaUnderRecovery rur,\n                                          long recoveryId,\n                                          long newlength) throws IOException {\n    //check recovery id\n    if (rur.getRecoveryID() !\u003d recoveryId) {\n      throw new IOException(\"rur.getRecoveryID() !\u003d recoveryId \u003d \" + recoveryId\n          + \", rur\u003d\" + rur);\n    }\n\n    // bump rur\u0027s GS to be recovery id\n    bumpReplicaGS(rur, recoveryId);\n\n    //update length\n    final File replicafile \u003d rur.getBlockFile();\n    if (rur.getNumBytes() \u003c newlength) {\n      throw new IOException(\"rur.getNumBytes() \u003c newlength \u003d \" + newlength\n          + \", rur\u003d\" + rur);\n    }\n    if (rur.getNumBytes() \u003e newlength) {\n      rur.unlinkBlock(1);\n      truncateBlock(replicafile, rur.getMetaFile(), rur.getNumBytes(), newlength);\n      // update RUR with the new length\n      rur.setNumBytes(newlength);\n   }\n\n    // finalize the block\n    return finalizeReplica(bpid, rur);\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java"
    }
  }
}