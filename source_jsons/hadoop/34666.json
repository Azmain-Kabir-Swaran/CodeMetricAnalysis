{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerManagerImpl.java",
  "functionName": "startContainers",
  "functionId": "startContainers___requests-StartContainersRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
  "functionStartLine": 933,
  "functionEndLine": 987,
  "numCommitsSeen": 195,
  "timeTaken": 15404,
  "changeHistory": [
    "32fe351bb654e684f127f47ab808c497e0d3f258",
    "424887ecb7d11a72837f2757ed3ff9e0fe8c5b5d",
    "d971bf252f36e902a0fe446cb11201835ad16bcb",
    "c8172f5f143d2fefafa5a412899ab7cd081b406d",
    "55ae1439233e8585d624b2872e1e4753ef63eebb",
    "c3dc1af072574f5890a8d43e4d60526951b4b8bc",
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02",
    "bcf2890502fbd11dd394048fe30d67c92aeec4fa",
    "49afc64cd469bc3a775c18e0458661e39270b7a5",
    "3ca3137179ef093e42cde06587c9ea785b10f32c",
    "243bcd367ff3130d74676280233041f88aca62a5",
    "f4d80e91ae314d316100baa7770b9d73ea853d9c",
    "c6c41abf683be17c3917a7f94953b55347aaa69f",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "a2c42330047bf955a6a585dcddf798920d4c8640",
    "2692675fc3b5046d2ec88542c30203c87e135b70",
    "b16c5638b5190c56f9d854d873589cb5c11c8b32",
    "259edf8dca44de54033e96f7eb65a83aaa6096f2",
    "ca8024673178fa1c80224b390dfba932921693d9",
    "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1",
    "9eb53b9c841233538a51e4e854b261536c0b85d4",
    "fbb55784d93e1a819daf55d936e864d344579cbf",
    "8e1c2823fc014a5a045c86760c61111d0bb59d2f",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "4e5818698778bff9d2b1ba14297d8393e49927c7",
    "7f4dc277572df6ba25fa961073b99a5bdb086c00",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449",
    "237154982bd5853c6a374cb265520e0602adc52f",
    "df2991c0cbc3f35c2640b93680667507c4f810dd",
    "e3bb120e9fefb21168edd7cd06f0cbfb92a5e02b",
    "11b9dd4e844c762f8c53e5fafa25f29eece1bc87",
    "02a81203bd0ff6116e3c68d376b3af3838231986",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
    "cdfabf5ae289836968b3d296668593b9500b6f26",
    "ade0f0560f729e50382c6992f713f29e2dd5b270",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "32fe351bb654e684f127f47ab808c497e0d3f258": "Ybodychange",
    "424887ecb7d11a72837f2757ed3ff9e0fe8c5b5d": "Ybodychange",
    "d971bf252f36e902a0fe446cb11201835ad16bcb": "Ybodychange",
    "c8172f5f143d2fefafa5a412899ab7cd081b406d": "Ybodychange",
    "55ae1439233e8585d624b2872e1e4753ef63eebb": "Ybodychange",
    "c3dc1af072574f5890a8d43e4d60526951b4b8bc": "Ybodychange",
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02": "Ybodychange",
    "bcf2890502fbd11dd394048fe30d67c92aeec4fa": "Ybodychange",
    "49afc64cd469bc3a775c18e0458661e39270b7a5": "Ybodychange",
    "3ca3137179ef093e42cde06587c9ea785b10f32c": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
    "243bcd367ff3130d74676280233041f88aca62a5": "Ybodychange",
    "f4d80e91ae314d316100baa7770b9d73ea853d9c": "Ybodychange",
    "c6c41abf683be17c3917a7f94953b55347aaa69f": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Yexceptionschange",
    "a2c42330047bf955a6a585dcddf798920d4c8640": "Ybodychange",
    "2692675fc3b5046d2ec88542c30203c87e135b70": "Ybodychange",
    "b16c5638b5190c56f9d854d873589cb5c11c8b32": "Ybodychange",
    "259edf8dca44de54033e96f7eb65a83aaa6096f2": "Ybodychange",
    "ca8024673178fa1c80224b390dfba932921693d9": "Ybodychange",
    "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1": "Ybodychange",
    "9eb53b9c841233538a51e4e854b261536c0b85d4": "Yexceptionschange",
    "fbb55784d93e1a819daf55d936e864d344579cbf": "Ybodychange",
    "8e1c2823fc014a5a045c86760c61111d0bb59d2f": "Ybodychange",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": "Ybodychange",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "4e5818698778bff9d2b1ba14297d8393e49927c7": "Ybodychange",
    "7f4dc277572df6ba25fa961073b99a5bdb086c00": "Ybodychange",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": "Ybodychange",
    "237154982bd5853c6a374cb265520e0602adc52f": "Ybodychange",
    "df2991c0cbc3f35c2640b93680667507c4f810dd": "Ybodychange",
    "e3bb120e9fefb21168edd7cd06f0cbfb92a5e02b": "Ybodychange",
    "11b9dd4e844c762f8c53e5fafa25f29eece1bc87": "Ybodychange",
    "02a81203bd0ff6116e3c68d376b3af3838231986": "Ybodychange",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": "Ybodychange",
    "cdfabf5ae289836968b3d296668593b9500b6f26": "Ybodychange",
    "ade0f0560f729e50382c6992f713f29e2dd5b270": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "32fe351bb654e684f127f47ab808c497e0d3f258": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8864. NM incorrectly logs container user as the user who sent a start/stop container request in its audit log. (Contributed by Wilfred Spiegelenburg)\n",
      "commitDate": "18/10/18 8:28 AM",
      "commitName": "32fe351bb654e684f127f47ab808c497e0d3f258",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "26/09/18 11:51 AM",
      "commitNameOld": "913f87dada27776c539dfb352400ecf8d40e7943",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 21.86,
      "commitsBetweenForRepo": 222,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,55 @@\n   public StartContainersResponse startContainers(\n       StartContainersRequest requests) throws YarnException, IOException {\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n+    String remoteUser \u003d remoteUgi.getUserName();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n     authorizeUser(remoteUgi, nmTokenIdentifier);\n     List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n     Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n         new HashMap\u003cContainerId, SerializedException\u003e();\n     // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n     // to avoid race condition during NM-RM resync (due to RM restart) while a\n     // container is being started, in particular when the container has not yet\n     // been added to the containers map in NMContext.\n     synchronized (this.context) {\n       for (StartContainerRequest request : requests\n           .getStartContainerRequests()) {\n         ContainerId containerId \u003d null;\n         try {\n           if (request.getContainerToken() \u003d\u003d null\n               || request.getContainerToken().getIdentifier() \u003d\u003d null) {\n             throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n           }\n \n           ContainerTokenIdentifier containerTokenIdentifier \u003d BuilderUtils\n               .newContainerTokenIdentifier(request.getContainerToken());\n           verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n               containerTokenIdentifier);\n           containerId \u003d containerTokenIdentifier.getContainerID();\n \n           // Initialize the AMRMProxy service instance only if the container is of\n           // type AM and if the AMRMProxy service is enabled\n           if (amrmProxyEnabled \u0026\u0026 containerTokenIdentifier.getContainerType()\n               .equals(ContainerType.APPLICATION_MASTER)) {\n             this.getAMRMProxyService().processApplicationStartRequest(request);\n           }\n           performContainerPreStartChecks(nmTokenIdentifier, request,\n               containerTokenIdentifier);\n-          startContainerInternal(containerTokenIdentifier, request);\n+          startContainerInternal(containerTokenIdentifier, request,\n+              remoteUser);\n           succeededContainers.add(containerId);\n         } catch (YarnException e) {\n           failedContainers.put(containerId, SerializedException.newInstance(e));\n         } catch (InvalidToken ie) {\n           failedContainers\n               .put(containerId, SerializedException.newInstance(ie));\n           throw ie;\n         } catch (IOException e) {\n           throw RPCUtil.getRemoteException(e);\n         }\n       }\n       return StartContainersResponse\n           .newInstance(getAuxServiceMetaData(), succeededContainers,\n               failedContainers);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainersResponse startContainers(\n      StartContainersRequest requests) throws YarnException, IOException {\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    String remoteUser \u003d remoteUgi.getUserName();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi, nmTokenIdentifier);\n    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n    // to avoid race condition during NM-RM resync (due to RM restart) while a\n    // container is being started, in particular when the container has not yet\n    // been added to the containers map in NMContext.\n    synchronized (this.context) {\n      for (StartContainerRequest request : requests\n          .getStartContainerRequests()) {\n        ContainerId containerId \u003d null;\n        try {\n          if (request.getContainerToken() \u003d\u003d null\n              || request.getContainerToken().getIdentifier() \u003d\u003d null) {\n            throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n          }\n\n          ContainerTokenIdentifier containerTokenIdentifier \u003d BuilderUtils\n              .newContainerTokenIdentifier(request.getContainerToken());\n          verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n              containerTokenIdentifier);\n          containerId \u003d containerTokenIdentifier.getContainerID();\n\n          // Initialize the AMRMProxy service instance only if the container is of\n          // type AM and if the AMRMProxy service is enabled\n          if (amrmProxyEnabled \u0026\u0026 containerTokenIdentifier.getContainerType()\n              .equals(ContainerType.APPLICATION_MASTER)) {\n            this.getAMRMProxyService().processApplicationStartRequest(request);\n          }\n          performContainerPreStartChecks(nmTokenIdentifier, request,\n              containerTokenIdentifier);\n          startContainerInternal(containerTokenIdentifier, request,\n              remoteUser);\n          succeededContainers.add(containerId);\n        } catch (YarnException e) {\n          failedContainers.put(containerId, SerializedException.newInstance(e));\n        } catch (InvalidToken ie) {\n          failedContainers\n              .put(containerId, SerializedException.newInstance(ie));\n          throw ie;\n        } catch (IOException e) {\n          throw RPCUtil.getRemoteException(e);\n        }\n      }\n      return StartContainersResponse\n          .newInstance(getAuxServiceMetaData(), succeededContainers,\n              failedContainers);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "424887ecb7d11a72837f2757ed3ff9e0fe8c5b5d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3839. Quit throwing NMNotYetReadyException. Contributed by Manikandan R\n",
      "commitDate": "08/05/17 3:14 PM",
      "commitName": "424887ecb7d11a72837f2757ed3ff9e0fe8c5b5d",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "06/04/17 4:54 PM",
      "commitNameOld": "0116c3c95769e204ab2600510f0efd6baafb43e0",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 31.93,
      "commitsBetweenForRepo": 163,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,53 @@\n   public StartContainersResponse startContainers(\n       StartContainersRequest requests) throws YarnException, IOException {\n-    if (blockNewContainerRequests.get()) {\n-      throw new NMNotYetReadyException(\n-          \"Rejecting new containers as NodeManager has not\"\n-              + \" yet connected with ResourceManager\");\n-    }\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n     authorizeUser(remoteUgi, nmTokenIdentifier);\n     List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n     Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n         new HashMap\u003cContainerId, SerializedException\u003e();\n     // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n     // to avoid race condition during NM-RM resync (due to RM restart) while a\n     // container is being started, in particular when the container has not yet\n     // been added to the containers map in NMContext.\n     synchronized (this.context) {\n       for (StartContainerRequest request : requests\n           .getStartContainerRequests()) {\n         ContainerId containerId \u003d null;\n         try {\n           if (request.getContainerToken() \u003d\u003d null\n               || request.getContainerToken().getIdentifier() \u003d\u003d null) {\n             throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n           }\n \n           ContainerTokenIdentifier containerTokenIdentifier \u003d BuilderUtils\n               .newContainerTokenIdentifier(request.getContainerToken());\n           verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n               containerTokenIdentifier);\n           containerId \u003d containerTokenIdentifier.getContainerID();\n \n           // Initialize the AMRMProxy service instance only if the container is of\n           // type AM and if the AMRMProxy service is enabled\n           if (amrmProxyEnabled \u0026\u0026 containerTokenIdentifier.getContainerType()\n               .equals(ContainerType.APPLICATION_MASTER)) {\n             this.getAMRMProxyService().processApplicationStartRequest(request);\n           }\n           performContainerPreStartChecks(nmTokenIdentifier, request,\n               containerTokenIdentifier);\n           startContainerInternal(containerTokenIdentifier, request);\n           succeededContainers.add(containerId);\n         } catch (YarnException e) {\n           failedContainers.put(containerId, SerializedException.newInstance(e));\n         } catch (InvalidToken ie) {\n           failedContainers\n               .put(containerId, SerializedException.newInstance(ie));\n           throw ie;\n         } catch (IOException e) {\n           throw RPCUtil.getRemoteException(e);\n         }\n       }\n       return StartContainersResponse\n           .newInstance(getAuxServiceMetaData(), succeededContainers,\n               failedContainers);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainersResponse startContainers(\n      StartContainersRequest requests) throws YarnException, IOException {\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi, nmTokenIdentifier);\n    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n    // to avoid race condition during NM-RM resync (due to RM restart) while a\n    // container is being started, in particular when the container has not yet\n    // been added to the containers map in NMContext.\n    synchronized (this.context) {\n      for (StartContainerRequest request : requests\n          .getStartContainerRequests()) {\n        ContainerId containerId \u003d null;\n        try {\n          if (request.getContainerToken() \u003d\u003d null\n              || request.getContainerToken().getIdentifier() \u003d\u003d null) {\n            throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n          }\n\n          ContainerTokenIdentifier containerTokenIdentifier \u003d BuilderUtils\n              .newContainerTokenIdentifier(request.getContainerToken());\n          verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n              containerTokenIdentifier);\n          containerId \u003d containerTokenIdentifier.getContainerID();\n\n          // Initialize the AMRMProxy service instance only if the container is of\n          // type AM and if the AMRMProxy service is enabled\n          if (amrmProxyEnabled \u0026\u0026 containerTokenIdentifier.getContainerType()\n              .equals(ContainerType.APPLICATION_MASTER)) {\n            this.getAMRMProxyService().processApplicationStartRequest(request);\n          }\n          performContainerPreStartChecks(nmTokenIdentifier, request,\n              containerTokenIdentifier);\n          startContainerInternal(containerTokenIdentifier, request);\n          succeededContainers.add(containerId);\n        } catch (YarnException e) {\n          failedContainers.put(containerId, SerializedException.newInstance(e));\n        } catch (InvalidToken ie) {\n          failedContainers\n              .put(containerId, SerializedException.newInstance(ie));\n          throw ie;\n        } catch (IOException e) {\n          throw RPCUtil.getRemoteException(e);\n        }\n      }\n      return StartContainersResponse\n          .newInstance(getAuxServiceMetaData(), succeededContainers,\n              failedContainers);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "d971bf252f36e902a0fe446cb11201835ad16bcb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5073. Refactor startContainerInternal() in ContainerManager to remove unused parameter. (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "10/05/16 10:31 PM",
      "commitName": "d971bf252f36e902a0fe446cb11201835ad16bcb",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "29/04/16 3:39 AM",
      "commitNameOld": "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 11.79,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,58 @@\n   public StartContainersResponse startContainers(\n       StartContainersRequest requests) throws YarnException, IOException {\n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\"\n               + \" yet connected with ResourceManager\");\n     }\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n     authorizeUser(remoteUgi, nmTokenIdentifier);\n     List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n     Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n         new HashMap\u003cContainerId, SerializedException\u003e();\n     // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n     // to avoid race condition during NM-RM resync (due to RM restart) while a\n     // container is being started, in particular when the container has not yet\n     // been added to the containers map in NMContext.\n     synchronized (this.context) {\n       for (StartContainerRequest request : requests\n           .getStartContainerRequests()) {\n         ContainerId containerId \u003d null;\n         try {\n           if (request.getContainerToken() \u003d\u003d null\n               || request.getContainerToken().getIdentifier() \u003d\u003d null) {\n             throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n           }\n \n           ContainerTokenIdentifier containerTokenIdentifier \u003d BuilderUtils\n               .newContainerTokenIdentifier(request.getContainerToken());\n           verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n               containerTokenIdentifier);\n           containerId \u003d containerTokenIdentifier.getContainerID();\n \n           // Initialize the AMRMProxy service instance only if the container is of\n           // type AM and if the AMRMProxy service is enabled\n           if (amrmProxyEnabled \u0026\u0026 containerTokenIdentifier.getContainerType()\n               .equals(ContainerType.APPLICATION_MASTER)) {\n             this.getAMRMProxyService().processApplicationStartRequest(request);\n           }\n           performContainerPreStartChecks(nmTokenIdentifier, request,\n               containerTokenIdentifier);\n-          startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n-              request);\n+          startContainerInternal(containerTokenIdentifier, request);\n           succeededContainers.add(containerId);\n         } catch (YarnException e) {\n           failedContainers.put(containerId, SerializedException.newInstance(e));\n         } catch (InvalidToken ie) {\n           failedContainers\n               .put(containerId, SerializedException.newInstance(ie));\n           throw ie;\n         } catch (IOException e) {\n           throw RPCUtil.getRemoteException(e);\n         }\n       }\n       return StartContainersResponse\n           .newInstance(getAuxServiceMetaData(), succeededContainers,\n               failedContainers);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainersResponse startContainers(\n      StartContainersRequest requests) throws YarnException, IOException {\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\"\n              + \" yet connected with ResourceManager\");\n    }\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi, nmTokenIdentifier);\n    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n    // to avoid race condition during NM-RM resync (due to RM restart) while a\n    // container is being started, in particular when the container has not yet\n    // been added to the containers map in NMContext.\n    synchronized (this.context) {\n      for (StartContainerRequest request : requests\n          .getStartContainerRequests()) {\n        ContainerId containerId \u003d null;\n        try {\n          if (request.getContainerToken() \u003d\u003d null\n              || request.getContainerToken().getIdentifier() \u003d\u003d null) {\n            throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n          }\n\n          ContainerTokenIdentifier containerTokenIdentifier \u003d BuilderUtils\n              .newContainerTokenIdentifier(request.getContainerToken());\n          verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n              containerTokenIdentifier);\n          containerId \u003d containerTokenIdentifier.getContainerID();\n\n          // Initialize the AMRMProxy service instance only if the container is of\n          // type AM and if the AMRMProxy service is enabled\n          if (amrmProxyEnabled \u0026\u0026 containerTokenIdentifier.getContainerType()\n              .equals(ContainerType.APPLICATION_MASTER)) {\n            this.getAMRMProxyService().processApplicationStartRequest(request);\n          }\n          performContainerPreStartChecks(nmTokenIdentifier, request,\n              containerTokenIdentifier);\n          startContainerInternal(containerTokenIdentifier, request);\n          succeededContainers.add(containerId);\n        } catch (YarnException e) {\n          failedContainers.put(containerId, SerializedException.newInstance(e));\n        } catch (InvalidToken ie) {\n          failedContainers\n              .put(containerId, SerializedException.newInstance(ie));\n          throw ie;\n        } catch (IOException e) {\n          throw RPCUtil.getRemoteException(e);\n        }\n      }\n      return StartContainersResponse\n          .newInstance(getAuxServiceMetaData(), succeededContainers,\n              failedContainers);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "c8172f5f143d2fefafa5a412899ab7cd081b406d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2883. Queuing of container requests in the NM. (Konstantinos Karanasos and Arun Suresh via kasha)\n",
      "commitDate": "20/04/16 9:55 AM",
      "commitName": "c8172f5f143d2fefafa5a412899ab7cd081b406d",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "14/04/16 12:17 PM",
      "commitNameOld": "3150ae8108a1fc40a67926be6254824c1e37cb38",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 5.9,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,59 @@\n   public StartContainersResponse startContainers(\n       StartContainersRequest requests) throws YarnException, IOException {\n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\"\n               + \" yet connected with ResourceManager\");\n     }\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n     authorizeUser(remoteUgi, nmTokenIdentifier);\n     List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n     Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n         new HashMap\u003cContainerId, SerializedException\u003e();\n     // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n     // to avoid race condition during NM-RM resync (due to RM restart) while a\n     // container is being started, in particular when the container has not yet\n     // been added to the containers map in NMContext.\n     synchronized (this.context) {\n       for (StartContainerRequest request : requests\n           .getStartContainerRequests()) {\n         ContainerId containerId \u003d null;\n         try {\n           if (request.getContainerToken() \u003d\u003d null\n               || request.getContainerToken().getIdentifier() \u003d\u003d null) {\n             throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n           }\n \n           ContainerTokenIdentifier containerTokenIdentifier \u003d BuilderUtils\n               .newContainerTokenIdentifier(request.getContainerToken());\n           verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n               containerTokenIdentifier);\n           containerId \u003d containerTokenIdentifier.getContainerID();\n \n           // Initialize the AMRMProxy service instance only if the container is of\n           // type AM and if the AMRMProxy service is enabled\n           if (amrmProxyEnabled \u0026\u0026 containerTokenIdentifier.getContainerType()\n               .equals(ContainerType.APPLICATION_MASTER)) {\n             this.getAMRMProxyService().processApplicationStartRequest(request);\n           }\n-\n+          performContainerPreStartChecks(nmTokenIdentifier, request,\n+              containerTokenIdentifier);\n           startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n               request);\n           succeededContainers.add(containerId);\n         } catch (YarnException e) {\n           failedContainers.put(containerId, SerializedException.newInstance(e));\n         } catch (InvalidToken ie) {\n           failedContainers\n               .put(containerId, SerializedException.newInstance(ie));\n           throw ie;\n         } catch (IOException e) {\n           throw RPCUtil.getRemoteException(e);\n         }\n       }\n       return StartContainersResponse\n           .newInstance(getAuxServiceMetaData(), succeededContainers,\n               failedContainers);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainersResponse startContainers(\n      StartContainersRequest requests) throws YarnException, IOException {\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\"\n              + \" yet connected with ResourceManager\");\n    }\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi, nmTokenIdentifier);\n    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n    // to avoid race condition during NM-RM resync (due to RM restart) while a\n    // container is being started, in particular when the container has not yet\n    // been added to the containers map in NMContext.\n    synchronized (this.context) {\n      for (StartContainerRequest request : requests\n          .getStartContainerRequests()) {\n        ContainerId containerId \u003d null;\n        try {\n          if (request.getContainerToken() \u003d\u003d null\n              || request.getContainerToken().getIdentifier() \u003d\u003d null) {\n            throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n          }\n\n          ContainerTokenIdentifier containerTokenIdentifier \u003d BuilderUtils\n              .newContainerTokenIdentifier(request.getContainerToken());\n          verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n              containerTokenIdentifier);\n          containerId \u003d containerTokenIdentifier.getContainerID();\n\n          // Initialize the AMRMProxy service instance only if the container is of\n          // type AM and if the AMRMProxy service is enabled\n          if (amrmProxyEnabled \u0026\u0026 containerTokenIdentifier.getContainerType()\n              .equals(ContainerType.APPLICATION_MASTER)) {\n            this.getAMRMProxyService().processApplicationStartRequest(request);\n          }\n          performContainerPreStartChecks(nmTokenIdentifier, request,\n              containerTokenIdentifier);\n          startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n              request);\n          succeededContainers.add(containerId);\n        } catch (YarnException e) {\n          failedContainers.put(containerId, SerializedException.newInstance(e));\n        } catch (InvalidToken ie) {\n          failedContainers\n              .put(containerId, SerializedException.newInstance(ie));\n          throw ie;\n        } catch (IOException e) {\n          throw RPCUtil.getRemoteException(e);\n        }\n      }\n      return StartContainersResponse\n          .newInstance(getAuxServiceMetaData(), succeededContainers,\n              failedContainers);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "55ae1439233e8585d624b2872e1e4753ef63eebb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4117. End to end unit test with mini YARN cluster for AMRMProxy Service. Contributed by Giovanni Matteo Fumarola\n",
      "commitDate": "27/03/16 8:22 PM",
      "commitName": "55ae1439233e8585d624b2872e1e4753ef63eebb",
      "commitAuthor": "Jian He",
      "commitDateOld": "23/02/16 12:49 PM",
      "commitNameOld": "d284e187b8db43056236032ebc2114ee462c27f6",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 33.27,
      "commitsBetweenForRepo": 187,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   public StartContainersResponse startContainers(\n       StartContainersRequest requests) throws YarnException, IOException {\n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\"\n               + \" yet connected with ResourceManager\");\n     }\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n     authorizeUser(remoteUgi, nmTokenIdentifier);\n     List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n     Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n         new HashMap\u003cContainerId, SerializedException\u003e();\n     // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n     // to avoid race condition during NM-RM resync (due to RM restart) while a\n     // container is being started, in particular when the container has not yet\n     // been added to the containers map in NMContext.\n     synchronized (this.context) {\n       for (StartContainerRequest request : requests\n           .getStartContainerRequests()) {\n         ContainerId containerId \u003d null;\n         try {\n           if (request.getContainerToken() \u003d\u003d null\n               || request.getContainerToken().getIdentifier() \u003d\u003d null) {\n             throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n           }\n \n           ContainerTokenIdentifier containerTokenIdentifier \u003d BuilderUtils\n               .newContainerTokenIdentifier(request.getContainerToken());\n           verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n               containerTokenIdentifier);\n           containerId \u003d containerTokenIdentifier.getContainerID();\n \n           // Initialize the AMRMProxy service instance only if the container is of\n           // type AM and if the AMRMProxy service is enabled\n-          if (isARMRMProxyEnabled() \u0026\u0026 containerTokenIdentifier\n-              .getContainerType().equals(ContainerType.APPLICATION_MASTER)) {\n-            this.amrmProxyService.processApplicationStartRequest(request);\n+          if (amrmProxyEnabled \u0026\u0026 containerTokenIdentifier.getContainerType()\n+              .equals(ContainerType.APPLICATION_MASTER)) {\n+            this.getAMRMProxyService().processApplicationStartRequest(request);\n           }\n \n           startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n               request);\n           succeededContainers.add(containerId);\n         } catch (YarnException e) {\n           failedContainers.put(containerId, SerializedException.newInstance(e));\n         } catch (InvalidToken ie) {\n           failedContainers\n               .put(containerId, SerializedException.newInstance(ie));\n           throw ie;\n         } catch (IOException e) {\n           throw RPCUtil.getRemoteException(e);\n         }\n       }\n       return StartContainersResponse\n           .newInstance(getAuxServiceMetaData(), succeededContainers,\n               failedContainers);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainersResponse startContainers(\n      StartContainersRequest requests) throws YarnException, IOException {\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\"\n              + \" yet connected with ResourceManager\");\n    }\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi, nmTokenIdentifier);\n    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n    // to avoid race condition during NM-RM resync (due to RM restart) while a\n    // container is being started, in particular when the container has not yet\n    // been added to the containers map in NMContext.\n    synchronized (this.context) {\n      for (StartContainerRequest request : requests\n          .getStartContainerRequests()) {\n        ContainerId containerId \u003d null;\n        try {\n          if (request.getContainerToken() \u003d\u003d null\n              || request.getContainerToken().getIdentifier() \u003d\u003d null) {\n            throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n          }\n\n          ContainerTokenIdentifier containerTokenIdentifier \u003d BuilderUtils\n              .newContainerTokenIdentifier(request.getContainerToken());\n          verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n              containerTokenIdentifier);\n          containerId \u003d containerTokenIdentifier.getContainerID();\n\n          // Initialize the AMRMProxy service instance only if the container is of\n          // type AM and if the AMRMProxy service is enabled\n          if (amrmProxyEnabled \u0026\u0026 containerTokenIdentifier.getContainerType()\n              .equals(ContainerType.APPLICATION_MASTER)) {\n            this.getAMRMProxyService().processApplicationStartRequest(request);\n          }\n\n          startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n              request);\n          succeededContainers.add(containerId);\n        } catch (YarnException e) {\n          failedContainers.put(containerId, SerializedException.newInstance(e));\n        } catch (InvalidToken ie) {\n          failedContainers\n              .put(containerId, SerializedException.newInstance(ie));\n          throw ie;\n        } catch (IOException e) {\n          throw RPCUtil.getRemoteException(e);\n        }\n      }\n      return StartContainersResponse\n          .newInstance(getAuxServiceMetaData(), succeededContainers,\n              failedContainers);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "c3dc1af072574f5890a8d43e4d60526951b4b8bc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1644. RM-NM protocol changes and NodeStatusUpdater implementation to support container resizing. Contributed by Meng Ding\n",
      "commitDate": "23/09/15 1:29 PM",
      "commitName": "c3dc1af072574f5890a8d43e4d60526951b4b8bc",
      "commitAuthor": "Jian He",
      "commitDateOld": "23/09/15 1:29 PM",
      "commitNameOld": "5f5a968d65c44a831176764439e00db9203999ed",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,58 @@\n-      startContainers(StartContainersRequest requests) throws YarnException,\n-          IOException {\n+  public StartContainersResponse startContainers(\n+      StartContainersRequest requests) throws YarnException, IOException {\n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n-        \"Rejecting new containers as NodeManager has not\"\n-            + \" yet connected with ResourceManager\");\n+          \"Rejecting new containers as NodeManager has not\"\n+              + \" yet connected with ResourceManager\");\n     }\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n     authorizeUser(remoteUgi, nmTokenIdentifier);\n     List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n     Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n         new HashMap\u003cContainerId, SerializedException\u003e();\n-    for (StartContainerRequest request : requests.getStartContainerRequests()) {\n-      ContainerId containerId \u003d null;\n-      try {\n-        if (request.getContainerToken() \u003d\u003d null ||\n-            request.getContainerToken().getIdentifier() \u003d\u003d null) {\n-          throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n-        }\n-        ContainerTokenIdentifier containerTokenIdentifier \u003d\n-            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n-        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n-          containerTokenIdentifier);\n-        containerId \u003d containerTokenIdentifier.getContainerID();\n+    // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n+    // to avoid race condition during NM-RM resync (due to RM restart) while a\n+    // container is being started, in particular when the container has not yet\n+    // been added to the containers map in NMContext.\n+    synchronized (this.context) {\n+      for (StartContainerRequest request : requests\n+          .getStartContainerRequests()) {\n+        ContainerId containerId \u003d null;\n+        try {\n+          if (request.getContainerToken() \u003d\u003d null\n+              || request.getContainerToken().getIdentifier() \u003d\u003d null) {\n+            throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n+          }\n \n-        // Initialize the AMRMProxy service instance only if the container is of\n-        // type AM and if the AMRMProxy service is enabled\n-        if (isARMRMProxyEnabled()\n-            \u0026\u0026 containerTokenIdentifier.getContainerType().equals(\n-                ContainerType.APPLICATION_MASTER)) {\n-          this.amrmProxyService.processApplicationStartRequest(request);\n-        }\n+          ContainerTokenIdentifier containerTokenIdentifier \u003d BuilderUtils\n+              .newContainerTokenIdentifier(request.getContainerToken());\n+          verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n+              containerTokenIdentifier);\n+          containerId \u003d containerTokenIdentifier.getContainerID();\n \n-        startContainerInternal(nmTokenIdentifier,\n-            containerTokenIdentifier, request);\n-        succeededContainers.add(containerId);\n-      } catch (YarnException e) {\n-        failedContainers.put(containerId, SerializedException.newInstance(e));\n-      } catch (InvalidToken ie) {\n-        failedContainers.put(containerId, SerializedException.newInstance(ie));\n-        throw ie;\n-      } catch (IOException e) {\n-        throw RPCUtil.getRemoteException(e);\n+          // Initialize the AMRMProxy service instance only if the container is of\n+          // type AM and if the AMRMProxy service is enabled\n+          if (isARMRMProxyEnabled() \u0026\u0026 containerTokenIdentifier\n+              .getContainerType().equals(ContainerType.APPLICATION_MASTER)) {\n+            this.amrmProxyService.processApplicationStartRequest(request);\n+          }\n+\n+          startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n+              request);\n+          succeededContainers.add(containerId);\n+        } catch (YarnException e) {\n+          failedContainers.put(containerId, SerializedException.newInstance(e));\n+        } catch (InvalidToken ie) {\n+          failedContainers\n+              .put(containerId, SerializedException.newInstance(ie));\n+          throw ie;\n+        } catch (IOException e) {\n+          throw RPCUtil.getRemoteException(e);\n+        }\n       }\n+      return StartContainersResponse\n+          .newInstance(getAuxServiceMetaData(), succeededContainers,\n+              failedContainers);\n     }\n-\n-    return StartContainersResponse.newInstance(getAuxServiceMetaData(),\n-        succeededContainers, failedContainers);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainersResponse startContainers(\n      StartContainersRequest requests) throws YarnException, IOException {\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\"\n              + \" yet connected with ResourceManager\");\n    }\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi, nmTokenIdentifier);\n    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n    // to avoid race condition during NM-RM resync (due to RM restart) while a\n    // container is being started, in particular when the container has not yet\n    // been added to the containers map in NMContext.\n    synchronized (this.context) {\n      for (StartContainerRequest request : requests\n          .getStartContainerRequests()) {\n        ContainerId containerId \u003d null;\n        try {\n          if (request.getContainerToken() \u003d\u003d null\n              || request.getContainerToken().getIdentifier() \u003d\u003d null) {\n            throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n          }\n\n          ContainerTokenIdentifier containerTokenIdentifier \u003d BuilderUtils\n              .newContainerTokenIdentifier(request.getContainerToken());\n          verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n              containerTokenIdentifier);\n          containerId \u003d containerTokenIdentifier.getContainerID();\n\n          // Initialize the AMRMProxy service instance only if the container is of\n          // type AM and if the AMRMProxy service is enabled\n          if (isARMRMProxyEnabled() \u0026\u0026 containerTokenIdentifier\n              .getContainerType().equals(ContainerType.APPLICATION_MASTER)) {\n            this.amrmProxyService.processApplicationStartRequest(request);\n          }\n\n          startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n              request);\n          succeededContainers.add(containerId);\n        } catch (YarnException e) {\n          failedContainers.put(containerId, SerializedException.newInstance(e));\n        } catch (InvalidToken ie) {\n          failedContainers\n              .put(containerId, SerializedException.newInstance(ie));\n          throw ie;\n        } catch (IOException e) {\n          throw RPCUtil.getRemoteException(e);\n        }\n      }\n      return StartContainersResponse\n          .newInstance(getAuxServiceMetaData(), succeededContainers,\n              failedContainers);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2884. Added a proxy service in NM to proxy the the communication between AM and RM. Contributed by Kishore Chaliparambil\n",
      "commitDate": "07/09/15 6:35 PM",
      "commitName": "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02",
      "commitAuthor": "Jian He",
      "commitDateOld": "02/09/15 1:43 AM",
      "commitNameOld": "095ab9ab5fa5f415fba41fee81b6008cf0455af8",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 5.7,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,50 @@\n       startContainers(StartContainersRequest requests) throws YarnException,\n           IOException {\n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n         \"Rejecting new containers as NodeManager has not\"\n             + \" yet connected with ResourceManager\");\n     }\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n     authorizeUser(remoteUgi,nmTokenIdentifier);\n     List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n     Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n         new HashMap\u003cContainerId, SerializedException\u003e();\n     for (StartContainerRequest request : requests.getStartContainerRequests()) {\n       ContainerId containerId \u003d null;\n       try {\n         if (request.getContainerToken() \u003d\u003d null ||\n             request.getContainerToken().getIdentifier() \u003d\u003d null) {\n           throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n         }\n         ContainerTokenIdentifier containerTokenIdentifier \u003d\n             BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n         verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n           containerTokenIdentifier);\n         containerId \u003d containerTokenIdentifier.getContainerID();\n-        startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n-          request);\n+\n+        // Initialize the AMRMProxy service instance only if the container is of\n+        // type AM and if the AMRMProxy service is enabled\n+        if (isARMRMProxyEnabled()\n+            \u0026\u0026 containerTokenIdentifier.getContainerType().equals(\n+                ContainerType.APPLICATION_MASTER)) {\n+          this.amrmProxyService.processApplicationStartRequest(request);\n+        }\n+\n+        startContainerInternal(nmTokenIdentifier,\n+            containerTokenIdentifier, request);\n         succeededContainers.add(containerId);\n       } catch (YarnException e) {\n         failedContainers.put(containerId, SerializedException.newInstance(e));\n       } catch (InvalidToken ie) {\n         failedContainers.put(containerId, SerializedException.newInstance(ie));\n         throw ie;\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n \n     return StartContainersResponse.newInstance(getAuxServiceMetaData(),\n-      succeededContainers, failedContainers);\n+        succeededContainers, failedContainers);\n   }\n\\ No newline at end of file\n",
      "actualSource": "      startContainers(StartContainersRequest requests) throws YarnException,\n          IOException {\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n        \"Rejecting new containers as NodeManager has not\"\n            + \" yet connected with ResourceManager\");\n    }\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi,nmTokenIdentifier);\n    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    for (StartContainerRequest request : requests.getStartContainerRequests()) {\n      ContainerId containerId \u003d null;\n      try {\n        if (request.getContainerToken() \u003d\u003d null ||\n            request.getContainerToken().getIdentifier() \u003d\u003d null) {\n          throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n        }\n        ContainerTokenIdentifier containerTokenIdentifier \u003d\n            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n          containerTokenIdentifier);\n        containerId \u003d containerTokenIdentifier.getContainerID();\n\n        // Initialize the AMRMProxy service instance only if the container is of\n        // type AM and if the AMRMProxy service is enabled\n        if (isARMRMProxyEnabled()\n            \u0026\u0026 containerTokenIdentifier.getContainerType().equals(\n                ContainerType.APPLICATION_MASTER)) {\n          this.amrmProxyService.processApplicationStartRequest(request);\n        }\n\n        startContainerInternal(nmTokenIdentifier,\n            containerTokenIdentifier, request);\n        succeededContainers.add(containerId);\n      } catch (YarnException e) {\n        failedContainers.put(containerId, SerializedException.newInstance(e));\n      } catch (InvalidToken ie) {\n        failedContainers.put(containerId, SerializedException.newInstance(ie));\n        throw ie;\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n\n    return StartContainersResponse.newInstance(getAuxServiceMetaData(),\n        succeededContainers, failedContainers);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "bcf2890502fbd11dd394048fe30d67c92aeec4fa": {
      "type": "Ybodychange",
      "commitMessage": "YARN-644: Basic null check is not performed on passed in arguments before using them in ContainerManagerImpl.startContainer\n",
      "commitDate": "08/05/15 9:11 AM",
      "commitName": "bcf2890502fbd11dd394048fe30d67c92aeec4fa",
      "commitAuthor": "Robert (Bobby) Evans",
      "commitDateOld": "12/02/15 11:46 AM",
      "commitNameOld": "04f5ef18f7877ce30b12b1a3c1e851c420531b72",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 84.85,
      "commitsBetweenForRepo": 787,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,41 @@\n       startContainers(StartContainersRequest requests) throws YarnException,\n           IOException {\n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n         \"Rejecting new containers as NodeManager has not\"\n             + \" yet connected with ResourceManager\");\n     }\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n     authorizeUser(remoteUgi,nmTokenIdentifier);\n     List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n     Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n         new HashMap\u003cContainerId, SerializedException\u003e();\n     for (StartContainerRequest request : requests.getStartContainerRequests()) {\n       ContainerId containerId \u003d null;\n       try {\n+        if (request.getContainerToken() \u003d\u003d null ||\n+            request.getContainerToken().getIdentifier() \u003d\u003d null) {\n+          throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n+        }\n         ContainerTokenIdentifier containerTokenIdentifier \u003d\n             BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n         verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n           containerTokenIdentifier);\n         containerId \u003d containerTokenIdentifier.getContainerID();\n         startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n           request);\n         succeededContainers.add(containerId);\n       } catch (YarnException e) {\n         failedContainers.put(containerId, SerializedException.newInstance(e));\n       } catch (InvalidToken ie) {\n         failedContainers.put(containerId, SerializedException.newInstance(ie));\n         throw ie;\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n \n     return StartContainersResponse.newInstance(getAuxServiceMetaData(),\n       succeededContainers, failedContainers);\n   }\n\\ No newline at end of file\n",
      "actualSource": "      startContainers(StartContainersRequest requests) throws YarnException,\n          IOException {\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n        \"Rejecting new containers as NodeManager has not\"\n            + \" yet connected with ResourceManager\");\n    }\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi,nmTokenIdentifier);\n    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    for (StartContainerRequest request : requests.getStartContainerRequests()) {\n      ContainerId containerId \u003d null;\n      try {\n        if (request.getContainerToken() \u003d\u003d null ||\n            request.getContainerToken().getIdentifier() \u003d\u003d null) {\n          throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n        }\n        ContainerTokenIdentifier containerTokenIdentifier \u003d\n            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n          containerTokenIdentifier);\n        containerId \u003d containerTokenIdentifier.getContainerID();\n        startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n          request);\n        succeededContainers.add(containerId);\n      } catch (YarnException e) {\n        failedContainers.put(containerId, SerializedException.newInstance(e));\n      } catch (InvalidToken ie) {\n        failedContainers.put(containerId, SerializedException.newInstance(ie));\n        throw ie;\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n\n    return StartContainersResponse.newInstance(getAuxServiceMetaData(),\n      succeededContainers, failedContainers);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "49afc64cd469bc3a775c18e0458661e39270b7a5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1065. NM should provide AuxillaryService data to the container (Xuan Gong via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1520135 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/13 1:42 PM",
      "commitName": "49afc64cd469bc3a775c18e0458661e39270b7a5",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "01/09/13 5:09 PM",
      "commitNameOld": "a759abcd898224c3481c55aa7e424bc286f60b15",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.86,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n       startContainers(StartContainersRequest requests) throws YarnException,\n           IOException {\n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n         \"Rejecting new containers as NodeManager has not\"\n             + \" yet connected with ResourceManager\");\n     }\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n     authorizeUser(remoteUgi,nmTokenIdentifier);\n     List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n     Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n         new HashMap\u003cContainerId, SerializedException\u003e();\n     for (StartContainerRequest request : requests.getStartContainerRequests()) {\n       ContainerId containerId \u003d null;\n       try {\n         ContainerTokenIdentifier containerTokenIdentifier \u003d\n             BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n         verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n           containerTokenIdentifier);\n         containerId \u003d containerTokenIdentifier.getContainerID();\n         startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n           request);\n         succeededContainers.add(containerId);\n       } catch (YarnException e) {\n         failedContainers.put(containerId, SerializedException.newInstance(e));\n       } catch (InvalidToken ie) {\n         failedContainers.put(containerId, SerializedException.newInstance(ie));\n         throw ie;\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n \n-    return StartContainersResponse.newInstance(auxiliaryServices.getMetaData(),\n+    return StartContainersResponse.newInstance(getAuxServiceMetaData(),\n       succeededContainers, failedContainers);\n   }\n\\ No newline at end of file\n",
      "actualSource": "      startContainers(StartContainersRequest requests) throws YarnException,\n          IOException {\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n        \"Rejecting new containers as NodeManager has not\"\n            + \" yet connected with ResourceManager\");\n    }\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi,nmTokenIdentifier);\n    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    for (StartContainerRequest request : requests.getStartContainerRequests()) {\n      ContainerId containerId \u003d null;\n      try {\n        ContainerTokenIdentifier containerTokenIdentifier \u003d\n            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n          containerTokenIdentifier);\n        containerId \u003d containerTokenIdentifier.getContainerID();\n        startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n          request);\n        succeededContainers.add(containerId);\n      } catch (YarnException e) {\n        failedContainers.put(containerId, SerializedException.newInstance(e));\n      } catch (InvalidToken ie) {\n        failedContainers.put(containerId, SerializedException.newInstance(ie));\n        throw ie;\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n\n    return StartContainersResponse.newInstance(getAuxServiceMetaData(),\n      succeededContainers, failedContainers);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "3ca3137179ef093e42cde06587c9ea785b10f32c": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-926. Modified ContainerManagerProtcol APIs to take in requests for multiple containers. Contributed by Jian He.\nMAPREDUCE-5412. Update MR app to use multiple containers API of ContainerManager after YARN-926. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506391 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/07/13 8:41 PM",
      "commitName": "3ca3137179ef093e42cde06587c9ea785b10f32c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-926. Modified ContainerManagerProtcol APIs to take in requests for multiple containers. Contributed by Jian He.\nMAPREDUCE-5412. Update MR app to use multiple containers API of ContainerManager after YARN-926. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/07/13 8:41 PM",
          "commitName": "3ca3137179ef093e42cde06587c9ea785b10f32c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/07/13 12:31 AM",
          "commitNameOld": "c6facfb10db3f7791e35dd02d11990924a89711f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 6.84,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,37 @@\n-  public StartContainerResponse startContainer(StartContainerRequest request)\n-      throws YarnException, IOException {\n-\n+      startContainers(StartContainersRequest requests) throws YarnException,\n+          IOException {\n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n         \"Rejecting new containers as NodeManager has not\"\n             + \" yet connected with ResourceManager\");\n     }\n-    /*\n-     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n-     * here instead of RPC layer because at the time of opening/authenticating\n-     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n-     * Also new NMToken is issued only at startContainer (once it gets renewed).\n-     * \n-     * 2) It should validate containerToken. Need to check below things. a) It\n-     * is signed by correct master key (part of retrieve password). b) It\n-     * belongs to correct Node Manager (part of retrieve password). c) It has\n-     * correct RMIdentifier. d) It is not expired.\n-     */\n-    // update NMToken\n-\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n-    \n-    // Validate containerToken\n-    ContainerTokenIdentifier containerTokenIdentifier \u003d\n-        verifyAndGetContainerTokenIdentifier(request.getContainerToken());\n-\n-    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier,\n-      remoteUgi);\n-\n-    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n-        .getRMIdentifier()) {\n-        // Is the container coming from unknown RM\n-        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n-        sb.append(containerTokenIdentifier.getContainerID().toString())\n-          .append(\" rejected as it is allocated by a previous RM\");\n-        throw new InvalidContainerException(sb.toString());\n-    }\n-    \n-    updateNMTokenIdentifier(nmTokenIdentifier);\n-    \n-    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n-    String containerIdStr \u003d containerId.toString();\n-    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n-\n-    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n-\n-    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n-\n-    Credentials credentials \u003d parseCredentials(launchContext);\n-\n-    Container container \u003d\n-        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n-          credentials, metrics, containerTokenIdentifier);\n-    ApplicationId applicationID \u003d\n-        containerId.getApplicationAttemptId().getApplicationId();\n-    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n-      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n-        \"ContainerManagerImpl\", \"Container already running on this node!\",\n-        applicationID, containerId);\n-      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n-          + \" already is running on this node!!\");\n+    authorizeUser(remoteUgi,nmTokenIdentifier);\n+    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n+    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n+        new HashMap\u003cContainerId, SerializedException\u003e();\n+    for (StartContainerRequest request : requests.getStartContainerRequests()) {\n+      ContainerId containerId \u003d null;\n+      try {\n+        ContainerTokenIdentifier containerTokenIdentifier \u003d\n+            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n+        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n+          containerTokenIdentifier);\n+        containerId \u003d containerTokenIdentifier.getContainerID();\n+        startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n+          request);\n+        succeededContainers.add(containerId);\n+      } catch (YarnException e) {\n+        failedContainers.put(containerId, SerializedException.newInstance(e));\n+      } catch (InvalidToken ie) {\n+        failedContainers.put(containerId, SerializedException.newInstance(ie));\n+        throw ie;\n+      } catch (IOException e) {\n+        throw RPCUtil.getRemoteException(e);\n+      }\n     }\n \n-    // Create the application\n-    Application application \u003d\n-        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n-          credentials, context);\n-    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n-      application)) {\n-      LOG.info(\"Creating a new application reference for app \" + applicationID);\n-\n-      dispatcher.getEventHandler().handle(\n-        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n-          .getApplicationACLs()));\n-    }\n-\n-    dispatcher.getEventHandler().handle(\n-      new ApplicationContainerInitEvent(container));\n-\n-    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n-      containerTokenIdentifier);\n-    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n-      \"ContainerManageImpl\", applicationID, containerId);\n-    StartContainerResponse response \u003d\n-        recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.setAllServicesMetaData(auxiliaryServices.getMetaData());\n-    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n-    // launch. A finished Application will not launch containers.\n-    metrics.launchedContainer();\n-    metrics.allocateContainer(containerTokenIdentifier.getResource());\n-    return response;\n+    return StartContainersResponse.newInstance(auxiliaryServices.getMetaData(),\n+      succeededContainers, failedContainers);\n   }\n\\ No newline at end of file\n",
          "actualSource": "      startContainers(StartContainersRequest requests) throws YarnException,\n          IOException {\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n        \"Rejecting new containers as NodeManager has not\"\n            + \" yet connected with ResourceManager\");\n    }\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi,nmTokenIdentifier);\n    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    for (StartContainerRequest request : requests.getStartContainerRequests()) {\n      ContainerId containerId \u003d null;\n      try {\n        ContainerTokenIdentifier containerTokenIdentifier \u003d\n            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n          containerTokenIdentifier);\n        containerId \u003d containerTokenIdentifier.getContainerID();\n        startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n          request);\n        succeededContainers.add(containerId);\n      } catch (YarnException e) {\n        failedContainers.put(containerId, SerializedException.newInstance(e));\n      } catch (InvalidToken ie) {\n        failedContainers.put(containerId, SerializedException.newInstance(ie));\n        throw ie;\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n\n    return StartContainersResponse.newInstance(auxiliaryServices.getMetaData(),\n      succeededContainers, failedContainers);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
          "extendedDetails": {
            "oldValue": "startContainer",
            "newValue": "startContainers"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-926. Modified ContainerManagerProtcol APIs to take in requests for multiple containers. Contributed by Jian He.\nMAPREDUCE-5412. Update MR app to use multiple containers API of ContainerManager after YARN-926. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/07/13 8:41 PM",
          "commitName": "3ca3137179ef093e42cde06587c9ea785b10f32c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/07/13 12:31 AM",
          "commitNameOld": "c6facfb10db3f7791e35dd02d11990924a89711f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 6.84,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,37 @@\n-  public StartContainerResponse startContainer(StartContainerRequest request)\n-      throws YarnException, IOException {\n-\n+      startContainers(StartContainersRequest requests) throws YarnException,\n+          IOException {\n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n         \"Rejecting new containers as NodeManager has not\"\n             + \" yet connected with ResourceManager\");\n     }\n-    /*\n-     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n-     * here instead of RPC layer because at the time of opening/authenticating\n-     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n-     * Also new NMToken is issued only at startContainer (once it gets renewed).\n-     * \n-     * 2) It should validate containerToken. Need to check below things. a) It\n-     * is signed by correct master key (part of retrieve password). b) It\n-     * belongs to correct Node Manager (part of retrieve password). c) It has\n-     * correct RMIdentifier. d) It is not expired.\n-     */\n-    // update NMToken\n-\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n-    \n-    // Validate containerToken\n-    ContainerTokenIdentifier containerTokenIdentifier \u003d\n-        verifyAndGetContainerTokenIdentifier(request.getContainerToken());\n-\n-    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier,\n-      remoteUgi);\n-\n-    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n-        .getRMIdentifier()) {\n-        // Is the container coming from unknown RM\n-        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n-        sb.append(containerTokenIdentifier.getContainerID().toString())\n-          .append(\" rejected as it is allocated by a previous RM\");\n-        throw new InvalidContainerException(sb.toString());\n-    }\n-    \n-    updateNMTokenIdentifier(nmTokenIdentifier);\n-    \n-    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n-    String containerIdStr \u003d containerId.toString();\n-    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n-\n-    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n-\n-    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n-\n-    Credentials credentials \u003d parseCredentials(launchContext);\n-\n-    Container container \u003d\n-        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n-          credentials, metrics, containerTokenIdentifier);\n-    ApplicationId applicationID \u003d\n-        containerId.getApplicationAttemptId().getApplicationId();\n-    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n-      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n-        \"ContainerManagerImpl\", \"Container already running on this node!\",\n-        applicationID, containerId);\n-      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n-          + \" already is running on this node!!\");\n+    authorizeUser(remoteUgi,nmTokenIdentifier);\n+    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n+    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n+        new HashMap\u003cContainerId, SerializedException\u003e();\n+    for (StartContainerRequest request : requests.getStartContainerRequests()) {\n+      ContainerId containerId \u003d null;\n+      try {\n+        ContainerTokenIdentifier containerTokenIdentifier \u003d\n+            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n+        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n+          containerTokenIdentifier);\n+        containerId \u003d containerTokenIdentifier.getContainerID();\n+        startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n+          request);\n+        succeededContainers.add(containerId);\n+      } catch (YarnException e) {\n+        failedContainers.put(containerId, SerializedException.newInstance(e));\n+      } catch (InvalidToken ie) {\n+        failedContainers.put(containerId, SerializedException.newInstance(ie));\n+        throw ie;\n+      } catch (IOException e) {\n+        throw RPCUtil.getRemoteException(e);\n+      }\n     }\n \n-    // Create the application\n-    Application application \u003d\n-        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n-          credentials, context);\n-    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n-      application)) {\n-      LOG.info(\"Creating a new application reference for app \" + applicationID);\n-\n-      dispatcher.getEventHandler().handle(\n-        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n-          .getApplicationACLs()));\n-    }\n-\n-    dispatcher.getEventHandler().handle(\n-      new ApplicationContainerInitEvent(container));\n-\n-    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n-      containerTokenIdentifier);\n-    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n-      \"ContainerManageImpl\", applicationID, containerId);\n-    StartContainerResponse response \u003d\n-        recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.setAllServicesMetaData(auxiliaryServices.getMetaData());\n-    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n-    // launch. A finished Application will not launch containers.\n-    metrics.launchedContainer();\n-    metrics.allocateContainer(containerTokenIdentifier.getResource());\n-    return response;\n+    return StartContainersResponse.newInstance(auxiliaryServices.getMetaData(),\n+      succeededContainers, failedContainers);\n   }\n\\ No newline at end of file\n",
          "actualSource": "      startContainers(StartContainersRequest requests) throws YarnException,\n          IOException {\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n        \"Rejecting new containers as NodeManager has not\"\n            + \" yet connected with ResourceManager\");\n    }\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi,nmTokenIdentifier);\n    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    for (StartContainerRequest request : requests.getStartContainerRequests()) {\n      ContainerId containerId \u003d null;\n      try {\n        ContainerTokenIdentifier containerTokenIdentifier \u003d\n            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n          containerTokenIdentifier);\n        containerId \u003d containerTokenIdentifier.getContainerID();\n        startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n          request);\n        succeededContainers.add(containerId);\n      } catch (YarnException e) {\n        failedContainers.put(containerId, SerializedException.newInstance(e));\n      } catch (InvalidToken ie) {\n        failedContainers.put(containerId, SerializedException.newInstance(ie));\n        throw ie;\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n\n    return StartContainersResponse.newInstance(auxiliaryServices.getMetaData(),\n      succeededContainers, failedContainers);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
          "extendedDetails": {
            "oldValue": "[request-StartContainerRequest]",
            "newValue": "[requests-StartContainersRequest]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-926. Modified ContainerManagerProtcol APIs to take in requests for multiple containers. Contributed by Jian He.\nMAPREDUCE-5412. Update MR app to use multiple containers API of ContainerManager after YARN-926. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/07/13 8:41 PM",
          "commitName": "3ca3137179ef093e42cde06587c9ea785b10f32c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/07/13 12:31 AM",
          "commitNameOld": "c6facfb10db3f7791e35dd02d11990924a89711f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 6.84,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,37 @@\n-  public StartContainerResponse startContainer(StartContainerRequest request)\n-      throws YarnException, IOException {\n-\n+      startContainers(StartContainersRequest requests) throws YarnException,\n+          IOException {\n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n         \"Rejecting new containers as NodeManager has not\"\n             + \" yet connected with ResourceManager\");\n     }\n-    /*\n-     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n-     * here instead of RPC layer because at the time of opening/authenticating\n-     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n-     * Also new NMToken is issued only at startContainer (once it gets renewed).\n-     * \n-     * 2) It should validate containerToken. Need to check below things. a) It\n-     * is signed by correct master key (part of retrieve password). b) It\n-     * belongs to correct Node Manager (part of retrieve password). c) It has\n-     * correct RMIdentifier. d) It is not expired.\n-     */\n-    // update NMToken\n-\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n-    \n-    // Validate containerToken\n-    ContainerTokenIdentifier containerTokenIdentifier \u003d\n-        verifyAndGetContainerTokenIdentifier(request.getContainerToken());\n-\n-    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier,\n-      remoteUgi);\n-\n-    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n-        .getRMIdentifier()) {\n-        // Is the container coming from unknown RM\n-        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n-        sb.append(containerTokenIdentifier.getContainerID().toString())\n-          .append(\" rejected as it is allocated by a previous RM\");\n-        throw new InvalidContainerException(sb.toString());\n-    }\n-    \n-    updateNMTokenIdentifier(nmTokenIdentifier);\n-    \n-    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n-    String containerIdStr \u003d containerId.toString();\n-    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n-\n-    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n-\n-    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n-\n-    Credentials credentials \u003d parseCredentials(launchContext);\n-\n-    Container container \u003d\n-        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n-          credentials, metrics, containerTokenIdentifier);\n-    ApplicationId applicationID \u003d\n-        containerId.getApplicationAttemptId().getApplicationId();\n-    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n-      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n-        \"ContainerManagerImpl\", \"Container already running on this node!\",\n-        applicationID, containerId);\n-      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n-          + \" already is running on this node!!\");\n+    authorizeUser(remoteUgi,nmTokenIdentifier);\n+    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n+    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n+        new HashMap\u003cContainerId, SerializedException\u003e();\n+    for (StartContainerRequest request : requests.getStartContainerRequests()) {\n+      ContainerId containerId \u003d null;\n+      try {\n+        ContainerTokenIdentifier containerTokenIdentifier \u003d\n+            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n+        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n+          containerTokenIdentifier);\n+        containerId \u003d containerTokenIdentifier.getContainerID();\n+        startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n+          request);\n+        succeededContainers.add(containerId);\n+      } catch (YarnException e) {\n+        failedContainers.put(containerId, SerializedException.newInstance(e));\n+      } catch (InvalidToken ie) {\n+        failedContainers.put(containerId, SerializedException.newInstance(ie));\n+        throw ie;\n+      } catch (IOException e) {\n+        throw RPCUtil.getRemoteException(e);\n+      }\n     }\n \n-    // Create the application\n-    Application application \u003d\n-        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n-          credentials, context);\n-    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n-      application)) {\n-      LOG.info(\"Creating a new application reference for app \" + applicationID);\n-\n-      dispatcher.getEventHandler().handle(\n-        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n-          .getApplicationACLs()));\n-    }\n-\n-    dispatcher.getEventHandler().handle(\n-      new ApplicationContainerInitEvent(container));\n-\n-    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n-      containerTokenIdentifier);\n-    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n-      \"ContainerManageImpl\", applicationID, containerId);\n-    StartContainerResponse response \u003d\n-        recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.setAllServicesMetaData(auxiliaryServices.getMetaData());\n-    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n-    // launch. A finished Application will not launch containers.\n-    metrics.launchedContainer();\n-    metrics.allocateContainer(containerTokenIdentifier.getResource());\n-    return response;\n+    return StartContainersResponse.newInstance(auxiliaryServices.getMetaData(),\n+      succeededContainers, failedContainers);\n   }\n\\ No newline at end of file\n",
          "actualSource": "      startContainers(StartContainersRequest requests) throws YarnException,\n          IOException {\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n        \"Rejecting new containers as NodeManager has not\"\n            + \" yet connected with ResourceManager\");\n    }\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi,nmTokenIdentifier);\n    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    for (StartContainerRequest request : requests.getStartContainerRequests()) {\n      ContainerId containerId \u003d null;\n      try {\n        ContainerTokenIdentifier containerTokenIdentifier \u003d\n            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n          containerTokenIdentifier);\n        containerId \u003d containerTokenIdentifier.getContainerID();\n        startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n          request);\n        succeededContainers.add(containerId);\n      } catch (YarnException e) {\n        failedContainers.put(containerId, SerializedException.newInstance(e));\n      } catch (InvalidToken ie) {\n        failedContainers.put(containerId, SerializedException.newInstance(ie));\n        throw ie;\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n\n    return StartContainersResponse.newInstance(auxiliaryServices.getMetaData(),\n      succeededContainers, failedContainers);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
          "extendedDetails": {
            "oldValue": "StartContainerResponse",
            "newValue": "StartContainersResponse"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-926. Modified ContainerManagerProtcol APIs to take in requests for multiple containers. Contributed by Jian He.\nMAPREDUCE-5412. Update MR app to use multiple containers API of ContainerManager after YARN-926. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/07/13 8:41 PM",
          "commitName": "3ca3137179ef093e42cde06587c9ea785b10f32c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/07/13 12:31 AM",
          "commitNameOld": "c6facfb10db3f7791e35dd02d11990924a89711f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 6.84,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,37 @@\n-  public StartContainerResponse startContainer(StartContainerRequest request)\n-      throws YarnException, IOException {\n-\n+      startContainers(StartContainersRequest requests) throws YarnException,\n+          IOException {\n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n         \"Rejecting new containers as NodeManager has not\"\n             + \" yet connected with ResourceManager\");\n     }\n-    /*\n-     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n-     * here instead of RPC layer because at the time of opening/authenticating\n-     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n-     * Also new NMToken is issued only at startContainer (once it gets renewed).\n-     * \n-     * 2) It should validate containerToken. Need to check below things. a) It\n-     * is signed by correct master key (part of retrieve password). b) It\n-     * belongs to correct Node Manager (part of retrieve password). c) It has\n-     * correct RMIdentifier. d) It is not expired.\n-     */\n-    // update NMToken\n-\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n-    \n-    // Validate containerToken\n-    ContainerTokenIdentifier containerTokenIdentifier \u003d\n-        verifyAndGetContainerTokenIdentifier(request.getContainerToken());\n-\n-    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier,\n-      remoteUgi);\n-\n-    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n-        .getRMIdentifier()) {\n-        // Is the container coming from unknown RM\n-        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n-        sb.append(containerTokenIdentifier.getContainerID().toString())\n-          .append(\" rejected as it is allocated by a previous RM\");\n-        throw new InvalidContainerException(sb.toString());\n-    }\n-    \n-    updateNMTokenIdentifier(nmTokenIdentifier);\n-    \n-    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n-    String containerIdStr \u003d containerId.toString();\n-    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n-\n-    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n-\n-    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n-\n-    Credentials credentials \u003d parseCredentials(launchContext);\n-\n-    Container container \u003d\n-        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n-          credentials, metrics, containerTokenIdentifier);\n-    ApplicationId applicationID \u003d\n-        containerId.getApplicationAttemptId().getApplicationId();\n-    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n-      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n-        \"ContainerManagerImpl\", \"Container already running on this node!\",\n-        applicationID, containerId);\n-      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n-          + \" already is running on this node!!\");\n+    authorizeUser(remoteUgi,nmTokenIdentifier);\n+    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n+    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n+        new HashMap\u003cContainerId, SerializedException\u003e();\n+    for (StartContainerRequest request : requests.getStartContainerRequests()) {\n+      ContainerId containerId \u003d null;\n+      try {\n+        ContainerTokenIdentifier containerTokenIdentifier \u003d\n+            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n+        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n+          containerTokenIdentifier);\n+        containerId \u003d containerTokenIdentifier.getContainerID();\n+        startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n+          request);\n+        succeededContainers.add(containerId);\n+      } catch (YarnException e) {\n+        failedContainers.put(containerId, SerializedException.newInstance(e));\n+      } catch (InvalidToken ie) {\n+        failedContainers.put(containerId, SerializedException.newInstance(ie));\n+        throw ie;\n+      } catch (IOException e) {\n+        throw RPCUtil.getRemoteException(e);\n+      }\n     }\n \n-    // Create the application\n-    Application application \u003d\n-        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n-          credentials, context);\n-    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n-      application)) {\n-      LOG.info(\"Creating a new application reference for app \" + applicationID);\n-\n-      dispatcher.getEventHandler().handle(\n-        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n-          .getApplicationACLs()));\n-    }\n-\n-    dispatcher.getEventHandler().handle(\n-      new ApplicationContainerInitEvent(container));\n-\n-    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n-      containerTokenIdentifier);\n-    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n-      \"ContainerManageImpl\", applicationID, containerId);\n-    StartContainerResponse response \u003d\n-        recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.setAllServicesMetaData(auxiliaryServices.getMetaData());\n-    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n-    // launch. A finished Application will not launch containers.\n-    metrics.launchedContainer();\n-    metrics.allocateContainer(containerTokenIdentifier.getResource());\n-    return response;\n+    return StartContainersResponse.newInstance(auxiliaryServices.getMetaData(),\n+      succeededContainers, failedContainers);\n   }\n\\ No newline at end of file\n",
          "actualSource": "      startContainers(StartContainersRequest requests) throws YarnException,\n          IOException {\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n        \"Rejecting new containers as NodeManager has not\"\n            + \" yet connected with ResourceManager\");\n    }\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi,nmTokenIdentifier);\n    List\u003cContainerId\u003e succeededContainers \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    for (StartContainerRequest request : requests.getStartContainerRequests()) {\n      ContainerId containerId \u003d null;\n      try {\n        ContainerTokenIdentifier containerTokenIdentifier \u003d\n            BuilderUtils.newContainerTokenIdentifier(request.getContainerToken());\n        verifyAndGetContainerTokenIdentifier(request.getContainerToken(),\n          containerTokenIdentifier);\n        containerId \u003d containerTokenIdentifier.getContainerID();\n        startContainerInternal(nmTokenIdentifier, containerTokenIdentifier,\n          request);\n        succeededContainers.add(containerId);\n      } catch (YarnException e) {\n        failedContainers.put(containerId, SerializedException.newInstance(e));\n      } catch (InvalidToken ie) {\n        failedContainers.put(containerId, SerializedException.newInstance(ie));\n        throw ie;\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n\n    return StartContainersResponse.newInstance(auxiliaryServices.getMetaData(),\n      succeededContainers, failedContainers);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "243bcd367ff3130d74676280233041f88aca62a5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-694. Starting to use NMTokens to authenticate all communication with NodeManagers. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494369 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/06/13 4:19 PM",
      "commitName": "243bcd367ff3130d74676280233041f88aca62a5",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/06/13 11:20 PM",
      "commitNameOld": "f4d80e91ae314d316100baa7770b9d73ea853d9c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.71,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,94 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n-          \"Rejecting new containers as NodeManager has not\" +\n-          \" yet connected with ResourceManager\");\n+        \"Rejecting new containers as NodeManager has not\"\n+            + \" yet connected with ResourceManager\");\n     }\n-\n-    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n-    org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n-\n-    ContainerTokenIdentifier tokenIdentifier \u003d null;\n-    try {\n-      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n-    } catch (IOException e) {\n-      throw RPCUtil.getRemoteException(e);\n-    }\n+    /*\n+     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n+     * here instead of RPC layer because at the time of opening/authenticating\n+     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n+     * Also new NMToken is issued only at startContainer (once it gets renewed).\n+     * \n+     * 2) It should validate containerToken. Need to check below things. a) It\n+     * is signed by correct master key (part of retrieve password). b) It\n+     * belongs to correct Node Manager (part of retrieve password). c) It has\n+     * correct RMIdentifier. d) It is not expired.\n+     */\n+    // update NMToken\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n-    ContainerTokenIdentifier tokenId \u003d \n-        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n+    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n+    \n+    // Validate containerToken\n+    ContainerTokenIdentifier containerTokenIdentifier \u003d\n+        verifyAndGetContainerTokenIdentifier(request.getContainerToken());\n \n-    ContainerId containerID \u003d tokenId.getContainerID();\n-    String containerIDStr \u003d containerID.toString();\n+    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier,\n+      remoteUgi);\n \n-    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n-\n-    // Is the container coming from unknown RM\n-    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n-      .getRMIdentifier()) {\n-      String msg \u003d \"\\nContainer \"+ containerIDStr\n-          + \" rejected as it is allocated by a previous RM\";\n-      LOG.error(msg);\n-      throw new InvalidContainerException(msg);\n+    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n+        .getRMIdentifier()) {\n+        // Is the container coming from unknown RM\n+        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n+        sb.append(containerTokenIdentifier.getContainerID().toString())\n+          .append(\" rejected as it is allocated by a previous RM\");\n+        throw new InvalidContainerException(sb.toString());\n     }\n+    \n+    updateNMTokenIdentifier(nmTokenIdentifier);\n+    \n+    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n+    String containerIdStr \u003d containerId.toString();\n+    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n-    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n-        + tokenId.getApplicationSubmitter());\n+    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n-    // //////////// Parse credentials\n-    ByteBuffer tokens \u003d launchContext.getTokens();\n-    Credentials credentials \u003d new Credentials();\n-    if (tokens !\u003d null) {\n-      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n-      tokens.rewind();\n-      buf.reset(tokens);\n-      try {\n-        credentials.readTokenStorageStream(buf);\n-        if (LOG.isDebugEnabled()) {\n-          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n-              .getAllTokens()) {\n-            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n-          }\n-        }\n-      } catch (IOException e) {\n-        throw RPCUtil.getRemoteException(e);\n-      }\n-    }\n-    // //////////// End of parsing credentials\n-    String user \u003d tokenId.getApplicationSubmitter();\n+    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n+\n+    Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n-          credentials, metrics, tokenId);\n-    ApplicationId applicationID \u003d \n-        containerID.getApplicationAttemptId().getApplicationId();\n-    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n-      NMAuditLogger.logFailure(user, \n-          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n-          \"Container already running on this node!\",\n-          applicationID, containerID);\n-      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n+          credentials, metrics, containerTokenIdentifier);\n+    ApplicationId applicationID \u003d\n+        containerId.getApplicationAttemptId().getApplicationId();\n+    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n+      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n+        \"ContainerManagerImpl\", \"Container already running on this node!\",\n+        applicationID, containerId);\n+      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n-        new ApplicationImpl(dispatcher, this.aclsManager,\n-          user, applicationID, credentials,\n-          context);\n-    if (null \u003d\u003d\n-        context.getApplications().putIfAbsent(applicationID, application)) {\n-      LOG.info(\"Creating a new application reference for app \"\n-          + applicationID);\n+        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n+          credentials, context);\n+    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n+      application)) {\n+      LOG.info(\"Creating a new application reference for app \" + applicationID);\n+\n       dispatcher.getEventHandler().handle(\n-          new ApplicationInitEvent(applicationID, container\n-              .getLaunchContext().getApplicationACLs()));\n+        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n+          .getApplicationACLs()));\n     }\n \n-    // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n-        new ApplicationContainerInitEvent(container));\n-    \n-    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n-      tokenId);\n-    NMAuditLogger.logSuccess(user, \n-        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n-        applicationID, containerID);\n+      new ApplicationContainerInitEvent(container));\n \n+    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n+      containerTokenIdentifier);\n+    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n+      \"ContainerManageImpl\", applicationID, containerId);\n     StartContainerResponse response \u003d\n-        StartContainerResponse.newInstance(auxiliaryServices.getMetaData());\n+        recordFactory.newRecordInstance(StartContainerResponse.class);\n+    response.setAllServicesMetaData(auxiliaryServices.getMetaData());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n-    metrics.allocateContainer(tokenId.getResource());\n+    metrics.allocateContainer(containerTokenIdentifier.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n        \"Rejecting new containers as NodeManager has not\"\n            + \" yet connected with ResourceManager\");\n    }\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    // update NMToken\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    \n    // Validate containerToken\n    ContainerTokenIdentifier containerTokenIdentifier \u003d\n        verifyAndGetContainerTokenIdentifier(request.getContainerToken());\n\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier,\n      remoteUgi);\n\n    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    \n    updateNMTokenIdentifier(nmTokenIdentifier);\n    \n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n          credentials, context);\n    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n      application)) {\n      LOG.info(\"Creating a new application reference for app \" + applicationID);\n\n      dispatcher.getEventHandler().handle(\n        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n          .getApplicationACLs()));\n    }\n\n    dispatcher.getEventHandler().handle(\n      new ApplicationContainerInitEvent(container));\n\n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      containerTokenIdentifier);\n    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n      \"ContainerManageImpl\", applicationID, containerId);\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServicesMetaData(auxiliaryServices.getMetaData());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(containerTokenIdentifier.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "f4d80e91ae314d316100baa7770b9d73ea853d9c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-841. Move Auxiliary service to yarn-api, annotate and document it. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494031 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 11:20 PM",
      "commitName": "f4d80e91ae314d316100baa7770b9d73ea853d9c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/06/13 11:39 PM",
      "commitNameOld": "b9efe6bd4a1277b4067ecde715a7713a85968886",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.99,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,108 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\");\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n \n     ContainerTokenIdentifier tokenIdentifier \u003d null;\n     try {\n       tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n     } catch (IOException e) {\n       throw RPCUtil.getRemoteException(e);\n     }\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     ContainerTokenIdentifier tokenId \u003d \n         getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n \n     ContainerId containerID \u003d tokenId.getContainerID();\n     String containerIDStr \u003d containerID.toString();\n \n     authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n \n     // Is the container coming from unknown RM\n     if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw new InvalidContainerException(msg);\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n     String user \u003d tokenId.getApplicationSubmitter();\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           user, applicationID, credentials,\n           context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n     NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n-        recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.setAllServiceResponse(auxiliaryServices.getMeta());\n+        StartContainerResponse.newInstance(auxiliaryServices.getMetaData());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(tokenId.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\");\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n\n    ContainerTokenIdentifier tokenIdentifier \u003d null;\n    try {\n      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n    } catch (IOException e) {\n      throw RPCUtil.getRemoteException(e);\n    }\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n\n    ContainerId containerID \u003d tokenId.getContainerID();\n    String containerIDStr \u003d containerID.toString();\n\n    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n\n    // Is the container coming from unknown RM\n    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw new InvalidContainerException(msg);\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        StartContainerResponse.newInstance(auxiliaryServices.getMetaData());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(tokenId.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "c6c41abf683be17c3917a7f94953b55347aaa69f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-737. Throw some specific exceptions directly instead of wrapping them in YarnException. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1491896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/06/13 11:47 AM",
      "commitName": "c6c41abf683be17c3917a7f94953b55347aaa69f",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "03/06/13 9:05 PM",
      "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.61,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,109 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n-      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n+      throw new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n-          \" yet connected with ResourceManager\"));\n+          \" yet connected with ResourceManager\");\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n \n     ContainerTokenIdentifier tokenIdentifier \u003d null;\n     try {\n       tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n     } catch (IOException e) {\n       throw RPCUtil.getRemoteException(e);\n     }\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     ContainerTokenIdentifier tokenId \u003d \n         getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n \n     ContainerId containerID \u003d tokenId.getContainerID();\n     String containerIDStr \u003d containerID.toString();\n \n     authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n \n     // Is the container coming from unknown RM\n     if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n-      throw RPCUtil\n-        .getRemoteException(new InvalidContainerException(msg));\n+      throw new InvalidContainerException(msg);\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n     String user \u003d tokenId.getApplicationSubmitter();\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           user, applicationID, credentials,\n           context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n     NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(tokenId.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\");\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n\n    ContainerTokenIdentifier tokenIdentifier \u003d null;\n    try {\n      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n    } catch (IOException e) {\n      throw RPCUtil.getRemoteException(e);\n    }\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n\n    ContainerId containerID \u003d tokenId.getContainerID();\n    String containerIDStr \u003d containerID.toString();\n\n    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n\n    // Is the container coming from unknown RM\n    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw new InvalidContainerException(msg);\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(tokenId.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/06/13 5:34 PM",
      "commitNameOld": "d33534c4fb35cb82ff8d56abeeb63a949e72a031",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n-      throws YarnRemoteException, IOException {\n+      throws YarnException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n \n     ContainerTokenIdentifier tokenIdentifier \u003d null;\n     try {\n       tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n     } catch (IOException e) {\n       throw RPCUtil.getRemoteException(e);\n     }\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     ContainerTokenIdentifier tokenId \u003d \n         getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n \n     ContainerId containerID \u003d tokenId.getContainerID();\n     String containerIDStr \u003d containerID.toString();\n \n     authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n \n     // Is the container coming from unknown RM\n     if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n     String user \u003d tokenId.getApplicationSubmitter();\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           user, applicationID, credentials,\n           context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n     NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(tokenId.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n\n    ContainerTokenIdentifier tokenIdentifier \u003d null;\n    try {\n      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n    } catch (IOException e) {\n      throw RPCUtil.getRemoteException(e);\n    }\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n\n    ContainerId containerID \u003d tokenId.getContainerID();\n    String containerIDStr \u003d containerID.toString();\n\n    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n\n    // Is the container coming from unknown RM\n    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(tokenId.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException, IOException]",
        "newValue": "[YarnException, IOException]"
      }
    },
    "a2c42330047bf955a6a585dcddf798920d4c8640": {
      "type": "Ybodychange",
      "commitMessage": "YARN-717. Put object creation factories for Token in the class itself and remove useless derivations for specific tokens. Contributed by Jian He.\nMAPREDUCE-5289. Updated MR App to use Token directly after YARN-717. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488616 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/06/13 2:43 PM",
      "commitName": "a2c42330047bf955a6a585dcddf798920d4c8640",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/05/13 5:14 PM",
      "commitNameOld": "39f019f41392d9e46ea1dc86ddd5563aabbeda1e",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 0.89,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n-    ContainerToken token \u003d request.getContainerToken();\n+    org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n \n     ContainerTokenIdentifier tokenIdentifier \u003d null;\n     try {\n       tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n     } catch (IOException e) {\n       throw RPCUtil.getRemoteException(e);\n     }\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     ContainerTokenIdentifier tokenId \u003d \n         getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n \n     ContainerId containerID \u003d tokenId.getContainerID();\n     String containerIDStr \u003d containerID.toString();\n \n     authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n \n     // Is the container coming from unknown RM\n     if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n     String user \u003d tokenId.getApplicationSubmitter();\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           user, applicationID, credentials,\n           context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n     NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(tokenId.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n\n    ContainerTokenIdentifier tokenIdentifier \u003d null;\n    try {\n      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n    } catch (IOException e) {\n      throw RPCUtil.getRemoteException(e);\n    }\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n\n    ContainerId containerID \u003d tokenId.getContainerID();\n    String containerIDStr \u003d containerID.toString();\n\n    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n\n    // Is the container coming from unknown RM\n    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(tokenId.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "2692675fc3b5046d2ec88542c30203c87e135b70": {
      "type": "Ybodychange",
      "commitMessage": "YARN-684. ContainerManager.startContainer should use ContainerTokenIdentifier instead of the entire Container. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488085 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/13 9:13 PM",
      "commitName": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "29/05/13 9:59 PM",
      "commitNameOld": "b16c5638b5190c56f9d854d873589cb5c11c8b32",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 0.97,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,110 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n-    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n-        request.getContainer();\n-    ContainerId containerID \u003d lauchContainer.getId();\n+    ContainerToken token \u003d request.getContainerToken();\n+\n+    ContainerTokenIdentifier tokenIdentifier \u003d null;\n+    try {\n+      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n+    } catch (IOException e) {\n+      throw RPCUtil.getRemoteException(e);\n+    }\n+\n+    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n+    ContainerTokenIdentifier tokenId \u003d \n+        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n+\n+    ContainerId containerID \u003d tokenId.getContainerID();\n     String containerIDStr \u003d containerID.toString();\n \n-    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n-    ContainerTokenIdentifier tokenId \u003d \n-        getContainerTokenIdentifier(remoteUgi, lauchContainer);\n-    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n-      tokenId);\n+    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n \n     // Is the container coming from unknown RM\n     if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n     String user \u003d tokenId.getApplicationSubmitter();\n \n-    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n-        launchContext, lauchContainer, credentials, metrics, tokenId);\n+    Container container \u003d\n+        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n+          credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           user, applicationID, credentials,\n           context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n     NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n-    metrics.allocateContainer(lauchContainer.getResource());\n+    metrics.allocateContainer(tokenId.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    ContainerToken token \u003d request.getContainerToken();\n\n    ContainerTokenIdentifier tokenIdentifier \u003d null;\n    try {\n      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n    } catch (IOException e) {\n      throw RPCUtil.getRemoteException(e);\n    }\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n\n    ContainerId containerID \u003d tokenId.getContainerID();\n    String containerIDStr \u003d containerID.toString();\n\n    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n\n    // Is the container coming from unknown RM\n    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(tokenId.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "b16c5638b5190c56f9d854d873589cb5c11c8b32": {
      "type": "Ybodychange",
      "commitMessage": "YARN-719. Move RMIdentifier from Container to ContainerTokenIdentifier. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1487741 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/05/13 9:59 PM",
      "commitName": "b16c5638b5190c56f9d854d873589cb5c11c8b32",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "23/05/13 8:22 PM",
      "commitNameOld": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.07,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n     ContainerTokenIdentifier tokenId \u003d \n         getContainerTokenIdentifier(remoteUgi, lauchContainer);\n     authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n       tokenId);\n \n     // Is the container coming from unknown RM\n-    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n+    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n     String user \u003d tokenId.getApplicationSubmitter();\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, lauchContainer, credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           user, applicationID, credentials,\n           context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n     NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, lauchContainer);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n      tokenId);\n\n    // Is the container coming from unknown RM\n    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "259edf8dca44de54033e96f7eb65a83aaa6096f2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-571. Remove user from ContainerLaunchContext. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1485928 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/05/13 8:22 PM",
      "commitName": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/05/13 11:36 PM",
      "commitNameOld": "ca8024673178fa1c80224b390dfba932921693d9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.87,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,102 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n     ContainerTokenIdentifier tokenId \u003d \n         getContainerTokenIdentifier(remoteUgi, lauchContainer);\n     authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n       tokenId);\n \n     // Is the container coming from unknown RM\n     if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n-        + launchContext.getUser());\n+        + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n+    String user \u003d tokenId.getApplicationSubmitter();\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n-        launchContext, lauchContainer, credentials, metrics);\n+        launchContext, lauchContainer, credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n-      NMAuditLogger.logFailure(launchContext.getUser(), \n+      NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n-          launchContext.getUser(), applicationID, credentials, context);\n+          user, applicationID, credentials,\n+          context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n-    NMAuditLogger.logSuccess(launchContext.getUser(), \n+    NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, lauchContainer);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n      tokenId);\n\n    // Is the container coming from unknown RM\n    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "ca8024673178fa1c80224b390dfba932921693d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-617. Made ContainerTokens to be used for validation at NodeManager also in unsecure mode to prevent AMs from faking resource requirements in unsecure mode. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1483667 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/05/13 11:36 PM",
      "commitName": "ca8024673178fa1c80224b390dfba932921693d9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/05/13 9:11 PM",
      "commitNameOld": "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 3.1,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,100 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n-    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n+    ContainerTokenIdentifier tokenId \u003d \n+        getContainerTokenIdentifier(remoteUgi, lauchContainer);\n+    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n+      tokenId);\n \n     // Is the container coming from unknown RM\n     if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, lauchContainer, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n-    if (UserGroupInformation.isSecurityEnabled()) {\n-      ContainerTokenIdentifier tokenId \u003d\n-          selectContainerTokenIdentifier(remoteUgi);\n-      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n-        tokenId);\n-    }\n-\n+    \n+    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n+      tokenId);\n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, lauchContainer);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n      tokenId);\n\n    // Is the container coming from unknown RM\n    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-615. Rename ContainerLaunchContext.containerTokens to tokens. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1482199 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/13 9:11 PM",
      "commitName": "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "06/05/13 5:42 PM",
      "commitNameOld": "9eb53b9c841233538a51e4e854b261536c0b85d4",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.15,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,101 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n     authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n \n     // Is the container coming from unknown RM\n     if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + launchContext.getUser());\n \n     // //////////// Parse credentials\n-    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n+    ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, lauchContainer, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     if (UserGroupInformation.isSecurityEnabled()) {\n       ContainerTokenIdentifier tokenId \u003d\n           selectContainerTokenIdentifier(remoteUgi);\n       this.context.getContainerTokenSecretManager().startContainerSuccessful(\n         tokenId);\n     }\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n\n    // Is the container coming from unknown RM\n    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    if (UserGroupInformation.isSecurityEnabled()) {\n      ContainerTokenIdentifier tokenId \u003d\n          selectContainerTokenIdentifier(remoteUgi);\n      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n        tokenId);\n    }\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "9eb53b9c841233538a51e4e854b261536c0b85d4": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-632. Changed ContainerManager api to throw IOException and YarnRemoteException. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479740 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/05/13 5:42 PM",
      "commitName": "9eb53b9c841233538a51e4e854b261536c0b85d4",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "06/05/13 12:04 PM",
      "commitNameOld": "92b7165a71656468f17ce8b760ce11e648932f0e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,101 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n-      throws YarnRemoteException {\n+      throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n     authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n \n     // Is the container coming from unknown RM\n     if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, lauchContainer, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     if (UserGroupInformation.isSecurityEnabled()) {\n       ContainerTokenIdentifier tokenId \u003d\n           selectContainerTokenIdentifier(remoteUgi);\n       this.context.getContainerTokenSecretManager().startContainerSuccessful(\n         tokenId);\n     }\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n\n    // Is the container coming from unknown RM\n    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    if (UserGroupInformation.isSecurityEnabled()) {\n      ContainerTokenIdentifier tokenId \u003d\n          selectContainerTokenIdentifier(remoteUgi);\n      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n        tokenId);\n    }\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException]",
        "newValue": "[YarnRemoteException, IOException]"
      }
    },
    "fbb55784d93e1a819daf55d936e864d344579cbf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-562. Modified NM to reject any containers allocated by a previous ResourceManager. Contributed by Jian He.\nMAPREDUCE-5167. Update MR App after YARN-562 to use the new builder API for the container. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1476034 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/04/13 8:50 PM",
      "commitName": "fbb55784d93e1a819daf55d936e864d344579cbf",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/04/13 6:33 PM",
      "commitNameOld": "8e1c2823fc014a5a045c86760c61111d0bb59d2f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.1,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,101 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n+\n+    if (blockNewContainerRequests.get()) {\n+      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n+          \"Rejecting new containers as NodeManager has not\" +\n+          \" yet connected with ResourceManager\"));\n+    }\n+\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n     authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n \n+    // Is the container coming from unknown RM\n+    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n+      .getRMIdentifier()) {\n+      String msg \u003d \"\\nContainer \"+ containerIDStr\n+          + \" rejected as it is allocated by a previous RM\";\n+      LOG.error(msg);\n+      throw RPCUtil\n+        .getRemoteException(new InvalidContainerException(msg));\n+    }\n+\n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, lauchContainer, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     if (UserGroupInformation.isSecurityEnabled()) {\n       ContainerTokenIdentifier tokenId \u003d\n           selectContainerTokenIdentifier(remoteUgi);\n       this.context.getContainerTokenSecretManager().startContainerSuccessful(\n         tokenId);\n     }\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n\n    // Is the container coming from unknown RM\n    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    if (UserGroupInformation.isSecurityEnabled()) {\n      ContainerTokenIdentifier tokenId \u003d\n          selectContainerTokenIdentifier(remoteUgi);\n      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n        tokenId);\n    }\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "8e1c2823fc014a5a045c86760c61111d0bb59d2f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-441. Removed unused utility methods for collections from two API records. Contributed by Xuan Gong.\nMAPREDUCE-5163. Update MR App to not use API utility methods for collections after YARN-441. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469657 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/04/13 6:33 PM",
      "commitName": "8e1c2823fc014a5a045c86760c61111d0bb59d2f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "11/04/13 12:28 PM",
      "commitNameOld": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.25,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n     authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, lauchContainer, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     if (UserGroupInformation.isSecurityEnabled()) {\n       ContainerTokenIdentifier tokenId \u003d\n           selectContainerTokenIdentifier(remoteUgi);\n       this.context.getContainerTokenSecretManager().startContainerSuccessful(\n         tokenId);\n     }\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.addAllServiceResponse(auxiliaryServices.getMeta());\n+    response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    if (UserGroupInformation.isSecurityEnabled()) {\n      ContainerTokenIdentifier tokenId \u003d\n          selectContainerTokenIdentifier(remoteUgi);\n      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n        tokenId);\n    }\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-486. Changed NM\u0027s startContainer API to accept Container record given by RM as a direct parameter instead of as part of the ContainerLaunchContext record. Contributed by Xuan Gong.\nMAPREDUCE-5139. Update MR AM to use the modified startContainer API after YARN-486. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1467063 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/04/13 12:28 PM",
      "commitName": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/12/12 4:12 AM",
      "commitNameOld": "235749a8ab5f303b5b3a2993da8c5bea1818183b",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 129.3,
      "commitsBetweenForRepo": 595,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,84 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n-\n-    ContainerId containerID \u003d launchContext.getContainerId();\n+    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n+        request.getContainer();\n+    ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n-    authorizeRequest(containerIDStr, launchContext, remoteUgi);\n+    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n-        launchContext, credentials, metrics);\n+        launchContext, lauchContainer, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     if (UserGroupInformation.isSecurityEnabled()) {\n       ContainerTokenIdentifier tokenId \u003d\n           selectContainerTokenIdentifier(remoteUgi);\n       this.context.getContainerTokenSecretManager().startContainerSuccessful(\n         tokenId);\n     }\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n-    metrics.allocateContainer(launchContext.getResource());\n+    metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    if (UserGroupInformation.isSecurityEnabled()) {\n      ContainerTokenIdentifier tokenId \u003d\n          selectContainerTokenIdentifier(remoteUgi);\n      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n        tokenId);\n    }\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-39. RM-NM secret-keys should be randomly generated and rolled every so often. (Contributed by Vinod Kumar Vavilapalli and Siddharth Seth)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1377180 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/12 7:18 PM",
      "commitName": "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 16.87,
      "commitsBetweenForRepo": 114,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,83 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     ContainerId containerID \u003d launchContext.getContainerId();\n-    authorizeRequest(containerID, launchContext);\n+    String containerIDStr \u003d containerID.toString();\n \n-    LOG.info(\"Start request for \" + launchContext.getContainerId()\n-        + \" by user \" + launchContext.getUser());\n+    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n+    authorizeRequest(containerIDStr, launchContext, remoteUgi);\n+\n+    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n+        + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n-      throw RPCUtil.getRemoteException(\"Container \" + containerID\n+      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n-            launchContext.getUser(), applicationID, credentials, context);\n+          launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      ContainerTokenIdentifier tokenId \u003d\n+          selectContainerTokenIdentifier(remoteUgi);\n+      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n+        tokenId);\n+    }\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    ContainerId containerID \u003d launchContext.getContainerId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    authorizeRequest(containerIDStr, launchContext, remoteUgi);\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    if (UserGroupInformation.isSecurityEnabled()) {\n      ContainerTokenIdentifier tokenId \u003d\n          selectContainerTokenIdentifier(remoteUgi);\n      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n        tokenId);\n    }\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    ContainerId containerID \u003d launchContext.getContainerId();\n    authorizeRequest(containerID, launchContext);\n\n    LOG.info(\"Start request for \" + launchContext.getContainerId()\n        + \" by user \" + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n            launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java"
      }
    },
    "4e5818698778bff9d2b1ba14297d8393e49927c7": {
      "type": "Ybodychange",
      "commitMessage": "Removed some logs.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1304099 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/03/12 3:20 PM",
      "commitName": "4e5818698778bff9d2b1ba14297d8393e49927c7",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "20/02/12 9:08 PM",
      "commitNameOld": "5ee495e6f34faff231ad87ec890188eb63617393",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 30.72,
      "commitsBetweenForRepo": 207,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,74 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     ContainerId containerID \u003d launchContext.getContainerId();\n     authorizeRequest(containerID, launchContext);\n \n-    LOG.info(\" container is \" + request);\n+    LOG.info(\"Start request for \" + launchContext.getContainerId()\n+        + \" by user \" + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n             launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    ContainerId containerID \u003d launchContext.getContainerId();\n    authorizeRequest(containerID, launchContext);\n\n    LOG.info(\"Start request for \" + launchContext.getContainerId()\n        + \" by user \" + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n            launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "7f4dc277572df6ba25fa961073b99a5bdb086c00": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3256. Added authorization checks for the protocol between NodeManager and ApplicationMaster. Contributed by Vinod K V.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1194850 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/10/11 2:35 AM",
      "commitName": "7f4dc277572df6ba25fa961073b99a5bdb086c00",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "27/10/11 11:45 PM",
      "commitNameOld": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,73 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n+    ContainerId containerID \u003d launchContext.getContainerId();\n+    authorizeRequest(containerID, launchContext);\n+\n     LOG.info(\" container is \" + request);\n-  \n+\n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n-    Container container \u003d\n-        new ContainerImpl(getConfig(), this.dispatcher, launchContext, credentials, metrics);\n-    ContainerId containerID \u003d launchContext.getContainerId();\n+    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n+        launchContext, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n             launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    ContainerId containerID \u003d launchContext.getContainerId();\n    authorizeRequest(containerID, launchContext);\n\n    LOG.info(\" container is \" + request);\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n            launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2989. Modified JobHistory to link to task and AM logs from the JobHistoryServer. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 11:45 PM",
      "commitName": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "26/10/11 4:58 PM",
      "commitNameOld": "237154982bd5853c6a374cb265520e0602adc52f",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.28,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,71 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n-    Application application \u003d new ApplicationImpl(dispatcher,\n-        this.aclsManager, launchContext.getUser(), applicationID, credentials);\n+    Application application \u003d\n+        new ApplicationImpl(dispatcher, this.aclsManager,\n+            launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n            launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "237154982bd5853c6a374cb265520e0602adc52f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3205. Fix memory specifications to be physical rather than virtual, allowing for a ratio between the two to be configurable. Contributed by Todd Lipcon. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189542 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/10/11 4:58 PM",
      "commitName": "237154982bd5853c6a374cb265520e0602adc52f",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/10/11 11:07 PM",
      "commitNameOld": "d19cfe01642f9582e1fe5d567beb480399c37a01",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 1.74,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n-        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n+        new ContainerImpl(getConfig(), this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         this.aclsManager, launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        this.aclsManager, launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "df2991c0cbc3f35c2640b93680667507c4f810dd": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3104. Implemented Application-acls. (vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1186748 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/10/11 4:45 AM",
      "commitName": "df2991c0cbc3f35c2640b93680667507c4f810dd",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/10/11 11:40 PM",
      "commitNameOld": "e3bb120e9fefb21168edd7cd06f0cbfb92a5e02b",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.21,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,70 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n-        launchContext.getUser(), applicationID, credentials);\n+        this.aclsManager, launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n-          new ApplicationInitEvent(applicationID));\n+          new ApplicationInitEvent(applicationID, container\n+              .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        this.aclsManager, launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "e3bb120e9fefb21168edd7cd06f0cbfb92a5e02b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3162. Separated application-init and container-init event types in NodeManager\u0027s Application state machine. Contributed by Todd Lipcon.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1185988 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/10/11 11:40 PM",
      "commitName": "e3bb120e9fefb21168edd7cd06f0cbfb92a5e02b",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/10/11 9:45 PM",
      "commitNameOld": "11b9dd4e844c762f8c53e5fafa25f29eece1bc87",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 8.08,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,69 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n+      dispatcher.getEventHandler().handle(\n+          new ApplicationInitEvent(applicationID));\n     }\n \n     // TODO: Validate the request\n-    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n+    dispatcher.getEventHandler().handle(\n+        new ApplicationContainerInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "11b9dd4e844c762f8c53e5fafa25f29eece1bc87": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3161. Improved some javadocs and fixed some typos in YARN. Contributed by Todd Lipcon.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1181622 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/10/11 9:45 PM",
      "commitName": "11b9dd4e844c762f8c53e5fafa25f29eece1bc87",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "07/10/11 8:23 AM",
      "commitNameOld": "02a81203bd0ff6116e3c68d376b3af3838231986",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.56,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.addAllServiceResponse(auxiluaryServices.getMeta());\n+    response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "02a81203bd0ff6116e3c68d376b3af3838231986": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2751. Modified NodeManager to stop leaving around local files after application finishes. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1180071 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/10/11 8:23 AM",
      "commitName": "02a81203bd0ff6116e3c68d376b3af3838231986",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "05/10/11 4:43 AM",
      "commitNameOld": "66137cf17cb4abccd6065819d97edc63c6510477",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.15,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,66 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiluaryServices.getMeta());\n+    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n+    // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiluaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2896. Simplify all apis to in org.apache.hadoop.yarn.api.records.* to be get/set only. Added javadocs to all public records.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169980 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/09/11 5:05 PM",
      "commitName": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "12/09/11 12:11 AM",
      "commitNameOld": "6b2f2efe4de4e709a2b9c64b7b3b3138e1939668",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.7,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,64 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n-    ApplicationId applicationID \u003d containerID.getAppId();\n+    ApplicationId applicationID \u003d \n+        containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiluaryServices.getMeta());\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiluaryServices.getMeta());\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "cdfabf5ae289836968b3d296668593b9500b6f26": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2655. Add audit logs to ResourceManager and NodeManager. Contributed by Thomas Graves.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165949 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/11 6:24 PM",
      "commitName": "cdfabf5ae289836968b3d296668593b9500b6f26",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "31/08/11 4:38 AM",
      "commitNameOld": "ade0f0560f729e50382c6992f713f29e2dd5b270",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,63 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d containerID.getAppId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n+      NMAuditLogger.logFailure(launchContext.getUser(), \n+          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n+          \"Container already running on this node!\",\n+          applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n+\n+    NMAuditLogger.logSuccess(launchContext.getUser(), \n+        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n+        applicationID, containerID);\n+\n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiluaryServices.getMeta());\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d containerID.getAppId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiluaryServices.getMeta());\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "ade0f0560f729e50382c6992f713f29e2dd5b270": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2652. Enabled multiple NMs to be runnable on a single node by making shuffle service port to be truely configurable. Contributed by Robert Joseph Evans.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1163585 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/08/11 4:38 AM",
      "commitName": "ade0f0560f729e50382c6992f713f29e2dd5b270",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 6.48,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,54 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d containerID.getAppId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n+    response.addAllServiceResponse(auxiluaryServices.getMeta());\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d containerID.getAppId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiluaryServices.getMeta());\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d containerID.getAppId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,53 @@\n+  public StartContainerResponse startContainer(StartContainerRequest request)\n+      throws YarnRemoteException {\n+    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n+\n+    LOG.info(\" container is \" + request);\n+  \n+    // //////////// Parse credentials\n+    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n+    Credentials credentials \u003d new Credentials();\n+    if (tokens !\u003d null) {\n+      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n+      tokens.rewind();\n+      buf.reset(tokens);\n+      try {\n+        credentials.readTokenStorageStream(buf);\n+        if (LOG.isDebugEnabled()) {\n+          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n+              .getAllTokens()) {\n+            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n+          }\n+        }\n+      } catch (IOException e) {\n+        throw RPCUtil.getRemoteException(e);\n+      }\n+    }\n+    // //////////// End of parsing credentials\n+\n+    Container container \u003d\n+        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n+    ContainerId containerID \u003d launchContext.getContainerId();\n+    ApplicationId applicationID \u003d containerID.getAppId();\n+    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n+      throw RPCUtil.getRemoteException(\"Container \" + containerID\n+          + \" already is running on this node!!\");\n+    }\n+\n+    // Create the application\n+    Application application \u003d new ApplicationImpl(dispatcher,\n+        launchContext.getUser(), applicationID, credentials);\n+    if (null \u003d\u003d\n+        context.getApplications().putIfAbsent(applicationID, application)) {\n+      LOG.info(\"Creating a new application reference for app \"\n+          + applicationID);\n+    }\n+\n+    // TODO: Validate the request\n+    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n+    StartContainerResponse response \u003d\n+        recordFactory.newRecordInstance(StartContainerResponse.class);\n+    metrics.launchedContainer();\n+    metrics.allocateContainer(launchContext.getResource());\n+    return response;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d containerID.getAppId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java"
    }
  }
}