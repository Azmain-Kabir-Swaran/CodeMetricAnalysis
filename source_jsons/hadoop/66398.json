{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SLSCapacityScheduler.java",
  "functionName": "updateQueueWithAllocateRequest",
  "functionId": "updateQueueWithAllocateRequest___allocation-Allocation__attemptId-ApplicationAttemptId__resourceRequests-List__ResourceRequest____containerIds-List__ContainerId__",
  "sourceFilePath": "hadoop-tools/hadoop-sls/src/main/java/org/apache/hadoop/yarn/sls/scheduler/SLSCapacityScheduler.java",
  "functionStartLine": 278,
  "functionEndLine": 354,
  "numCommitsSeen": 21,
  "timeTaken": 1428,
  "changeHistory": [
    "6a5516c2381f107d96b8326939514de3c6e53d3d",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae",
    "e07f3c87cd3542760efcf713f909375b69eec00f"
  ],
  "changeHistoryShort": {
    "6a5516c2381f107d96b8326939514de3c6e53d3d": "Ybodychange",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": "Ybodychange",
    "e07f3c87cd3542760efcf713f909375b69eec00f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6a5516c2381f107d96b8326939514de3c6e53d3d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5654. Not be able to run SLS with FairScheduler (yufeigu via rkanter)\n",
      "commitDate": "29/03/17 4:18 PM",
      "commitName": "6a5516c2381f107d96b8326939514de3c6e53d3d",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "21/03/17 3:21 PM",
      "commitNameOld": "cc938e99ec0904824c8072184eff75619fcaf040",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 8.04,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,77 @@\n   private void updateQueueWithAllocateRequest(Allocation allocation,\n                         ApplicationAttemptId attemptId,\n                         List\u003cResourceRequest\u003e resourceRequests,\n                         List\u003cContainerId\u003e containerIds) throws IOException {\n     // update queue information\n     Resource pendingResource \u003d Resources.createResource(0, 0);\n     Resource allocatedResource \u003d Resources.createResource(0, 0);\n     String queueName \u003d appQueueMap.get(attemptId);\n     // container requested\n     for (ResourceRequest request : resourceRequests) {\n       if (request.getResourceName().equals(ResourceRequest.ANY)) {\n         Resources.addTo(pendingResource,\n                 Resources.multiply(request.getCapability(),\n                         request.getNumContainers()));\n       }\n     }\n     // container allocated\n     for (Container container : allocation.getContainers()) {\n       Resources.addTo(allocatedResource, container.getResource());\n       Resources.subtractFrom(pendingResource, container.getResource());\n     }\n     // container released from AM\n     SchedulerAppReport report \u003d super.getSchedulerAppInfo(attemptId);\n     for (ContainerId containerId : containerIds) {\n       Container container \u003d null;\n       for (RMContainer c : report.getLiveContainers()) {\n         if (c.getContainerId().equals(containerId)) {\n           container \u003d c.getContainer();\n           break;\n         }\n       }\n       if (container !\u003d null) {\n         // released allocated containers\n         Resources.subtractFrom(allocatedResource, container.getResource());\n       } else {\n         for (RMContainer c : report.getReservedContainers()) {\n           if (c.getContainerId().equals(containerId)) {\n             container \u003d c.getContainer();\n             break;\n           }\n         }\n         if (container !\u003d null) {\n           // released reserved containers\n           Resources.subtractFrom(pendingResource, container.getResource());\n         }\n       }\n     }\n     // containers released/preemption from scheduler\n     Set\u003cContainerId\u003e preemptionContainers \u003d new HashSet\u003cContainerId\u003e();\n     if (allocation.getContainerPreemptions() !\u003d null) {\n       preemptionContainers.addAll(allocation.getContainerPreemptions());\n     }\n     if (allocation.getStrictContainerPreemptions() !\u003d null) {\n       preemptionContainers.addAll(allocation.getStrictContainerPreemptions());\n     }\n     if (! preemptionContainers.isEmpty()) {\n       for (ContainerId containerId : preemptionContainers) {\n         if (! preemptionContainerMap.containsKey(containerId)) {\n           Container container \u003d null;\n           for (RMContainer c : report.getLiveContainers()) {\n             if (c.getContainerId().equals(containerId)) {\n               container \u003d c.getContainer();\n               break;\n             }\n           }\n           if (container !\u003d null) {\n             preemptionContainerMap.put(containerId, container.getResource());\n           }\n         }\n \n       }\n     }\n \n     // update metrics\n-    SortedMap\u003cString, Counter\u003e counterMap \u003d metrics.getCounters();\n-    String names[] \u003d new String[]{\n-            \"counter.queue.\" + queueName + \".pending.memory\",\n-            \"counter.queue.\" + queueName + \".pending.cores\",\n-            \"counter.queue.\" + queueName + \".allocated.memory\",\n-            \"counter.queue.\" + queueName + \".allocated.cores\"};\n-    long values[] \u003d new long[]{pendingResource.getMemorySize(),\n-            pendingResource.getVirtualCores(),\n-            allocatedResource.getMemorySize(), allocatedResource.getVirtualCores()};\n-    for (int i \u003d names.length - 1; i \u003e\u003d 0; i --) {\n-      if (! counterMap.containsKey(names[i])) {\n-        metrics.counter(names[i]);\n-        counterMap \u003d metrics.getCounters();\n-      }\n-      counterMap.get(names[i]).inc(values[i]);\n-    }\n-\n-    queueLock.lock();\n-    try {\n-      if (! schedulerMetrics.isTracked(queueName)) {\n-        schedulerMetrics.trackQueue(queueName);\n-      }\n-    } finally {\n-      queueLock.unlock();\n-    }\n+    schedulerMetrics.updateQueueMetrics(pendingResource, allocatedResource,\n+        queueName);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateQueueWithAllocateRequest(Allocation allocation,\n                        ApplicationAttemptId attemptId,\n                        List\u003cResourceRequest\u003e resourceRequests,\n                        List\u003cContainerId\u003e containerIds) throws IOException {\n    // update queue information\n    Resource pendingResource \u003d Resources.createResource(0, 0);\n    Resource allocatedResource \u003d Resources.createResource(0, 0);\n    String queueName \u003d appQueueMap.get(attemptId);\n    // container requested\n    for (ResourceRequest request : resourceRequests) {\n      if (request.getResourceName().equals(ResourceRequest.ANY)) {\n        Resources.addTo(pendingResource,\n                Resources.multiply(request.getCapability(),\n                        request.getNumContainers()));\n      }\n    }\n    // container allocated\n    for (Container container : allocation.getContainers()) {\n      Resources.addTo(allocatedResource, container.getResource());\n      Resources.subtractFrom(pendingResource, container.getResource());\n    }\n    // container released from AM\n    SchedulerAppReport report \u003d super.getSchedulerAppInfo(attemptId);\n    for (ContainerId containerId : containerIds) {\n      Container container \u003d null;\n      for (RMContainer c : report.getLiveContainers()) {\n        if (c.getContainerId().equals(containerId)) {\n          container \u003d c.getContainer();\n          break;\n        }\n      }\n      if (container !\u003d null) {\n        // released allocated containers\n        Resources.subtractFrom(allocatedResource, container.getResource());\n      } else {\n        for (RMContainer c : report.getReservedContainers()) {\n          if (c.getContainerId().equals(containerId)) {\n            container \u003d c.getContainer();\n            break;\n          }\n        }\n        if (container !\u003d null) {\n          // released reserved containers\n          Resources.subtractFrom(pendingResource, container.getResource());\n        }\n      }\n    }\n    // containers released/preemption from scheduler\n    Set\u003cContainerId\u003e preemptionContainers \u003d new HashSet\u003cContainerId\u003e();\n    if (allocation.getContainerPreemptions() !\u003d null) {\n      preemptionContainers.addAll(allocation.getContainerPreemptions());\n    }\n    if (allocation.getStrictContainerPreemptions() !\u003d null) {\n      preemptionContainers.addAll(allocation.getStrictContainerPreemptions());\n    }\n    if (! preemptionContainers.isEmpty()) {\n      for (ContainerId containerId : preemptionContainers) {\n        if (! preemptionContainerMap.containsKey(containerId)) {\n          Container container \u003d null;\n          for (RMContainer c : report.getLiveContainers()) {\n            if (c.getContainerId().equals(containerId)) {\n              container \u003d c.getContainer();\n              break;\n            }\n          }\n          if (container !\u003d null) {\n            preemptionContainerMap.put(containerId, container.getResource());\n          }\n        }\n\n      }\n    }\n\n    // update metrics\n    schedulerMetrics.updateQueueMetrics(pendingResource, allocatedResource,\n        queueName);\n  }",
      "path": "hadoop-tools/hadoop-sls/src/main/java/org/apache/hadoop/yarn/sls/scheduler/SLSCapacityScheduler.java",
      "extendedDetails": {}
    },
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4844. Add getMemorySize/getVirtualCoresSize to o.a.h.y.api.records.Resource. Contributed by Wangda Tan.\n",
      "commitDate": "29/05/16 8:54 AM",
      "commitName": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "23/09/15 1:29 PM",
      "commitNameOld": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 248.81,
      "commitsBetweenForRepo": 1666,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,100 @@\n   private void updateQueueWithAllocateRequest(Allocation allocation,\n                         ApplicationAttemptId attemptId,\n                         List\u003cResourceRequest\u003e resourceRequests,\n                         List\u003cContainerId\u003e containerIds) throws IOException {\n     // update queue information\n     Resource pendingResource \u003d Resources.createResource(0, 0);\n     Resource allocatedResource \u003d Resources.createResource(0, 0);\n     String queueName \u003d appQueueMap.get(attemptId);\n     // container requested\n     for (ResourceRequest request : resourceRequests) {\n       if (request.getResourceName().equals(ResourceRequest.ANY)) {\n         Resources.addTo(pendingResource,\n                 Resources.multiply(request.getCapability(),\n                         request.getNumContainers()));\n       }\n     }\n     // container allocated\n     for (Container container : allocation.getContainers()) {\n       Resources.addTo(allocatedResource, container.getResource());\n       Resources.subtractFrom(pendingResource, container.getResource());\n     }\n     // container released from AM\n     SchedulerAppReport report \u003d super.getSchedulerAppInfo(attemptId);\n     for (ContainerId containerId : containerIds) {\n       Container container \u003d null;\n       for (RMContainer c : report.getLiveContainers()) {\n         if (c.getContainerId().equals(containerId)) {\n           container \u003d c.getContainer();\n           break;\n         }\n       }\n       if (container !\u003d null) {\n         // released allocated containers\n         Resources.subtractFrom(allocatedResource, container.getResource());\n       } else {\n         for (RMContainer c : report.getReservedContainers()) {\n           if (c.getContainerId().equals(containerId)) {\n             container \u003d c.getContainer();\n             break;\n           }\n         }\n         if (container !\u003d null) {\n           // released reserved containers\n           Resources.subtractFrom(pendingResource, container.getResource());\n         }\n       }\n     }\n     // containers released/preemption from scheduler\n     Set\u003cContainerId\u003e preemptionContainers \u003d new HashSet\u003cContainerId\u003e();\n     if (allocation.getContainerPreemptions() !\u003d null) {\n       preemptionContainers.addAll(allocation.getContainerPreemptions());\n     }\n     if (allocation.getStrictContainerPreemptions() !\u003d null) {\n       preemptionContainers.addAll(allocation.getStrictContainerPreemptions());\n     }\n     if (! preemptionContainers.isEmpty()) {\n       for (ContainerId containerId : preemptionContainers) {\n         if (! preemptionContainerMap.containsKey(containerId)) {\n           Container container \u003d null;\n           for (RMContainer c : report.getLiveContainers()) {\n             if (c.getContainerId().equals(containerId)) {\n               container \u003d c.getContainer();\n               break;\n             }\n           }\n           if (container !\u003d null) {\n             preemptionContainerMap.put(containerId, container.getResource());\n           }\n         }\n \n       }\n     }\n \n     // update metrics\n     SortedMap\u003cString, Counter\u003e counterMap \u003d metrics.getCounters();\n     String names[] \u003d new String[]{\n             \"counter.queue.\" + queueName + \".pending.memory\",\n             \"counter.queue.\" + queueName + \".pending.cores\",\n             \"counter.queue.\" + queueName + \".allocated.memory\",\n             \"counter.queue.\" + queueName + \".allocated.cores\"};\n-    int values[] \u003d new int[]{pendingResource.getMemory(),\n+    long values[] \u003d new long[]{pendingResource.getMemorySize(),\n             pendingResource.getVirtualCores(),\n-            allocatedResource.getMemory(), allocatedResource.getVirtualCores()};\n+            allocatedResource.getMemorySize(), allocatedResource.getVirtualCores()};\n     for (int i \u003d names.length - 1; i \u003e\u003d 0; i --) {\n       if (! counterMap.containsKey(names[i])) {\n         metrics.counter(names[i]);\n         counterMap \u003d metrics.getCounters();\n       }\n       counterMap.get(names[i]).inc(values[i]);\n     }\n \n     queueLock.lock();\n     try {\n       if (! schedulerMetrics.isTracked(queueName)) {\n         schedulerMetrics.trackQueue(queueName);\n       }\n     } finally {\n       queueLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateQueueWithAllocateRequest(Allocation allocation,\n                        ApplicationAttemptId attemptId,\n                        List\u003cResourceRequest\u003e resourceRequests,\n                        List\u003cContainerId\u003e containerIds) throws IOException {\n    // update queue information\n    Resource pendingResource \u003d Resources.createResource(0, 0);\n    Resource allocatedResource \u003d Resources.createResource(0, 0);\n    String queueName \u003d appQueueMap.get(attemptId);\n    // container requested\n    for (ResourceRequest request : resourceRequests) {\n      if (request.getResourceName().equals(ResourceRequest.ANY)) {\n        Resources.addTo(pendingResource,\n                Resources.multiply(request.getCapability(),\n                        request.getNumContainers()));\n      }\n    }\n    // container allocated\n    for (Container container : allocation.getContainers()) {\n      Resources.addTo(allocatedResource, container.getResource());\n      Resources.subtractFrom(pendingResource, container.getResource());\n    }\n    // container released from AM\n    SchedulerAppReport report \u003d super.getSchedulerAppInfo(attemptId);\n    for (ContainerId containerId : containerIds) {\n      Container container \u003d null;\n      for (RMContainer c : report.getLiveContainers()) {\n        if (c.getContainerId().equals(containerId)) {\n          container \u003d c.getContainer();\n          break;\n        }\n      }\n      if (container !\u003d null) {\n        // released allocated containers\n        Resources.subtractFrom(allocatedResource, container.getResource());\n      } else {\n        for (RMContainer c : report.getReservedContainers()) {\n          if (c.getContainerId().equals(containerId)) {\n            container \u003d c.getContainer();\n            break;\n          }\n        }\n        if (container !\u003d null) {\n          // released reserved containers\n          Resources.subtractFrom(pendingResource, container.getResource());\n        }\n      }\n    }\n    // containers released/preemption from scheduler\n    Set\u003cContainerId\u003e preemptionContainers \u003d new HashSet\u003cContainerId\u003e();\n    if (allocation.getContainerPreemptions() !\u003d null) {\n      preemptionContainers.addAll(allocation.getContainerPreemptions());\n    }\n    if (allocation.getStrictContainerPreemptions() !\u003d null) {\n      preemptionContainers.addAll(allocation.getStrictContainerPreemptions());\n    }\n    if (! preemptionContainers.isEmpty()) {\n      for (ContainerId containerId : preemptionContainers) {\n        if (! preemptionContainerMap.containsKey(containerId)) {\n          Container container \u003d null;\n          for (RMContainer c : report.getLiveContainers()) {\n            if (c.getContainerId().equals(containerId)) {\n              container \u003d c.getContainer();\n              break;\n            }\n          }\n          if (container !\u003d null) {\n            preemptionContainerMap.put(containerId, container.getResource());\n          }\n        }\n\n      }\n    }\n\n    // update metrics\n    SortedMap\u003cString, Counter\u003e counterMap \u003d metrics.getCounters();\n    String names[] \u003d new String[]{\n            \"counter.queue.\" + queueName + \".pending.memory\",\n            \"counter.queue.\" + queueName + \".pending.cores\",\n            \"counter.queue.\" + queueName + \".allocated.memory\",\n            \"counter.queue.\" + queueName + \".allocated.cores\"};\n    long values[] \u003d new long[]{pendingResource.getMemorySize(),\n            pendingResource.getVirtualCores(),\n            allocatedResource.getMemorySize(), allocatedResource.getVirtualCores()};\n    for (int i \u003d names.length - 1; i \u003e\u003d 0; i --) {\n      if (! counterMap.containsKey(names[i])) {\n        metrics.counter(names[i]);\n        counterMap \u003d metrics.getCounters();\n      }\n      counterMap.get(names[i]).inc(values[i]);\n    }\n\n    queueLock.lock();\n    try {\n      if (! schedulerMetrics.isTracked(queueName)) {\n        schedulerMetrics.trackQueue(queueName);\n      }\n    } finally {\n      queueLock.unlock();\n    }\n  }",
      "path": "hadoop-tools/hadoop-sls/src/main/java/org/apache/hadoop/yarn/sls/scheduler/SLSCapacityScheduler.java",
      "extendedDetails": {}
    },
    "e07f3c87cd3542760efcf713f909375b69eec00f": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1471. Preserve scheduler typeinfo in simulator to work with resource monitors.\nContributed by Carlo Curino.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1552173 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/12/13 4:07 PM",
      "commitName": "e07f3c87cd3542760efcf713f909375b69eec00f",
      "commitAuthor": "Christopher Douglas",
      "diff": "@@ -0,0 +1,100 @@\n+  private void updateQueueWithAllocateRequest(Allocation allocation,\n+                        ApplicationAttemptId attemptId,\n+                        List\u003cResourceRequest\u003e resourceRequests,\n+                        List\u003cContainerId\u003e containerIds) throws IOException {\n+    // update queue information\n+    Resource pendingResource \u003d Resources.createResource(0, 0);\n+    Resource allocatedResource \u003d Resources.createResource(0, 0);\n+    String queueName \u003d appQueueMap.get(attemptId);\n+    // container requested\n+    for (ResourceRequest request : resourceRequests) {\n+      if (request.getResourceName().equals(ResourceRequest.ANY)) {\n+        Resources.addTo(pendingResource,\n+                Resources.multiply(request.getCapability(),\n+                        request.getNumContainers()));\n+      }\n+    }\n+    // container allocated\n+    for (Container container : allocation.getContainers()) {\n+      Resources.addTo(allocatedResource, container.getResource());\n+      Resources.subtractFrom(pendingResource, container.getResource());\n+    }\n+    // container released from AM\n+    SchedulerAppReport report \u003d super.getSchedulerAppInfo(attemptId);\n+    for (ContainerId containerId : containerIds) {\n+      Container container \u003d null;\n+      for (RMContainer c : report.getLiveContainers()) {\n+        if (c.getContainerId().equals(containerId)) {\n+          container \u003d c.getContainer();\n+          break;\n+        }\n+      }\n+      if (container !\u003d null) {\n+        // released allocated containers\n+        Resources.subtractFrom(allocatedResource, container.getResource());\n+      } else {\n+        for (RMContainer c : report.getReservedContainers()) {\n+          if (c.getContainerId().equals(containerId)) {\n+            container \u003d c.getContainer();\n+            break;\n+          }\n+        }\n+        if (container !\u003d null) {\n+          // released reserved containers\n+          Resources.subtractFrom(pendingResource, container.getResource());\n+        }\n+      }\n+    }\n+    // containers released/preemption from scheduler\n+    Set\u003cContainerId\u003e preemptionContainers \u003d new HashSet\u003cContainerId\u003e();\n+    if (allocation.getContainerPreemptions() !\u003d null) {\n+      preemptionContainers.addAll(allocation.getContainerPreemptions());\n+    }\n+    if (allocation.getStrictContainerPreemptions() !\u003d null) {\n+      preemptionContainers.addAll(allocation.getStrictContainerPreemptions());\n+    }\n+    if (! preemptionContainers.isEmpty()) {\n+      for (ContainerId containerId : preemptionContainers) {\n+        if (! preemptionContainerMap.containsKey(containerId)) {\n+          Container container \u003d null;\n+          for (RMContainer c : report.getLiveContainers()) {\n+            if (c.getContainerId().equals(containerId)) {\n+              container \u003d c.getContainer();\n+              break;\n+            }\n+          }\n+          if (container !\u003d null) {\n+            preemptionContainerMap.put(containerId, container.getResource());\n+          }\n+        }\n+\n+      }\n+    }\n+\n+    // update metrics\n+    SortedMap\u003cString, Counter\u003e counterMap \u003d metrics.getCounters();\n+    String names[] \u003d new String[]{\n+            \"counter.queue.\" + queueName + \".pending.memory\",\n+            \"counter.queue.\" + queueName + \".pending.cores\",\n+            \"counter.queue.\" + queueName + \".allocated.memory\",\n+            \"counter.queue.\" + queueName + \".allocated.cores\"};\n+    int values[] \u003d new int[]{pendingResource.getMemory(),\n+            pendingResource.getVirtualCores(),\n+            allocatedResource.getMemory(), allocatedResource.getVirtualCores()};\n+    for (int i \u003d names.length - 1; i \u003e\u003d 0; i --) {\n+      if (! counterMap.containsKey(names[i])) {\n+        metrics.counter(names[i]);\n+        counterMap \u003d metrics.getCounters();\n+      }\n+      counterMap.get(names[i]).inc(values[i]);\n+    }\n+\n+    queueLock.lock();\n+    try {\n+      if (! schedulerMetrics.isTracked(queueName)) {\n+        schedulerMetrics.trackQueue(queueName);\n+      }\n+    } finally {\n+      queueLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateQueueWithAllocateRequest(Allocation allocation,\n                        ApplicationAttemptId attemptId,\n                        List\u003cResourceRequest\u003e resourceRequests,\n                        List\u003cContainerId\u003e containerIds) throws IOException {\n    // update queue information\n    Resource pendingResource \u003d Resources.createResource(0, 0);\n    Resource allocatedResource \u003d Resources.createResource(0, 0);\n    String queueName \u003d appQueueMap.get(attemptId);\n    // container requested\n    for (ResourceRequest request : resourceRequests) {\n      if (request.getResourceName().equals(ResourceRequest.ANY)) {\n        Resources.addTo(pendingResource,\n                Resources.multiply(request.getCapability(),\n                        request.getNumContainers()));\n      }\n    }\n    // container allocated\n    for (Container container : allocation.getContainers()) {\n      Resources.addTo(allocatedResource, container.getResource());\n      Resources.subtractFrom(pendingResource, container.getResource());\n    }\n    // container released from AM\n    SchedulerAppReport report \u003d super.getSchedulerAppInfo(attemptId);\n    for (ContainerId containerId : containerIds) {\n      Container container \u003d null;\n      for (RMContainer c : report.getLiveContainers()) {\n        if (c.getContainerId().equals(containerId)) {\n          container \u003d c.getContainer();\n          break;\n        }\n      }\n      if (container !\u003d null) {\n        // released allocated containers\n        Resources.subtractFrom(allocatedResource, container.getResource());\n      } else {\n        for (RMContainer c : report.getReservedContainers()) {\n          if (c.getContainerId().equals(containerId)) {\n            container \u003d c.getContainer();\n            break;\n          }\n        }\n        if (container !\u003d null) {\n          // released reserved containers\n          Resources.subtractFrom(pendingResource, container.getResource());\n        }\n      }\n    }\n    // containers released/preemption from scheduler\n    Set\u003cContainerId\u003e preemptionContainers \u003d new HashSet\u003cContainerId\u003e();\n    if (allocation.getContainerPreemptions() !\u003d null) {\n      preemptionContainers.addAll(allocation.getContainerPreemptions());\n    }\n    if (allocation.getStrictContainerPreemptions() !\u003d null) {\n      preemptionContainers.addAll(allocation.getStrictContainerPreemptions());\n    }\n    if (! preemptionContainers.isEmpty()) {\n      for (ContainerId containerId : preemptionContainers) {\n        if (! preemptionContainerMap.containsKey(containerId)) {\n          Container container \u003d null;\n          for (RMContainer c : report.getLiveContainers()) {\n            if (c.getContainerId().equals(containerId)) {\n              container \u003d c.getContainer();\n              break;\n            }\n          }\n          if (container !\u003d null) {\n            preemptionContainerMap.put(containerId, container.getResource());\n          }\n        }\n\n      }\n    }\n\n    // update metrics\n    SortedMap\u003cString, Counter\u003e counterMap \u003d metrics.getCounters();\n    String names[] \u003d new String[]{\n            \"counter.queue.\" + queueName + \".pending.memory\",\n            \"counter.queue.\" + queueName + \".pending.cores\",\n            \"counter.queue.\" + queueName + \".allocated.memory\",\n            \"counter.queue.\" + queueName + \".allocated.cores\"};\n    int values[] \u003d new int[]{pendingResource.getMemory(),\n            pendingResource.getVirtualCores(),\n            allocatedResource.getMemory(), allocatedResource.getVirtualCores()};\n    for (int i \u003d names.length - 1; i \u003e\u003d 0; i --) {\n      if (! counterMap.containsKey(names[i])) {\n        metrics.counter(names[i]);\n        counterMap \u003d metrics.getCounters();\n      }\n      counterMap.get(names[i]).inc(values[i]);\n    }\n\n    queueLock.lock();\n    try {\n      if (! schedulerMetrics.isTracked(queueName)) {\n        schedulerMetrics.trackQueue(queueName);\n      }\n    } finally {\n      queueLock.unlock();\n    }\n  }",
      "path": "hadoop-tools/hadoop-sls/src/main/java/org/apache/hadoop/yarn/sls/scheduler/SLSCapacityScheduler.java"
    }
  }
}