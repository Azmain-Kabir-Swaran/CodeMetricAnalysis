{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RollingLevelDBTimelineStore.java",
  "functionName": "putEntities",
  "functionId": "putEntities___entityUpdates-TreeMap__Long,RollingWriteBatch____indexUpdates-TreeMap__Long,RollingWriteBatch____entity-TimelineEntity__response-TimelinePutResponse",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
  "functionStartLine": 852,
  "functionEndLine": 1142,
  "numCommitsSeen": 12,
  "timeTaken": 966,
  "changeHistory": [
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f"
  ],
  "changeHistoryShort": {
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3448. Added a rolling time-to-live LevelDB timeline store implementation. Contributed by Jonathan Eagles.\n",
      "commitDate": "07/05/15 10:01 AM",
      "commitName": "daf3e4ef8bf73cbe4a799d51b4765809cd81089f",
      "commitAuthor": "Zhijie Shen",
      "diff": "@@ -0,0 +1,291 @@\n+  private long putEntities(TreeMap\u003cLong, RollingWriteBatch\u003e entityUpdates,\n+      TreeMap\u003cLong, RollingWriteBatch\u003e indexUpdates, TimelineEntity entity,\n+      TimelinePutResponse response) {\n+\n+    long putCount \u003d 0;\n+    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n+        new ArrayList\u003cEntityIdentifier\u003e();\n+    byte[] revStartTime \u003d null;\n+    Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n+    try {\n+      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n+      // look up the start time for the entity\n+      Long startTime \u003d getAndSetStartTime(entity.getEntityId(),\n+          entity.getEntityType(), entity.getStartTime(), events);\n+      if (startTime \u003d\u003d null) {\n+        // if no start time is found, add an error and return\n+        TimelinePutError error \u003d new TimelinePutError();\n+        error.setEntityId(entity.getEntityId());\n+        error.setEntityType(entity.getEntityType());\n+        error.setErrorCode(TimelinePutError.NO_START_TIME);\n+        response.addError(error);\n+        return putCount;\n+      }\n+\n+      // Must have a domain\n+      if (StringUtils.isEmpty(entity.getDomainId())) {\n+        TimelinePutError error \u003d new TimelinePutError();\n+        error.setEntityId(entity.getEntityId());\n+        error.setEntityType(entity.getEntityType());\n+        error.setErrorCode(TimelinePutError.NO_DOMAIN);\n+        response.addError(error);\n+        return putCount;\n+      }\n+\n+      revStartTime \u003d writeReverseOrderedLong(startTime);\n+      long roundedStartTime \u003d entitydb.computeCurrentCheckMillis(startTime);\n+      RollingWriteBatch rollingWriteBatch \u003d entityUpdates.get(roundedStartTime);\n+      if (rollingWriteBatch \u003d\u003d null) {\n+        DB db \u003d entitydb.getDBForStartTime(startTime);\n+        if (db !\u003d null) {\n+          WriteBatch writeBatch \u003d db.createWriteBatch();\n+          rollingWriteBatch \u003d new RollingWriteBatch(db, writeBatch);\n+          entityUpdates.put(roundedStartTime, rollingWriteBatch);\n+        }\n+      }\n+      if (rollingWriteBatch \u003d\u003d null) {\n+        // if no start time is found, add an error and return\n+        TimelinePutError error \u003d new TimelinePutError();\n+        error.setEntityId(entity.getEntityId());\n+        error.setEntityType(entity.getEntityType());\n+        error.setErrorCode(TimelinePutError.EXPIRED_ENTITY);\n+        response.addError(error);\n+        return putCount;\n+      }\n+      WriteBatch writeBatch \u003d rollingWriteBatch.getWriteBatch();\n+\n+      // Save off the getBytes conversion to avoid unnecessary cost\n+      byte[] entityIdBytes \u003d entity.getEntityId().getBytes(UTF_8);\n+      byte[] entityTypeBytes \u003d entity.getEntityType().getBytes(UTF_8);\n+      byte[] domainIdBytes \u003d entity.getDomainId().getBytes(UTF_8);\n+\n+      // write entity marker\n+      byte[] markerKey \u003d KeyBuilder.newInstance(3).add(entityTypeBytes, true)\n+          .add(revStartTime).add(entityIdBytes, true).getBytesForLookup();\n+      writeBatch.put(markerKey, EMPTY_BYTES);\n+      ++putCount;\n+\n+      // write domain id entry\n+      byte[] domainkey \u003d KeyBuilder.newInstance(4).add(entityTypeBytes, true)\n+          .add(revStartTime).add(entityIdBytes, true).add(DOMAIN_ID_COLUMN)\n+          .getBytes();\n+      writeBatch.put(domainkey, domainIdBytes);\n+      ++putCount;\n+\n+      // write event entries\n+      if (events !\u003d null) {\n+        for (TimelineEvent event : events) {\n+          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n+          byte[] key \u003d KeyBuilder.newInstance().add(entityTypeBytes, true)\n+              .add(revStartTime).add(entityIdBytes, true).add(EVENTS_COLUMN)\n+              .add(revts).add(event.getEventType().getBytes(UTF_8)).getBytes();\n+          byte[] value \u003d fstConf.asByteArray(event.getEventInfo());\n+          writeBatch.put(key, value);\n+          ++putCount;\n+        }\n+      }\n+\n+      // write primary filter entries\n+      primaryFilters \u003d entity.getPrimaryFilters();\n+      if (primaryFilters !\u003d null) {\n+        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter : primaryFilters\n+            .entrySet()) {\n+          for (Object primaryFilterValue : primaryFilter.getValue()) {\n+            byte[] key \u003d KeyBuilder.newInstance(6).add(entityTypeBytes, true)\n+                .add(revStartTime).add(entityIdBytes, true)\n+                .add(PRIMARY_FILTERS_COLUMN).add(primaryFilter.getKey())\n+                .add(fstConf.asByteArray(primaryFilterValue)).getBytes();\n+            writeBatch.put(key, EMPTY_BYTES);\n+            ++putCount;\n+          }\n+        }\n+      }\n+\n+      // write other info entries\n+      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n+      if (otherInfo !\u003d null) {\n+        for (Entry\u003cString, Object\u003e info : otherInfo.entrySet()) {\n+          byte[] key \u003d KeyBuilder.newInstance(5).add(entityTypeBytes, true)\n+              .add(revStartTime).add(entityIdBytes, true)\n+              .add(OTHER_INFO_COLUMN).add(info.getKey()).getBytes();\n+          byte[] value \u003d fstConf.asByteArray(info.getValue());\n+          writeBatch.put(key, value);\n+          ++putCount;\n+        }\n+      }\n+\n+      // write related entity entries\n+      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d entity.getRelatedEntities();\n+      if (relatedEntities !\u003d null) {\n+        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList : relatedEntities\n+            .entrySet()) {\n+          String relatedEntityType \u003d relatedEntityList.getKey();\n+          for (String relatedEntityId : relatedEntityList.getValue()) {\n+            // look up start time of related entity\n+            Long relatedStartTimeLong \u003d getStartTimeLong(relatedEntityId,\n+                relatedEntityType);\n+            // delay writing the related entity if no start time is found\n+            if (relatedStartTimeLong \u003d\u003d null) {\n+              relatedEntitiesWithoutStartTimes.add(new EntityIdentifier(\n+                  relatedEntityId, relatedEntityType));\n+              continue;\n+            }\n+\n+            byte[] relatedEntityStartTime \u003d\n+                writeReverseOrderedLong(relatedStartTimeLong);\n+            long relatedRoundedStartTime \u003d entitydb\n+                .computeCurrentCheckMillis(relatedStartTimeLong);\n+            RollingWriteBatch relatedRollingWriteBatch \u003d entityUpdates\n+                .get(relatedRoundedStartTime);\n+            if (relatedRollingWriteBatch \u003d\u003d null) {\n+              DB db \u003d entitydb.getDBForStartTime(relatedStartTimeLong);\n+              if (db !\u003d null) {\n+                WriteBatch relatedWriteBatch \u003d db.createWriteBatch();\n+                relatedRollingWriteBatch \u003d new RollingWriteBatch(db,\n+                    relatedWriteBatch);\n+                entityUpdates.put(relatedRoundedStartTime,\n+                    relatedRollingWriteBatch);\n+              }\n+            }\n+            if (relatedRollingWriteBatch \u003d\u003d null) {\n+              // if no start time is found, add an error and return\n+              TimelinePutError error \u003d new TimelinePutError();\n+              error.setEntityId(entity.getEntityId());\n+              error.setEntityType(entity.getEntityType());\n+              error.setErrorCode(TimelinePutError.EXPIRED_ENTITY);\n+              response.addError(error);\n+              continue;\n+            }\n+            // This is the existing entity\n+            byte[] relatedDomainIdBytes \u003d relatedRollingWriteBatch.getDB().get(\n+                createDomainIdKey(relatedEntityId, relatedEntityType,\n+                    relatedEntityStartTime));\n+            // The timeline data created by the server before 2.6 won\u0027t have\n+            // the domain field. We assume this timeline data is in the\n+            // default timeline domain.\n+            String domainId \u003d null;\n+            if (relatedDomainIdBytes \u003d\u003d null) {\n+              domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n+            } else {\n+              domainId \u003d new String(relatedDomainIdBytes, UTF_8);\n+            }\n+            if (!domainId.equals(entity.getDomainId())) {\n+              // in this case the entity will be put, but the relation will be\n+              // ignored\n+              TimelinePutError error \u003d new TimelinePutError();\n+              error.setEntityId(entity.getEntityId());\n+              error.setEntityType(entity.getEntityType());\n+              error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n+              response.addError(error);\n+              continue;\n+            }\n+            // write \"forward\" entry (related entity -\u003e entity)\n+            byte[] key \u003d createRelatedEntityKey(relatedEntityId,\n+                relatedEntityType, relatedEntityStartTime,\n+                entity.getEntityId(), entity.getEntityType());\n+            WriteBatch relatedWriteBatch \u003d relatedRollingWriteBatch\n+                .getWriteBatch();\n+            relatedWriteBatch.put(key, EMPTY_BYTES);\n+            ++putCount;\n+          }\n+        }\n+      }\n+\n+      // write index entities\n+      RollingWriteBatch indexRollingWriteBatch \u003d indexUpdates\n+          .get(roundedStartTime);\n+      if (indexRollingWriteBatch \u003d\u003d null) {\n+        DB db \u003d indexdb.getDBForStartTime(startTime);\n+        if (db !\u003d null) {\n+          WriteBatch indexWriteBatch \u003d db.createWriteBatch();\n+          indexRollingWriteBatch \u003d new RollingWriteBatch(db, indexWriteBatch);\n+          indexUpdates.put(roundedStartTime, indexRollingWriteBatch);\n+        }\n+      }\n+      if (indexRollingWriteBatch \u003d\u003d null) {\n+        // if no start time is found, add an error and return\n+        TimelinePutError error \u003d new TimelinePutError();\n+        error.setEntityId(entity.getEntityId());\n+        error.setEntityType(entity.getEntityType());\n+        error.setErrorCode(TimelinePutError.EXPIRED_ENTITY);\n+        response.addError(error);\n+        return putCount;\n+      }\n+      WriteBatch indexWriteBatch \u003d indexRollingWriteBatch.getWriteBatch();\n+      putCount +\u003d writePrimaryFilterEntries(indexWriteBatch, primaryFilters,\n+          markerKey, EMPTY_BYTES);\n+    } catch (IOException e) {\n+      LOG.error(\"Error putting entity \" + entity.getEntityId() + \" of type \"\n+          + entity.getEntityType(), e);\n+      TimelinePutError error \u003d new TimelinePutError();\n+      error.setEntityId(entity.getEntityId());\n+      error.setEntityType(entity.getEntityType());\n+      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n+      response.addError(error);\n+    }\n+\n+    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n+      try {\n+        Long relatedEntityStartAndInsertTime \u003d getAndSetStartTime(\n+            relatedEntity.getId(), relatedEntity.getType(),\n+            readReverseOrderedLong(revStartTime, 0), null);\n+        if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n+          throw new IOException(\"Error setting start time for related entity\");\n+        }\n+        long relatedStartTimeLong \u003d relatedEntityStartAndInsertTime;\n+        long relatedRoundedStartTime \u003d entitydb\n+            .computeCurrentCheckMillis(relatedStartTimeLong);\n+        RollingWriteBatch relatedRollingWriteBatch \u003d entityUpdates\n+            .get(relatedRoundedStartTime);\n+        if (relatedRollingWriteBatch \u003d\u003d null) {\n+          DB db \u003d entitydb.getDBForStartTime(relatedStartTimeLong);\n+          if (db !\u003d null) {\n+            WriteBatch relatedWriteBatch \u003d db.createWriteBatch();\n+            relatedRollingWriteBatch \u003d new RollingWriteBatch(db,\n+                relatedWriteBatch);\n+            entityUpdates\n+                .put(relatedRoundedStartTime, relatedRollingWriteBatch);\n+          }\n+        }\n+        if (relatedRollingWriteBatch \u003d\u003d null) {\n+          // if no start time is found, add an error and return\n+          TimelinePutError error \u003d new TimelinePutError();\n+          error.setEntityId(entity.getEntityId());\n+          error.setEntityType(entity.getEntityType());\n+          error.setErrorCode(TimelinePutError.EXPIRED_ENTITY);\n+          response.addError(error);\n+          continue;\n+        }\n+        WriteBatch relatedWriteBatch \u003d relatedRollingWriteBatch.getWriteBatch();\n+        byte[] relatedEntityStartTime \u003d\n+            writeReverseOrderedLong(relatedEntityStartAndInsertTime);\n+        // This is the new entity, the domain should be the same\n+        byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n+            relatedEntity.getType(), relatedEntityStartTime);\n+        relatedWriteBatch.put(key, entity.getDomainId().getBytes(UTF_8));\n+        ++putCount;\n+        relatedWriteBatch.put(\n+            createRelatedEntityKey(relatedEntity.getId(),\n+                relatedEntity.getType(), relatedEntityStartTime,\n+                entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n+        ++putCount;\n+        relatedWriteBatch.put(\n+            createEntityMarkerKey(relatedEntity.getId(),\n+                relatedEntity.getType(), relatedEntityStartTime), EMPTY_BYTES);\n+        ++putCount;\n+      } catch (IOException e) {\n+        LOG.error(\n+            \"Error putting related entity \" + relatedEntity.getId()\n+                + \" of type \" + relatedEntity.getType() + \" for entity \"\n+                + entity.getEntityId() + \" of type \" + entity.getEntityType(),\n+            e);\n+        TimelinePutError error \u003d new TimelinePutError();\n+        error.setEntityId(entity.getEntityId());\n+        error.setEntityType(entity.getEntityType());\n+        error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n+        response.addError(error);\n+      }\n+    }\n+\n+    return putCount;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private long putEntities(TreeMap\u003cLong, RollingWriteBatch\u003e entityUpdates,\n      TreeMap\u003cLong, RollingWriteBatch\u003e indexUpdates, TimelineEntity entity,\n      TimelinePutResponse response) {\n\n    long putCount \u003d 0;\n    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n        new ArrayList\u003cEntityIdentifier\u003e();\n    byte[] revStartTime \u003d null;\n    Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n    try {\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      Long startTime \u003d getAndSetStartTime(entity.getEntityId(),\n          entity.getEntityType(), entity.getStartTime(), events);\n      if (startTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_START_TIME);\n        response.addError(error);\n        return putCount;\n      }\n\n      // Must have a domain\n      if (StringUtils.isEmpty(entity.getDomainId())) {\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_DOMAIN);\n        response.addError(error);\n        return putCount;\n      }\n\n      revStartTime \u003d writeReverseOrderedLong(startTime);\n      long roundedStartTime \u003d entitydb.computeCurrentCheckMillis(startTime);\n      RollingWriteBatch rollingWriteBatch \u003d entityUpdates.get(roundedStartTime);\n      if (rollingWriteBatch \u003d\u003d null) {\n        DB db \u003d entitydb.getDBForStartTime(startTime);\n        if (db !\u003d null) {\n          WriteBatch writeBatch \u003d db.createWriteBatch();\n          rollingWriteBatch \u003d new RollingWriteBatch(db, writeBatch);\n          entityUpdates.put(roundedStartTime, rollingWriteBatch);\n        }\n      }\n      if (rollingWriteBatch \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.EXPIRED_ENTITY);\n        response.addError(error);\n        return putCount;\n      }\n      WriteBatch writeBatch \u003d rollingWriteBatch.getWriteBatch();\n\n      // Save off the getBytes conversion to avoid unnecessary cost\n      byte[] entityIdBytes \u003d entity.getEntityId().getBytes(UTF_8);\n      byte[] entityTypeBytes \u003d entity.getEntityType().getBytes(UTF_8);\n      byte[] domainIdBytes \u003d entity.getDomainId().getBytes(UTF_8);\n\n      // write entity marker\n      byte[] markerKey \u003d KeyBuilder.newInstance(3).add(entityTypeBytes, true)\n          .add(revStartTime).add(entityIdBytes, true).getBytesForLookup();\n      writeBatch.put(markerKey, EMPTY_BYTES);\n      ++putCount;\n\n      // write domain id entry\n      byte[] domainkey \u003d KeyBuilder.newInstance(4).add(entityTypeBytes, true)\n          .add(revStartTime).add(entityIdBytes, true).add(DOMAIN_ID_COLUMN)\n          .getBytes();\n      writeBatch.put(domainkey, domainIdBytes);\n      ++putCount;\n\n      // write event entries\n      if (events !\u003d null) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d KeyBuilder.newInstance().add(entityTypeBytes, true)\n              .add(revStartTime).add(entityIdBytes, true).add(EVENTS_COLUMN)\n              .add(revts).add(event.getEventType().getBytes(UTF_8)).getBytes();\n          byte[] value \u003d fstConf.asByteArray(event.getEventInfo());\n          writeBatch.put(key, value);\n          ++putCount;\n        }\n      }\n\n      // write primary filter entries\n      primaryFilters \u003d entity.getPrimaryFilters();\n      if (primaryFilters !\u003d null) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter : primaryFilters\n            .entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d KeyBuilder.newInstance(6).add(entityTypeBytes, true)\n                .add(revStartTime).add(entityIdBytes, true)\n                .add(PRIMARY_FILTERS_COLUMN).add(primaryFilter.getKey())\n                .add(fstConf.asByteArray(primaryFilterValue)).getBytes();\n            writeBatch.put(key, EMPTY_BYTES);\n            ++putCount;\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null) {\n        for (Entry\u003cString, Object\u003e info : otherInfo.entrySet()) {\n          byte[] key \u003d KeyBuilder.newInstance(5).add(entityTypeBytes, true)\n              .add(revStartTime).add(entityIdBytes, true)\n              .add(OTHER_INFO_COLUMN).add(info.getKey()).getBytes();\n          byte[] value \u003d fstConf.asByteArray(info.getValue());\n          writeBatch.put(key, value);\n          ++putCount;\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d entity.getRelatedEntities();\n      if (relatedEntities !\u003d null) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList : relatedEntities\n            .entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // look up start time of related entity\n            Long relatedStartTimeLong \u003d getStartTimeLong(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedStartTimeLong \u003d\u003d null) {\n              relatedEntitiesWithoutStartTimes.add(new EntityIdentifier(\n                  relatedEntityId, relatedEntityType));\n              continue;\n            }\n\n            byte[] relatedEntityStartTime \u003d\n                writeReverseOrderedLong(relatedStartTimeLong);\n            long relatedRoundedStartTime \u003d entitydb\n                .computeCurrentCheckMillis(relatedStartTimeLong);\n            RollingWriteBatch relatedRollingWriteBatch \u003d entityUpdates\n                .get(relatedRoundedStartTime);\n            if (relatedRollingWriteBatch \u003d\u003d null) {\n              DB db \u003d entitydb.getDBForStartTime(relatedStartTimeLong);\n              if (db !\u003d null) {\n                WriteBatch relatedWriteBatch \u003d db.createWriteBatch();\n                relatedRollingWriteBatch \u003d new RollingWriteBatch(db,\n                    relatedWriteBatch);\n                entityUpdates.put(relatedRoundedStartTime,\n                    relatedRollingWriteBatch);\n              }\n            }\n            if (relatedRollingWriteBatch \u003d\u003d null) {\n              // if no start time is found, add an error and return\n              TimelinePutError error \u003d new TimelinePutError();\n              error.setEntityId(entity.getEntityId());\n              error.setEntityType(entity.getEntityType());\n              error.setErrorCode(TimelinePutError.EXPIRED_ENTITY);\n              response.addError(error);\n              continue;\n            }\n            // This is the existing entity\n            byte[] relatedDomainIdBytes \u003d relatedRollingWriteBatch.getDB().get(\n                createDomainIdKey(relatedEntityId, relatedEntityType,\n                    relatedEntityStartTime));\n            // The timeline data created by the server before 2.6 won\u0027t have\n            // the domain field. We assume this timeline data is in the\n            // default timeline domain.\n            String domainId \u003d null;\n            if (relatedDomainIdBytes \u003d\u003d null) {\n              domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n            } else {\n              domainId \u003d new String(relatedDomainIdBytes, UTF_8);\n            }\n            if (!domainId.equals(entity.getDomainId())) {\n              // in this case the entity will be put, but the relation will be\n              // ignored\n              TimelinePutError error \u003d new TimelinePutError();\n              error.setEntityId(entity.getEntityId());\n              error.setEntityType(entity.getEntityType());\n              error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n              response.addError(error);\n              continue;\n            }\n            // write \"forward\" entry (related entity -\u003e entity)\n            byte[] key \u003d createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            WriteBatch relatedWriteBatch \u003d relatedRollingWriteBatch\n                .getWriteBatch();\n            relatedWriteBatch.put(key, EMPTY_BYTES);\n            ++putCount;\n          }\n        }\n      }\n\n      // write index entities\n      RollingWriteBatch indexRollingWriteBatch \u003d indexUpdates\n          .get(roundedStartTime);\n      if (indexRollingWriteBatch \u003d\u003d null) {\n        DB db \u003d indexdb.getDBForStartTime(startTime);\n        if (db !\u003d null) {\n          WriteBatch indexWriteBatch \u003d db.createWriteBatch();\n          indexRollingWriteBatch \u003d new RollingWriteBatch(db, indexWriteBatch);\n          indexUpdates.put(roundedStartTime, indexRollingWriteBatch);\n        }\n      }\n      if (indexRollingWriteBatch \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.EXPIRED_ENTITY);\n        response.addError(error);\n        return putCount;\n      }\n      WriteBatch indexWriteBatch \u003d indexRollingWriteBatch.getWriteBatch();\n      putCount +\u003d writePrimaryFilterEntries(indexWriteBatch, primaryFilters,\n          markerKey, EMPTY_BYTES);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() + \" of type \"\n          + entity.getEntityType(), e);\n      TimelinePutError error \u003d new TimelinePutError();\n      error.setEntityId(entity.getEntityId());\n      error.setEntityType(entity.getEntityType());\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      try {\n        Long relatedEntityStartAndInsertTime \u003d getAndSetStartTime(\n            relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        long relatedStartTimeLong \u003d relatedEntityStartAndInsertTime;\n        long relatedRoundedStartTime \u003d entitydb\n            .computeCurrentCheckMillis(relatedStartTimeLong);\n        RollingWriteBatch relatedRollingWriteBatch \u003d entityUpdates\n            .get(relatedRoundedStartTime);\n        if (relatedRollingWriteBatch \u003d\u003d null) {\n          DB db \u003d entitydb.getDBForStartTime(relatedStartTimeLong);\n          if (db !\u003d null) {\n            WriteBatch relatedWriteBatch \u003d db.createWriteBatch();\n            relatedRollingWriteBatch \u003d new RollingWriteBatch(db,\n                relatedWriteBatch);\n            entityUpdates\n                .put(relatedRoundedStartTime, relatedRollingWriteBatch);\n          }\n        }\n        if (relatedRollingWriteBatch \u003d\u003d null) {\n          // if no start time is found, add an error and return\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entity.getEntityId());\n          error.setEntityType(entity.getEntityType());\n          error.setErrorCode(TimelinePutError.EXPIRED_ENTITY);\n          response.addError(error);\n          continue;\n        }\n        WriteBatch relatedWriteBatch \u003d relatedRollingWriteBatch.getWriteBatch();\n        byte[] relatedEntityStartTime \u003d\n            writeReverseOrderedLong(relatedEntityStartAndInsertTime);\n        // This is the new entity, the domain should be the same\n        byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime);\n        relatedWriteBatch.put(key, entity.getDomainId().getBytes(UTF_8));\n        ++putCount;\n        relatedWriteBatch.put(\n            createRelatedEntityKey(relatedEntity.getId(),\n                relatedEntity.getType(), relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        ++putCount;\n        relatedWriteBatch.put(\n            createEntityMarkerKey(relatedEntity.getId(),\n                relatedEntity.getType(), relatedEntityStartTime), EMPTY_BYTES);\n        ++putCount;\n      } catch (IOException e) {\n        LOG.error(\n            \"Error putting related entity \" + relatedEntity.getId()\n                + \" of type \" + relatedEntity.getType() + \" for entity \"\n                + entity.getEntityId() + \" of type \" + entity.getEntityType(),\n            e);\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n        response.addError(error);\n      }\n    }\n\n    return putCount;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java"
    }
  }
}