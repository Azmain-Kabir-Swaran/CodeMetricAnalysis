{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NamenodeFsck.java",
  "functionName": "blockIdCK",
  "functionId": "blockIdCK___blockId-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
  "functionStartLine": 276,
  "functionEndLine": 345,
  "numCommitsSeen": 120,
  "timeTaken": 9960,
  "changeHistory": [
    "7806403842ddd0f5b339e3dca42688b970cae267",
    "c36d69a7b30927eaea16335e06cfcc247accde35",
    "78ae2aed8f84d2d3983f81a5219e8b1f1ec59dca",
    "2f8e9b7e4b1721ed5c7db8882eff70f83164e320",
    "c18590fce283378edb09acd4e764706a9a4a8b5f",
    "8c84a2a93c22a93b4ff46dd917f6efb995675fbd",
    "132478e805ba0f955345217b8ad87c2d17cccb2d",
    "d806a5bf079bf136114520c5a3a9d1f16ecf2eda",
    "f97a0f8c2cdad0668a3892319f6969fafc2f04cd",
    "745d04be59accf80feda0ad38efcc74ba362f2ca",
    "2470a7bf88c7d7e0889905e35671c440c3ae649b",
    "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75",
    "d62b63d297bff12d93de560dd50ddd48743b851d",
    "6e3fcffe291faec40fa9214f4880a35a952836c4",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "b008348dbf9bdd5070930be5d182116c5d370f6b",
    "a38a37c63417a3b19dcdf98251af196c9d7b8c31",
    "9f2f583f401189c3f4a2687795a9e3e0b288322b",
    "ba9371492036983a9899398907ab41fe548f29b3",
    "6d5da9484185ca9f585195d6da069b9cd5be4044",
    "f8f5887209a7d8e53c0a77abef275cbcaf1f7a5b",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
    "371a3b87ed346732ed58a4faab0c6c1db57c86ed"
  ],
  "changeHistoryShort": {
    "7806403842ddd0f5b339e3dca42688b970cae267": "Ybodychange",
    "c36d69a7b30927eaea16335e06cfcc247accde35": "Ybodychange",
    "78ae2aed8f84d2d3983f81a5219e8b1f1ec59dca": "Ybodychange",
    "2f8e9b7e4b1721ed5c7db8882eff70f83164e320": "Ybodychange",
    "c18590fce283378edb09acd4e764706a9a4a8b5f": "Ybodychange",
    "8c84a2a93c22a93b4ff46dd917f6efb995675fbd": "Ybodychange",
    "132478e805ba0f955345217b8ad87c2d17cccb2d": "Ybodychange",
    "d806a5bf079bf136114520c5a3a9d1f16ecf2eda": "Ybodychange",
    "f97a0f8c2cdad0668a3892319f6969fafc2f04cd": "Ybodychange",
    "745d04be59accf80feda0ad38efcc74ba362f2ca": "Ybodychange",
    "2470a7bf88c7d7e0889905e35671c440c3ae649b": "Ybodychange",
    "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75": "Ybodychange",
    "d62b63d297bff12d93de560dd50ddd48743b851d": "Ybodychange",
    "6e3fcffe291faec40fa9214f4880a35a952836c4": "Ybodychange",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Ybodychange",
    "b008348dbf9bdd5070930be5d182116c5d370f6b": "Ybodychange",
    "a38a37c63417a3b19dcdf98251af196c9d7b8c31": "Ybodychange",
    "9f2f583f401189c3f4a2687795a9e3e0b288322b": "Ybodychange",
    "ba9371492036983a9899398907ab41fe548f29b3": "Ybodychange",
    "6d5da9484185ca9f585195d6da069b9cd5be4044": "Ybodychange",
    "f8f5887209a7d8e53c0a77abef275cbcaf1f7a5b": "Ybodychange",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": "Ybodychange",
    "371a3b87ed346732ed58a4faab0c6c1db57c86ed": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7806403842ddd0f5b339e3dca42688b970cae267": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14266. EC : Fsck -blockId shows null for EC Blocks if One Block Is Not Available. Contributed by Ayush Saxena.\n",
      "commitDate": "12/02/19 8:27 AM",
      "commitName": "7806403842ddd0f5b339e3dca42688b970cae267",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "11/01/19 10:54 AM",
      "commitNameOld": "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 31.9,
      "commitsBetweenForRepo": 227,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,70 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     namenode.getNamesystem().readLock();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n       if (blockInfo \u003d\u003d null || blockInfo.isDeleted()) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n       NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           blockManager.getExpectedRedundancyNum(blockInfo));\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       if (this.showMaintenanceState) {\n         out.println(\"No. of entering maintenance Replica: \"\n             + numberReplicas.liveEnteringMaintenanceReplicas());\n         out.println(\"No. of in maintenance Replica: \"\n             + numberReplicas.maintenanceNotForReadReplicas());\n       }\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (blockManager.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n       }\n-\n-      //report block replicas status on datanodes\n-      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n-        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n-        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n-            dn.getNetworkLocation() + \" \");\n-        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n-          out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n-              blockManager.getCorruptReason(block, dn));\n-        } else if (dn.isDecommissioned() ){\n-          out.print(DECOMMISSIONED_STATUS);\n-        } else if (dn.isDecommissionInProgress()) {\n-          out.print(DECOMMISSIONING_STATUS);\n-        } else if (this.showMaintenanceState \u0026\u0026 dn.isEnteringMaintenance()) {\n-          out.print(ENTERING_MAINTENANCE_STATUS);\n-        } else if (this.showMaintenanceState \u0026\u0026 dn.isInMaintenance()) {\n-          out.print(IN_MAINTENANCE_STATUS);\n-        } else {\n-          out.print(HEALTHY_STATUS);\n+      // report block replicas status on datanodes\n+      if (blockInfo.isStriped()) {\n+        for (int idx \u003d (blockInfo.getCapacity() - 1); idx \u003e\u003d 0; idx--) {\n+          DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n+          if (dn \u003d\u003d null) {\n+            continue;\n+          }\n+          printDatanodeReplicaStatus(block, corruptionRecord, dn);\n         }\n-        out.print(\"\\n\");\n+      } else {\n+        for (int idx \u003d (blockInfo.numNodes() - 1); idx \u003e\u003d 0; idx--) {\n+          DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n+          printDatanodeReplicaStatus(block, corruptionRecord, dn);\n+        }\n       }\n-    } catch (Exception e){\n+    } catch (Exception e) {\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     } finally {\n       namenode.getNamesystem().readUnlock(\"fsck\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    namenode.getNamesystem().readLock();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n      if (blockInfo \u003d\u003d null || blockInfo.isDeleted()) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n      NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          blockManager.getExpectedRedundancyNum(blockInfo));\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      if (this.showMaintenanceState) {\n        out.println(\"No. of entering maintenance Replica: \"\n            + numberReplicas.liveEnteringMaintenanceReplicas());\n        out.println(\"No. of in maintenance Replica: \"\n            + numberReplicas.maintenanceNotForReadReplicas());\n      }\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (blockManager.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n      }\n      // report block replicas status on datanodes\n      if (blockInfo.isStriped()) {\n        for (int idx \u003d (blockInfo.getCapacity() - 1); idx \u003e\u003d 0; idx--) {\n          DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n          if (dn \u003d\u003d null) {\n            continue;\n          }\n          printDatanodeReplicaStatus(block, corruptionRecord, dn);\n        }\n      } else {\n        for (int idx \u003d (blockInfo.numNodes() - 1); idx \u003e\u003d 0; idx--) {\n          DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n          printDatanodeReplicaStatus(block, corruptionRecord, dn);\n        }\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    } finally {\n      namenode.getNamesystem().readUnlock(\"fsck\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "c36d69a7b30927eaea16335e06cfcc247accde35": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13027. Handle possible NPEs due to deleted blocks in race condition. Contributed by Vinayakumar B.\n\n(cherry picked from commit 65977e5d8124be2bc208af25beed934933f170b3)\n",
      "commitDate": "30/08/18 9:45 AM",
      "commitName": "c36d69a7b30927eaea16335e06cfcc247accde35",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "02/07/18 3:11 AM",
      "commitNameOld": "5d748bd056a32f2c6922514cd0c5b31d866a9919",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 59.27,
      "commitsBetweenForRepo": 448,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,77 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n+    namenode.getNamesystem().readLock();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n-      if(blockInfo \u003d\u003d null) {\n+      if (blockInfo \u003d\u003d null || blockInfo.isDeleted()) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n       NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           blockManager.getExpectedRedundancyNum(blockInfo));\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       if (this.showMaintenanceState) {\n         out.println(\"No. of entering maintenance Replica: \"\n             + numberReplicas.liveEnteringMaintenanceReplicas());\n         out.println(\"No. of in maintenance Replica: \"\n             + numberReplicas.maintenanceNotForReadReplicas());\n       }\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (blockManager.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n               blockManager.getCorruptReason(block, dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else if (this.showMaintenanceState \u0026\u0026 dn.isEnteringMaintenance()) {\n           out.print(ENTERING_MAINTENANCE_STATUS);\n         } else if (this.showMaintenanceState \u0026\u0026 dn.isInMaintenance()) {\n           out.print(IN_MAINTENANCE_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n+    } finally {\n+      namenode.getNamesystem().readUnlock(\"fsck\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    namenode.getNamesystem().readLock();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n      if (blockInfo \u003d\u003d null || blockInfo.isDeleted()) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n      NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          blockManager.getExpectedRedundancyNum(blockInfo));\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      if (this.showMaintenanceState) {\n        out.println(\"No. of entering maintenance Replica: \"\n            + numberReplicas.liveEnteringMaintenanceReplicas());\n        out.println(\"No. of in maintenance Replica: \"\n            + numberReplicas.maintenanceNotForReadReplicas());\n      }\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (blockManager.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n              blockManager.getCorruptReason(block, dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else if (this.showMaintenanceState \u0026\u0026 dn.isEnteringMaintenance()) {\n          out.print(ENTERING_MAINTENANCE_STATUS);\n        } else if (this.showMaintenanceState \u0026\u0026 dn.isInMaintenance()) {\n          out.print(IN_MAINTENANCE_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    } finally {\n      namenode.getNamesystem().readUnlock(\"fsck\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "78ae2aed8f84d2d3983f81a5219e8b1f1ec59dca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11259. Update fsck to display maintenance state info. (Manoj Govindassamy via lei)\n",
      "commitDate": "19/01/17 12:28 AM",
      "commitName": "78ae2aed8f84d2d3983f81a5219e8b1f1ec59dca",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "18/01/17 1:31 PM",
      "commitNameOld": "a2a5d7b5bca715835d92816e7b267b59f7270708",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.46,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,74 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n       NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           blockManager.getExpectedRedundancyNum(blockInfo));\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n+      if (this.showMaintenanceState) {\n+        out.println(\"No. of entering maintenance Replica: \"\n+            + numberReplicas.liveEnteringMaintenanceReplicas());\n+        out.println(\"No. of in maintenance Replica: \"\n+            + numberReplicas.maintenanceNotForReadReplicas());\n+      }\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (blockManager.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n               blockManager.getCorruptReason(block, dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n+        } else if (this.showMaintenanceState \u0026\u0026 dn.isEnteringMaintenance()) {\n+          out.print(ENTERING_MAINTENANCE_STATUS);\n+        } else if (this.showMaintenanceState \u0026\u0026 dn.isInMaintenance()) {\n+          out.print(IN_MAINTENANCE_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n      NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          blockManager.getExpectedRedundancyNum(blockInfo));\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      if (this.showMaintenanceState) {\n        out.println(\"No. of entering maintenance Replica: \"\n            + numberReplicas.liveEnteringMaintenanceReplicas());\n        out.println(\"No. of in maintenance Replica: \"\n            + numberReplicas.maintenanceNotForReadReplicas());\n      }\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (blockManager.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n              blockManager.getCorruptReason(block, dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else if (this.showMaintenanceState \u0026\u0026 dn.isEnteringMaintenance()) {\n          out.print(ENTERING_MAINTENANCE_STATUS);\n        } else if (this.showMaintenanceState \u0026\u0026 dn.isInMaintenance()) {\n          out.print(IN_MAINTENANCE_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "2f8e9b7e4b1721ed5c7db8882eff70f83164e320": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-11259. Update fsck to display maintenance state info. (Manoj Govindassamy via lei)\"\n\nThis reverts commit c18590fce283378edb09acd4e764706a9a4a8b5f.\n",
      "commitDate": "15/01/17 11:11 PM",
      "commitName": "2f8e9b7e4b1721ed5c7db8882eff70f83164e320",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "10/01/17 3:37 AM",
      "commitNameOld": "c18590fce283378edb09acd4e764706a9a4a8b5f",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 5.82,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,64 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n       NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           blockManager.getExpectedRedundancyNum(blockInfo));\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n-      out.println(\"No. of entering maintenance Replica: \"\n-          + numberReplicas.liveEnteringMaintenanceReplicas());\n-      out.println(\"No. of in maintenance Replica: \"\n-          + numberReplicas.maintenanceNotForReadReplicas());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (blockManager.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n               blockManager.getCorruptReason(block, dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n-        } else if (dn.isEnteringMaintenance()) {\n-          out.print(ENTERING_MAINTENANCE_STATUS);\n-        } else if (dn.isInMaintenance()) {\n-          out.print(IN_MAINTENANCE_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n      NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          blockManager.getExpectedRedundancyNum(blockInfo));\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (blockManager.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n              blockManager.getCorruptReason(block, dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "c18590fce283378edb09acd4e764706a9a4a8b5f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11259. Update fsck to display maintenance state info. (Manoj Govindassamy via lei)\n",
      "commitDate": "10/01/17 3:37 AM",
      "commitName": "c18590fce283378edb09acd4e764706a9a4a8b5f",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "14/11/16 11:05 AM",
      "commitNameOld": "ff0b99eafeda035ebe0dc82cfe689808047a8893",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 56.69,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,72 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n       NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           blockManager.getExpectedRedundancyNum(blockInfo));\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n+      out.println(\"No. of entering maintenance Replica: \"\n+          + numberReplicas.liveEnteringMaintenanceReplicas());\n+      out.println(\"No. of in maintenance Replica: \"\n+          + numberReplicas.maintenanceNotForReadReplicas());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (blockManager.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n               blockManager.getCorruptReason(block, dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n+        } else if (dn.isEnteringMaintenance()) {\n+          out.print(ENTERING_MAINTENANCE_STATUS);\n+        } else if (dn.isInMaintenance()) {\n+          out.print(IN_MAINTENANCE_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n      NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          blockManager.getExpectedRedundancyNum(blockInfo));\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of entering maintenance Replica: \"\n          + numberReplicas.liveEnteringMaintenanceReplicas());\n      out.println(\"No. of in maintenance Replica: \"\n          + numberReplicas.maintenanceNotForReadReplicas());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (blockManager.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n              blockManager.getCorruptReason(block, dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else if (dn.isEnteringMaintenance()) {\n          out.print(ENTERING_MAINTENANCE_STATUS);\n        } else if (dn.isInMaintenance()) {\n          out.print(IN_MAINTENANCE_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "8c84a2a93c22a93b4ff46dd917f6efb995675fbd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10236. Erasure Coding: Rename replication-based names in BlockManager to more generic [part-3]. Contributed by Rakesh R.\n",
      "commitDate": "26/05/16 4:50 PM",
      "commitName": "8c84a2a93c22a93b4ff46dd917f6efb995675fbd",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "25/04/16 12:01 PM",
      "commitNameOld": "f308561f1d885491b88db73ac63003202056d661",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 31.2,
      "commitsBetweenForRepo": 220,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n       NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n-          blockManager.getExpectedReplicaNum(blockInfo));\n+          blockManager.getExpectedRedundancyNum(blockInfo));\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (blockManager.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n               blockManager.getCorruptReason(block, dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n      NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          blockManager.getExpectedRedundancyNum(blockInfo));\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (blockManager.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n              blockManager.getCorruptReason(block, dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "132478e805ba0f955345217b8ad87c2d17cccb2d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9527. The return type of FSNamesystem.getBlockCollection should be changed to INodeFile.\n",
      "commitDate": "09/12/15 5:55 PM",
      "commitName": "132478e805ba0f955345217b8ad87c2d17cccb2d",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "03/11/15 5:16 PM",
      "commitNameOld": "194251c85250fcbe80a6ffee88b2cd4689334be3",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 36.03,
      "commitsBetweenForRepo": 230,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,64 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n-      BlockCollection bc \u003d blockManager.getBlockCollection(blockInfo);\n-      INode iNode \u003d (INode) bc;\n+      final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n       NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           blockManager.getExpectedReplicaNum(blockInfo));\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (blockManager.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n               blockManager.getCorruptReason(block, dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      final INodeFile iNode \u003d namenode.getNamesystem().getBlockCollection(blockInfo);\n      NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          blockManager.getExpectedReplicaNum(blockInfo));\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (blockManager.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n              blockManager.getCorruptReason(block, dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "d806a5bf079bf136114520c5a3a9d1f16ecf2eda": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9070. Allow fsck display pending replica location information for being-written blocks. Contributed by Gao Rui.\n",
      "commitDate": "21/10/15 2:44 PM",
      "commitName": "d806a5bf079bf136114520c5a3a9d1f16ecf2eda",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "21/10/15 8:06 AM",
      "commitNameOld": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,65 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n-    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n-      BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n+      BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n-      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n+      BlockCollection bc \u003d blockManager.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n-      NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n+      NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n-          bm.getExpectedReplicaNum(blockInfo));\n+          blockManager.getExpectedReplicaNum(blockInfo));\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n-      if (bm.getCorruptReplicas(block) !\u003d null) {\n-        corruptionRecord \u003d bm.getCorruptReplicas(block);\n+      if (blockManager.getCorruptReplicas(block) !\u003d null) {\n+        corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n-          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n-            bm.getCorruptReason(block,dn));\n+          out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n+              blockManager.getCorruptReason(block, dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d blockManager.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d blockManager.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d blockManager.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          blockManager.getExpectedReplicaNum(blockInfo));\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (blockManager.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d blockManager.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS + \"\\t ReasonCode: \" +\n              blockManager.getCorruptReason(block, dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "f97a0f8c2cdad0668a3892319f6969fafc2f04cd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8969. Clean up findbugs warnings for HDFS-8823 and HDFS-8932. Contributed by Anu Engineer.\n",
      "commitDate": "27/08/15 1:03 PM",
      "commitName": "f97a0f8c2cdad0668a3892319f6969fafc2f04cd",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "22/08/15 12:09 AM",
      "commitNameOld": "745d04be59accf80feda0ad38efcc74ba362f2ca",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 5.54,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,65 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n       NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n-      if (blockInfo !\u003d null) {\n-        out.println(\"No. of Expected Replica: \" + blockInfo.getReplication());\n-      }\n+      out.println(\"No. of Expected Replica: \" + blockInfo.getReplication());\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (bm.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d bm.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n             bm.getCorruptReason(block,dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" + blockInfo.getReplication());\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "745d04be59accf80feda0ad38efcc74ba362f2ca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8823. Move replication factor into individual blocks. Contributed by Haohui Mai.\n",
      "commitDate": "22/08/15 12:09 AM",
      "commitName": "745d04be59accf80feda0ad38efcc74ba362f2ca",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "20/08/15 4:31 PM",
      "commitNameOld": "c8bca62718203a1dad9b70d164bdf10cc71b40cd",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 1.32,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,67 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n       NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n-      out.println(\"No. of Expected Replica: \" +\n-          bc.getPreferredBlockReplication());\n+      if (blockInfo !\u003d null) {\n+        out.println(\"No. of Expected Replica: \" + blockInfo.getReplication());\n+      }\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (bm.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d bm.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n             bm.getCorruptReason(block,dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      if (blockInfo !\u003d null) {\n        out.println(\"No. of Expected Replica: \" + blockInfo.getReplication());\n      }\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "2470a7bf88c7d7e0889905e35671c440c3ae649b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8563. Erasure Coding: fsck handles file smaller than a full stripe. Contributed by Walter Su.\n",
      "commitDate": "09/07/15 10:55 AM",
      "commitName": "2470a7bf88c7d7e0889905e35671c440c3ae649b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "10/06/15 10:18 PM",
      "commitNameOld": "98d340745be682fb251677bb4830aca76119868f",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 28.53,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n-      BlockInfo blockInfo \u003d namenode.getNamesystem().getStoredBlock(block);\n+      BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n       NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           bm.getExpectedReplicaNum(bc, blockInfo));\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (bm.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d bm.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n             bm.getCorruptReason(block,dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          bm.getExpectedReplicaNum(bc, blockInfo));\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8652. Track BlockInfo instead of Block in CorruptReplicasMap. Contributed by Jing Zhao.\"\n\nThis reverts commit d62b63d297bff12d93de560dd50ddd48743b851d.\n",
      "commitDate": "07/07/15 10:13 AM",
      "commitName": "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "06/07/15 3:54 PM",
      "commitNameOld": "d62b63d297bff12d93de560dd50ddd48743b851d",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,66 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n       NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           bc.getPreferredBlockReplication());\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n-      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d\n-          bm.getCorruptReplicas(blockInfo);\n+      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n+      if (bm.getCorruptReplicas(block) !\u003d null) {\n+        corruptionRecord \u003d bm.getCorruptReplicas(block);\n+      }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n-            bm.getCorruptReason(blockInfo, dn));\n+            bm.getCorruptReason(block,dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          bc.getPreferredBlockReplication());\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "d62b63d297bff12d93de560dd50ddd48743b851d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8652. Track BlockInfo instead of Block in CorruptReplicasMap. Contributed by Jing Zhao.\n",
      "commitDate": "06/07/15 3:54 PM",
      "commitName": "d62b63d297bff12d93de560dd50ddd48743b851d",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/06/15 10:49 AM",
      "commitNameOld": "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 10.21,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,64 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n       NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           bc.getPreferredBlockReplication());\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n-      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n-      if (bm.getCorruptReplicas(block) !\u003d null) {\n-        corruptionRecord \u003d bm.getCorruptReplicas(block);\n-      }\n+      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d\n+          bm.getCorruptReplicas(blockInfo);\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n-            bm.getCorruptReason(block,dn));\n+            bm.getCorruptReason(blockInfo, dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          bc.getPreferredBlockReplication());\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d\n          bm.getCorruptReplicas(blockInfo);\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(blockInfo, dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "6e3fcffe291faec40fa9214f4880a35a952836c4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8608. Merge HDFS-7912 to trunk and branch-2 (track BlockInfo instead of Block in UnderReplicatedBlocks and PendingReplicationBlocks). Contributed by Zhe Zhang.\n",
      "commitDate": "17/06/15 8:05 AM",
      "commitName": "6e3fcffe291faec40fa9214f4880a35a952836c4",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "27/05/15 3:42 PM",
      "commitNameOld": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 20.68,
      "commitsBetweenForRepo": 151,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n-      NumberReplicas numberReplicas\u003d bm.countNodes(block);\n+      NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           bc.getPreferredBlockReplication());\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (bm.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d bm.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n             bm.getCorruptReason(block,dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          bc.getPreferredBlockReplication());\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "19/05/15 10:50 AM",
      "commitNameOld": "470c87dbc6c24dd3b370f1ad9e7ab1f6dabd2080",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 8.2,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n-      BlockInfoContiguous blockInfo \u003d bm.getStoredBlock(block);\n+      BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n       NumberReplicas numberReplicas\u003d bm.countNodes(block);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           bc.getPreferredBlockReplication());\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (bm.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d bm.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n             bm.getCorruptReason(block,dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(block);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          bc.getPreferredBlockReplication());\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "b008348dbf9bdd5070930be5d182116c5d370f6b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8418. Fix the isNeededReplication calculation for Striped block in NN. Contributed by Yi Liu.\n",
      "commitDate": "26/05/15 12:02 PM",
      "commitName": "b008348dbf9bdd5070930be5d182116c5d370f6b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:41 AM",
      "commitNameOld": "a38a37c63417a3b19dcdf98251af196c9d7b8c31",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d namenode.getNamesystem().getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n       NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n-          bc.getPreferredBlockReplication());\n+          bm.getExpectedReplicaNum(bc, blockInfo));\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (bm.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d bm.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n             bm.getCorruptReason(block,dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d namenode.getNamesystem().getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          bm.getExpectedReplicaNum(bc, blockInfo));\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "a38a37c63417a3b19dcdf98251af196c9d7b8c31": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7912. Erasure Coding: track BlockInfo instead of Block in UnderReplicatedBlocks and PendingReplicationBlocks. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:41 AM",
      "commitName": "a38a37c63417a3b19dcdf98251af196c9d7b8c31",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:07 AM",
      "commitNameOld": "9af1f4779b646fb2f09b5e36447c8b8abe920a7c",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfo blockInfo \u003d namenode.getNamesystem().getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n-      NumberReplicas numberReplicas\u003d bm.countNodes(block);\n+      NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           bc.getPreferredBlockReplication());\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (bm.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d bm.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n             bm.getCorruptReason(block,dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d namenode.getNamesystem().getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(blockInfo);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          bc.getPreferredBlockReplication());\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "9f2f583f401189c3f4a2687795a9e3e0b288322b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7749. Erasure Coding: Add striped block support in INodeFile. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:07 AM",
      "commitName": "9f2f583f401189c3f4a2687795a9e3e0b288322b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:07 AM",
      "commitNameOld": "ba9371492036983a9899398907ab41fe548f29b3",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,66 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n-      BlockInfoContiguous blockInfo \u003d namenode.getNamesystem()\n-          .getStoredBlock(block);\n+      BlockInfo blockInfo \u003d namenode.getNamesystem().getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n       NumberReplicas numberReplicas\u003d bm.countNodes(block);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           bc.getPreferredBlockReplication());\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (bm.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d bm.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n             bm.getCorruptReason(block,dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d namenode.getNamesystem().getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(block);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          bc.getPreferredBlockReplication());\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "ba9371492036983a9899398907ab41fe548f29b3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7716. Erasure Coding: extend BlockInfo to handle EC info. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:07 AM",
      "commitName": "ba9371492036983a9899398907ab41fe548f29b3",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "19/05/15 10:50 AM",
      "commitNameOld": "470c87dbc6c24dd3b370f1ad9e7ab1f6dabd2080",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 7.01,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,67 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n-      BlockInfoContiguous blockInfo \u003d bm.getStoredBlock(block);\n+      BlockInfoContiguous blockInfo \u003d namenode.getNamesystem()\n+          .getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n       NumberReplicas numberReplicas\u003d bm.countNodes(block);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" +\n           bc.getPreferredBlockReplication());\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" +\n           numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" +\n           numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (bm.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d bm.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n             bm.getCorruptReason(block,dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfoContiguous blockInfo \u003d namenode.getNamesystem()\n          .getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(block);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          bc.getPreferredBlockReplication());\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "6d5da9484185ca9f585195d6da069b9cd5be4044": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8255. Rename getBlockReplication to getPreferredBlockReplication. (Contributed by Zhe Zhang)\n",
      "commitDate": "12/05/15 6:29 AM",
      "commitName": "6d5da9484185ca9f585195d6da069b9cd5be4044",
      "commitAuthor": "yliu",
      "commitDateOld": "07/05/15 10:31 PM",
      "commitNameOld": "2ea0f2fc938febd7fbbe03656a91ae3db1409c50",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 4.33,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,66 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfoContiguous blockInfo \u003d bm.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n       NumberReplicas numberReplicas\u003d bm.countNodes(block);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n-      out.println(\"No. of Expected Replica: \" + bc.getBlockReplication());\n+      out.println(\"No. of Expected Replica: \" +\n+          bc.getPreferredBlockReplication());\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n-      out.println(\"No. of stale Replica: \" + numberReplicas.replicasOnStaleNodes());\n+      out.println(\"No. of stale Replica: \" +\n+          numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommissioned Replica: \"\n           + numberReplicas.decommissioned());\n       out.println(\"No. of decommissioning Replica: \"\n           + numberReplicas.decommissioning());\n-      out.println(\"No. of corrupted Replica: \" + numberReplicas.corruptReplicas());\n+      out.println(\"No. of corrupted Replica: \" +\n+          numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (bm.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d bm.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n             bm.getCorruptReason(block,dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfoContiguous blockInfo \u003d bm.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(block);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" +\n          bc.getPreferredBlockReplication());\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" +\n          numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" +\n          numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "f8f5887209a7d8e53c0a77abef275cbcaf1f7a5b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7933. fsck should also report decommissioning replicas. Contributed by Xiaoyu Yao.\n",
      "commitDate": "11/04/15 1:23 PM",
      "commitName": "f8f5887209a7d8e53c0a77abef275cbcaf1f7a5b",
      "commitAuthor": "cnauroth",
      "commitDateOld": "20/03/15 12:02 PM",
      "commitNameOld": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 22.06,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,63 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n       BlockInfoContiguous blockInfo \u003d bm.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n       NumberReplicas numberReplicas\u003d bm.countNodes(block);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" + bc.getBlockReplication());\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" + numberReplicas.replicasOnStaleNodes());\n-      out.println(\"No. of decommission Replica: \"\n-          + numberReplicas.decommissionedReplicas());\n+      out.println(\"No. of decommissioned Replica: \"\n+          + numberReplicas.decommissioned());\n+      out.println(\"No. of decommissioning Replica: \"\n+          + numberReplicas.decommissioning());\n       out.println(\"No. of corrupted Replica: \" + numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (bm.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d bm.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n             bm.getCorruptReason(block,dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfoContiguous blockInfo \u003d bm.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(block);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" + bc.getBlockReplication());\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" + numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommissioned Replica: \"\n          + numberReplicas.decommissioned());\n      out.println(\"No. of decommissioning Replica: \"\n          + numberReplicas.decommissioning());\n      out.println(\"No. of corrupted Replica: \" + numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7743. Code cleanup of BlockInfo and rename BlockInfo to BlockInfoContiguous. Contributed by Jing Zhao.\n",
      "commitDate": "08/02/15 11:51 AM",
      "commitName": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "11/12/14 12:36 PM",
      "commitNameOld": "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 58.97,
      "commitsBetweenForRepo": 381,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n   public void blockIdCK(String blockId) {\n \n     if(blockId \u003d\u003d null) {\n       out.println(\"Please provide valid blockId!\");\n       return;\n     }\n \n     BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n     try {\n       //get blockInfo\n       Block block \u003d new Block(Block.getBlockId(blockId));\n       //find which file this block belongs to\n-      BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n+      BlockInfoContiguous blockInfo \u003d bm.getStoredBlock(block);\n       if(blockInfo \u003d\u003d null) {\n         out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n         LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n         return;\n       }\n       BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n       INode iNode \u003d (INode) bc;\n       NumberReplicas numberReplicas\u003d bm.countNodes(block);\n       out.println(\"Block Id: \" + blockId);\n       out.println(\"Block belongs to: \"+iNode.getFullPathName());\n       out.println(\"No. of Expected Replica: \" + bc.getBlockReplication());\n       out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n       out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n       out.println(\"No. of stale Replica: \" + numberReplicas.replicasOnStaleNodes());\n       out.println(\"No. of decommission Replica: \"\n           + numberReplicas.decommissionedReplicas());\n       out.println(\"No. of corrupted Replica: \" + numberReplicas.corruptReplicas());\n       //record datanodes that have corrupted block replica\n       Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n       if (bm.getCorruptReplicas(block) !\u003d null) {\n         corruptionRecord \u003d bm.getCorruptReplicas(block);\n       }\n \n       //report block replicas status on datanodes\n       for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n         DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n         out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n             dn.getNetworkLocation() + \" \");\n         if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n           out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n             bm.getCorruptReason(block,dn));\n         } else if (dn.isDecommissioned() ){\n           out.print(DECOMMISSIONED_STATUS);\n         } else if (dn.isDecommissionInProgress()) {\n           out.print(DECOMMISSIONING_STATUS);\n         } else {\n           out.print(HEALTHY_STATUS);\n         }\n         out.print(\"\\n\");\n       }\n     } catch (Exception e){\n       String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n       LOG.warn(errMsg, e);\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n       LOG.warn(\"Error in looking up block\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfoContiguous blockInfo \u003d bm.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(block);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" + bc.getBlockReplication());\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" + numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommission Replica: \"\n          + numberReplicas.decommissionedReplicas());\n      out.println(\"No. of corrupted Replica: \" + numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "371a3b87ed346732ed58a4faab0c6c1db57c86ed": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-6663. Admin command to track file and locations from block id.\nContributed by Chen He.\n",
      "commitDate": "28/10/14 12:26 PM",
      "commitName": "371a3b87ed346732ed58a4faab0c6c1db57c86ed",
      "commitAuthor": "Kihwal Lee",
      "diff": "@@ -0,0 +1,61 @@\n+  public void blockIdCK(String blockId) {\n+\n+    if(blockId \u003d\u003d null) {\n+      out.println(\"Please provide valid blockId!\");\n+      return;\n+    }\n+\n+    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n+    try {\n+      //get blockInfo\n+      Block block \u003d new Block(Block.getBlockId(blockId));\n+      //find which file this block belongs to\n+      BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n+      if(blockInfo \u003d\u003d null) {\n+        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n+        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n+        return;\n+      }\n+      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n+      INode iNode \u003d (INode) bc;\n+      NumberReplicas numberReplicas\u003d bm.countNodes(block);\n+      out.println(\"Block Id: \" + blockId);\n+      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n+      out.println(\"No. of Expected Replica: \" + bc.getBlockReplication());\n+      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n+      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n+      out.println(\"No. of stale Replica: \" + numberReplicas.replicasOnStaleNodes());\n+      out.println(\"No. of decommission Replica: \"\n+          + numberReplicas.decommissionedReplicas());\n+      out.println(\"No. of corrupted Replica: \" + numberReplicas.corruptReplicas());\n+      //record datanodes that have corrupted block replica\n+      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n+      if (bm.getCorruptReplicas(block) !\u003d null) {\n+        corruptionRecord \u003d bm.getCorruptReplicas(block);\n+      }\n+\n+      //report block replicas status on datanodes\n+      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n+        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n+        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n+            dn.getNetworkLocation() + \" \");\n+        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n+          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n+            bm.getCorruptReason(block,dn));\n+        } else if (dn.isDecommissioned() ){\n+          out.print(DECOMMISSIONED_STATUS);\n+        } else if (dn.isDecommissionInProgress()) {\n+          out.print(DECOMMISSIONING_STATUS);\n+        } else {\n+          out.print(HEALTHY_STATUS);\n+        }\n+        out.print(\"\\n\");\n+      }\n+    } catch (Exception e){\n+      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n+      LOG.warn(errMsg, e);\n+      out.println(e.getMessage());\n+      out.print(\"\\n\\n\" + errMsg);\n+      LOG.warn(\"Error in looking up block\", e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void blockIdCK(String blockId) {\n\n    if(blockId \u003d\u003d null) {\n      out.println(\"Please provide valid blockId!\");\n      return;\n    }\n\n    BlockManager bm \u003d namenode.getNamesystem().getBlockManager();\n    try {\n      //get blockInfo\n      Block block \u003d new Block(Block.getBlockId(blockId));\n      //find which file this block belongs to\n      BlockInfo blockInfo \u003d bm.getStoredBlock(block);\n      if(blockInfo \u003d\u003d null) {\n        out.println(\"Block \"+ blockId +\" \" + NONEXISTENT_STATUS);\n        LOG.warn(\"Block \"+ blockId + \" \" + NONEXISTENT_STATUS);\n        return;\n      }\n      BlockCollection bc \u003d bm.getBlockCollection(blockInfo);\n      INode iNode \u003d (INode) bc;\n      NumberReplicas numberReplicas\u003d bm.countNodes(block);\n      out.println(\"Block Id: \" + blockId);\n      out.println(\"Block belongs to: \"+iNode.getFullPathName());\n      out.println(\"No. of Expected Replica: \" + bc.getBlockReplication());\n      out.println(\"No. of live Replica: \" + numberReplicas.liveReplicas());\n      out.println(\"No. of excess Replica: \" + numberReplicas.excessReplicas());\n      out.println(\"No. of stale Replica: \" + numberReplicas.replicasOnStaleNodes());\n      out.println(\"No. of decommission Replica: \"\n          + numberReplicas.decommissionedReplicas());\n      out.println(\"No. of corrupted Replica: \" + numberReplicas.corruptReplicas());\n      //record datanodes that have corrupted block replica\n      Collection\u003cDatanodeDescriptor\u003e corruptionRecord \u003d null;\n      if (bm.getCorruptReplicas(block) !\u003d null) {\n        corruptionRecord \u003d bm.getCorruptReplicas(block);\n      }\n\n      //report block replicas status on datanodes\n      for(int idx \u003d (blockInfo.numNodes()-1); idx \u003e\u003d 0; idx--) {\n        DatanodeDescriptor dn \u003d blockInfo.getDatanode(idx);\n        out.print(\"Block replica on datanode/rack: \" + dn.getHostName() +\n            dn.getNetworkLocation() + \" \");\n        if (corruptionRecord !\u003d null \u0026\u0026 corruptionRecord.contains(dn)) {\n          out.print(CORRUPT_STATUS+\"\\t ReasonCode: \"+\n            bm.getCorruptReason(block,dn));\n        } else if (dn.isDecommissioned() ){\n          out.print(DECOMMISSIONED_STATUS);\n        } else if (dn.isDecommissionInProgress()) {\n          out.print(DECOMMISSIONING_STATUS);\n        } else {\n          out.print(HEALTHY_STATUS);\n        }\n        out.print(\"\\n\");\n      }\n    } catch (Exception e){\n      String errMsg \u003d \"Fsck on blockId \u0027\" + blockId;\n      LOG.warn(errMsg, e);\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n      LOG.warn(\"Error in looking up block\", e);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java"
    }
  }
}