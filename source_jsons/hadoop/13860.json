{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockManager.java",
  "functionName": "checkReplicaCorrupt",
  "functionId": "checkReplicaCorrupt___reported-Block__reportedState-ReplicaState__storedBlock-BlockInfo__ucState-BlockUCState__dn-DatanodeDescriptor",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
  "functionStartLine": 3259,
  "functionEndLine": 3359,
  "numCommitsSeen": 912,
  "timeTaken": 19974,
  "changeHistory": [
    "66400c1cbb2b4b2f08f7db965c8b7237072bdcc4",
    "e0ff8e2c10f38298b81624df1e62743ac171f18d",
    "a7f085d6bf499edf23e650a4f7211c53a442da0e",
    "c09dc258a8f64fab852bf6f26187163480dbee3c",
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "b008348dbf9bdd5070930be5d182116c5d370f6b",
    "5e8837dd6cc747b3259751930f2a9eed7163bcad",
    "4d0bc724f29b646e252f53d1c654a23e8526a4bf",
    "ba9371492036983a9899398907ab41fe548f29b3",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
    "30a9ec26f799977ba36d8860daf0a90705927fae",
    "ceea91c9cd8b2a18be13217894ccf1c17198de18",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
    "28e8151ad3defc85a4ac1d19b39a9377253c718f",
    "f1ff05bf47a7dfb670bc63e4e6e58d74f6b5b4a7",
    "408e558d8d44c07973054229bff422a6c327abf0",
    "be7dd8333a7e56e732171db0781786987de03195"
  ],
  "changeHistoryShort": {
    "66400c1cbb2b4b2f08f7db965c8b7237072bdcc4": "Ybodychange",
    "e0ff8e2c10f38298b81624df1e62743ac171f18d": "Ybodychange",
    "a7f085d6bf499edf23e650a4f7211c53a442da0e": "Ybodychange",
    "c09dc258a8f64fab852bf6f26187163480dbee3c": "Ybodychange",
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046": "Ybodychange",
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5": "Ybodychange",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Yparameterchange",
    "b008348dbf9bdd5070930be5d182116c5d370f6b": "Ybodychange",
    "5e8837dd6cc747b3259751930f2a9eed7163bcad": "Ybodychange",
    "4d0bc724f29b646e252f53d1c654a23e8526a4bf": "Ybodychange",
    "ba9371492036983a9899398907ab41fe548f29b3": "Ymultichange(Yparameterchange,Ybodychange)",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": "Yparameterchange",
    "30a9ec26f799977ba36d8860daf0a90705927fae": "Ybodychange",
    "ceea91c9cd8b2a18be13217894ccf1c17198de18": "Ybodychange",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": "Ybodychange",
    "28e8151ad3defc85a4ac1d19b39a9377253c718f": "Ymultichange(Yparameterchange,Ybodychange)",
    "f1ff05bf47a7dfb670bc63e4e6e58d74f6b5b4a7": "Ybodychange",
    "408e558d8d44c07973054229bff422a6c327abf0": "Ybodychange",
    "be7dd8333a7e56e732171db0781786987de03195": "Ybodychange"
  },
  "changeHistoryDetails": {
    "66400c1cbb2b4b2f08f7db965c8b7237072bdcc4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14808. EC: Improper size values for corrupt ec block in LOG. Contributed by Ayush Saxena.\n",
      "commitDate": "24/09/19 1:01 PM",
      "commitName": "66400c1cbb2b4b2f08f7db965c8b7237072bdcc4",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "12/09/19 11:47 AM",
      "commitNameOld": "4852a90e4b077ece2d68595210e62959a9923683",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 12.05,
      "commitsBetweenForRepo": 104,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,101 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState,\n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         boolean wrongSize;\n+        long blockMapSize;\n         if (storedBlock.isStriped()) {\n           assert BlockIdManager.isStripedBlockID(reported.getBlockId());\n           assert storedBlock.getBlockId() \u003d\u003d\n               BlockIdManager.convertToStripedID(reported.getBlockId());\n           BlockInfoStriped stripedBlock \u003d (BlockInfoStriped) storedBlock;\n           int reportedBlkIdx \u003d BlockIdManager.getBlockIndex(reported);\n-          wrongSize \u003d reported.getNumBytes() !\u003d getInternalBlockLength(\n-              stripedBlock.getNumBytes(), stripedBlock.getCellSize(),\n-              stripedBlock.getDataBlockNum(), reportedBlkIdx);\n+          blockMapSize \u003d getInternalBlockLength(stripedBlock.getNumBytes(),\n+              stripedBlock.getCellSize(), stripedBlock.getDataBlockNum(),\n+              reportedBlkIdx);\n+          wrongSize \u003d reported.getNumBytes() !\u003d blockMapSize;\n         } else {\n-          wrongSize \u003d storedBlock.getNumBytes() !\u003d reported.getNumBytes();\n+          blockMapSize \u003d storedBlock.getNumBytes();\n+          wrongSize \u003d blockMapSize !\u003d reported.getNumBytes();\n         }\n         if (wrongSize) {\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n-              \"length in block map \" + storedBlock.getNumBytes(),\n+              \"length in block map \" + blockMapSize,\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       case UNDER_CONSTRUCTION:\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported state \" + reportedState\n               + \", But reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       final long reportedGS \u003d reported.getGenerationStamp();\n       if (!storedBlock.isComplete()) {\n         //When DN report lesser GS than the storedBlock then mark it is corrupt,\n         //As already valid replica will be present.\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               reportedGS,\n               \"reported \" + reportedState + \" replica with genstamp \"\n                   + reportedGS\n                   + \" does not match Stored block\u0027s genstamp in block map \"\n                   + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n             + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for {} on {}: ignoring it, since \"\n                   + \"it is complete with the same genstamp\", storedBlock, dn);\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(\"{}\", msg);\n       return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n           Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState,\n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        boolean wrongSize;\n        long blockMapSize;\n        if (storedBlock.isStriped()) {\n          assert BlockIdManager.isStripedBlockID(reported.getBlockId());\n          assert storedBlock.getBlockId() \u003d\u003d\n              BlockIdManager.convertToStripedID(reported.getBlockId());\n          BlockInfoStriped stripedBlock \u003d (BlockInfoStriped) storedBlock;\n          int reportedBlkIdx \u003d BlockIdManager.getBlockIndex(reported);\n          blockMapSize \u003d getInternalBlockLength(stripedBlock.getNumBytes(),\n              stripedBlock.getCellSize(), stripedBlock.getDataBlockNum(),\n              reportedBlkIdx);\n          wrongSize \u003d reported.getNumBytes() !\u003d blockMapSize;\n        } else {\n          blockMapSize \u003d storedBlock.getNumBytes();\n          wrongSize \u003d blockMapSize !\u003d reported.getNumBytes();\n        }\n        if (wrongSize) {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + blockMapSize,\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported state \" + reportedState\n              + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      final long reportedGS \u003d reported.getGenerationStamp();\n      if (!storedBlock.isComplete()) {\n        //When DN report lesser GS than the storedBlock then mark it is corrupt,\n        //As already valid replica will be present.\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              reportedGS,\n              \"reported \" + reportedState + \" replica with genstamp \"\n                  + reportedGS\n                  + \" does not match Stored block\u0027s genstamp in block map \"\n                  + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for {} on {}: ignoring it, since \"\n                  + \"it is complete with the same genstamp\", storedBlock, dn);\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(\"{}\", msg);\n      return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n          Reason.INVALID_STATE);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "e0ff8e2c10f38298b81624df1e62743ac171f18d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13840. RBW Blocks which are having less GS should be added to Corrupt. Contributed by Brahma Reddy Battula\n",
      "commitDate": "26/09/18 11:14 AM",
      "commitName": "e0ff8e2c10f38298b81624df1e62743ac171f18d",
      "commitAuthor": "Brahma Reddy Battula",
      "commitDateOld": "30/08/18 9:45 AM",
      "commitNameOld": "c36d69a7b30927eaea16335e06cfcc247accde35",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 27.06,
      "commitsBetweenForRepo": 274,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,98 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState,\n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         boolean wrongSize;\n         if (storedBlock.isStriped()) {\n           assert BlockIdManager.isStripedBlockID(reported.getBlockId());\n           assert storedBlock.getBlockId() \u003d\u003d\n               BlockIdManager.convertToStripedID(reported.getBlockId());\n           BlockInfoStriped stripedBlock \u003d (BlockInfoStriped) storedBlock;\n           int reportedBlkIdx \u003d BlockIdManager.getBlockIndex(reported);\n           wrongSize \u003d reported.getNumBytes() !\u003d getInternalBlockLength(\n               stripedBlock.getNumBytes(), stripedBlock.getCellSize(),\n               stripedBlock.getDataBlockNum(), reportedBlkIdx);\n         } else {\n           wrongSize \u003d storedBlock.getNumBytes() !\u003d reported.getNumBytes();\n         }\n         if (wrongSize) {\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes(),\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       case UNDER_CONSTRUCTION:\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported state \" + reportedState\n               + \", But reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n+      final long reportedGS \u003d reported.getGenerationStamp();\n       if (!storedBlock.isComplete()) {\n+        //When DN report lesser GS than the storedBlock then mark it is corrupt,\n+        //As already valid replica will be present.\n+        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n+          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n+              reportedGS,\n+              \"reported \" + reportedState + \" replica with genstamp \"\n+                  + reportedGS\n+                  + \" does not match Stored block\u0027s genstamp in block map \"\n+                  + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n+        }\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n-        final long reportedGS \u003d reported.getGenerationStamp();\n         return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n             + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for {} on {}: ignoring it, since \"\n                   + \"it is complete with the same genstamp\", storedBlock, dn);\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(\"{}\", msg);\n       return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n           Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState,\n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        boolean wrongSize;\n        if (storedBlock.isStriped()) {\n          assert BlockIdManager.isStripedBlockID(reported.getBlockId());\n          assert storedBlock.getBlockId() \u003d\u003d\n              BlockIdManager.convertToStripedID(reported.getBlockId());\n          BlockInfoStriped stripedBlock \u003d (BlockInfoStriped) storedBlock;\n          int reportedBlkIdx \u003d BlockIdManager.getBlockIndex(reported);\n          wrongSize \u003d reported.getNumBytes() !\u003d getInternalBlockLength(\n              stripedBlock.getNumBytes(), stripedBlock.getCellSize(),\n              stripedBlock.getDataBlockNum(), reportedBlkIdx);\n        } else {\n          wrongSize \u003d storedBlock.getNumBytes() !\u003d reported.getNumBytes();\n        }\n        if (wrongSize) {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported state \" + reportedState\n              + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      final long reportedGS \u003d reported.getGenerationStamp();\n      if (!storedBlock.isComplete()) {\n        //When DN report lesser GS than the storedBlock then mark it is corrupt,\n        //As already valid replica will be present.\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              reportedGS,\n              \"reported \" + reportedState + \" replica with genstamp \"\n                  + reportedGS\n                  + \" does not match Stored block\u0027s genstamp in block map \"\n                  + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for {} on {}: ignoring it, since \"\n                  + \"it is complete with the same genstamp\", storedBlock, dn);\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(\"{}\", msg);\n      return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n          Reason.INVALID_STATE);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "a7f085d6bf499edf23e650a4f7211c53a442da0e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11832. Switch leftover logs to slf4j format in BlockManager.java. Contributed by Hui Xu and Chen Liang.\n",
      "commitDate": "29/05/17 1:30 AM",
      "commitName": "a7f085d6bf499edf23e650a4f7211c53a442da0e",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "25/05/17 7:35 AM",
      "commitNameOld": "2e41f8803dd46d1bab16c1b206c71be72ea260a1",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 3.75,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,88 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState,\n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         boolean wrongSize;\n         if (storedBlock.isStriped()) {\n           assert BlockIdManager.isStripedBlockID(reported.getBlockId());\n           assert storedBlock.getBlockId() \u003d\u003d\n               BlockIdManager.convertToStripedID(reported.getBlockId());\n           BlockInfoStriped stripedBlock \u003d (BlockInfoStriped) storedBlock;\n           int reportedBlkIdx \u003d BlockIdManager.getBlockIndex(reported);\n           wrongSize \u003d reported.getNumBytes() !\u003d getInternalBlockLength(\n               stripedBlock.getNumBytes(), stripedBlock.getCellSize(),\n               stripedBlock.getDataBlockNum(), reportedBlkIdx);\n         } else {\n           wrongSize \u003d storedBlock.getNumBytes() !\u003d reported.getNumBytes();\n         }\n         if (wrongSize) {\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes(),\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       case UNDER_CONSTRUCTION:\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported state \" + reportedState\n               + \", But reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n         return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n             + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n-          LOG.info(\"Received an RBW replica for \" + storedBlock +\n-              \" on \" + dn + \": ignoring it, since it is \" +\n-              \"complete with the same genstamp\");\n+          LOG.info(\"Received an RBW replica for {} on {}: ignoring it, since \"\n+                  + \"it is complete with the same genstamp\", storedBlock, dn);\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n-      LOG.warn(msg);\n+      LOG.warn(\"{}\", msg);\n       return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n           Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState,\n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        boolean wrongSize;\n        if (storedBlock.isStriped()) {\n          assert BlockIdManager.isStripedBlockID(reported.getBlockId());\n          assert storedBlock.getBlockId() \u003d\u003d\n              BlockIdManager.convertToStripedID(reported.getBlockId());\n          BlockInfoStriped stripedBlock \u003d (BlockInfoStriped) storedBlock;\n          int reportedBlkIdx \u003d BlockIdManager.getBlockIndex(reported);\n          wrongSize \u003d reported.getNumBytes() !\u003d getInternalBlockLength(\n              stripedBlock.getNumBytes(), stripedBlock.getCellSize(),\n              stripedBlock.getDataBlockNum(), reportedBlkIdx);\n        } else {\n          wrongSize \u003d storedBlock.getNumBytes() !\u003d reported.getNumBytes();\n        }\n        if (wrongSize) {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported state \" + reportedState\n              + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for {} on {}: ignoring it, since \"\n                  + \"it is complete with the same genstamp\", storedBlock, dn);\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(\"{}\", msg);\n      return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n          Reason.INVALID_STATE);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "c09dc258a8f64fab852bf6f26187163480dbee3c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8882. Erasure Coding: Use datablocks, parityblocks and cell size from ErasureCodingPolicy. Contributed by Vinayakumar B.\n\nChange-Id: Ic56da0b426f47c63dac440aef6f5fc8554f6cf13\n",
      "commitDate": "23/09/15 1:34 PM",
      "commitName": "c09dc258a8f64fab852bf6f26187163480dbee3c",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "22/09/15 1:27 PM",
      "commitNameOld": "1080c3730068177ddd10dc313890ac1f5dc58f1a",
      "commitAuthorOld": "",
      "daysBetweenCommits": 1.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,89 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState,\n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         boolean wrongSize;\n         if (storedBlock.isStriped()) {\n           assert BlockIdManager.isStripedBlockID(reported.getBlockId());\n           assert storedBlock.getBlockId() \u003d\u003d\n               BlockIdManager.convertToStripedID(reported.getBlockId());\n           BlockInfoStriped stripedBlock \u003d (BlockInfoStriped) storedBlock;\n           int reportedBlkIdx \u003d BlockIdManager.getBlockIndex(reported);\n-          wrongSize \u003d reported.getNumBytes() !\u003d\n-              getInternalBlockLength(stripedBlock.getNumBytes(),\n-                  BLOCK_STRIPED_CELL_SIZE,\n-                  stripedBlock.getDataBlockNum(), reportedBlkIdx);\n+          wrongSize \u003d reported.getNumBytes() !\u003d getInternalBlockLength(\n+              stripedBlock.getNumBytes(), stripedBlock.getCellSize(),\n+              stripedBlock.getDataBlockNum(), reportedBlkIdx);\n         } else {\n           wrongSize \u003d storedBlock.getNumBytes() !\u003d reported.getNumBytes();\n         }\n         if (wrongSize) {\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes(),\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       case UNDER_CONSTRUCTION:\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported state \" + reportedState\n               + \", But reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n         return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n             + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since it is \" +\n               \"complete with the same genstamp\");\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n       return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n           Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState,\n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        boolean wrongSize;\n        if (storedBlock.isStriped()) {\n          assert BlockIdManager.isStripedBlockID(reported.getBlockId());\n          assert storedBlock.getBlockId() \u003d\u003d\n              BlockIdManager.convertToStripedID(reported.getBlockId());\n          BlockInfoStriped stripedBlock \u003d (BlockInfoStriped) storedBlock;\n          int reportedBlkIdx \u003d BlockIdManager.getBlockIndex(reported);\n          wrongSize \u003d reported.getNumBytes() !\u003d getInternalBlockLength(\n              stripedBlock.getNumBytes(), stripedBlock.getCellSize(),\n              stripedBlock.getDataBlockNum(), reportedBlkIdx);\n        } else {\n          wrongSize \u003d storedBlock.getNumBytes() !\u003d reported.getNumBytes();\n        }\n        if (wrongSize) {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported state \" + reportedState\n              + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since it is \" +\n              \"complete with the same genstamp\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n          Reason.INVALID_STATE);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8623. Refactor NameNode handling of invalid, corrupt, and under-recovery blocks. Contributed by Zhe Zhang.\"\n\nThis reverts commit de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5.\n",
      "commitDate": "06/08/15 10:21 AM",
      "commitName": "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "31/07/15 4:15 PM",
      "commitNameOld": "d311a38a6b32bbb210bd8748cfb65463e9c0740e",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 5.75,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,74 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState,\n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n-          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n+          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n-                  + \" does not match genstamp in block map \"\n-                  + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n+              + \" does not match genstamp in block map \"\n+              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n-          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n+          return new BlockToMarkCorrupt(storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n-                  reported.getNumBytes() + \" does not match \" +\n-                  \"length in block map \" + storedBlock.getNumBytes(),\n+              reported.getNumBytes() + \" does not match \" +\n+              \"length in block map \" + storedBlock.getNumBytes(),\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       case UNDER_CONSTRUCTION:\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n-          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n-              reportedGS, \"block is \" + ucState + \" and reported state \"\n-              + reportedState + \", But reported genstamp \" + reportedGS\n+          return new BlockToMarkCorrupt(storedBlock, reportedGS, \"block is \"\n+              + ucState + \" and reported state \" + reportedState\n+              + \", But reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n-              + storedBlock.getGenerationStamp(),\n-              Reason.GENSTAMP_MISMATCH);\n+              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n-      } else if (storedBlock.getGenerationStamp() !\u003d\n-          reported.getGenerationStamp()) {\n+      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n-        return new BlockToMarkCorrupt(\n-            new Block(reported), storedBlock, reportedGS,\n-            \"reported \" + reportedState +\n-                \" replica with genstamp \" + reportedGS +\n-                \" does not match COMPLETE block\u0027s genstamp in block map \" +\n-                storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n+        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n+            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n+            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n+            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since it is \" +\n               \"complete with the same genstamp\");\n           return null;\n         } else {\n-          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n+          return new BlockToMarkCorrupt(storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n-      return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n-          Reason.INVALID_STATE);\n+      return new BlockToMarkCorrupt(storedBlock, msg, Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState,\n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(storedBlock, reportedGS, \"block is \"\n              + ucState + \" and reported state \" + reportedState\n              + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since it is \" +\n              \"complete with the same genstamp\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(storedBlock, msg, Reason.INVALID_STATE);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8623. Refactor NameNode handling of invalid, corrupt, and under-recovery blocks. Contributed by Zhe Zhang.\n",
      "commitDate": "26/06/15 10:49 AM",
      "commitName": "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "24/06/15 2:42 PM",
      "commitNameOld": "afe9ea3c12e1f5a71922400eadb642960bc87ca1",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,79 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState,\n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n-          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n+          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n-              + \" does not match genstamp in block map \"\n-              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n+                  + \" does not match genstamp in block map \"\n+                  + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n-          return new BlockToMarkCorrupt(storedBlock,\n+          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n-              reported.getNumBytes() + \" does not match \" +\n-              \"length in block map \" + storedBlock.getNumBytes(),\n+                  reported.getNumBytes() + \" does not match \" +\n+                  \"length in block map \" + storedBlock.getNumBytes(),\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       case UNDER_CONSTRUCTION:\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n-          return new BlockToMarkCorrupt(storedBlock, reportedGS, \"block is \"\n-              + ucState + \" and reported state \" + reportedState\n-              + \", But reported genstamp \" + reportedGS\n+          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n+              reportedGS, \"block is \" + ucState + \" and reported state \"\n+              + reportedState + \", But reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n-              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n+              + storedBlock.getGenerationStamp(),\n+              Reason.GENSTAMP_MISMATCH);\n         }\n         return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n-      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n+      } else if (storedBlock.getGenerationStamp() !\u003d\n+          reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n-        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n-            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n-            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n-            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n+        return new BlockToMarkCorrupt(\n+            new Block(reported), storedBlock, reportedGS,\n+            \"reported \" + reportedState +\n+                \" replica with genstamp \" + reportedGS +\n+                \" does not match COMPLETE block\u0027s genstamp in block map \" +\n+                storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since it is \" +\n               \"complete with the same genstamp\");\n           return null;\n         } else {\n-          return new BlockToMarkCorrupt(storedBlock,\n+          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n-      return new BlockToMarkCorrupt(storedBlock, msg, Reason.INVALID_STATE);\n+      return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n+          Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState,\n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n                  + \" does not match genstamp in block map \"\n                  + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n                  reported.getNumBytes() + \" does not match \" +\n                  \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              reportedGS, \"block is \" + ucState + \" and reported state \"\n              + reportedState + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(),\n              Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d\n          reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(\n            new Block(reported), storedBlock, reportedGS,\n            \"reported \" + reportedState +\n                \" replica with genstamp \" + reportedGS +\n                \" does not match COMPLETE block\u0027s genstamp in block map \" +\n                storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since it is \" +\n              \"complete with the same genstamp\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n          Reason.INVALID_STATE);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Yparameterchange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "19/05/15 11:05 AM",
      "commitNameOld": "8860e352c394372e4eb3ebdf82ea899567f34e4e",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 8.19,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n-      BlockInfoContiguous storedBlock, BlockUCState ucState,\n+      BlockInfo storedBlock, BlockUCState ucState,\n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes(),\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       case UNDER_CONSTRUCTION:\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(storedBlock, reportedGS, \"block is \"\n               + ucState + \" and reported state \" + reportedState\n               + \", But reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n         return new BlockToMarkCorrupt(storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n             + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since it is \" +\n               \"complete with the same genstamp\");\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n       return new BlockToMarkCorrupt(storedBlock, msg, Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState,\n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(storedBlock, reportedGS, \"block is \"\n              + ucState + \" and reported state \" + reportedState\n              + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since it is \" +\n              \"complete with the same genstamp\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(storedBlock, msg, Reason.INVALID_STATE);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {
        "oldValue": "[reported-Block, reportedState-ReplicaState, storedBlock-BlockInfoContiguous, ucState-BlockUCState, dn-DatanodeDescriptor]",
        "newValue": "[reported-Block, reportedState-ReplicaState, storedBlock-BlockInfo, ucState-BlockUCState, dn-DatanodeDescriptor]"
      }
    },
    "b008348dbf9bdd5070930be5d182116c5d370f6b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8418. Fix the isNeededReplication calculation for Striped block in NN. Contributed by Yi Liu.\n",
      "commitDate": "26/05/15 12:02 PM",
      "commitName": "b008348dbf9bdd5070930be5d182116c5d370f6b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 12:02 PM",
      "commitNameOld": "d8ea443af0b1c8289a1dd738945831ff8be0e9c1",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState,\n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         boolean wrongSize;\n         if (storedBlock.isStriped()) {\n           assert BlockIdManager.isStripedBlockID(reported.getBlockId());\n           assert storedBlock.getBlockId() \u003d\u003d\n               BlockIdManager.convertToStripedID(reported.getBlockId());\n           BlockInfoStriped stripedBlock \u003d (BlockInfoStriped) storedBlock;\n           int reportedBlkIdx \u003d BlockIdManager.getBlockIndex(reported);\n           wrongSize \u003d reported.getNumBytes() !\u003d\n               getInternalBlockLength(stripedBlock.getNumBytes(),\n-                  HdfsConstants.BLOCK_STRIPED_CELL_SIZE,\n+                  BLOCK_STRIPED_CELL_SIZE,\n                   stripedBlock.getDataBlockNum(), reportedBlkIdx);\n         } else {\n           wrongSize \u003d storedBlock.getNumBytes() !\u003d reported.getNumBytes();\n         }\n         if (wrongSize) {\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes(),\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       case UNDER_CONSTRUCTION:\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported state \" + reportedState\n               + \", But reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n         return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n             + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since it is \" +\n               \"complete with the same genstamp\");\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n       return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n           Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState,\n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        boolean wrongSize;\n        if (storedBlock.isStriped()) {\n          assert BlockIdManager.isStripedBlockID(reported.getBlockId());\n          assert storedBlock.getBlockId() \u003d\u003d\n              BlockIdManager.convertToStripedID(reported.getBlockId());\n          BlockInfoStriped stripedBlock \u003d (BlockInfoStriped) storedBlock;\n          int reportedBlkIdx \u003d BlockIdManager.getBlockIndex(reported);\n          wrongSize \u003d reported.getNumBytes() !\u003d\n              getInternalBlockLength(stripedBlock.getNumBytes(),\n                  BLOCK_STRIPED_CELL_SIZE,\n                  stripedBlock.getDataBlockNum(), reportedBlkIdx);\n        } else {\n          wrongSize \u003d storedBlock.getNumBytes() !\u003d reported.getNumBytes();\n        }\n        if (wrongSize) {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported state \" + reportedState\n              + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since it is \" +\n              \"complete with the same genstamp\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n          Reason.INVALID_STATE);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "5e8837dd6cc747b3259751930f2a9eed7163bcad": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8120. Erasure coding: created util class to analyze striped block groups. Contributed by Zhe Zhang and Li Bo.\n",
      "commitDate": "26/05/15 11:59 AM",
      "commitName": "5e8837dd6cc747b3259751930f2a9eed7163bcad",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:58 AM",
      "commitNameOld": "4d0bc724f29b646e252f53d1c654a23e8526a4bf",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,90 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState,\n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n-        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n+        }\n+        boolean wrongSize;\n+        if (storedBlock.isStriped()) {\n+          assert BlockIdManager.isStripedBlockID(reported.getBlockId());\n+          assert storedBlock.getBlockId() \u003d\u003d\n+              BlockIdManager.convertToStripedID(reported.getBlockId());\n+          BlockInfoStriped stripedBlock \u003d (BlockInfoStriped) storedBlock;\n+          int reportedBlkIdx \u003d BlockIdManager.getBlockIndex(reported);\n+          wrongSize \u003d reported.getNumBytes() !\u003d\n+              getInternalBlockLength(stripedBlock.getNumBytes(),\n+                  HdfsConstants.BLOCK_STRIPED_CELL_SIZE,\n+                  stripedBlock.getDataBlockNum(), reportedBlkIdx);\n+        } else {\n+          wrongSize \u003d storedBlock.getNumBytes() !\u003d reported.getNumBytes();\n+        }\n+        if (wrongSize) {\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes(),\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       case UNDER_CONSTRUCTION:\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported state \" + reportedState\n               + \", But reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n         return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n             + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since it is \" +\n               \"complete with the same genstamp\");\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n       return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n           Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState,\n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        boolean wrongSize;\n        if (storedBlock.isStriped()) {\n          assert BlockIdManager.isStripedBlockID(reported.getBlockId());\n          assert storedBlock.getBlockId() \u003d\u003d\n              BlockIdManager.convertToStripedID(reported.getBlockId());\n          BlockInfoStriped stripedBlock \u003d (BlockInfoStriped) storedBlock;\n          int reportedBlkIdx \u003d BlockIdManager.getBlockIndex(reported);\n          wrongSize \u003d reported.getNumBytes() !\u003d\n              getInternalBlockLength(stripedBlock.getNumBytes(),\n                  HdfsConstants.BLOCK_STRIPED_CELL_SIZE,\n                  stripedBlock.getDataBlockNum(), reportedBlkIdx);\n        } else {\n          wrongSize \u003d storedBlock.getNumBytes() !\u003d reported.getNumBytes();\n        }\n        if (wrongSize) {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported state \" + reportedState\n              + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since it is \" +\n              \"complete with the same genstamp\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n          Reason.INVALID_STATE);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "4d0bc724f29b646e252f53d1c654a23e8526a4bf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8077. Erasure coding: fix bugs in EC zone and symlinks. Contributed by Jing Zhao and Zhe Zhang.\n",
      "commitDate": "26/05/15 11:58 AM",
      "commitName": "4d0bc724f29b646e252f53d1c654a23e8526a4bf",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:55 AM",
      "commitNameOld": "c243319eab89928bc06e0357a50f9422cbe54f7d",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState,\n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n-          return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n+          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n-          return new BlockToMarkCorrupt(reported, storedBlock,\n+          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes(),\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       case UNDER_CONSTRUCTION:\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n-          return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n+          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported state \" + reportedState\n               + \", But reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n-        return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n+        return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n             + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since it is \" +\n               \"complete with the same genstamp\");\n           return null;\n         } else {\n-          return new BlockToMarkCorrupt(reported, storedBlock,\n+          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n-      return new BlockToMarkCorrupt(reported, storedBlock, msg,\n+      return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n           Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState,\n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported state \" + reportedState\n              + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(new Block(reported), storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since it is \" +\n              \"complete with the same genstamp\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(new Block(reported), storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(new Block(reported), storedBlock, msg,\n          Reason.INVALID_STATE);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "ba9371492036983a9899398907ab41fe548f29b3": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7716. Erasure Coding: extend BlockInfo to handle EC info. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:07 AM",
      "commitName": "ba9371492036983a9899398907ab41fe548f29b3",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7716. Erasure Coding: extend BlockInfo to handle EC info. Contributed by Jing Zhao.\n",
          "commitDate": "26/05/15 11:07 AM",
          "commitName": "ba9371492036983a9899398907ab41fe548f29b3",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "26/05/15 11:03 AM",
          "commitNameOld": "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8",
          "commitAuthorOld": "Zhe Zhang",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,75 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n-      BlockInfoContiguous storedBlock, BlockUCState ucState,\n+      BlockInfo storedBlock, BlockUCState ucState,\n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n-          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n+          return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n-          return new BlockToMarkCorrupt(storedBlock,\n+          return new BlockToMarkCorrupt(reported, storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes(),\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       case UNDER_CONSTRUCTION:\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n-          return new BlockToMarkCorrupt(storedBlock, reportedGS, \"block is \"\n-              + ucState + \" and reported state \" + reportedState\n+          return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n+              \"block is \" + ucState + \" and reported state \" + reportedState\n               + \", But reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n-        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n+        return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n             + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since it is \" +\n               \"complete with the same genstamp\");\n           return null;\n         } else {\n-          return new BlockToMarkCorrupt(storedBlock,\n+          return new BlockToMarkCorrupt(reported, storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n-      return new BlockToMarkCorrupt(storedBlock, msg, Reason.INVALID_STATE);\n+      return new BlockToMarkCorrupt(reported, storedBlock, msg,\n+          Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState,\n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n          return new BlockToMarkCorrupt(reported, storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported state \" + reportedState\n              + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since it is \" +\n              \"complete with the same genstamp\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(reported, storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(reported, storedBlock, msg,\n          Reason.INVALID_STATE);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {
            "oldValue": "[reported-Block, reportedState-ReplicaState, storedBlock-BlockInfoContiguous, ucState-BlockUCState, dn-DatanodeDescriptor]",
            "newValue": "[reported-Block, reportedState-ReplicaState, storedBlock-BlockInfo, ucState-BlockUCState, dn-DatanodeDescriptor]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7716. Erasure Coding: extend BlockInfo to handle EC info. Contributed by Jing Zhao.\n",
          "commitDate": "26/05/15 11:07 AM",
          "commitName": "ba9371492036983a9899398907ab41fe548f29b3",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "26/05/15 11:03 AM",
          "commitNameOld": "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8",
          "commitAuthorOld": "Zhe Zhang",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,75 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n-      BlockInfoContiguous storedBlock, BlockUCState ucState,\n+      BlockInfo storedBlock, BlockUCState ucState,\n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n-          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n+          return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n-          return new BlockToMarkCorrupt(storedBlock,\n+          return new BlockToMarkCorrupt(reported, storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes(),\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       case UNDER_CONSTRUCTION:\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n-          return new BlockToMarkCorrupt(storedBlock, reportedGS, \"block is \"\n-              + ucState + \" and reported state \" + reportedState\n+          return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n+              \"block is \" + ucState + \" and reported state \" + reportedState\n               + \", But reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n-        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n+        return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n             + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since it is \" +\n               \"complete with the same genstamp\");\n           return null;\n         } else {\n-          return new BlockToMarkCorrupt(storedBlock,\n+          return new BlockToMarkCorrupt(reported, storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n-      return new BlockToMarkCorrupt(storedBlock, msg, Reason.INVALID_STATE);\n+      return new BlockToMarkCorrupt(reported, storedBlock, msg,\n+          Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState,\n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n          return new BlockToMarkCorrupt(reported, storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported state \" + reportedState\n              + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(reported, storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since it is \" +\n              \"complete with the same genstamp\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(reported, storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(reported, storedBlock, msg,\n          Reason.INVALID_STATE);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": {
      "type": "Yparameterchange",
      "commitMessage": "HDFS-7743. Code cleanup of BlockInfo and rename BlockInfo to BlockInfoContiguous. Contributed by Jing Zhao.\n",
      "commitDate": "08/02/15 11:51 AM",
      "commitName": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "04/02/15 11:31 AM",
      "commitNameOld": "9175105eeaecf0a1d60b57989b73ce45cee4689b",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.01,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n-      BlockInfo storedBlock, BlockUCState ucState, \n+      BlockInfoContiguous storedBlock, BlockUCState ucState,\n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes(),\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       case UNDER_CONSTRUCTION:\n         if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(storedBlock, reportedGS, \"block is \"\n               + ucState + \" and reported state \" + reportedState\n               + \", But reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         }\n         return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n         return new BlockToMarkCorrupt(storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n             + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since it is \" +\n               \"complete with the same genstamp\");\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n       return new BlockToMarkCorrupt(storedBlock, msg, Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfoContiguous storedBlock, BlockUCState ucState,\n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(storedBlock, reportedGS, \"block is \"\n              + ucState + \" and reported state \" + reportedState\n              + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since it is \" +\n              \"complete with the same genstamp\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(storedBlock, msg, Reason.INVALID_STATE);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {
        "oldValue": "[reported-Block, reportedState-ReplicaState, storedBlock-BlockInfo, ucState-BlockUCState, dn-DatanodeDescriptor]",
        "newValue": "[reported-Block, reportedState-ReplicaState, storedBlock-BlockInfoContiguous, ucState-BlockUCState, dn-DatanodeDescriptor]"
      }
    },
    "30a9ec26f799977ba36d8860daf0a90705927fae": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5723. Append failed FINALIZED replica should not be accepted as valid when that block is underconstruction. Contributed by Vinayakumar B.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615491 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/08/14 11:44 PM",
      "commitName": "30a9ec26f799977ba36d8860daf0a90705927fae",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "01/08/14 9:58 AM",
      "commitNameOld": "45db4d204b796eee6dd0e39d3cc94b70c47028d4",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 2.57,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,74 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState, \n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes(),\n               Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n+      case UNDER_CONSTRUCTION:\n+        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n+          final long reportedGS \u003d reported.getGenerationStamp();\n+          return new BlockToMarkCorrupt(storedBlock, reportedGS, \"block is \"\n+              + ucState + \" and reported state \" + reportedState\n+              + \", But reported genstamp \" + reportedGS\n+              + \" does not match genstamp in block map \"\n+              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n+        }\n+        return null;\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n         return new BlockToMarkCorrupt(storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n             + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since it is \" +\n               \"complete with the same genstamp\");\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"reported replica has invalid state \" + reportedState,\n               Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n       return new BlockToMarkCorrupt(storedBlock, msg, Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState, \n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      case UNDER_CONSTRUCTION:\n        if (storedBlock.getGenerationStamp() \u003e reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(storedBlock, reportedGS, \"block is \"\n              + ucState + \" and reported state \" + reportedState\n              + \", But reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        }\n        return null;\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since it is \" +\n              \"complete with the same genstamp\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(storedBlock, msg, Reason.INVALID_STATE);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "ceea91c9cd8b2a18be13217894ccf1c17198de18": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5438. Flaws in block report processing can cause data loss. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1542054 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/11/13 12:11 PM",
      "commitName": "ceea91c9cd8b2a18be13217894ccf1c17198de18",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "16/10/13 7:14 PM",
      "commitNameOld": "34f08944b7c8d58f531a3f3bf3d4ee4cd3fa643a",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 28.75,
      "commitsBetweenForRepo": 147,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,64 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState, \n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n-              + storedBlock.getGenerationStamp());\n+              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n         } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n-              \"length in block map \" + storedBlock.getNumBytes());\n+              \"length in block map \" + storedBlock.getNumBytes(),\n+              Reason.SIZE_MISMATCH);\n         } else {\n           return null; // not corrupt\n         }\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n         return new BlockToMarkCorrupt(storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n-            + storedBlock.getGenerationStamp());\n+            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since it is \" +\n               \"complete with the same genstamp\");\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(storedBlock,\n-              \"reported replica has invalid state \" + reportedState);\n+              \"reported replica has invalid state \" + reportedState,\n+              Reason.INVALID_STATE);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n-      return new BlockToMarkCorrupt(storedBlock, msg);\n+      return new BlockToMarkCorrupt(storedBlock, msg, Reason.INVALID_STATE);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState, \n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes(),\n              Reason.SIZE_MISMATCH);\n        } else {\n          return null; // not corrupt\n        }\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp(), Reason.GENSTAMP_MISMATCH);\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since it is \" +\n              \"complete with the same genstamp\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"reported replica has invalid state \" + reportedState,\n              Reason.INVALID_STATE);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(storedBlock, msg, Reason.INVALID_STATE);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4122. Cleanup HDFS logs and reduce the size of logged messages. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1403120 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/12 4:10 PM",
      "commitName": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "22/10/12 11:30 AM",
      "commitNameOld": "75cdb5bb4965161021df47376cccf058bf413f3b",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 6.19,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState, \n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n           final long reportedGS \u003d reported.getGenerationStamp();\n           return new BlockToMarkCorrupt(storedBlock, reportedGS,\n               \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n               + \" does not match genstamp in block map \"\n               + storedBlock.getGenerationStamp());\n         } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes());\n         } else {\n           return null; // not corrupt\n         }\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n         final long reportedGS \u003d reported.getGenerationStamp();\n         return new BlockToMarkCorrupt(storedBlock, reportedGS,\n             \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n             + \" does not match COMPLETE block\u0027s genstamp in block map \"\n             + storedBlock.getGenerationStamp());\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n-          LOG.info(\"Received an RBW replica for block \" + storedBlock +\n-              \" on \" + dn + \": ignoring it, since the block is \" +\n-              \"complete with the same generation stamp.\");\n+          LOG.info(\"Received an RBW replica for \" + storedBlock +\n+              \" on \" + dn + \": ignoring it, since it is \" +\n+              \"complete with the same genstamp\");\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"reported replica has invalid state \" + reportedState);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n       return new BlockToMarkCorrupt(storedBlock, msg);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState, \n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp());\n        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes());\n        } else {\n          return null; // not corrupt\n        }\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp());\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since it is \" +\n              \"complete with the same genstamp\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"reported replica has invalid state \" + reportedState);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(storedBlock, msg);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "28e8151ad3defc85a4ac1d19b39a9377253c718f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-3157. Fix a bug in the case that the generation stamps of the stored block in a namenode and the reported block from a datanode do not match.  Contributed by Ashish Singhi\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1356086 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/07/12 12:26 AM",
      "commitName": "28e8151ad3defc85a4ac1d19b39a9377253c718f",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-3157. Fix a bug in the case that the generation stamps of the stored block in a namenode and the reported block from a datanode do not match.  Contributed by Ashish Singhi\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1356086 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/07/12 12:26 AM",
          "commitName": "28e8151ad3defc85a4ac1d19b39a9377253c718f",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "28/06/12 10:54 AM",
          "commitNameOld": "550853203b3a76078833f392912896f5442e1db5",
          "commitAuthorOld": "Eli Collins",
          "daysBetweenCommits": 3.56,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,62 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n-      Block iblk, ReplicaState reportedState, \n+      Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState, \n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n-        if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n-          return new BlockToMarkCorrupt(storedBlock,\n-              \"block is \" + ucState + \" and reported genstamp \" +\n-              iblk.getGenerationStamp() + \" does not match \" +\n-              \"genstamp in block map \" + storedBlock.getGenerationStamp());\n-        } else if (storedBlock.getNumBytes() !\u003d iblk.getNumBytes()) {\n+        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n+          final long reportedGS \u003d reported.getGenerationStamp();\n+          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n+              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n+              + \" does not match genstamp in block map \"\n+              + storedBlock.getGenerationStamp());\n+        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n-              iblk.getNumBytes() + \" does not match \" +\n+              reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes());\n         } else {\n           return null; // not corrupt\n         }\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n-      } else if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n-        return new BlockToMarkCorrupt(storedBlock,\n-            \"reported \" + reportedState + \" replica with genstamp \" +\n-            iblk.getGenerationStamp() + \" does not match COMPLETE block\u0027s \" +\n-            \"genstamp in block map \" + storedBlock.getGenerationStamp());\n+      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n+        final long reportedGS \u003d reported.getGenerationStamp();\n+        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n+            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n+            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n+            + storedBlock.getGenerationStamp());\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for block \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since the block is \" +\n               \"complete with the same generation stamp.\");\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"reported replica has invalid state \" + reportedState);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n-      // log here at WARN level since this is really a broken HDFS\n-      // invariant\n+      // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n       return new BlockToMarkCorrupt(storedBlock, msg);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState, \n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp());\n        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes());\n        } else {\n          return null; // not corrupt\n        }\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp());\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for block \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since the block is \" +\n              \"complete with the same generation stamp.\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"reported replica has invalid state \" + reportedState);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(storedBlock, msg);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {
            "oldValue": "[iblk-Block, reportedState-ReplicaState, storedBlock-BlockInfo, ucState-BlockUCState, dn-DatanodeDescriptor]",
            "newValue": "[reported-Block, reportedState-ReplicaState, storedBlock-BlockInfo, ucState-BlockUCState, dn-DatanodeDescriptor]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3157. Fix a bug in the case that the generation stamps of the stored block in a namenode and the reported block from a datanode do not match.  Contributed by Ashish Singhi\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1356086 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/07/12 12:26 AM",
          "commitName": "28e8151ad3defc85a4ac1d19b39a9377253c718f",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "28/06/12 10:54 AM",
          "commitNameOld": "550853203b3a76078833f392912896f5442e1db5",
          "commitAuthorOld": "Eli Collins",
          "daysBetweenCommits": 3.56,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,62 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n-      Block iblk, ReplicaState reportedState, \n+      Block reported, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState, \n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n-        if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n-          return new BlockToMarkCorrupt(storedBlock,\n-              \"block is \" + ucState + \" and reported genstamp \" +\n-              iblk.getGenerationStamp() + \" does not match \" +\n-              \"genstamp in block map \" + storedBlock.getGenerationStamp());\n-        } else if (storedBlock.getNumBytes() !\u003d iblk.getNumBytes()) {\n+        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n+          final long reportedGS \u003d reported.getGenerationStamp();\n+          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n+              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n+              + \" does not match genstamp in block map \"\n+              + storedBlock.getGenerationStamp());\n+        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n-              iblk.getNumBytes() + \" does not match \" +\n+              reported.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes());\n         } else {\n           return null; // not corrupt\n         }\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n-      } else if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n-        return new BlockToMarkCorrupt(storedBlock,\n-            \"reported \" + reportedState + \" replica with genstamp \" +\n-            iblk.getGenerationStamp() + \" does not match COMPLETE block\u0027s \" +\n-            \"genstamp in block map \" + storedBlock.getGenerationStamp());\n+      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n+        final long reportedGS \u003d reported.getGenerationStamp();\n+        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n+            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n+            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n+            + storedBlock.getGenerationStamp());\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for block \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since the block is \" +\n               \"complete with the same generation stamp.\");\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"reported replica has invalid state \" + reportedState);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n-      // log here at WARN level since this is really a broken HDFS\n-      // invariant\n+      // log here at WARN level since this is really a broken HDFS invariant\n       LOG.warn(msg);\n       return new BlockToMarkCorrupt(storedBlock, msg);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block reported, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState, \n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n          final long reportedGS \u003d reported.getGenerationStamp();\n          return new BlockToMarkCorrupt(storedBlock, reportedGS,\n              \"block is \" + ucState + \" and reported genstamp \" + reportedGS\n              + \" does not match genstamp in block map \"\n              + storedBlock.getGenerationStamp());\n        } else if (storedBlock.getNumBytes() !\u003d reported.getNumBytes()) {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              reported.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes());\n        } else {\n          return null; // not corrupt\n        }\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d reported.getGenerationStamp()) {\n        final long reportedGS \u003d reported.getGenerationStamp();\n        return new BlockToMarkCorrupt(storedBlock, reportedGS,\n            \"reported \" + reportedState + \" replica with genstamp \" + reportedGS\n            + \" does not match COMPLETE block\u0027s genstamp in block map \"\n            + storedBlock.getGenerationStamp());\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for block \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since the block is \" +\n              \"complete with the same generation stamp.\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"reported replica has invalid state \" + reportedState);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(storedBlock, msg);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "f1ff05bf47a7dfb670bc63e4e6e58d74f6b5b4a7": {
      "type": "Ybodychange",
      "commitMessage": "Reverting (Need to re-do the patch. new BlockInfo does not set iNode ) HDFS-3157. Error in deleting block is keep on coming from DN even after the block report and directory scanning has happened. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1336572 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/05/12 2:59 AM",
      "commitName": "f1ff05bf47a7dfb670bc63e4e6e58d74f6b5b4a7",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "08/05/12 12:45 PM",
      "commitNameOld": "408e558d8d44c07973054229bff422a6c327abf0",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 1.59,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,61 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block iblk, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState, \n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n-          return new BlockToMarkCorrupt(new BlockInfo(iblk, storedBlock\n-              .getINode().getReplication()),\n+          return new BlockToMarkCorrupt(storedBlock,\n               \"block is \" + ucState + \" and reported genstamp \" +\n               iblk.getGenerationStamp() + \" does not match \" +\n               \"genstamp in block map \" + storedBlock.getGenerationStamp());\n         } else if (storedBlock.getNumBytes() !\u003d iblk.getNumBytes()) {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               iblk.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes());\n         } else {\n           return null; // not corrupt\n         }\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n-        return new BlockToMarkCorrupt(new BlockInfo(iblk, storedBlock\n-            .getINode().getReplication()),\n+        return new BlockToMarkCorrupt(storedBlock,\n             \"reported \" + reportedState + \" replica with genstamp \" +\n             iblk.getGenerationStamp() + \" does not match COMPLETE block\u0027s \" +\n             \"genstamp in block map \" + storedBlock.getGenerationStamp());\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for block \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since the block is \" +\n               \"complete with the same generation stamp.\");\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"reported replica has invalid state \" + reportedState);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS\n       // invariant\n       LOG.warn(msg);\n       return new BlockToMarkCorrupt(storedBlock, msg);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block iblk, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState, \n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"block is \" + ucState + \" and reported genstamp \" +\n              iblk.getGenerationStamp() + \" does not match \" +\n              \"genstamp in block map \" + storedBlock.getGenerationStamp());\n        } else if (storedBlock.getNumBytes() !\u003d iblk.getNumBytes()) {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              iblk.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes());\n        } else {\n          return null; // not corrupt\n        }\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n        return new BlockToMarkCorrupt(storedBlock,\n            \"reported \" + reportedState + \" replica with genstamp \" +\n            iblk.getGenerationStamp() + \" does not match COMPLETE block\u0027s \" +\n            \"genstamp in block map \" + storedBlock.getGenerationStamp());\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for block \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since the block is \" +\n              \"complete with the same generation stamp.\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"reported replica has invalid state \" + reportedState);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS\n      // invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(storedBlock, msg);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "408e558d8d44c07973054229bff422a6c327abf0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3157. Error in deleting block is keep on coming from DN even after the block report and directory scanning has happened. Contributed by Ashish Singhi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1335719 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/12 12:45 PM",
      "commitName": "408e558d8d44c07973054229bff422a6c327abf0",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "07/05/12 5:06 PM",
      "commitNameOld": "f0f9a3631fe4950f5cf548f192226836925d0f05",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.82,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,63 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block iblk, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState, \n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n-          return new BlockToMarkCorrupt(storedBlock,\n+          return new BlockToMarkCorrupt(new BlockInfo(iblk, storedBlock\n+              .getINode().getReplication()),\n               \"block is \" + ucState + \" and reported genstamp \" +\n               iblk.getGenerationStamp() + \" does not match \" +\n               \"genstamp in block map \" + storedBlock.getGenerationStamp());\n         } else if (storedBlock.getNumBytes() !\u003d iblk.getNumBytes()) {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               iblk.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes());\n         } else {\n           return null; // not corrupt\n         }\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n-        return new BlockToMarkCorrupt(storedBlock,\n+        return new BlockToMarkCorrupt(new BlockInfo(iblk, storedBlock\n+            .getINode().getReplication()),\n             \"reported \" + reportedState + \" replica with genstamp \" +\n             iblk.getGenerationStamp() + \" does not match COMPLETE block\u0027s \" +\n             \"genstamp in block map \" + storedBlock.getGenerationStamp());\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for block \" + storedBlock +\n               \" on \" + dn + \": ignoring it, since the block is \" +\n               \"complete with the same generation stamp.\");\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"reported replica has invalid state \" + reportedState);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n       \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS\n       // invariant\n       LOG.warn(msg);\n       return new BlockToMarkCorrupt(storedBlock, msg);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block iblk, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState, \n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n          return new BlockToMarkCorrupt(new BlockInfo(iblk, storedBlock\n              .getINode().getReplication()),\n              \"block is \" + ucState + \" and reported genstamp \" +\n              iblk.getGenerationStamp() + \" does not match \" +\n              \"genstamp in block map \" + storedBlock.getGenerationStamp());\n        } else if (storedBlock.getNumBytes() !\u003d iblk.getNumBytes()) {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              iblk.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes());\n        } else {\n          return null; // not corrupt\n        }\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n        return new BlockToMarkCorrupt(new BlockInfo(iblk, storedBlock\n            .getINode().getReplication()),\n            \"reported \" + reportedState + \" replica with genstamp \" +\n            iblk.getGenerationStamp() + \" does not match COMPLETE block\u0027s \" +\n            \"genstamp in block map \" + storedBlock.getGenerationStamp());\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for block \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since the block is \" +\n              \"complete with the same generation stamp.\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"reported replica has invalid state \" + reportedState);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS\n      // invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(storedBlock, msg);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "be7dd8333a7e56e732171db0781786987de03195": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3144. Refactor DatanodeID#getName by use. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308205 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/04/12 3:12 PM",
      "commitName": "be7dd8333a7e56e732171db0781786987de03195",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "31/03/12 12:58 PM",
      "commitNameOld": "8bd825bb6f35fd6fef397e3ccae0898bf7bed201",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 1.09,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n   private BlockToMarkCorrupt checkReplicaCorrupt(\n       Block iblk, ReplicaState reportedState, \n       BlockInfo storedBlock, BlockUCState ucState, \n       DatanodeDescriptor dn) {\n     switch(reportedState) {\n     case FINALIZED:\n       switch(ucState) {\n       case COMPLETE:\n       case COMMITTED:\n         if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"block is \" + ucState + \" and reported genstamp \" +\n               iblk.getGenerationStamp() + \" does not match \" +\n               \"genstamp in block map \" + storedBlock.getGenerationStamp());\n         } else if (storedBlock.getNumBytes() !\u003d iblk.getNumBytes()) {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"block is \" + ucState + \" and reported length \" +\n               iblk.getNumBytes() + \" does not match \" +\n               \"length in block map \" + storedBlock.getNumBytes());\n         } else {\n           return null; // not corrupt\n         }\n       default:\n         return null;\n       }\n     case RBW:\n     case RWR:\n       if (!storedBlock.isComplete()) {\n         return null; // not corrupt\n       } else if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n         return new BlockToMarkCorrupt(storedBlock,\n             \"reported \" + reportedState + \" replica with genstamp \" +\n             iblk.getGenerationStamp() + \" does not match COMPLETE block\u0027s \" +\n             \"genstamp in block map \" + storedBlock.getGenerationStamp());\n       } else { // COMPLETE block, same genstamp\n         if (reportedState \u003d\u003d ReplicaState.RBW) {\n           // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n           // the block report got a little bit delayed after the pipeline\n           // closed. So, ignore this report, assuming we will get a\n           // FINALIZED replica later. See HDFS-2791\n           LOG.info(\"Received an RBW replica for block \" + storedBlock +\n-              \" on \" + dn.getName() + \": ignoring it, since the block is \" +\n+              \" on \" + dn + \": ignoring it, since the block is \" +\n               \"complete with the same generation stamp.\");\n           return null;\n         } else {\n           return new BlockToMarkCorrupt(storedBlock,\n               \"reported replica has invalid state \" + reportedState);\n         }\n       }\n     case RUR:       // should not be reported\n     case TEMPORARY: // should not be reported\n     default:\n       String msg \u003d \"Unexpected replica state \" + reportedState\n       + \" for block: \" + storedBlock + \n-      \" on \" + dn.getName() + \" size \" + storedBlock.getNumBytes();\n+      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n       // log here at WARN level since this is really a broken HDFS\n       // invariant\n       LOG.warn(msg);\n       return new BlockToMarkCorrupt(storedBlock, msg);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockToMarkCorrupt checkReplicaCorrupt(\n      Block iblk, ReplicaState reportedState, \n      BlockInfo storedBlock, BlockUCState ucState, \n      DatanodeDescriptor dn) {\n    switch(reportedState) {\n    case FINALIZED:\n      switch(ucState) {\n      case COMPLETE:\n      case COMMITTED:\n        if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"block is \" + ucState + \" and reported genstamp \" +\n              iblk.getGenerationStamp() + \" does not match \" +\n              \"genstamp in block map \" + storedBlock.getGenerationStamp());\n        } else if (storedBlock.getNumBytes() !\u003d iblk.getNumBytes()) {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"block is \" + ucState + \" and reported length \" +\n              iblk.getNumBytes() + \" does not match \" +\n              \"length in block map \" + storedBlock.getNumBytes());\n        } else {\n          return null; // not corrupt\n        }\n      default:\n        return null;\n      }\n    case RBW:\n    case RWR:\n      if (!storedBlock.isComplete()) {\n        return null; // not corrupt\n      } else if (storedBlock.getGenerationStamp() !\u003d iblk.getGenerationStamp()) {\n        return new BlockToMarkCorrupt(storedBlock,\n            \"reported \" + reportedState + \" replica with genstamp \" +\n            iblk.getGenerationStamp() + \" does not match COMPLETE block\u0027s \" +\n            \"genstamp in block map \" + storedBlock.getGenerationStamp());\n      } else { // COMPLETE block, same genstamp\n        if (reportedState \u003d\u003d ReplicaState.RBW) {\n          // If it\u0027s a RBW report for a COMPLETE block, it may just be that\n          // the block report got a little bit delayed after the pipeline\n          // closed. So, ignore this report, assuming we will get a\n          // FINALIZED replica later. See HDFS-2791\n          LOG.info(\"Received an RBW replica for block \" + storedBlock +\n              \" on \" + dn + \": ignoring it, since the block is \" +\n              \"complete with the same generation stamp.\");\n          return null;\n        } else {\n          return new BlockToMarkCorrupt(storedBlock,\n              \"reported replica has invalid state \" + reportedState);\n        }\n      }\n    case RUR:       // should not be reported\n    case TEMPORARY: // should not be reported\n    default:\n      String msg \u003d \"Unexpected replica state \" + reportedState\n      + \" for block: \" + storedBlock + \n      \" on \" + dn + \" size \" + storedBlock.getNumBytes();\n      // log here at WARN level since this is really a broken HDFS\n      // invariant\n      LOG.warn(msg);\n      return new BlockToMarkCorrupt(storedBlock, msg);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    }
  }
}