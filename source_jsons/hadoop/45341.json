{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RequestHedgingRMFailoverProxyProvider.java",
  "functionName": "invoke",
  "functionId": "invoke___proxy-Object__method-Method(modifiers-final)__args-Object[](modifiers-final)",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/RequestHedgingRMFailoverProxyProvider.java",
  "functionStartLine": 140,
  "functionEndLine": 187,
  "numCommitsSeen": 7,
  "timeTaken": 1598,
  "changeHistory": [
    "eec52e158b7bc14b2d3d53512323ba05e15e09e3",
    "0a166b13472213db0a0cd2dfdaddb2b1746b3957",
    "fa00d3e20560bee412b49e5792595749a247a8ab",
    "618bfd6ac2a5b62d39e9bed80f75362bafc0ef28"
  ],
  "changeHistoryShort": {
    "eec52e158b7bc14b2d3d53512323ba05e15e09e3": "Ybodychange",
    "0a166b13472213db0a0cd2dfdaddb2b1746b3957": "Ybodychange",
    "fa00d3e20560bee412b49e5792595749a247a8ab": "Ybodychange",
    "618bfd6ac2a5b62d39e9bed80f75362bafc0ef28": "Yintroduced"
  },
  "changeHistoryDetails": {
    "eec52e158b7bc14b2d3d53512323ba05e15e09e3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6145. Improve log message on fail over. Contributed by Jian He.\n",
      "commitDate": "08/02/17 2:11 AM",
      "commitName": "eec52e158b7bc14b2d3d53512323ba05e15e09e3",
      "commitAuthor": "Junping Du",
      "commitDateOld": "24/10/16 6:59 PM",
      "commitNameOld": "0a166b13472213db0a0cd2dfdaddb2b1746b3957",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 106.34,
      "commitsBetweenForRepo": 658,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,48 @@\n     public Object invoke(Object proxy, final Method method, final Object[] args)\n         throws Throwable {\n       if (successfulProxy !\u003d null) {\n         return invokeMethod(nonRetriableProxy.get(successfulProxy), method,\n             args);\n       }\n \n+      LOG.info(\"Looking for the active RM in \" + Arrays.toString(rmServiceIds)\n+          + \"...\");\n       ExecutorService executor \u003d null;\n       CompletionService\u003cObject\u003e completionService;\n       try {\n         Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n         executor \u003d HadoopExecutors.newFixedThreadPool(allProxies.size());\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n         for (final ProxyInfo\u003cT\u003e pInfo : allProxies.values()) {\n           Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n             @Override\n             public Object call() throws Exception {\n               return method.invoke(pInfo.proxy, args);\n             }\n           };\n           proxyMap.put(completionService.submit(c), pInfo);\n         }\n \n         Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n         String pInfo \u003d proxyMap.get(callResultFuture).proxyInfo;\n         successfulProxy \u003d pInfo;\n         Object retVal;\n         try {\n           retVal \u003d callResultFuture.get();\n-          LOG.info(\"Invocation successful on [\" + pInfo + \"]\");\n+          LOG.info(\"Found active RM [\" + pInfo + \"]\");\n           return retVal;\n         } catch (Exception ex) {\n           // Throw exception from first responding RM so that clients can handle\n           // appropriately\n           Throwable rootCause \u003d extraRootException(ex);\n           LOG.warn(\"Invocation returned exception: \" + rootCause.toString()\n               + \" on \" + \"[\" + pInfo + \"], so propagating back to caller.\");\n           throw rootCause;\n         }\n \n       } finally {\n         if (executor !\u003d null) {\n           executor.shutdownNow();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      if (successfulProxy !\u003d null) {\n        return invokeMethod(nonRetriableProxy.get(successfulProxy), method,\n            args);\n      }\n\n      LOG.info(\"Looking for the active RM in \" + Arrays.toString(rmServiceIds)\n          + \"...\");\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n        executor \u003d HadoopExecutors.newFixedThreadPool(allProxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final ProxyInfo\u003cT\u003e pInfo : allProxies.values()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override\n            public Object call() throws Exception {\n              return method.invoke(pInfo.proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pInfo);\n        }\n\n        Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n        String pInfo \u003d proxyMap.get(callResultFuture).proxyInfo;\n        successfulProxy \u003d pInfo;\n        Object retVal;\n        try {\n          retVal \u003d callResultFuture.get();\n          LOG.info(\"Found active RM [\" + pInfo + \"]\");\n          return retVal;\n        } catch (Exception ex) {\n          // Throw exception from first responding RM so that clients can handle\n          // appropriately\n          Throwable rootCause \u003d extraRootException(ex);\n          LOG.warn(\"Invocation returned exception: \" + rootCause.toString()\n              + \" on \" + \"[\" + pInfo + \"], so propagating back to caller.\");\n          throw rootCause;\n        }\n\n      } finally {\n        if (executor !\u003d null) {\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/RequestHedgingRMFailoverProxyProvider.java",
      "extendedDetails": {}
    },
    "0a166b13472213db0a0cd2dfdaddb2b1746b3957": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5711. Propogate exceptions back to client when using hedging RM failover provider.\n",
      "commitDate": "24/10/16 6:59 PM",
      "commitName": "0a166b13472213db0a0cd2dfdaddb2b1746b3957",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "10/02/16 10:36 PM",
      "commitNameOld": "fa00d3e20560bee412b49e5792595749a247a8ab",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 256.81,
      "commitsBetweenForRepo": 1789,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,46 @@\n-    public Object invoke(Object proxy, final Method method,\n-        final Object[] args) throws Throwable {\n+    public Object invoke(Object proxy, final Method method, final Object[] args)\n+        throws Throwable {\n       if (successfulProxy !\u003d null) {\n-        return invokeMethod(nonRetriableProxy.get(successfulProxy), method, args);\n+        return invokeMethod(nonRetriableProxy.get(successfulProxy), method,\n+            args);\n       }\n \n       ExecutorService executor \u003d null;\n       CompletionService\u003cObject\u003e completionService;\n       try {\n         Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n-        int numAttempts \u003d 0;\n         executor \u003d HadoopExecutors.newFixedThreadPool(allProxies.size());\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n         for (final ProxyInfo\u003cT\u003e pInfo : allProxies.values()) {\n           Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n-            @Override public Object call() throws Exception {\n+            @Override\n+            public Object call() throws Exception {\n               return method.invoke(pInfo.proxy, args);\n             }\n           };\n           proxyMap.put(completionService.submit(c), pInfo);\n-          numAttempts++;\n         }\n \n-        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n-        while (numAttempts \u003e 0) {\n-          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n-          String pInfo \u003d proxyMap.get(callResultFuture).proxyInfo;\n-          Object retVal;\n-          try {\n-            retVal \u003d callResultFuture.get();\n-            successfulProxy \u003d pInfo;\n-            LOG.info(\"Invocation successful on [\" + pInfo + \"]\");\n-            return retVal;\n-          } catch (Exception ex) {\n-            LOG.warn(\"Invocation returned exception on \" + \"[\" + pInfo + \"]\");\n-            badResults.put(pInfo, ex);\n-            numAttempts--;\n-          }\n+        Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n+        String pInfo \u003d proxyMap.get(callResultFuture).proxyInfo;\n+        successfulProxy \u003d pInfo;\n+        Object retVal;\n+        try {\n+          retVal \u003d callResultFuture.get();\n+          LOG.info(\"Invocation successful on [\" + pInfo + \"]\");\n+          return retVal;\n+        } catch (Exception ex) {\n+          // Throw exception from first responding RM so that clients can handle\n+          // appropriately\n+          Throwable rootCause \u003d extraRootException(ex);\n+          LOG.warn(\"Invocation returned exception: \" + rootCause.toString()\n+              + \" on \" + \"[\" + pInfo + \"], so propagating back to caller.\");\n+          throw rootCause;\n         }\n \n-        // At this point we should have All bad results (Exceptions)\n-        // Or should have returned with successful result.\n-        if (badResults.size() \u003d\u003d 1) {\n-          throw badResults.values().iterator().next();\n-        } else {\n-          throw new MultiException(badResults);\n-        }\n       } finally {\n         if (executor !\u003d null) {\n           executor.shutdownNow();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n      if (successfulProxy !\u003d null) {\n        return invokeMethod(nonRetriableProxy.get(successfulProxy), method,\n            args);\n      }\n\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n        executor \u003d HadoopExecutors.newFixedThreadPool(allProxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final ProxyInfo\u003cT\u003e pInfo : allProxies.values()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override\n            public Object call() throws Exception {\n              return method.invoke(pInfo.proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pInfo);\n        }\n\n        Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n        String pInfo \u003d proxyMap.get(callResultFuture).proxyInfo;\n        successfulProxy \u003d pInfo;\n        Object retVal;\n        try {\n          retVal \u003d callResultFuture.get();\n          LOG.info(\"Invocation successful on [\" + pInfo + \"]\");\n          return retVal;\n        } catch (Exception ex) {\n          // Throw exception from first responding RM so that clients can handle\n          // appropriately\n          Throwable rootCause \u003d extraRootException(ex);\n          LOG.warn(\"Invocation returned exception: \" + rootCause.toString()\n              + \" on \" + \"[\" + pInfo + \"], so propagating back to caller.\");\n          throw rootCause;\n        }\n\n      } finally {\n        if (executor !\u003d null) {\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/RequestHedgingRMFailoverProxyProvider.java",
      "extendedDetails": {}
    },
    "fa00d3e20560bee412b49e5792595749a247a8ab": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4655. Log uncaught exceptions/errors in various thread pools in YARN. Contributed by Sidharta Seethana.\n",
      "commitDate": "10/02/16 10:36 PM",
      "commitName": "fa00d3e20560bee412b49e5792595749a247a8ab",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "22/01/16 6:20 PM",
      "commitNameOld": "618bfd6ac2a5b62d39e9bed80f75362bafc0ef28",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 19.18,
      "commitsBetweenForRepo": 133,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n     public Object invoke(Object proxy, final Method method,\n         final Object[] args) throws Throwable {\n       if (successfulProxy !\u003d null) {\n         return invokeMethod(nonRetriableProxy.get(successfulProxy), method, args);\n       }\n \n       ExecutorService executor \u003d null;\n       CompletionService\u003cObject\u003e completionService;\n       try {\n         Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n         int numAttempts \u003d 0;\n-        executor \u003d Executors.newFixedThreadPool(allProxies.size());\n+        executor \u003d HadoopExecutors.newFixedThreadPool(allProxies.size());\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n         for (final ProxyInfo\u003cT\u003e pInfo : allProxies.values()) {\n           Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n             @Override public Object call() throws Exception {\n               return method.invoke(pInfo.proxy, args);\n             }\n           };\n           proxyMap.put(completionService.submit(c), pInfo);\n           numAttempts++;\n         }\n \n         Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n         while (numAttempts \u003e 0) {\n           Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n           String pInfo \u003d proxyMap.get(callResultFuture).proxyInfo;\n           Object retVal;\n           try {\n             retVal \u003d callResultFuture.get();\n             successfulProxy \u003d pInfo;\n             LOG.info(\"Invocation successful on [\" + pInfo + \"]\");\n             return retVal;\n           } catch (Exception ex) {\n             LOG.warn(\"Invocation returned exception on \" + \"[\" + pInfo + \"]\");\n             badResults.put(pInfo, ex);\n             numAttempts--;\n           }\n         }\n \n         // At this point we should have All bad results (Exceptions)\n         // Or should have returned with successful result.\n         if (badResults.size() \u003d\u003d 1) {\n           throw badResults.values().iterator().next();\n         } else {\n           throw new MultiException(badResults);\n         }\n       } finally {\n         if (executor !\u003d null) {\n           executor.shutdownNow();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method,\n        final Object[] args) throws Throwable {\n      if (successfulProxy !\u003d null) {\n        return invokeMethod(nonRetriableProxy.get(successfulProxy), method, args);\n      }\n\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n        int numAttempts \u003d 0;\n        executor \u003d HadoopExecutors.newFixedThreadPool(allProxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final ProxyInfo\u003cT\u003e pInfo : allProxies.values()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override public Object call() throws Exception {\n              return method.invoke(pInfo.proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pInfo);\n          numAttempts++;\n        }\n\n        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n        while (numAttempts \u003e 0) {\n          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n          String pInfo \u003d proxyMap.get(callResultFuture).proxyInfo;\n          Object retVal;\n          try {\n            retVal \u003d callResultFuture.get();\n            successfulProxy \u003d pInfo;\n            LOG.info(\"Invocation successful on [\" + pInfo + \"]\");\n            return retVal;\n          } catch (Exception ex) {\n            LOG.warn(\"Invocation returned exception on \" + \"[\" + pInfo + \"]\");\n            badResults.put(pInfo, ex);\n            numAttempts--;\n          }\n        }\n\n        // At this point we should have All bad results (Exceptions)\n        // Or should have returned with successful result.\n        if (badResults.size() \u003d\u003d 1) {\n          throw badResults.values().iterator().next();\n        } else {\n          throw new MultiException(badResults);\n        }\n      } finally {\n        if (executor !\u003d null) {\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/RequestHedgingRMFailoverProxyProvider.java",
      "extendedDetails": {}
    },
    "618bfd6ac2a5b62d39e9bed80f75362bafc0ef28": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4496. Improve HA ResourceManager Failover detection on the client.\nContributed by Jian He\n",
      "commitDate": "22/01/16 6:20 PM",
      "commitName": "618bfd6ac2a5b62d39e9bed80f75362bafc0ef28",
      "commitAuthor": "Xuan",
      "diff": "@@ -0,0 +1,53 @@\n+    public Object invoke(Object proxy, final Method method,\n+        final Object[] args) throws Throwable {\n+      if (successfulProxy !\u003d null) {\n+        return invokeMethod(nonRetriableProxy.get(successfulProxy), method, args);\n+      }\n+\n+      ExecutorService executor \u003d null;\n+      CompletionService\u003cObject\u003e completionService;\n+      try {\n+        Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n+        int numAttempts \u003d 0;\n+        executor \u003d Executors.newFixedThreadPool(allProxies.size());\n+        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n+        for (final ProxyInfo\u003cT\u003e pInfo : allProxies.values()) {\n+          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n+            @Override public Object call() throws Exception {\n+              return method.invoke(pInfo.proxy, args);\n+            }\n+          };\n+          proxyMap.put(completionService.submit(c), pInfo);\n+          numAttempts++;\n+        }\n+\n+        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n+        while (numAttempts \u003e 0) {\n+          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n+          String pInfo \u003d proxyMap.get(callResultFuture).proxyInfo;\n+          Object retVal;\n+          try {\n+            retVal \u003d callResultFuture.get();\n+            successfulProxy \u003d pInfo;\n+            LOG.info(\"Invocation successful on [\" + pInfo + \"]\");\n+            return retVal;\n+          } catch (Exception ex) {\n+            LOG.warn(\"Invocation returned exception on \" + \"[\" + pInfo + \"]\");\n+            badResults.put(pInfo, ex);\n+            numAttempts--;\n+          }\n+        }\n+\n+        // At this point we should have All bad results (Exceptions)\n+        // Or should have returned with successful result.\n+        if (badResults.size() \u003d\u003d 1) {\n+          throw badResults.values().iterator().next();\n+        } else {\n+          throw new MultiException(badResults);\n+        }\n+      } finally {\n+        if (executor !\u003d null) {\n+          executor.shutdownNow();\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method,\n        final Object[] args) throws Throwable {\n      if (successfulProxy !\u003d null) {\n        return invokeMethod(nonRetriableProxy.get(successfulProxy), method, args);\n      }\n\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n        int numAttempts \u003d 0;\n        executor \u003d Executors.newFixedThreadPool(allProxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final ProxyInfo\u003cT\u003e pInfo : allProxies.values()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override public Object call() throws Exception {\n              return method.invoke(pInfo.proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pInfo);\n          numAttempts++;\n        }\n\n        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n        while (numAttempts \u003e 0) {\n          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n          String pInfo \u003d proxyMap.get(callResultFuture).proxyInfo;\n          Object retVal;\n          try {\n            retVal \u003d callResultFuture.get();\n            successfulProxy \u003d pInfo;\n            LOG.info(\"Invocation successful on [\" + pInfo + \"]\");\n            return retVal;\n          } catch (Exception ex) {\n            LOG.warn(\"Invocation returned exception on \" + \"[\" + pInfo + \"]\");\n            badResults.put(pInfo, ex);\n            numAttempts--;\n          }\n        }\n\n        // At this point we should have All bad results (Exceptions)\n        // Or should have returned with successful result.\n        if (badResults.size() \u003d\u003d 1) {\n          throw badResults.values().iterator().next();\n        } else {\n          throw new MultiException(badResults);\n        }\n      } finally {\n        if (executor !\u003d null) {\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/RequestHedgingRMFailoverProxyProvider.java"
    }
  }
}