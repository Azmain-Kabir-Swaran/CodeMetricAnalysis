{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DFSInotifyEventInputStream.java",
  "functionName": "poll",
  "functionId": "poll",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInotifyEventInputStream.java",
  "functionStartLine": 96,
  "functionEndLine": 133,
  "numCommitsSeen": 9,
  "timeTaken": 2888,
  "changeHistory": [
    "7136e8c5582dc4061b566cb9f11a0d6a6d08bb93",
    "892ade689f9bcce76daae8f66fc00a49bee8548e",
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
    "c4ccbe62c0857261b197a68c1e03a02e92f21a38",
    "75a326aaff8c92349701d9b3473c3070b8c2be44",
    "faa4455be512e070fa420084be8d1be5c72f3b08"
  ],
  "changeHistoryShort": {
    "7136e8c5582dc4061b566cb9f11a0d6a6d08bb93": "Ybodychange",
    "892ade689f9bcce76daae8f66fc00a49bee8548e": "Ybodychange",
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c": "Yfilerename",
    "c4ccbe62c0857261b197a68c1e03a02e92f21a38": "Ybodychange",
    "75a326aaff8c92349701d9b3473c3070b8c2be44": "Ymultichange(Yreturntypechange,Ybodychange)",
    "faa4455be512e070fa420084be8d1be5c72f3b08": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7136e8c5582dc4061b566cb9f11a0d6a6d08bb93": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8979. Clean up checkstyle warnings in hadoop-hdfs-client module. Contributed by Mingliang Liu.\n",
      "commitDate": "03/10/15 11:38 AM",
      "commitName": "7136e8c5582dc4061b566cb9f11a0d6a6d08bb93",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "28/09/15 7:42 AM",
      "commitNameOld": "892ade689f9bcce76daae8f66fc00a49bee8548e",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 5.16,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,38 @@\n   public EventBatch poll() throws IOException, MissingEventsException {\n-    TraceScope scope \u003d tracer.newScope(\"inotifyPoll\");\n-    try {\n+    try (TraceScope ignored \u003d tracer.newScope(\"inotifyPoll\")) {\n       // need to keep retrying until the NN sends us the latest committed txid\n       if (lastReadTxid \u003d\u003d -1) {\n         LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n         lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n         return null;\n       }\n       if (!it.hasNext()) {\n         EventBatchList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n         if (el.getLastTxid() !\u003d -1) {\n           // we only want to set syncTxid when we were actually able to read some\n           // edits on the NN -- otherwise it will seem like edits are being\n           // generated faster than we can read them when the problem is really\n           // that we are temporarily unable to read edits\n           syncTxid \u003d el.getSyncTxid();\n           it \u003d el.getBatches().iterator();\n           long formerLastReadTxid \u003d lastReadTxid;\n           lastReadTxid \u003d el.getLastTxid();\n           if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n             throw new MissingEventsException(formerLastReadTxid + 1,\n                 el.getFirstTxid());\n           }\n         } else {\n           LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n-            \"after txid {}\", lastReadTxid);\n+              \"after txid {}\", lastReadTxid);\n           return null;\n         }\n       }\n \n       if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n         // newly seen edit log ops actually got converted to events\n         return it.next();\n       } else {\n         return null;\n       }\n-    } finally {\n-      scope.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public EventBatch poll() throws IOException, MissingEventsException {\n    try (TraceScope ignored \u003d tracer.newScope(\"inotifyPoll\")) {\n      // need to keep retrying until the NN sends us the latest committed txid\n      if (lastReadTxid \u003d\u003d -1) {\n        LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n        lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n        return null;\n      }\n      if (!it.hasNext()) {\n        EventBatchList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n        if (el.getLastTxid() !\u003d -1) {\n          // we only want to set syncTxid when we were actually able to read some\n          // edits on the NN -- otherwise it will seem like edits are being\n          // generated faster than we can read them when the problem is really\n          // that we are temporarily unable to read edits\n          syncTxid \u003d el.getSyncTxid();\n          it \u003d el.getBatches().iterator();\n          long formerLastReadTxid \u003d lastReadTxid;\n          lastReadTxid \u003d el.getLastTxid();\n          if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n            throw new MissingEventsException(formerLastReadTxid + 1,\n                el.getFirstTxid());\n          }\n        } else {\n          LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n              \"after txid {}\", lastReadTxid);\n          return null;\n        }\n      }\n\n      if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n        // newly seen edit log ops actually got converted to events\n        return it.next();\n      } else {\n        return null;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInotifyEventInputStream.java",
      "extendedDetails": {}
    },
    "892ade689f9bcce76daae8f66fc00a49bee8548e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9080. Update htrace version to 4.0.1 (cmccabe)\n",
      "commitDate": "28/09/15 7:42 AM",
      "commitName": "892ade689f9bcce76daae8f66fc00a49bee8548e",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "26/09/15 11:08 AM",
      "commitNameOld": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.86,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,41 @@\n   public EventBatch poll() throws IOException, MissingEventsException {\n-    TraceScope scope \u003d\n-        Trace.startSpan(\"inotifyPoll\", traceSampler);\n+    TraceScope scope \u003d tracer.newScope(\"inotifyPoll\");\n     try {\n       // need to keep retrying until the NN sends us the latest committed txid\n       if (lastReadTxid \u003d\u003d -1) {\n         LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n         lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n         return null;\n       }\n       if (!it.hasNext()) {\n         EventBatchList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n         if (el.getLastTxid() !\u003d -1) {\n           // we only want to set syncTxid when we were actually able to read some\n           // edits on the NN -- otherwise it will seem like edits are being\n           // generated faster than we can read them when the problem is really\n           // that we are temporarily unable to read edits\n           syncTxid \u003d el.getSyncTxid();\n           it \u003d el.getBatches().iterator();\n           long formerLastReadTxid \u003d lastReadTxid;\n           lastReadTxid \u003d el.getLastTxid();\n           if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n             throw new MissingEventsException(formerLastReadTxid + 1,\n                 el.getFirstTxid());\n           }\n         } else {\n           LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n             \"after txid {}\", lastReadTxid);\n           return null;\n         }\n       }\n \n       if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n         // newly seen edit log ops actually got converted to events\n         return it.next();\n       } else {\n         return null;\n       }\n     } finally {\n       scope.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public EventBatch poll() throws IOException, MissingEventsException {\n    TraceScope scope \u003d tracer.newScope(\"inotifyPoll\");\n    try {\n      // need to keep retrying until the NN sends us the latest committed txid\n      if (lastReadTxid \u003d\u003d -1) {\n        LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n        lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n        return null;\n      }\n      if (!it.hasNext()) {\n        EventBatchList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n        if (el.getLastTxid() !\u003d -1) {\n          // we only want to set syncTxid when we were actually able to read some\n          // edits on the NN -- otherwise it will seem like edits are being\n          // generated faster than we can read them when the problem is really\n          // that we are temporarily unable to read edits\n          syncTxid \u003d el.getSyncTxid();\n          it \u003d el.getBatches().iterator();\n          long formerLastReadTxid \u003d lastReadTxid;\n          lastReadTxid \u003d el.getLastTxid();\n          if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n            throw new MissingEventsException(formerLastReadTxid + 1,\n                el.getFirstTxid());\n          }\n        } else {\n          LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n            \"after txid {}\", lastReadTxid);\n          return null;\n        }\n      }\n\n      if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n        // newly seen edit log ops actually got converted to events\n        return it.next();\n      } else {\n        return null;\n      }\n    } finally {\n      scope.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInotifyEventInputStream.java",
      "extendedDetails": {}
    },
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-8053. Move DFSIn/OutputStream and related classes to hadoop-hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "26/09/15 11:08 AM",
      "commitName": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "26/09/15 9:06 AM",
      "commitNameOld": "861b52db242f238d7e36ad75c158025be959a696",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public EventBatch poll() throws IOException, MissingEventsException {\n    TraceScope scope \u003d\n        Trace.startSpan(\"inotifyPoll\", traceSampler);\n    try {\n      // need to keep retrying until the NN sends us the latest committed txid\n      if (lastReadTxid \u003d\u003d -1) {\n        LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n        lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n        return null;\n      }\n      if (!it.hasNext()) {\n        EventBatchList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n        if (el.getLastTxid() !\u003d -1) {\n          // we only want to set syncTxid when we were actually able to read some\n          // edits on the NN -- otherwise it will seem like edits are being\n          // generated faster than we can read them when the problem is really\n          // that we are temporarily unable to read edits\n          syncTxid \u003d el.getSyncTxid();\n          it \u003d el.getBatches().iterator();\n          long formerLastReadTxid \u003d lastReadTxid;\n          lastReadTxid \u003d el.getLastTxid();\n          if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n            throw new MissingEventsException(formerLastReadTxid + 1,\n                el.getFirstTxid());\n          }\n        } else {\n          LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n            \"after txid {}\", lastReadTxid);\n          return null;\n        }\n      }\n\n      if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n        // newly seen edit log ops actually got converted to events\n        return it.next();\n      } else {\n        return null;\n      }\n    } finally {\n      scope.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInotifyEventInputStream.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSInotifyEventInputStream.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInotifyEventInputStream.java"
      }
    },
    "c4ccbe62c0857261b197a68c1e03a02e92f21a38": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7189. Add trace spans for DFSClient metadata operations. (Colin P. McCabe via yliu)\n",
      "commitDate": "15/01/15 8:23 AM",
      "commitName": "c4ccbe62c0857261b197a68c1e03a02e92f21a38",
      "commitAuthor": "yliu",
      "commitDateOld": "02/12/14 5:15 PM",
      "commitNameOld": "75a326aaff8c92349701d9b3473c3070b8c2be44",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 43.63,
      "commitsBetweenForRepo": 261,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,42 @@\n   public EventBatch poll() throws IOException, MissingEventsException {\n-    // need to keep retrying until the NN sends us the latest committed txid\n-    if (lastReadTxid \u003d\u003d -1) {\n-      LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n-      lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n-      return null;\n-    }\n-    if (!it.hasNext()) {\n-      EventBatchList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n-      if (el.getLastTxid() !\u003d -1) {\n-        // we only want to set syncTxid when we were actually able to read some\n-        // edits on the NN -- otherwise it will seem like edits are being\n-        // generated faster than we can read them when the problem is really\n-        // that we are temporarily unable to read edits\n-        syncTxid \u003d el.getSyncTxid();\n-        it \u003d el.getBatches().iterator();\n-        long formerLastReadTxid \u003d lastReadTxid;\n-        lastReadTxid \u003d el.getLastTxid();\n-        if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n-          throw new MissingEventsException(formerLastReadTxid + 1,\n-              el.getFirstTxid());\n-        }\n-      } else {\n-        LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n-          \"after txid {}\", lastReadTxid);\n+    TraceScope scope \u003d\n+        Trace.startSpan(\"inotifyPoll\", traceSampler);\n+    try {\n+      // need to keep retrying until the NN sends us the latest committed txid\n+      if (lastReadTxid \u003d\u003d -1) {\n+        LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n+        lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n         return null;\n       }\n-    }\n+      if (!it.hasNext()) {\n+        EventBatchList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n+        if (el.getLastTxid() !\u003d -1) {\n+          // we only want to set syncTxid when we were actually able to read some\n+          // edits on the NN -- otherwise it will seem like edits are being\n+          // generated faster than we can read them when the problem is really\n+          // that we are temporarily unable to read edits\n+          syncTxid \u003d el.getSyncTxid();\n+          it \u003d el.getBatches().iterator();\n+          long formerLastReadTxid \u003d lastReadTxid;\n+          lastReadTxid \u003d el.getLastTxid();\n+          if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n+            throw new MissingEventsException(formerLastReadTxid + 1,\n+                el.getFirstTxid());\n+          }\n+        } else {\n+          LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n+            \"after txid {}\", lastReadTxid);\n+          return null;\n+        }\n+      }\n \n-    if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n-      // newly seen edit log ops actually got converted to events\n-      return it.next();\n-    } else {\n-      return null;\n+      if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n+        // newly seen edit log ops actually got converted to events\n+        return it.next();\n+      } else {\n+        return null;\n+      }\n+    } finally {\n+      scope.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public EventBatch poll() throws IOException, MissingEventsException {\n    TraceScope scope \u003d\n        Trace.startSpan(\"inotifyPoll\", traceSampler);\n    try {\n      // need to keep retrying until the NN sends us the latest committed txid\n      if (lastReadTxid \u003d\u003d -1) {\n        LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n        lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n        return null;\n      }\n      if (!it.hasNext()) {\n        EventBatchList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n        if (el.getLastTxid() !\u003d -1) {\n          // we only want to set syncTxid when we were actually able to read some\n          // edits on the NN -- otherwise it will seem like edits are being\n          // generated faster than we can read them when the problem is really\n          // that we are temporarily unable to read edits\n          syncTxid \u003d el.getSyncTxid();\n          it \u003d el.getBatches().iterator();\n          long formerLastReadTxid \u003d lastReadTxid;\n          lastReadTxid \u003d el.getLastTxid();\n          if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n            throw new MissingEventsException(formerLastReadTxid + 1,\n                el.getFirstTxid());\n          }\n        } else {\n          LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n            \"after txid {}\", lastReadTxid);\n          return null;\n        }\n      }\n\n      if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n        // newly seen edit log ops actually got converted to events\n        return it.next();\n      } else {\n        return null;\n      }\n    } finally {\n      scope.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSInotifyEventInputStream.java",
      "extendedDetails": {}
    },
    "75a326aaff8c92349701d9b3473c3070b8c2be44": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-7446. HDFS inotify should have the ability to determine what txid it has read up to (cmccabe)\n",
      "commitDate": "02/12/14 5:15 PM",
      "commitName": "75a326aaff8c92349701d9b3473c3070b8c2be44",
      "commitAuthor": "Colin Patrick Mccabe",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-7446. HDFS inotify should have the ability to determine what txid it has read up to (cmccabe)\n",
          "commitDate": "02/12/14 5:15 PM",
          "commitName": "75a326aaff8c92349701d9b3473c3070b8c2be44",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "02/09/14 2:02 PM",
          "commitNameOld": "faa4455be512e070fa420084be8d1be5c72f3b08",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 91.18,
          "commitsBetweenForRepo": 869,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,36 @@\n-  public Event poll() throws IOException, MissingEventsException {\n+  public EventBatch poll() throws IOException, MissingEventsException {\n     // need to keep retrying until the NN sends us the latest committed txid\n     if (lastReadTxid \u003d\u003d -1) {\n       LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n       lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n       return null;\n     }\n     if (!it.hasNext()) {\n-      EventsList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n+      EventBatchList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n       if (el.getLastTxid() !\u003d -1) {\n         // we only want to set syncTxid when we were actually able to read some\n         // edits on the NN -- otherwise it will seem like edits are being\n         // generated faster than we can read them when the problem is really\n         // that we are temporarily unable to read edits\n         syncTxid \u003d el.getSyncTxid();\n-        it \u003d el.getEvents().iterator();\n+        it \u003d el.getBatches().iterator();\n         long formerLastReadTxid \u003d lastReadTxid;\n         lastReadTxid \u003d el.getLastTxid();\n         if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n           throw new MissingEventsException(formerLastReadTxid + 1,\n               el.getFirstTxid());\n         }\n       } else {\n         LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n           \"after txid {}\", lastReadTxid);\n         return null;\n       }\n     }\n \n     if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n       // newly seen edit log ops actually got converted to events\n       return it.next();\n     } else {\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public EventBatch poll() throws IOException, MissingEventsException {\n    // need to keep retrying until the NN sends us the latest committed txid\n    if (lastReadTxid \u003d\u003d -1) {\n      LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n      lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n      return null;\n    }\n    if (!it.hasNext()) {\n      EventBatchList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n      if (el.getLastTxid() !\u003d -1) {\n        // we only want to set syncTxid when we were actually able to read some\n        // edits on the NN -- otherwise it will seem like edits are being\n        // generated faster than we can read them when the problem is really\n        // that we are temporarily unable to read edits\n        syncTxid \u003d el.getSyncTxid();\n        it \u003d el.getBatches().iterator();\n        long formerLastReadTxid \u003d lastReadTxid;\n        lastReadTxid \u003d el.getLastTxid();\n        if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n          throw new MissingEventsException(formerLastReadTxid + 1,\n              el.getFirstTxid());\n        }\n      } else {\n        LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n          \"after txid {}\", lastReadTxid);\n        return null;\n      }\n    }\n\n    if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n      // newly seen edit log ops actually got converted to events\n      return it.next();\n    } else {\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSInotifyEventInputStream.java",
          "extendedDetails": {
            "oldValue": "Event",
            "newValue": "EventBatch"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7446. HDFS inotify should have the ability to determine what txid it has read up to (cmccabe)\n",
          "commitDate": "02/12/14 5:15 PM",
          "commitName": "75a326aaff8c92349701d9b3473c3070b8c2be44",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "02/09/14 2:02 PM",
          "commitNameOld": "faa4455be512e070fa420084be8d1be5c72f3b08",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 91.18,
          "commitsBetweenForRepo": 869,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,36 @@\n-  public Event poll() throws IOException, MissingEventsException {\n+  public EventBatch poll() throws IOException, MissingEventsException {\n     // need to keep retrying until the NN sends us the latest committed txid\n     if (lastReadTxid \u003d\u003d -1) {\n       LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n       lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n       return null;\n     }\n     if (!it.hasNext()) {\n-      EventsList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n+      EventBatchList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n       if (el.getLastTxid() !\u003d -1) {\n         // we only want to set syncTxid when we were actually able to read some\n         // edits on the NN -- otherwise it will seem like edits are being\n         // generated faster than we can read them when the problem is really\n         // that we are temporarily unable to read edits\n         syncTxid \u003d el.getSyncTxid();\n-        it \u003d el.getEvents().iterator();\n+        it \u003d el.getBatches().iterator();\n         long formerLastReadTxid \u003d lastReadTxid;\n         lastReadTxid \u003d el.getLastTxid();\n         if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n           throw new MissingEventsException(formerLastReadTxid + 1,\n               el.getFirstTxid());\n         }\n       } else {\n         LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n           \"after txid {}\", lastReadTxid);\n         return null;\n       }\n     }\n \n     if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n       // newly seen edit log ops actually got converted to events\n       return it.next();\n     } else {\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public EventBatch poll() throws IOException, MissingEventsException {\n    // need to keep retrying until the NN sends us the latest committed txid\n    if (lastReadTxid \u003d\u003d -1) {\n      LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n      lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n      return null;\n    }\n    if (!it.hasNext()) {\n      EventBatchList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n      if (el.getLastTxid() !\u003d -1) {\n        // we only want to set syncTxid when we were actually able to read some\n        // edits on the NN -- otherwise it will seem like edits are being\n        // generated faster than we can read them when the problem is really\n        // that we are temporarily unable to read edits\n        syncTxid \u003d el.getSyncTxid();\n        it \u003d el.getBatches().iterator();\n        long formerLastReadTxid \u003d lastReadTxid;\n        lastReadTxid \u003d el.getLastTxid();\n        if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n          throw new MissingEventsException(formerLastReadTxid + 1,\n              el.getFirstTxid());\n        }\n      } else {\n        LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n          \"after txid {}\", lastReadTxid);\n        return null;\n      }\n    }\n\n    if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n      // newly seen edit log ops actually got converted to events\n      return it.next();\n    } else {\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSInotifyEventInputStream.java",
          "extendedDetails": {}
        }
      ]
    },
    "faa4455be512e070fa420084be8d1be5c72f3b08": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-6634. inotify in HDFS. Contributed by James Thomas.\n",
      "commitDate": "02/09/14 2:02 PM",
      "commitName": "faa4455be512e070fa420084be8d1be5c72f3b08",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,36 @@\n+  public Event poll() throws IOException, MissingEventsException {\n+    // need to keep retrying until the NN sends us the latest committed txid\n+    if (lastReadTxid \u003d\u003d -1) {\n+      LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n+      lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n+      return null;\n+    }\n+    if (!it.hasNext()) {\n+      EventsList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n+      if (el.getLastTxid() !\u003d -1) {\n+        // we only want to set syncTxid when we were actually able to read some\n+        // edits on the NN -- otherwise it will seem like edits are being\n+        // generated faster than we can read them when the problem is really\n+        // that we are temporarily unable to read edits\n+        syncTxid \u003d el.getSyncTxid();\n+        it \u003d el.getEvents().iterator();\n+        long formerLastReadTxid \u003d lastReadTxid;\n+        lastReadTxid \u003d el.getLastTxid();\n+        if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n+          throw new MissingEventsException(formerLastReadTxid + 1,\n+              el.getFirstTxid());\n+        }\n+      } else {\n+        LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n+          \"after txid {}\", lastReadTxid);\n+        return null;\n+      }\n+    }\n+\n+    if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n+      // newly seen edit log ops actually got converted to events\n+      return it.next();\n+    } else {\n+      return null;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Event poll() throws IOException, MissingEventsException {\n    // need to keep retrying until the NN sends us the latest committed txid\n    if (lastReadTxid \u003d\u003d -1) {\n      LOG.debug(\"poll(): lastReadTxid is -1, reading current txid from NN\");\n      lastReadTxid \u003d namenode.getCurrentEditLogTxid();\n      return null;\n    }\n    if (!it.hasNext()) {\n      EventsList el \u003d namenode.getEditsFromTxid(lastReadTxid + 1);\n      if (el.getLastTxid() !\u003d -1) {\n        // we only want to set syncTxid when we were actually able to read some\n        // edits on the NN -- otherwise it will seem like edits are being\n        // generated faster than we can read them when the problem is really\n        // that we are temporarily unable to read edits\n        syncTxid \u003d el.getSyncTxid();\n        it \u003d el.getEvents().iterator();\n        long formerLastReadTxid \u003d lastReadTxid;\n        lastReadTxid \u003d el.getLastTxid();\n        if (el.getFirstTxid() !\u003d formerLastReadTxid + 1) {\n          throw new MissingEventsException(formerLastReadTxid + 1,\n              el.getFirstTxid());\n        }\n      } else {\n        LOG.debug(\"poll(): read no edits from the NN when requesting edits \" +\n          \"after txid {}\", lastReadTxid);\n        return null;\n      }\n    }\n\n    if (it.hasNext()) { // can be empty if el.getLastTxid !\u003d -1 but none of the\n      // newly seen edit log ops actually got converted to events\n      return it.next();\n    } else {\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSInotifyEventInputStream.java"
    }
  }
}