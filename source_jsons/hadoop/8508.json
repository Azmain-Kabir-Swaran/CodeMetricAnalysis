{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSImage.java",
  "functionName": "loadFSImage",
  "functionId": "loadFSImage___target-FSNamesystem__startOpt-StartupOption__recovery-MetaRecoveryContext",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
  "functionStartLine": 670,
  "functionEndLine": 774,
  "numCommitsSeen": 123,
  "timeTaken": 5902,
  "changeHistory": [
    "336abbd8737f3dff38f7bdad9721511c711c522b",
    "ebe5853a458150b7e42fe7434851bfcbe25e354d",
    "d2026ae9e6c86f4fd9e48b80e71233181c1853d9",
    "25051c3bd08efc12333a6acb51782cc7800403a4",
    "db37f02dc704ad9eec8c56e3e466a5f37d138d74",
    "eb6939cea0343840c62b930d4adb377f5eaf879f",
    "431e7d84c7b68b34ff18de19afe8e46637047fa6",
    "18620649f96d9e378fb7ea40de216284a9d525c7",
    "5d29338017fb8ebe8626002c1ca670842968ca4a",
    "98983b2788508936ad489e61ff61cacfe73ab1b9",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
    "016d3b8171191a0dc860c3c5ddf15fcbe6c8d973",
    "2088584864d829d59d8352b88dead8eafa6922e4"
  ],
  "changeHistoryShort": {
    "336abbd8737f3dff38f7bdad9721511c711c522b": "Ybodychange",
    "ebe5853a458150b7e42fe7434851bfcbe25e354d": "Ybodychange",
    "d2026ae9e6c86f4fd9e48b80e71233181c1853d9": "Ybodychange",
    "25051c3bd08efc12333a6acb51782cc7800403a4": "Ybodychange",
    "db37f02dc704ad9eec8c56e3e466a5f37d138d74": "Ybodychange",
    "eb6939cea0343840c62b930d4adb377f5eaf879f": "Ybodychange",
    "431e7d84c7b68b34ff18de19afe8e46637047fa6": "Ybodychange",
    "18620649f96d9e378fb7ea40de216284a9d525c7": "Ybodychange",
    "5d29338017fb8ebe8626002c1ca670842968ca4a": "Ybodychange",
    "98983b2788508936ad489e61ff61cacfe73ab1b9": "Ybodychange",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": "Ybodychange",
    "016d3b8171191a0dc860c3c5ddf15fcbe6c8d973": "Ybodychange",
    "2088584864d829d59d8352b88dead8eafa6922e4": "Ybodychange"
  },
  "changeHistoryDetails": {
    "336abbd8737f3dff38f7bdad9721511c711c522b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14886. In NameNode Web UI\u0027s Startup Progress page, Loading edits always shows 0 sec. Contributed by hemanthboyina.\n",
      "commitDate": "14/10/19 11:01 AM",
      "commitName": "336abbd8737f3dff38f7bdad9721511c711c522b",
      "commitAuthor": "Surendra Singh Lilhore",
      "commitDateOld": "26/08/19 3:57 PM",
      "commitNameOld": "07e3cf952eac9e47e7bd5e195b0f9fc28c468313",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 48.79,
      "commitsBetweenForRepo": 411,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,105 @@\n   private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     final boolean rollingRollback\n         \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n     final EnumSet\u003cNameNodeFile\u003e nnfs;\n     if (rollingRollback) {\n       // if it is rollback of rolling upgrade, only load from the rollback image\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n     } else {\n       // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n     }\n     final FSImageStorageInspector inspector \u003d storage\n         .readAndInspectDirs(nnfs, startOpt);\n \n     isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n     List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n \n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     prog.beginPhase(Phase.LOADING_FSIMAGE);\n     File phaseFile \u003d imageFiles.get(0).getFile();\n     prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n     prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n     boolean needToSave \u003d inspector.needToSave();\n \n     Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n \n     initEditLog(startOpt);\n \n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n       // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n       // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n       // OK to not be able to read all of edits right now.\n       // In the meanwhile, for HA upgrade, we will still write editlog thus need\n       // this toAtLeastTxId to be set to the max-seen txid\n       // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n       // the txid right before the upgrade marker.  \n       long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n           .getMaxSeenTxId() : 0;\n       if (rollingRollback) {\n         // note that the first image in imageFiles is the special checkpoint\n         // for the rolling upgrade\n         toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n       }\n       editStreams \u003d editLog.selectInputStreams(\n           imageFiles.get(0).getCheckpointTxId() + 1,\n           toAtLeastTxId, recovery, false);\n     } else {\n       editStreams \u003d FSImagePreTransactionalStorageInspector\n         .getEditLogStreams(storage);\n     }\n     int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n         DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n     for (EditLogInputStream elis : editStreams) {\n       elis.setMaxOpSize(maxOpSize);\n     }\n  \n     for (EditLogInputStream l : editStreams) {\n       LOG.debug(\"Planning to load edit log stream: \" + l);\n     }\n     if (!editStreams.iterator().hasNext()) {\n       LOG.info(\"No edit log streams selected.\");\n     }\n     \n     FSImageFile imageFile \u003d null;\n     for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n       try {\n         imageFile \u003d imageFiles.get(i);\n         loadFSImageFile(target, recovery, imageFile, startOpt);\n         break;\n       } catch (IllegalReservedPathException ie) {\n         throw new IOException(\"Failed to load image from \" + imageFile,\n             ie);\n       } catch (Exception e) {\n         LOG.error(\"Failed to load image from \" + imageFile, e);\n         target.clear();\n         imageFile \u003d null;\n       }\n     }\n     // Failed to load any images, error out\n     if (imageFile \u003d\u003d null) {\n       FSEditLog.closeAllStreams(editStreams);\n       throw new IOException(\"Failed to load FSImage file, see error(s) \" +\n           \"above for more info.\");\n     }\n     prog.endPhase(Phase.LOADING_FSIMAGE);\n     \n     if (!rollingRollback) {\n+      prog.beginPhase(Phase.LOADING_EDITS);\n       long txnsAdvanced \u003d loadEdits(editStreams, target, Long.MAX_VALUE,\n           startOpt, recovery);\n+      prog.endPhase(Phase.LOADING_EDITS);\n       needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n           txnsAdvanced);\n     } else {\n       // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n       // to the last txid in rollback fsimage.\n       rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n       needToSave \u003d false;\n     }\n     editLog.setNextTxId(lastAppliedTxId + 1);\n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    final boolean rollingRollback\n        \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n    final EnumSet\u003cNameNodeFile\u003e nnfs;\n    if (rollingRollback) {\n      // if it is rollback of rolling upgrade, only load from the rollback image\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n    } else {\n      // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n    }\n    final FSImageStorageInspector inspector \u003d storage\n        .readAndInspectDirs(nnfs, startOpt);\n\n    isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n    List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    prog.beginPhase(Phase.LOADING_FSIMAGE);\n    File phaseFile \u003d imageFiles.get(0).getFile();\n    prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n    prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n    boolean needToSave \u003d inspector.needToSave();\n\n    Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n\n    initEditLog(startOpt);\n\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n      // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n      // OK to not be able to read all of edits right now.\n      // In the meanwhile, for HA upgrade, we will still write editlog thus need\n      // this toAtLeastTxId to be set to the max-seen txid\n      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n      // the txid right before the upgrade marker.  \n      long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n          .getMaxSeenTxId() : 0;\n      if (rollingRollback) {\n        // note that the first image in imageFiles is the special checkpoint\n        // for the rolling upgrade\n        toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n      }\n      editStreams \u003d editLog.selectInputStreams(\n          imageFiles.get(0).getCheckpointTxId() + 1,\n          toAtLeastTxId, recovery, false);\n    } else {\n      editStreams \u003d FSImagePreTransactionalStorageInspector\n        .getEditLogStreams(storage);\n    }\n    int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n        DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n    for (EditLogInputStream elis : editStreams) {\n      elis.setMaxOpSize(maxOpSize);\n    }\n \n    for (EditLogInputStream l : editStreams) {\n      LOG.debug(\"Planning to load edit log stream: \" + l);\n    }\n    if (!editStreams.iterator().hasNext()) {\n      LOG.info(\"No edit log streams selected.\");\n    }\n    \n    FSImageFile imageFile \u003d null;\n    for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n      try {\n        imageFile \u003d imageFiles.get(i);\n        loadFSImageFile(target, recovery, imageFile, startOpt);\n        break;\n      } catch (IllegalReservedPathException ie) {\n        throw new IOException(\"Failed to load image from \" + imageFile,\n            ie);\n      } catch (Exception e) {\n        LOG.error(\"Failed to load image from \" + imageFile, e);\n        target.clear();\n        imageFile \u003d null;\n      }\n    }\n    // Failed to load any images, error out\n    if (imageFile \u003d\u003d null) {\n      FSEditLog.closeAllStreams(editStreams);\n      throw new IOException(\"Failed to load FSImage file, see error(s) \" +\n          \"above for more info.\");\n    }\n    prog.endPhase(Phase.LOADING_FSIMAGE);\n    \n    if (!rollingRollback) {\n      prog.beginPhase(Phase.LOADING_EDITS);\n      long txnsAdvanced \u003d loadEdits(editStreams, target, Long.MAX_VALUE,\n          startOpt, recovery);\n      prog.endPhase(Phase.LOADING_EDITS);\n      needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n          txnsAdvanced);\n    } else {\n      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n      // to the last txid in rollback fsimage.\n      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n      needToSave \u003d false;\n    }\n    editLog.setNextTxId(lastAppliedTxId + 1);\n    return needToSave;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "ebe5853a458150b7e42fe7434851bfcbe25e354d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12978. Fine-grained locking while consuming journal stream. Contributed by Konstantin Shvachko.",
      "commitDate": "31/05/18 2:56 PM",
      "commitName": "ebe5853a458150b7e42fe7434851bfcbe25e354d",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "28/03/18 12:49 PM",
      "commitNameOld": "a991e899fb9f98d2089f37ac9ac7c485d3bbb959",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 64.09,
      "commitsBetweenForRepo": 964,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,103 @@\n   private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     final boolean rollingRollback\n         \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n     final EnumSet\u003cNameNodeFile\u003e nnfs;\n     if (rollingRollback) {\n       // if it is rollback of rolling upgrade, only load from the rollback image\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n     } else {\n       // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n     }\n     final FSImageStorageInspector inspector \u003d storage\n         .readAndInspectDirs(nnfs, startOpt);\n \n     isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n     List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n \n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     prog.beginPhase(Phase.LOADING_FSIMAGE);\n     File phaseFile \u003d imageFiles.get(0).getFile();\n     prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n     prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n     boolean needToSave \u003d inspector.needToSave();\n \n     Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n \n     initEditLog(startOpt);\n \n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n       // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n       // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n       // OK to not be able to read all of edits right now.\n       // In the meanwhile, for HA upgrade, we will still write editlog thus need\n       // this toAtLeastTxId to be set to the max-seen txid\n       // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n       // the txid right before the upgrade marker.  \n       long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n           .getMaxSeenTxId() : 0;\n       if (rollingRollback) {\n         // note that the first image in imageFiles is the special checkpoint\n         // for the rolling upgrade\n         toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n       }\n       editStreams \u003d editLog.selectInputStreams(\n           imageFiles.get(0).getCheckpointTxId() + 1,\n           toAtLeastTxId, recovery, false);\n     } else {\n       editStreams \u003d FSImagePreTransactionalStorageInspector\n         .getEditLogStreams(storage);\n     }\n     int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n         DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n     for (EditLogInputStream elis : editStreams) {\n       elis.setMaxOpSize(maxOpSize);\n     }\n  \n     for (EditLogInputStream l : editStreams) {\n       LOG.debug(\"Planning to load edit log stream: \" + l);\n     }\n     if (!editStreams.iterator().hasNext()) {\n       LOG.info(\"No edit log streams selected.\");\n     }\n     \n     FSImageFile imageFile \u003d null;\n     for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n       try {\n         imageFile \u003d imageFiles.get(i);\n         loadFSImageFile(target, recovery, imageFile, startOpt);\n         break;\n       } catch (IllegalReservedPathException ie) {\n         throw new IOException(\"Failed to load image from \" + imageFile,\n             ie);\n       } catch (Exception e) {\n         LOG.error(\"Failed to load image from \" + imageFile, e);\n         target.clear();\n         imageFile \u003d null;\n       }\n     }\n     // Failed to load any images, error out\n     if (imageFile \u003d\u003d null) {\n       FSEditLog.closeAllStreams(editStreams);\n       throw new IOException(\"Failed to load FSImage file, see error(s) \" +\n           \"above for more info.\");\n     }\n     prog.endPhase(Phase.LOADING_FSIMAGE);\n     \n     if (!rollingRollback) {\n-      long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n+      long txnsAdvanced \u003d loadEdits(editStreams, target, Long.MAX_VALUE,\n+          startOpt, recovery);\n       needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n           txnsAdvanced);\n     } else {\n       // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n       // to the last txid in rollback fsimage.\n       rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n       needToSave \u003d false;\n     }\n     editLog.setNextTxId(lastAppliedTxId + 1);\n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    final boolean rollingRollback\n        \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n    final EnumSet\u003cNameNodeFile\u003e nnfs;\n    if (rollingRollback) {\n      // if it is rollback of rolling upgrade, only load from the rollback image\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n    } else {\n      // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n    }\n    final FSImageStorageInspector inspector \u003d storage\n        .readAndInspectDirs(nnfs, startOpt);\n\n    isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n    List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    prog.beginPhase(Phase.LOADING_FSIMAGE);\n    File phaseFile \u003d imageFiles.get(0).getFile();\n    prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n    prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n    boolean needToSave \u003d inspector.needToSave();\n\n    Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n\n    initEditLog(startOpt);\n\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n      // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n      // OK to not be able to read all of edits right now.\n      // In the meanwhile, for HA upgrade, we will still write editlog thus need\n      // this toAtLeastTxId to be set to the max-seen txid\n      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n      // the txid right before the upgrade marker.  \n      long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n          .getMaxSeenTxId() : 0;\n      if (rollingRollback) {\n        // note that the first image in imageFiles is the special checkpoint\n        // for the rolling upgrade\n        toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n      }\n      editStreams \u003d editLog.selectInputStreams(\n          imageFiles.get(0).getCheckpointTxId() + 1,\n          toAtLeastTxId, recovery, false);\n    } else {\n      editStreams \u003d FSImagePreTransactionalStorageInspector\n        .getEditLogStreams(storage);\n    }\n    int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n        DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n    for (EditLogInputStream elis : editStreams) {\n      elis.setMaxOpSize(maxOpSize);\n    }\n \n    for (EditLogInputStream l : editStreams) {\n      LOG.debug(\"Planning to load edit log stream: \" + l);\n    }\n    if (!editStreams.iterator().hasNext()) {\n      LOG.info(\"No edit log streams selected.\");\n    }\n    \n    FSImageFile imageFile \u003d null;\n    for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n      try {\n        imageFile \u003d imageFiles.get(i);\n        loadFSImageFile(target, recovery, imageFile, startOpt);\n        break;\n      } catch (IllegalReservedPathException ie) {\n        throw new IOException(\"Failed to load image from \" + imageFile,\n            ie);\n      } catch (Exception e) {\n        LOG.error(\"Failed to load image from \" + imageFile, e);\n        target.clear();\n        imageFile \u003d null;\n      }\n    }\n    // Failed to load any images, error out\n    if (imageFile \u003d\u003d null) {\n      FSEditLog.closeAllStreams(editStreams);\n      throw new IOException(\"Failed to load FSImage file, see error(s) \" +\n          \"above for more info.\");\n    }\n    prog.endPhase(Phase.LOADING_FSIMAGE);\n    \n    if (!rollingRollback) {\n      long txnsAdvanced \u003d loadEdits(editStreams, target, Long.MAX_VALUE,\n          startOpt, recovery);\n      needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n          txnsAdvanced);\n    } else {\n      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n      // to the last txid in rollback fsimage.\n      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n      needToSave \u003d false;\n    }\n    editLog.setNextTxId(lastAppliedTxId + 1);\n    return needToSave;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "d2026ae9e6c86f4fd9e48b80e71233181c1853d9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11262. Remove unused variables in FSImage.java. Contributed by Jagadesh Kiran N.\n",
      "commitDate": "19/12/16 9:34 PM",
      "commitName": "d2026ae9e6c86f4fd9e48b80e71233181c1853d9",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "01/12/16 6:08 AM",
      "commitNameOld": "e0fa49234fd37aca88e1caa95bac77bca192bae4",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 18.64,
      "commitsBetweenForRepo": 99,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,102 @@\n   private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     final boolean rollingRollback\n         \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n     final EnumSet\u003cNameNodeFile\u003e nnfs;\n     if (rollingRollback) {\n       // if it is rollback of rolling upgrade, only load from the rollback image\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n     } else {\n       // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n     }\n     final FSImageStorageInspector inspector \u003d storage\n         .readAndInspectDirs(nnfs, startOpt);\n \n     isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n     List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n \n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     prog.beginPhase(Phase.LOADING_FSIMAGE);\n     File phaseFile \u003d imageFiles.get(0).getFile();\n     prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n     prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n     boolean needToSave \u003d inspector.needToSave();\n \n     Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n \n     initEditLog(startOpt);\n \n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n       // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n       // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n       // OK to not be able to read all of edits right now.\n       // In the meanwhile, for HA upgrade, we will still write editlog thus need\n       // this toAtLeastTxId to be set to the max-seen txid\n       // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n       // the txid right before the upgrade marker.  \n       long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n           .getMaxSeenTxId() : 0;\n       if (rollingRollback) {\n         // note that the first image in imageFiles is the special checkpoint\n         // for the rolling upgrade\n         toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n       }\n       editStreams \u003d editLog.selectInputStreams(\n           imageFiles.get(0).getCheckpointTxId() + 1,\n           toAtLeastTxId, recovery, false);\n     } else {\n       editStreams \u003d FSImagePreTransactionalStorageInspector\n         .getEditLogStreams(storage);\n     }\n     int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n         DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n     for (EditLogInputStream elis : editStreams) {\n       elis.setMaxOpSize(maxOpSize);\n     }\n  \n     for (EditLogInputStream l : editStreams) {\n       LOG.debug(\"Planning to load edit log stream: \" + l);\n     }\n     if (!editStreams.iterator().hasNext()) {\n       LOG.info(\"No edit log streams selected.\");\n     }\n     \n-    Exception le \u003d null;\n     FSImageFile imageFile \u003d null;\n     for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n       try {\n         imageFile \u003d imageFiles.get(i);\n         loadFSImageFile(target, recovery, imageFile, startOpt);\n         break;\n       } catch (IllegalReservedPathException ie) {\n         throw new IOException(\"Failed to load image from \" + imageFile,\n             ie);\n       } catch (Exception e) {\n-        le \u003d e;\n         LOG.error(\"Failed to load image from \" + imageFile, e);\n         target.clear();\n         imageFile \u003d null;\n       }\n     }\n     // Failed to load any images, error out\n     if (imageFile \u003d\u003d null) {\n       FSEditLog.closeAllStreams(editStreams);\n       throw new IOException(\"Failed to load FSImage file, see error(s) \" +\n           \"above for more info.\");\n     }\n     prog.endPhase(Phase.LOADING_FSIMAGE);\n     \n     if (!rollingRollback) {\n       long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n       needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n           txnsAdvanced);\n     } else {\n       // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n       // to the last txid in rollback fsimage.\n       rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n       needToSave \u003d false;\n     }\n     editLog.setNextTxId(lastAppliedTxId + 1);\n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    final boolean rollingRollback\n        \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n    final EnumSet\u003cNameNodeFile\u003e nnfs;\n    if (rollingRollback) {\n      // if it is rollback of rolling upgrade, only load from the rollback image\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n    } else {\n      // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n    }\n    final FSImageStorageInspector inspector \u003d storage\n        .readAndInspectDirs(nnfs, startOpt);\n\n    isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n    List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    prog.beginPhase(Phase.LOADING_FSIMAGE);\n    File phaseFile \u003d imageFiles.get(0).getFile();\n    prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n    prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n    boolean needToSave \u003d inspector.needToSave();\n\n    Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n\n    initEditLog(startOpt);\n\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n      // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n      // OK to not be able to read all of edits right now.\n      // In the meanwhile, for HA upgrade, we will still write editlog thus need\n      // this toAtLeastTxId to be set to the max-seen txid\n      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n      // the txid right before the upgrade marker.  \n      long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n          .getMaxSeenTxId() : 0;\n      if (rollingRollback) {\n        // note that the first image in imageFiles is the special checkpoint\n        // for the rolling upgrade\n        toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n      }\n      editStreams \u003d editLog.selectInputStreams(\n          imageFiles.get(0).getCheckpointTxId() + 1,\n          toAtLeastTxId, recovery, false);\n    } else {\n      editStreams \u003d FSImagePreTransactionalStorageInspector\n        .getEditLogStreams(storage);\n    }\n    int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n        DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n    for (EditLogInputStream elis : editStreams) {\n      elis.setMaxOpSize(maxOpSize);\n    }\n \n    for (EditLogInputStream l : editStreams) {\n      LOG.debug(\"Planning to load edit log stream: \" + l);\n    }\n    if (!editStreams.iterator().hasNext()) {\n      LOG.info(\"No edit log streams selected.\");\n    }\n    \n    FSImageFile imageFile \u003d null;\n    for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n      try {\n        imageFile \u003d imageFiles.get(i);\n        loadFSImageFile(target, recovery, imageFile, startOpt);\n        break;\n      } catch (IllegalReservedPathException ie) {\n        throw new IOException(\"Failed to load image from \" + imageFile,\n            ie);\n      } catch (Exception e) {\n        LOG.error(\"Failed to load image from \" + imageFile, e);\n        target.clear();\n        imageFile \u003d null;\n      }\n    }\n    // Failed to load any images, error out\n    if (imageFile \u003d\u003d null) {\n      FSEditLog.closeAllStreams(editStreams);\n      throw new IOException(\"Failed to load FSImage file, see error(s) \" +\n          \"above for more info.\");\n    }\n    prog.endPhase(Phase.LOADING_FSIMAGE);\n    \n    if (!rollingRollback) {\n      long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n      needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n          txnsAdvanced);\n    } else {\n      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n      // to the last txid in rollback fsimage.\n      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n      needToSave \u003d false;\n    }\n    editLog.setNextTxId(lastAppliedTxId + 1);\n    return needToSave;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "25051c3bd08efc12333a6acb51782cc7800403a4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9569. Log the name of the fsimage being loaded for better supportability. (Yongjun Zhang)\n",
      "commitDate": "12/01/16 9:22 AM",
      "commitName": "25051c3bd08efc12333a6acb51782cc7800403a4",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "17/12/15 1:50 PM",
      "commitNameOld": "db37f02dc704ad9eec8c56e3e466a5f37d138d74",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 25.81,
      "commitsBetweenForRepo": 120,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,104 @@\n   private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     final boolean rollingRollback\n         \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n     final EnumSet\u003cNameNodeFile\u003e nnfs;\n     if (rollingRollback) {\n       // if it is rollback of rolling upgrade, only load from the rollback image\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n     } else {\n       // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n     }\n     final FSImageStorageInspector inspector \u003d storage\n         .readAndInspectDirs(nnfs, startOpt);\n \n     isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n     List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n \n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     prog.beginPhase(Phase.LOADING_FSIMAGE);\n     File phaseFile \u003d imageFiles.get(0).getFile();\n     prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n     prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n     boolean needToSave \u003d inspector.needToSave();\n \n     Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n \n     initEditLog(startOpt);\n \n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n       // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n       // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n       // OK to not be able to read all of edits right now.\n       // In the meanwhile, for HA upgrade, we will still write editlog thus need\n       // this toAtLeastTxId to be set to the max-seen txid\n       // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n       // the txid right before the upgrade marker.  \n       long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n           .getMaxSeenTxId() : 0;\n       if (rollingRollback) {\n         // note that the first image in imageFiles is the special checkpoint\n         // for the rolling upgrade\n         toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n       }\n       editStreams \u003d editLog.selectInputStreams(\n           imageFiles.get(0).getCheckpointTxId() + 1,\n           toAtLeastTxId, recovery, false);\n     } else {\n       editStreams \u003d FSImagePreTransactionalStorageInspector\n         .getEditLogStreams(storage);\n     }\n     int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n         DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n     for (EditLogInputStream elis : editStreams) {\n       elis.setMaxOpSize(maxOpSize);\n     }\n  \n     for (EditLogInputStream l : editStreams) {\n       LOG.debug(\"Planning to load edit log stream: \" + l);\n     }\n     if (!editStreams.iterator().hasNext()) {\n       LOG.info(\"No edit log streams selected.\");\n     }\n     \n+    Exception le \u003d null;\n     FSImageFile imageFile \u003d null;\n     for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n       try {\n         imageFile \u003d imageFiles.get(i);\n         loadFSImageFile(target, recovery, imageFile, startOpt);\n         break;\n-      } catch (IOException ioe) {\n-        LOG.error(\"Failed to load image from \" + imageFile, ioe);\n+      } catch (IllegalReservedPathException ie) {\n+        throw new IOException(\"Failed to load image from \" + imageFile,\n+            ie);\n+      } catch (Exception e) {\n+        le \u003d e;\n+        LOG.error(\"Failed to load image from \" + imageFile, e);\n         target.clear();\n         imageFile \u003d null;\n       }\n     }\n     // Failed to load any images, error out\n     if (imageFile \u003d\u003d null) {\n       FSEditLog.closeAllStreams(editStreams);\n-      throw new IOException(\"Failed to load an FSImage file!\");\n+      throw new IOException(\"Failed to load FSImage file, see error(s) \" +\n+          \"above for more info.\");\n     }\n     prog.endPhase(Phase.LOADING_FSIMAGE);\n     \n     if (!rollingRollback) {\n       long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n       needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n           txnsAdvanced);\n     } else {\n       // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n       // to the last txid in rollback fsimage.\n       rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n       needToSave \u003d false;\n     }\n     editLog.setNextTxId(lastAppliedTxId + 1);\n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    final boolean rollingRollback\n        \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n    final EnumSet\u003cNameNodeFile\u003e nnfs;\n    if (rollingRollback) {\n      // if it is rollback of rolling upgrade, only load from the rollback image\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n    } else {\n      // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n    }\n    final FSImageStorageInspector inspector \u003d storage\n        .readAndInspectDirs(nnfs, startOpt);\n\n    isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n    List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    prog.beginPhase(Phase.LOADING_FSIMAGE);\n    File phaseFile \u003d imageFiles.get(0).getFile();\n    prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n    prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n    boolean needToSave \u003d inspector.needToSave();\n\n    Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n\n    initEditLog(startOpt);\n\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n      // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n      // OK to not be able to read all of edits right now.\n      // In the meanwhile, for HA upgrade, we will still write editlog thus need\n      // this toAtLeastTxId to be set to the max-seen txid\n      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n      // the txid right before the upgrade marker.  \n      long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n          .getMaxSeenTxId() : 0;\n      if (rollingRollback) {\n        // note that the first image in imageFiles is the special checkpoint\n        // for the rolling upgrade\n        toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n      }\n      editStreams \u003d editLog.selectInputStreams(\n          imageFiles.get(0).getCheckpointTxId() + 1,\n          toAtLeastTxId, recovery, false);\n    } else {\n      editStreams \u003d FSImagePreTransactionalStorageInspector\n        .getEditLogStreams(storage);\n    }\n    int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n        DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n    for (EditLogInputStream elis : editStreams) {\n      elis.setMaxOpSize(maxOpSize);\n    }\n \n    for (EditLogInputStream l : editStreams) {\n      LOG.debug(\"Planning to load edit log stream: \" + l);\n    }\n    if (!editStreams.iterator().hasNext()) {\n      LOG.info(\"No edit log streams selected.\");\n    }\n    \n    Exception le \u003d null;\n    FSImageFile imageFile \u003d null;\n    for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n      try {\n        imageFile \u003d imageFiles.get(i);\n        loadFSImageFile(target, recovery, imageFile, startOpt);\n        break;\n      } catch (IllegalReservedPathException ie) {\n        throw new IOException(\"Failed to load image from \" + imageFile,\n            ie);\n      } catch (Exception e) {\n        le \u003d e;\n        LOG.error(\"Failed to load image from \" + imageFile, e);\n        target.clear();\n        imageFile \u003d null;\n      }\n    }\n    // Failed to load any images, error out\n    if (imageFile \u003d\u003d null) {\n      FSEditLog.closeAllStreams(editStreams);\n      throw new IOException(\"Failed to load FSImage file, see error(s) \" +\n          \"above for more info.\");\n    }\n    prog.endPhase(Phase.LOADING_FSIMAGE);\n    \n    if (!rollingRollback) {\n      long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n      needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n          txnsAdvanced);\n    } else {\n      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n      // to the last txid in rollback fsimage.\n      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n      needToSave \u003d false;\n    }\n    editLog.setNextTxId(lastAppliedTxId + 1);\n    return needToSave;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "db37f02dc704ad9eec8c56e3e466a5f37d138d74": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9569.  Log the name of the fsimage being loaded for better supportability. Contributed by Yongjun Zhang.\"\n\nThis reverts commit eb6939cea0343840c62b930d4adb377f5eaf879f.\n",
      "commitDate": "17/12/15 1:50 PM",
      "commitName": "db37f02dc704ad9eec8c56e3e466a5f37d138d74",
      "commitAuthor": "cnauroth",
      "commitDateOld": "17/12/15 8:29 AM",
      "commitNameOld": "eb6939cea0343840c62b930d4adb377f5eaf879f",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.22,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n   private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     final boolean rollingRollback\n         \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n     final EnumSet\u003cNameNodeFile\u003e nnfs;\n     if (rollingRollback) {\n       // if it is rollback of rolling upgrade, only load from the rollback image\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n     } else {\n       // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n     }\n     final FSImageStorageInspector inspector \u003d storage\n         .readAndInspectDirs(nnfs, startOpt);\n \n     isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n     List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n \n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     prog.beginPhase(Phase.LOADING_FSIMAGE);\n     File phaseFile \u003d imageFiles.get(0).getFile();\n     prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n     prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n     boolean needToSave \u003d inspector.needToSave();\n \n     Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n \n     initEditLog(startOpt);\n \n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n       // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n       // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n       // OK to not be able to read all of edits right now.\n       // In the meanwhile, for HA upgrade, we will still write editlog thus need\n       // this toAtLeastTxId to be set to the max-seen txid\n       // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n       // the txid right before the upgrade marker.  \n       long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n           .getMaxSeenTxId() : 0;\n       if (rollingRollback) {\n         // note that the first image in imageFiles is the special checkpoint\n         // for the rolling upgrade\n         toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n       }\n       editStreams \u003d editLog.selectInputStreams(\n           imageFiles.get(0).getCheckpointTxId() + 1,\n           toAtLeastTxId, recovery, false);\n     } else {\n       editStreams \u003d FSImagePreTransactionalStorageInspector\n         .getEditLogStreams(storage);\n     }\n     int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n         DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n     for (EditLogInputStream elis : editStreams) {\n       elis.setMaxOpSize(maxOpSize);\n     }\n  \n     for (EditLogInputStream l : editStreams) {\n       LOG.debug(\"Planning to load edit log stream: \" + l);\n     }\n     if (!editStreams.iterator().hasNext()) {\n       LOG.info(\"No edit log streams selected.\");\n     }\n     \n     FSImageFile imageFile \u003d null;\n     for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n       try {\n         imageFile \u003d imageFiles.get(i);\n         loadFSImageFile(target, recovery, imageFile, startOpt);\n         break;\n-      } catch (Exception e) {\n-        LOG.error(\"Failed to load image from \" + imageFile, e);\n+      } catch (IOException ioe) {\n+        LOG.error(\"Failed to load image from \" + imageFile, ioe);\n         target.clear();\n         imageFile \u003d null;\n       }\n     }\n     // Failed to load any images, error out\n     if (imageFile \u003d\u003d null) {\n       FSEditLog.closeAllStreams(editStreams);\n       throw new IOException(\"Failed to load an FSImage file!\");\n     }\n     prog.endPhase(Phase.LOADING_FSIMAGE);\n     \n     if (!rollingRollback) {\n       long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n       needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n           txnsAdvanced);\n     } else {\n       // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n       // to the last txid in rollback fsimage.\n       rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n       needToSave \u003d false;\n     }\n     editLog.setNextTxId(lastAppliedTxId + 1);\n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    final boolean rollingRollback\n        \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n    final EnumSet\u003cNameNodeFile\u003e nnfs;\n    if (rollingRollback) {\n      // if it is rollback of rolling upgrade, only load from the rollback image\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n    } else {\n      // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n    }\n    final FSImageStorageInspector inspector \u003d storage\n        .readAndInspectDirs(nnfs, startOpt);\n\n    isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n    List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    prog.beginPhase(Phase.LOADING_FSIMAGE);\n    File phaseFile \u003d imageFiles.get(0).getFile();\n    prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n    prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n    boolean needToSave \u003d inspector.needToSave();\n\n    Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n\n    initEditLog(startOpt);\n\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n      // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n      // OK to not be able to read all of edits right now.\n      // In the meanwhile, for HA upgrade, we will still write editlog thus need\n      // this toAtLeastTxId to be set to the max-seen txid\n      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n      // the txid right before the upgrade marker.  \n      long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n          .getMaxSeenTxId() : 0;\n      if (rollingRollback) {\n        // note that the first image in imageFiles is the special checkpoint\n        // for the rolling upgrade\n        toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n      }\n      editStreams \u003d editLog.selectInputStreams(\n          imageFiles.get(0).getCheckpointTxId() + 1,\n          toAtLeastTxId, recovery, false);\n    } else {\n      editStreams \u003d FSImagePreTransactionalStorageInspector\n        .getEditLogStreams(storage);\n    }\n    int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n        DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n    for (EditLogInputStream elis : editStreams) {\n      elis.setMaxOpSize(maxOpSize);\n    }\n \n    for (EditLogInputStream l : editStreams) {\n      LOG.debug(\"Planning to load edit log stream: \" + l);\n    }\n    if (!editStreams.iterator().hasNext()) {\n      LOG.info(\"No edit log streams selected.\");\n    }\n    \n    FSImageFile imageFile \u003d null;\n    for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n      try {\n        imageFile \u003d imageFiles.get(i);\n        loadFSImageFile(target, recovery, imageFile, startOpt);\n        break;\n      } catch (IOException ioe) {\n        LOG.error(\"Failed to load image from \" + imageFile, ioe);\n        target.clear();\n        imageFile \u003d null;\n      }\n    }\n    // Failed to load any images, error out\n    if (imageFile \u003d\u003d null) {\n      FSEditLog.closeAllStreams(editStreams);\n      throw new IOException(\"Failed to load an FSImage file!\");\n    }\n    prog.endPhase(Phase.LOADING_FSIMAGE);\n    \n    if (!rollingRollback) {\n      long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n      needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n          txnsAdvanced);\n    } else {\n      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n      // to the last txid in rollback fsimage.\n      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n      needToSave \u003d false;\n    }\n    editLog.setNextTxId(lastAppliedTxId + 1);\n    return needToSave;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "eb6939cea0343840c62b930d4adb377f5eaf879f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9569.  Log the name of the fsimage being loaded for better supportability. Contributed by Yongjun Zhang.\n",
      "commitDate": "17/12/15 8:29 AM",
      "commitName": "eb6939cea0343840c62b930d4adb377f5eaf879f",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "22/11/15 11:02 PM",
      "commitNameOld": "822869785707b5665962ec0c699cd383dc767345",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 24.39,
      "commitsBetweenForRepo": 156,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n   private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     final boolean rollingRollback\n         \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n     final EnumSet\u003cNameNodeFile\u003e nnfs;\n     if (rollingRollback) {\n       // if it is rollback of rolling upgrade, only load from the rollback image\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n     } else {\n       // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n     }\n     final FSImageStorageInspector inspector \u003d storage\n         .readAndInspectDirs(nnfs, startOpt);\n \n     isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n     List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n \n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     prog.beginPhase(Phase.LOADING_FSIMAGE);\n     File phaseFile \u003d imageFiles.get(0).getFile();\n     prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n     prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n     boolean needToSave \u003d inspector.needToSave();\n \n     Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n \n     initEditLog(startOpt);\n \n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n       // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n       // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n       // OK to not be able to read all of edits right now.\n       // In the meanwhile, for HA upgrade, we will still write editlog thus need\n       // this toAtLeastTxId to be set to the max-seen txid\n       // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n       // the txid right before the upgrade marker.  \n       long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n           .getMaxSeenTxId() : 0;\n       if (rollingRollback) {\n         // note that the first image in imageFiles is the special checkpoint\n         // for the rolling upgrade\n         toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n       }\n       editStreams \u003d editLog.selectInputStreams(\n           imageFiles.get(0).getCheckpointTxId() + 1,\n           toAtLeastTxId, recovery, false);\n     } else {\n       editStreams \u003d FSImagePreTransactionalStorageInspector\n         .getEditLogStreams(storage);\n     }\n     int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n         DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n     for (EditLogInputStream elis : editStreams) {\n       elis.setMaxOpSize(maxOpSize);\n     }\n  \n     for (EditLogInputStream l : editStreams) {\n       LOG.debug(\"Planning to load edit log stream: \" + l);\n     }\n     if (!editStreams.iterator().hasNext()) {\n       LOG.info(\"No edit log streams selected.\");\n     }\n     \n     FSImageFile imageFile \u003d null;\n     for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n       try {\n         imageFile \u003d imageFiles.get(i);\n         loadFSImageFile(target, recovery, imageFile, startOpt);\n         break;\n-      } catch (IOException ioe) {\n-        LOG.error(\"Failed to load image from \" + imageFile, ioe);\n+      } catch (Exception e) {\n+        LOG.error(\"Failed to load image from \" + imageFile, e);\n         target.clear();\n         imageFile \u003d null;\n       }\n     }\n     // Failed to load any images, error out\n     if (imageFile \u003d\u003d null) {\n       FSEditLog.closeAllStreams(editStreams);\n       throw new IOException(\"Failed to load an FSImage file!\");\n     }\n     prog.endPhase(Phase.LOADING_FSIMAGE);\n     \n     if (!rollingRollback) {\n       long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n       needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n           txnsAdvanced);\n     } else {\n       // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n       // to the last txid in rollback fsimage.\n       rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n       needToSave \u003d false;\n     }\n     editLog.setNextTxId(lastAppliedTxId + 1);\n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    final boolean rollingRollback\n        \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n    final EnumSet\u003cNameNodeFile\u003e nnfs;\n    if (rollingRollback) {\n      // if it is rollback of rolling upgrade, only load from the rollback image\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n    } else {\n      // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n    }\n    final FSImageStorageInspector inspector \u003d storage\n        .readAndInspectDirs(nnfs, startOpt);\n\n    isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n    List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    prog.beginPhase(Phase.LOADING_FSIMAGE);\n    File phaseFile \u003d imageFiles.get(0).getFile();\n    prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n    prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n    boolean needToSave \u003d inspector.needToSave();\n\n    Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n\n    initEditLog(startOpt);\n\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n      // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n      // OK to not be able to read all of edits right now.\n      // In the meanwhile, for HA upgrade, we will still write editlog thus need\n      // this toAtLeastTxId to be set to the max-seen txid\n      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n      // the txid right before the upgrade marker.  \n      long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n          .getMaxSeenTxId() : 0;\n      if (rollingRollback) {\n        // note that the first image in imageFiles is the special checkpoint\n        // for the rolling upgrade\n        toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n      }\n      editStreams \u003d editLog.selectInputStreams(\n          imageFiles.get(0).getCheckpointTxId() + 1,\n          toAtLeastTxId, recovery, false);\n    } else {\n      editStreams \u003d FSImagePreTransactionalStorageInspector\n        .getEditLogStreams(storage);\n    }\n    int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n        DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n    for (EditLogInputStream elis : editStreams) {\n      elis.setMaxOpSize(maxOpSize);\n    }\n \n    for (EditLogInputStream l : editStreams) {\n      LOG.debug(\"Planning to load edit log stream: \" + l);\n    }\n    if (!editStreams.iterator().hasNext()) {\n      LOG.info(\"No edit log streams selected.\");\n    }\n    \n    FSImageFile imageFile \u003d null;\n    for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n      try {\n        imageFile \u003d imageFiles.get(i);\n        loadFSImageFile(target, recovery, imageFile, startOpt);\n        break;\n      } catch (Exception e) {\n        LOG.error(\"Failed to load image from \" + imageFile, e);\n        target.clear();\n        imageFile \u003d null;\n      }\n    }\n    // Failed to load any images, error out\n    if (imageFile \u003d\u003d null) {\n      FSEditLog.closeAllStreams(editStreams);\n      throw new IOException(\"Failed to load an FSImage file!\");\n    }\n    prog.endPhase(Phase.LOADING_FSIMAGE);\n    \n    if (!rollingRollback) {\n      long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n      needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n          txnsAdvanced);\n    } else {\n      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n      // to the last txid in rollback fsimage.\n      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n      needToSave \u003d false;\n    }\n    editLog.setNextTxId(lastAppliedTxId + 1);\n    return needToSave;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "431e7d84c7b68b34ff18de19afe8e46637047fa6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7302. Remove \"downgrade\" from \"namenode -rollingUpgrade\" startup option since it may incorrectly finalize an ongoing rolling upgrade.\n    Contributed by Kai Sasaki\n",
      "commitDate": "02/03/15 6:04 PM",
      "commitName": "431e7d84c7b68b34ff18de19afe8e46637047fa6",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "21/02/15 3:38 PM",
      "commitNameOld": "8b465b4b8caed31ca9daeaae108f9a868a30a455",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 9.1,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,98 @@\n   private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     final boolean rollingRollback\n         \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n     final EnumSet\u003cNameNodeFile\u003e nnfs;\n     if (rollingRollback) {\n       // if it is rollback of rolling upgrade, only load from the rollback image\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n     } else {\n       // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n     }\n     final FSImageStorageInspector inspector \u003d storage\n         .readAndInspectDirs(nnfs, startOpt);\n \n     isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n     List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n \n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     prog.beginPhase(Phase.LOADING_FSIMAGE);\n     File phaseFile \u003d imageFiles.get(0).getFile();\n     prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n     prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n     boolean needToSave \u003d inspector.needToSave();\n \n     Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n \n     initEditLog(startOpt);\n \n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n       // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n       // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n       // OK to not be able to read all of edits right now.\n       // In the meanwhile, for HA upgrade, we will still write editlog thus need\n       // this toAtLeastTxId to be set to the max-seen txid\n       // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n       // the txid right before the upgrade marker.  \n       long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n           .getMaxSeenTxId() : 0;\n       if (rollingRollback) {\n         // note that the first image in imageFiles is the special checkpoint\n         // for the rolling upgrade\n         toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n       }\n       editStreams \u003d editLog.selectInputStreams(\n           imageFiles.get(0).getCheckpointTxId() + 1,\n           toAtLeastTxId, recovery, false);\n     } else {\n       editStreams \u003d FSImagePreTransactionalStorageInspector\n         .getEditLogStreams(storage);\n     }\n     int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n         DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n     for (EditLogInputStream elis : editStreams) {\n       elis.setMaxOpSize(maxOpSize);\n     }\n  \n     for (EditLogInputStream l : editStreams) {\n       LOG.debug(\"Planning to load edit log stream: \" + l);\n     }\n     if (!editStreams.iterator().hasNext()) {\n       LOG.info(\"No edit log streams selected.\");\n     }\n     \n     FSImageFile imageFile \u003d null;\n     for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n       try {\n         imageFile \u003d imageFiles.get(i);\n         loadFSImageFile(target, recovery, imageFile, startOpt);\n         break;\n       } catch (IOException ioe) {\n         LOG.error(\"Failed to load image from \" + imageFile, ioe);\n         target.clear();\n         imageFile \u003d null;\n       }\n     }\n     // Failed to load any images, error out\n     if (imageFile \u003d\u003d null) {\n       FSEditLog.closeAllStreams(editStreams);\n       throw new IOException(\"Failed to load an FSImage file!\");\n     }\n     prog.endPhase(Phase.LOADING_FSIMAGE);\n     \n     if (!rollingRollback) {\n       long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n       needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n           txnsAdvanced);\n-      if (RollingUpgradeStartupOption.DOWNGRADE.matches(startOpt)) {\n-        // rename rollback image if it is downgrade\n-        renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK, NameNodeFile.IMAGE);\n-      }\n     } else {\n       // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n       // to the last txid in rollback fsimage.\n       rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n       needToSave \u003d false;\n     }\n     editLog.setNextTxId(lastAppliedTxId + 1);\n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    final boolean rollingRollback\n        \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n    final EnumSet\u003cNameNodeFile\u003e nnfs;\n    if (rollingRollback) {\n      // if it is rollback of rolling upgrade, only load from the rollback image\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n    } else {\n      // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n    }\n    final FSImageStorageInspector inspector \u003d storage\n        .readAndInspectDirs(nnfs, startOpt);\n\n    isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n    List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    prog.beginPhase(Phase.LOADING_FSIMAGE);\n    File phaseFile \u003d imageFiles.get(0).getFile();\n    prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n    prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n    boolean needToSave \u003d inspector.needToSave();\n\n    Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n\n    initEditLog(startOpt);\n\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n      // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n      // OK to not be able to read all of edits right now.\n      // In the meanwhile, for HA upgrade, we will still write editlog thus need\n      // this toAtLeastTxId to be set to the max-seen txid\n      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n      // the txid right before the upgrade marker.  \n      long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n          .getMaxSeenTxId() : 0;\n      if (rollingRollback) {\n        // note that the first image in imageFiles is the special checkpoint\n        // for the rolling upgrade\n        toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n      }\n      editStreams \u003d editLog.selectInputStreams(\n          imageFiles.get(0).getCheckpointTxId() + 1,\n          toAtLeastTxId, recovery, false);\n    } else {\n      editStreams \u003d FSImagePreTransactionalStorageInspector\n        .getEditLogStreams(storage);\n    }\n    int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n        DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n    for (EditLogInputStream elis : editStreams) {\n      elis.setMaxOpSize(maxOpSize);\n    }\n \n    for (EditLogInputStream l : editStreams) {\n      LOG.debug(\"Planning to load edit log stream: \" + l);\n    }\n    if (!editStreams.iterator().hasNext()) {\n      LOG.info(\"No edit log streams selected.\");\n    }\n    \n    FSImageFile imageFile \u003d null;\n    for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n      try {\n        imageFile \u003d imageFiles.get(i);\n        loadFSImageFile(target, recovery, imageFile, startOpt);\n        break;\n      } catch (IOException ioe) {\n        LOG.error(\"Failed to load image from \" + imageFile, ioe);\n        target.clear();\n        imageFile \u003d null;\n      }\n    }\n    // Failed to load any images, error out\n    if (imageFile \u003d\u003d null) {\n      FSEditLog.closeAllStreams(editStreams);\n      throw new IOException(\"Failed to load an FSImage file!\");\n    }\n    prog.endPhase(Phase.LOADING_FSIMAGE);\n    \n    if (!rollingRollback) {\n      long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n      needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n          txnsAdvanced);\n    } else {\n      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n      // to the last txid in rollback fsimage.\n      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n      needToSave \u003d false;\n    }\n    editLog.setNextTxId(lastAppliedTxId + 1);\n    return needToSave;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "18620649f96d9e378fb7ea40de216284a9d525c7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7185. The active NameNode will not accept an fsimage sent from the standby during rolling upgrade. Contributed by Jing Zhao.\n",
      "commitDate": "15/10/14 10:27 AM",
      "commitName": "18620649f96d9e378fb7ea40de216284a9d525c7",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "18/07/14 10:14 AM",
      "commitNameOld": "5f9e52f7459d3dc4ac3a5febd1dc6e00829d30ed",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 89.01,
      "commitsBetweenForRepo": 875,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,102 @@\n   private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     final boolean rollingRollback\n         \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n     final EnumSet\u003cNameNodeFile\u003e nnfs;\n     if (rollingRollback) {\n       // if it is rollback of rolling upgrade, only load from the rollback image\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n     } else {\n       // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n     }\n-    final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(nnfs);\n+    final FSImageStorageInspector inspector \u003d storage\n+        .readAndInspectDirs(nnfs, startOpt);\n \n     isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n     List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n \n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     prog.beginPhase(Phase.LOADING_FSIMAGE);\n     File phaseFile \u003d imageFiles.get(0).getFile();\n     prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n     prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n     boolean needToSave \u003d inspector.needToSave();\n \n     Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n \n     initEditLog(startOpt);\n \n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n       // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n       // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n       // OK to not be able to read all of edits right now.\n       // In the meanwhile, for HA upgrade, we will still write editlog thus need\n       // this toAtLeastTxId to be set to the max-seen txid\n       // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n       // the txid right before the upgrade marker.  \n       long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n           .getMaxSeenTxId() : 0;\n       if (rollingRollback) {\n         // note that the first image in imageFiles is the special checkpoint\n         // for the rolling upgrade\n         toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n       }\n       editStreams \u003d editLog.selectInputStreams(\n           imageFiles.get(0).getCheckpointTxId() + 1,\n           toAtLeastTxId, recovery, false);\n     } else {\n       editStreams \u003d FSImagePreTransactionalStorageInspector\n         .getEditLogStreams(storage);\n     }\n     int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n         DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n     for (EditLogInputStream elis : editStreams) {\n       elis.setMaxOpSize(maxOpSize);\n     }\n  \n     for (EditLogInputStream l : editStreams) {\n       LOG.debug(\"Planning to load edit log stream: \" + l);\n     }\n     if (!editStreams.iterator().hasNext()) {\n       LOG.info(\"No edit log streams selected.\");\n     }\n     \n     FSImageFile imageFile \u003d null;\n     for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n       try {\n         imageFile \u003d imageFiles.get(i);\n-        loadFSImageFile(target, recovery, imageFile);\n+        loadFSImageFile(target, recovery, imageFile, startOpt);\n         break;\n       } catch (IOException ioe) {\n         LOG.error(\"Failed to load image from \" + imageFile, ioe);\n         target.clear();\n         imageFile \u003d null;\n       }\n     }\n     // Failed to load any images, error out\n     if (imageFile \u003d\u003d null) {\n       FSEditLog.closeAllStreams(editStreams);\n       throw new IOException(\"Failed to load an FSImage file!\");\n     }\n     prog.endPhase(Phase.LOADING_FSIMAGE);\n     \n     if (!rollingRollback) {\n       long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n       needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n           txnsAdvanced);\n       if (RollingUpgradeStartupOption.DOWNGRADE.matches(startOpt)) {\n         // rename rollback image if it is downgrade\n         renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK, NameNodeFile.IMAGE);\n       }\n     } else {\n       // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n       // to the last txid in rollback fsimage.\n       rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n       needToSave \u003d false;\n     }\n     editLog.setNextTxId(lastAppliedTxId + 1);\n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    final boolean rollingRollback\n        \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n    final EnumSet\u003cNameNodeFile\u003e nnfs;\n    if (rollingRollback) {\n      // if it is rollback of rolling upgrade, only load from the rollback image\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n    } else {\n      // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n    }\n    final FSImageStorageInspector inspector \u003d storage\n        .readAndInspectDirs(nnfs, startOpt);\n\n    isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n    List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    prog.beginPhase(Phase.LOADING_FSIMAGE);\n    File phaseFile \u003d imageFiles.get(0).getFile();\n    prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n    prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n    boolean needToSave \u003d inspector.needToSave();\n\n    Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n\n    initEditLog(startOpt);\n\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n      // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n      // OK to not be able to read all of edits right now.\n      // In the meanwhile, for HA upgrade, we will still write editlog thus need\n      // this toAtLeastTxId to be set to the max-seen txid\n      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n      // the txid right before the upgrade marker.  \n      long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n          .getMaxSeenTxId() : 0;\n      if (rollingRollback) {\n        // note that the first image in imageFiles is the special checkpoint\n        // for the rolling upgrade\n        toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n      }\n      editStreams \u003d editLog.selectInputStreams(\n          imageFiles.get(0).getCheckpointTxId() + 1,\n          toAtLeastTxId, recovery, false);\n    } else {\n      editStreams \u003d FSImagePreTransactionalStorageInspector\n        .getEditLogStreams(storage);\n    }\n    int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n        DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n    for (EditLogInputStream elis : editStreams) {\n      elis.setMaxOpSize(maxOpSize);\n    }\n \n    for (EditLogInputStream l : editStreams) {\n      LOG.debug(\"Planning to load edit log stream: \" + l);\n    }\n    if (!editStreams.iterator().hasNext()) {\n      LOG.info(\"No edit log streams selected.\");\n    }\n    \n    FSImageFile imageFile \u003d null;\n    for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n      try {\n        imageFile \u003d imageFiles.get(i);\n        loadFSImageFile(target, recovery, imageFile, startOpt);\n        break;\n      } catch (IOException ioe) {\n        LOG.error(\"Failed to load image from \" + imageFile, ioe);\n        target.clear();\n        imageFile \u003d null;\n      }\n    }\n    // Failed to load any images, error out\n    if (imageFile \u003d\u003d null) {\n      FSEditLog.closeAllStreams(editStreams);\n      throw new IOException(\"Failed to load an FSImage file!\");\n    }\n    prog.endPhase(Phase.LOADING_FSIMAGE);\n    \n    if (!rollingRollback) {\n      long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n      needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n          txnsAdvanced);\n      if (RollingUpgradeStartupOption.DOWNGRADE.matches(startOpt)) {\n        // rename rollback image if it is downgrade\n        renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK, NameNodeFile.IMAGE);\n      }\n    } else {\n      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n      // to the last txid in rollback fsimage.\n      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n      needToSave \u003d false;\n    }\n    editLog.setNextTxId(lastAppliedTxId + 1);\n    return needToSave;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "5d29338017fb8ebe8626002c1ca670842968ca4a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6041. Downgrade/Finalize should rename the rollback image instead of purging it. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1573851 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/03/14 8:42 PM",
      "commitName": "5d29338017fb8ebe8626002c1ca670842968ca4a",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "03/03/14 2:31 PM",
      "commitNameOld": "98983b2788508936ad489e61ff61cacfe73ab1b9",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,101 @@\n   private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     final boolean rollingRollback\n         \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n     final EnumSet\u003cNameNodeFile\u003e nnfs;\n     if (rollingRollback) {\n       // if it is rollback of rolling upgrade, only load from the rollback image\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n     } else {\n       // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n     }\n     final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(nnfs);\n \n     isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n     List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n \n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     prog.beginPhase(Phase.LOADING_FSIMAGE);\n     File phaseFile \u003d imageFiles.get(0).getFile();\n     prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n     prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n     boolean needToSave \u003d inspector.needToSave();\n \n     Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n \n     initEditLog(startOpt);\n \n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n       // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n       // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n       // OK to not be able to read all of edits right now.\n       // In the meanwhile, for HA upgrade, we will still write editlog thus need\n       // this toAtLeastTxId to be set to the max-seen txid\n       // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n       // the txid right before the upgrade marker.  \n       long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n           .getMaxSeenTxId() : 0;\n       if (rollingRollback) {\n         // note that the first image in imageFiles is the special checkpoint\n         // for the rolling upgrade\n         toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n       }\n       editStreams \u003d editLog.selectInputStreams(\n           imageFiles.get(0).getCheckpointTxId() + 1,\n           toAtLeastTxId, recovery, false);\n     } else {\n       editStreams \u003d FSImagePreTransactionalStorageInspector\n         .getEditLogStreams(storage);\n     }\n     int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n         DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n     for (EditLogInputStream elis : editStreams) {\n       elis.setMaxOpSize(maxOpSize);\n     }\n  \n     for (EditLogInputStream l : editStreams) {\n       LOG.debug(\"Planning to load edit log stream: \" + l);\n     }\n     if (!editStreams.iterator().hasNext()) {\n       LOG.info(\"No edit log streams selected.\");\n     }\n     \n     FSImageFile imageFile \u003d null;\n     for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n       try {\n         imageFile \u003d imageFiles.get(i);\n         loadFSImageFile(target, recovery, imageFile);\n         break;\n       } catch (IOException ioe) {\n         LOG.error(\"Failed to load image from \" + imageFile, ioe);\n         target.clear();\n         imageFile \u003d null;\n       }\n     }\n     // Failed to load any images, error out\n     if (imageFile \u003d\u003d null) {\n       FSEditLog.closeAllStreams(editStreams);\n       throw new IOException(\"Failed to load an FSImage file!\");\n     }\n     prog.endPhase(Phase.LOADING_FSIMAGE);\n     \n     if (!rollingRollback) {\n       long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n       needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n           txnsAdvanced);\n       if (RollingUpgradeStartupOption.DOWNGRADE.matches(startOpt)) {\n-        // purge rollback image if it is downgrade\n-        archivalManager.purgeCheckpoints(NameNodeFile.IMAGE_ROLLBACK);\n+        // rename rollback image if it is downgrade\n+        renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK, NameNodeFile.IMAGE);\n       }\n     } else {\n       // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n       // to the last txid in rollback fsimage.\n       rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n       needToSave \u003d false;\n     }\n     editLog.setNextTxId(lastAppliedTxId + 1);\n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    final boolean rollingRollback\n        \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n    final EnumSet\u003cNameNodeFile\u003e nnfs;\n    if (rollingRollback) {\n      // if it is rollback of rolling upgrade, only load from the rollback image\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n    } else {\n      // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n    }\n    final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(nnfs);\n\n    isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n    List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    prog.beginPhase(Phase.LOADING_FSIMAGE);\n    File phaseFile \u003d imageFiles.get(0).getFile();\n    prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n    prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n    boolean needToSave \u003d inspector.needToSave();\n\n    Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n\n    initEditLog(startOpt);\n\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n      // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n      // OK to not be able to read all of edits right now.\n      // In the meanwhile, for HA upgrade, we will still write editlog thus need\n      // this toAtLeastTxId to be set to the max-seen txid\n      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n      // the txid right before the upgrade marker.  \n      long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n          .getMaxSeenTxId() : 0;\n      if (rollingRollback) {\n        // note that the first image in imageFiles is the special checkpoint\n        // for the rolling upgrade\n        toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n      }\n      editStreams \u003d editLog.selectInputStreams(\n          imageFiles.get(0).getCheckpointTxId() + 1,\n          toAtLeastTxId, recovery, false);\n    } else {\n      editStreams \u003d FSImagePreTransactionalStorageInspector\n        .getEditLogStreams(storage);\n    }\n    int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n        DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n    for (EditLogInputStream elis : editStreams) {\n      elis.setMaxOpSize(maxOpSize);\n    }\n \n    for (EditLogInputStream l : editStreams) {\n      LOG.debug(\"Planning to load edit log stream: \" + l);\n    }\n    if (!editStreams.iterator().hasNext()) {\n      LOG.info(\"No edit log streams selected.\");\n    }\n    \n    FSImageFile imageFile \u003d null;\n    for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n      try {\n        imageFile \u003d imageFiles.get(i);\n        loadFSImageFile(target, recovery, imageFile);\n        break;\n      } catch (IOException ioe) {\n        LOG.error(\"Failed to load image from \" + imageFile, ioe);\n        target.clear();\n        imageFile \u003d null;\n      }\n    }\n    // Failed to load any images, error out\n    if (imageFile \u003d\u003d null) {\n      FSEditLog.closeAllStreams(editStreams);\n      throw new IOException(\"Failed to load an FSImage file!\");\n    }\n    prog.endPhase(Phase.LOADING_FSIMAGE);\n    \n    if (!rollingRollback) {\n      long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n      needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n          txnsAdvanced);\n      if (RollingUpgradeStartupOption.DOWNGRADE.matches(startOpt)) {\n        // rename rollback image if it is downgrade\n        renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK, NameNodeFile.IMAGE);\n      }\n    } else {\n      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n      // to the last txid in rollback fsimage.\n      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n      needToSave \u003d false;\n    }\n    editLog.setNextTxId(lastAppliedTxId + 1);\n    return needToSave;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "98983b2788508936ad489e61ff61cacfe73ab1b9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6042. Fix rolling upgrade documentation and error messages. (Contributed by szetszwo)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1573785 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/03/14 2:31 PM",
      "commitName": "98983b2788508936ad489e61ff61cacfe73ab1b9",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "28/02/14 11:33 AM",
      "commitNameOld": "1bab14bb49ec2b1a93f7d0763fb823b2ac715174",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.12,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,101 @@\n   private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n       MetaRecoveryContext recovery)\n       throws IOException {\n-    final boolean rollingRollback \u003d StartupOption\n-        .isRollingUpgradeRollback(startOpt);\n+    final boolean rollingRollback\n+        \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n     final EnumSet\u003cNameNodeFile\u003e nnfs;\n     if (rollingRollback) {\n       // if it is rollback of rolling upgrade, only load from the rollback image\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n     } else {\n       // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n       nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n     }\n     final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(nnfs);\n \n     isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n     List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n \n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     prog.beginPhase(Phase.LOADING_FSIMAGE);\n     File phaseFile \u003d imageFiles.get(0).getFile();\n     prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n     prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n     boolean needToSave \u003d inspector.needToSave();\n \n     Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n \n     initEditLog(startOpt);\n \n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n       // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n       // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n       // OK to not be able to read all of edits right now.\n       // In the meanwhile, for HA upgrade, we will still write editlog thus need\n       // this toAtLeastTxId to be set to the max-seen txid\n       // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n       // the txid right before the upgrade marker.  \n       long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n           .getMaxSeenTxId() : 0;\n       if (rollingRollback) {\n         // note that the first image in imageFiles is the special checkpoint\n         // for the rolling upgrade\n         toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n       }\n       editStreams \u003d editLog.selectInputStreams(\n           imageFiles.get(0).getCheckpointTxId() + 1,\n           toAtLeastTxId, recovery, false);\n     } else {\n       editStreams \u003d FSImagePreTransactionalStorageInspector\n         .getEditLogStreams(storage);\n     }\n     int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n         DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n     for (EditLogInputStream elis : editStreams) {\n       elis.setMaxOpSize(maxOpSize);\n     }\n  \n     for (EditLogInputStream l : editStreams) {\n       LOG.debug(\"Planning to load edit log stream: \" + l);\n     }\n     if (!editStreams.iterator().hasNext()) {\n       LOG.info(\"No edit log streams selected.\");\n     }\n     \n     FSImageFile imageFile \u003d null;\n     for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n       try {\n         imageFile \u003d imageFiles.get(i);\n         loadFSImageFile(target, recovery, imageFile);\n         break;\n       } catch (IOException ioe) {\n         LOG.error(\"Failed to load image from \" + imageFile, ioe);\n         target.clear();\n         imageFile \u003d null;\n       }\n     }\n     // Failed to load any images, error out\n     if (imageFile \u003d\u003d null) {\n       FSEditLog.closeAllStreams(editStreams);\n       throw new IOException(\"Failed to load an FSImage file!\");\n     }\n     prog.endPhase(Phase.LOADING_FSIMAGE);\n     \n     if (!rollingRollback) {\n       long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n       needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n           txnsAdvanced);\n-      if (StartupOption.isRollingUpgradeDowngrade(startOpt)) {\n+      if (RollingUpgradeStartupOption.DOWNGRADE.matches(startOpt)) {\n         // purge rollback image if it is downgrade\n         archivalManager.purgeCheckpoints(NameNodeFile.IMAGE_ROLLBACK);\n       }\n     } else {\n       // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n       // to the last txid in rollback fsimage.\n       rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n       needToSave \u003d false;\n     }\n     editLog.setNextTxId(lastAppliedTxId + 1);\n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    final boolean rollingRollback\n        \u003d RollingUpgradeStartupOption.ROLLBACK.matches(startOpt);\n    final EnumSet\u003cNameNodeFile\u003e nnfs;\n    if (rollingRollback) {\n      // if it is rollback of rolling upgrade, only load from the rollback image\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n    } else {\n      // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n    }\n    final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(nnfs);\n\n    isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n    List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    prog.beginPhase(Phase.LOADING_FSIMAGE);\n    File phaseFile \u003d imageFiles.get(0).getFile();\n    prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n    prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n    boolean needToSave \u003d inspector.needToSave();\n\n    Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n\n    initEditLog(startOpt);\n\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n      // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n      // OK to not be able to read all of edits right now.\n      // In the meanwhile, for HA upgrade, we will still write editlog thus need\n      // this toAtLeastTxId to be set to the max-seen txid\n      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n      // the txid right before the upgrade marker.  \n      long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n          .getMaxSeenTxId() : 0;\n      if (rollingRollback) {\n        // note that the first image in imageFiles is the special checkpoint\n        // for the rolling upgrade\n        toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n      }\n      editStreams \u003d editLog.selectInputStreams(\n          imageFiles.get(0).getCheckpointTxId() + 1,\n          toAtLeastTxId, recovery, false);\n    } else {\n      editStreams \u003d FSImagePreTransactionalStorageInspector\n        .getEditLogStreams(storage);\n    }\n    int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n        DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n    for (EditLogInputStream elis : editStreams) {\n      elis.setMaxOpSize(maxOpSize);\n    }\n \n    for (EditLogInputStream l : editStreams) {\n      LOG.debug(\"Planning to load edit log stream: \" + l);\n    }\n    if (!editStreams.iterator().hasNext()) {\n      LOG.info(\"No edit log streams selected.\");\n    }\n    \n    FSImageFile imageFile \u003d null;\n    for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n      try {\n        imageFile \u003d imageFiles.get(i);\n        loadFSImageFile(target, recovery, imageFile);\n        break;\n      } catch (IOException ioe) {\n        LOG.error(\"Failed to load image from \" + imageFile, ioe);\n        target.clear();\n        imageFile \u003d null;\n      }\n    }\n    // Failed to load any images, error out\n    if (imageFile \u003d\u003d null) {\n      FSEditLog.closeAllStreams(editStreams);\n      throw new IOException(\"Failed to load an FSImage file!\");\n    }\n    prog.endPhase(Phase.LOADING_FSIMAGE);\n    \n    if (!rollingRollback) {\n      long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n      needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n          txnsAdvanced);\n      if (RollingUpgradeStartupOption.DOWNGRADE.matches(startOpt)) {\n        // purge rollback image if it is downgrade\n        archivalManager.purgeCheckpoints(NameNodeFile.IMAGE_ROLLBACK);\n      }\n    } else {\n      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n      // to the last txid in rollback fsimage.\n      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n      needToSave \u003d false;\n    }\n    editLog.setNextTxId(lastAppliedTxId + 1);\n    return needToSave;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6000. Avoid saving namespace when starting rolling upgrade. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1571840 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/02/14 1:58 PM",
      "commitName": "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "23/02/14 1:35 PM",
      "commitNameOld": "8e7a2b8d5d9975690da20d3ff41d04f361171f0a",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.02,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,101 @@\n   private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     final boolean rollingRollback \u003d StartupOption\n         .isRollingUpgradeRollback(startOpt);\n-    final NameNodeFile nnf \u003d rollingRollback ? NameNodeFile.IMAGE_ROLLBACK\n-        : NameNodeFile.IMAGE;\n-    final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(nnf);\n+    final EnumSet\u003cNameNodeFile\u003e nnfs;\n+    if (rollingRollback) {\n+      // if it is rollback of rolling upgrade, only load from the rollback image\n+      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n+    } else {\n+      // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n+      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n+    }\n+    final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(nnfs);\n \n     isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n     List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n \n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     prog.beginPhase(Phase.LOADING_FSIMAGE);\n     File phaseFile \u003d imageFiles.get(0).getFile();\n     prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n     prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n     boolean needToSave \u003d inspector.needToSave();\n \n     Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n \n     initEditLog(startOpt);\n \n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n       // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n       // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n       // OK to not be able to read all of edits right now.\n       // In the meanwhile, for HA upgrade, we will still write editlog thus need\n       // this toAtLeastTxId to be set to the max-seen txid\n       // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n       // the txid right before the upgrade marker.  \n       long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n           .getMaxSeenTxId() : 0;\n       if (rollingRollback) {\n         // note that the first image in imageFiles is the special checkpoint\n         // for the rolling upgrade\n         toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n       }\n       editStreams \u003d editLog.selectInputStreams(\n           imageFiles.get(0).getCheckpointTxId() + 1,\n           toAtLeastTxId, recovery, false);\n     } else {\n       editStreams \u003d FSImagePreTransactionalStorageInspector\n         .getEditLogStreams(storage);\n     }\n     int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n         DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n     for (EditLogInputStream elis : editStreams) {\n       elis.setMaxOpSize(maxOpSize);\n     }\n  \n     for (EditLogInputStream l : editStreams) {\n       LOG.debug(\"Planning to load edit log stream: \" + l);\n     }\n     if (!editStreams.iterator().hasNext()) {\n       LOG.info(\"No edit log streams selected.\");\n     }\n     \n     FSImageFile imageFile \u003d null;\n     for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n       try {\n         imageFile \u003d imageFiles.get(i);\n         loadFSImageFile(target, recovery, imageFile);\n         break;\n       } catch (IOException ioe) {\n         LOG.error(\"Failed to load image from \" + imageFile, ioe);\n         target.clear();\n         imageFile \u003d null;\n       }\n     }\n     // Failed to load any images, error out\n     if (imageFile \u003d\u003d null) {\n       FSEditLog.closeAllStreams(editStreams);\n       throw new IOException(\"Failed to load an FSImage file!\");\n     }\n     prog.endPhase(Phase.LOADING_FSIMAGE);\n     \n     if (!rollingRollback) {\n       long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n       needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n           txnsAdvanced);\n+      if (StartupOption.isRollingUpgradeDowngrade(startOpt)) {\n+        // purge rollback image if it is downgrade\n+        archivalManager.purgeCheckpoints(NameNodeFile.IMAGE_ROLLBACK);\n+      }\n     } else {\n       // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n       // to the last txid in rollback fsimage.\n       rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n       needToSave \u003d false;\n     }\n     editLog.setNextTxId(lastAppliedTxId + 1);\n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    final boolean rollingRollback \u003d StartupOption\n        .isRollingUpgradeRollback(startOpt);\n    final EnumSet\u003cNameNodeFile\u003e nnfs;\n    if (rollingRollback) {\n      // if it is rollback of rolling upgrade, only load from the rollback image\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE_ROLLBACK);\n    } else {\n      // otherwise we can load from both IMAGE and IMAGE_ROLLBACK\n      nnfs \u003d EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK);\n    }\n    final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(nnfs);\n\n    isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n    List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    prog.beginPhase(Phase.LOADING_FSIMAGE);\n    File phaseFile \u003d imageFiles.get(0).getFile();\n    prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n    prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n    boolean needToSave \u003d inspector.needToSave();\n\n    Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n\n    initEditLog(startOpt);\n\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n      // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n      // OK to not be able to read all of edits right now.\n      // In the meanwhile, for HA upgrade, we will still write editlog thus need\n      // this toAtLeastTxId to be set to the max-seen txid\n      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n      // the txid right before the upgrade marker.  \n      long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n          .getMaxSeenTxId() : 0;\n      if (rollingRollback) {\n        // note that the first image in imageFiles is the special checkpoint\n        // for the rolling upgrade\n        toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n      }\n      editStreams \u003d editLog.selectInputStreams(\n          imageFiles.get(0).getCheckpointTxId() + 1,\n          toAtLeastTxId, recovery, false);\n    } else {\n      editStreams \u003d FSImagePreTransactionalStorageInspector\n        .getEditLogStreams(storage);\n    }\n    int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n        DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n    for (EditLogInputStream elis : editStreams) {\n      elis.setMaxOpSize(maxOpSize);\n    }\n \n    for (EditLogInputStream l : editStreams) {\n      LOG.debug(\"Planning to load edit log stream: \" + l);\n    }\n    if (!editStreams.iterator().hasNext()) {\n      LOG.info(\"No edit log streams selected.\");\n    }\n    \n    FSImageFile imageFile \u003d null;\n    for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n      try {\n        imageFile \u003d imageFiles.get(i);\n        loadFSImageFile(target, recovery, imageFile);\n        break;\n      } catch (IOException ioe) {\n        LOG.error(\"Failed to load image from \" + imageFile, ioe);\n        target.clear();\n        imageFile \u003d null;\n      }\n    }\n    // Failed to load any images, error out\n    if (imageFile \u003d\u003d null) {\n      FSEditLog.closeAllStreams(editStreams);\n      throw new IOException(\"Failed to load an FSImage file!\");\n    }\n    prog.endPhase(Phase.LOADING_FSIMAGE);\n    \n    if (!rollingRollback) {\n      long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n      needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n          txnsAdvanced);\n      if (StartupOption.isRollingUpgradeDowngrade(startOpt)) {\n        // purge rollback image if it is downgrade\n        archivalManager.purgeCheckpoints(NameNodeFile.IMAGE_ROLLBACK);\n      }\n    } else {\n      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n      // to the last txid in rollback fsimage.\n      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n      needToSave \u003d false;\n    }\n    editLog.setNextTxId(lastAppliedTxId + 1);\n    return needToSave;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "016d3b8171191a0dc860c3c5ddf15fcbe6c8d973": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5984. Fix TestEditLog and TestStandbyCheckpoints.  Contributed by jing9\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1570361 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/02/14 1:42 PM",
      "commitName": "016d3b8171191a0dc860c3c5ddf15fcbe6c8d973",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "19/02/14 8:38 PM",
      "commitNameOld": "55aec006f499fcf4ec98568d594b0585836cfa5e",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.71,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,91 @@\n   private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     final boolean rollingRollback \u003d StartupOption\n         .isRollingUpgradeRollback(startOpt);\n     final NameNodeFile nnf \u003d rollingRollback ? NameNodeFile.IMAGE_ROLLBACK\n         : NameNodeFile.IMAGE;\n     final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(nnf);\n \n     isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n     List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n \n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     prog.beginPhase(Phase.LOADING_FSIMAGE);\n     File phaseFile \u003d imageFiles.get(0).getFile();\n     prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n     prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n     boolean needToSave \u003d inspector.needToSave();\n \n     Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n \n     initEditLog(startOpt);\n \n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n       // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n       // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n       // OK to not be able to read all of edits right now.\n       // In the meanwhile, for HA upgrade, we will still write editlog thus need\n       // this toAtLeastTxId to be set to the max-seen txid\n       // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n       // the txid right before the upgrade marker.  \n       long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n           .getMaxSeenTxId() : 0;\n       if (rollingRollback) {\n         // note that the first image in imageFiles is the special checkpoint\n         // for the rolling upgrade\n         toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n       }\n       editStreams \u003d editLog.selectInputStreams(\n           imageFiles.get(0).getCheckpointTxId() + 1,\n           toAtLeastTxId, recovery, false);\n     } else {\n       editStreams \u003d FSImagePreTransactionalStorageInspector\n         .getEditLogStreams(storage);\n     }\n     int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n         DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n     for (EditLogInputStream elis : editStreams) {\n       elis.setMaxOpSize(maxOpSize);\n     }\n  \n     for (EditLogInputStream l : editStreams) {\n       LOG.debug(\"Planning to load edit log stream: \" + l);\n     }\n     if (!editStreams.iterator().hasNext()) {\n       LOG.info(\"No edit log streams selected.\");\n     }\n     \n     FSImageFile imageFile \u003d null;\n     for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n       try {\n         imageFile \u003d imageFiles.get(i);\n         loadFSImageFile(target, recovery, imageFile);\n         break;\n       } catch (IOException ioe) {\n         LOG.error(\"Failed to load image from \" + imageFile, ioe);\n         target.clear();\n         imageFile \u003d null;\n       }\n     }\n     // Failed to load any images, error out\n     if (imageFile \u003d\u003d null) {\n       FSEditLog.closeAllStreams(editStreams);\n       throw new IOException(\"Failed to load an FSImage file!\");\n     }\n     prog.endPhase(Phase.LOADING_FSIMAGE);\n-    long txnsAdvanced \u003d 0;\n     \n     if (!rollingRollback) {\n-      loadEdits(editStreams, target, startOpt, recovery);\n+      long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n       needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n           txnsAdvanced);\n     } else {\n       // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n       // to the last txid in rollback fsimage.\n       rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n       needToSave \u003d false;\n     }\n     editLog.setNextTxId(lastAppliedTxId + 1);\n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    final boolean rollingRollback \u003d StartupOption\n        .isRollingUpgradeRollback(startOpt);\n    final NameNodeFile nnf \u003d rollingRollback ? NameNodeFile.IMAGE_ROLLBACK\n        : NameNodeFile.IMAGE;\n    final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(nnf);\n\n    isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n    List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    prog.beginPhase(Phase.LOADING_FSIMAGE);\n    File phaseFile \u003d imageFiles.get(0).getFile();\n    prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n    prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n    boolean needToSave \u003d inspector.needToSave();\n\n    Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n\n    initEditLog(startOpt);\n\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n      // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n      // OK to not be able to read all of edits right now.\n      // In the meanwhile, for HA upgrade, we will still write editlog thus need\n      // this toAtLeastTxId to be set to the max-seen txid\n      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n      // the txid right before the upgrade marker.  \n      long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n          .getMaxSeenTxId() : 0;\n      if (rollingRollback) {\n        // note that the first image in imageFiles is the special checkpoint\n        // for the rolling upgrade\n        toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n      }\n      editStreams \u003d editLog.selectInputStreams(\n          imageFiles.get(0).getCheckpointTxId() + 1,\n          toAtLeastTxId, recovery, false);\n    } else {\n      editStreams \u003d FSImagePreTransactionalStorageInspector\n        .getEditLogStreams(storage);\n    }\n    int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n        DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n    for (EditLogInputStream elis : editStreams) {\n      elis.setMaxOpSize(maxOpSize);\n    }\n \n    for (EditLogInputStream l : editStreams) {\n      LOG.debug(\"Planning to load edit log stream: \" + l);\n    }\n    if (!editStreams.iterator().hasNext()) {\n      LOG.info(\"No edit log streams selected.\");\n    }\n    \n    FSImageFile imageFile \u003d null;\n    for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n      try {\n        imageFile \u003d imageFiles.get(i);\n        loadFSImageFile(target, recovery, imageFile);\n        break;\n      } catch (IOException ioe) {\n        LOG.error(\"Failed to load image from \" + imageFile, ioe);\n        target.clear();\n        imageFile \u003d null;\n      }\n    }\n    // Failed to load any images, error out\n    if (imageFile \u003d\u003d null) {\n      FSEditLog.closeAllStreams(editStreams);\n      throw new IOException(\"Failed to load an FSImage file!\");\n    }\n    prog.endPhase(Phase.LOADING_FSIMAGE);\n    \n    if (!rollingRollback) {\n      long txnsAdvanced \u003d loadEdits(editStreams, target, startOpt, recovery);\n      needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n          txnsAdvanced);\n    } else {\n      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n      // to the last txid in rollback fsimage.\n      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n      needToSave \u003d false;\n    }\n    editLog.setNextTxId(lastAppliedTxId + 1);\n    return needToSave;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "2088584864d829d59d8352b88dead8eafa6922e4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5980. Rollback does not need to load edits.  Contributed by jing9\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1570078 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/02/14 7:57 PM",
      "commitName": "2088584864d829d59d8352b88dead8eafa6922e4",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "19/02/14 11:41 AM",
      "commitNameOld": "377424e36a25ab34bba9aaed5feaae9d293eb57f",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.34,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,92 @@\n   private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n       MetaRecoveryContext recovery)\n       throws IOException {\n     final boolean rollingRollback \u003d StartupOption\n         .isRollingUpgradeRollback(startOpt);\n     final NameNodeFile nnf \u003d rollingRollback ? NameNodeFile.IMAGE_ROLLBACK\n         : NameNodeFile.IMAGE;\n     final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(nnf);\n \n     isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n     List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n \n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     prog.beginPhase(Phase.LOADING_FSIMAGE);\n     File phaseFile \u003d imageFiles.get(0).getFile();\n     prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n     prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n     boolean needToSave \u003d inspector.needToSave();\n \n     Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n \n     initEditLog(startOpt);\n \n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n       // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n       // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n       // OK to not be able to read all of edits right now.\n       // In the meanwhile, for HA upgrade, we will still write editlog thus need\n       // this toAtLeastTxId to be set to the max-seen txid\n       // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n       // the txid right before the upgrade marker.  \n       long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n           .getMaxSeenTxId() : 0;\n       if (rollingRollback) {\n         // note that the first image in imageFiles is the special checkpoint\n         // for the rolling upgrade\n         toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n       }\n       editStreams \u003d editLog.selectInputStreams(\n           imageFiles.get(0).getCheckpointTxId() + 1,\n           toAtLeastTxId, recovery, false);\n     } else {\n       editStreams \u003d FSImagePreTransactionalStorageInspector\n         .getEditLogStreams(storage);\n     }\n     int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n         DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n     for (EditLogInputStream elis : editStreams) {\n       elis.setMaxOpSize(maxOpSize);\n     }\n  \n     for (EditLogInputStream l : editStreams) {\n       LOG.debug(\"Planning to load edit log stream: \" + l);\n     }\n     if (!editStreams.iterator().hasNext()) {\n       LOG.info(\"No edit log streams selected.\");\n     }\n     \n     FSImageFile imageFile \u003d null;\n     for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n       try {\n         imageFile \u003d imageFiles.get(i);\n         loadFSImageFile(target, recovery, imageFile);\n         break;\n       } catch (IOException ioe) {\n         LOG.error(\"Failed to load image from \" + imageFile, ioe);\n         target.clear();\n         imageFile \u003d null;\n       }\n     }\n     // Failed to load any images, error out\n     if (imageFile \u003d\u003d null) {\n       FSEditLog.closeAllStreams(editStreams);\n       throw new IOException(\"Failed to load an FSImage file!\");\n     }\n     prog.endPhase(Phase.LOADING_FSIMAGE);\n     long txnsAdvanced \u003d 0;\n     \n-    loadEdits(editStreams, target, startOpt, recovery);\n-    if (rollingRollback) {\n-      // Trigger the rollback for rolling upgrade. \n-      // Here lastAppliedTxId \u003d\u003d (markerTxId - 1), and we should decrease 1 from\n-      // lastAppliedTxId for the start-segment transaction.\n-      rollingRollback(lastAppliedTxId--, imageFiles.get(0).getCheckpointTxId());\n-      needToSave \u003d false;\n-    } else {\n+    if (!rollingRollback) {\n+      loadEdits(editStreams, target, startOpt, recovery);\n       needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n           txnsAdvanced);\n+    } else {\n+      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n+      // to the last txid in rollback fsimage.\n+      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n+      needToSave \u003d false;\n     }\n     editLog.setNextTxId(lastAppliedTxId + 1);\n     return needToSave;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean loadFSImage(FSNamesystem target, StartupOption startOpt,\n      MetaRecoveryContext recovery)\n      throws IOException {\n    final boolean rollingRollback \u003d StartupOption\n        .isRollingUpgradeRollback(startOpt);\n    final NameNodeFile nnf \u003d rollingRollback ? NameNodeFile.IMAGE_ROLLBACK\n        : NameNodeFile.IMAGE;\n    final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(nnf);\n\n    isUpgradeFinalized \u003d inspector.isUpgradeFinalized();\n    List\u003cFSImageFile\u003e imageFiles \u003d inspector.getLatestImages();\n\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    prog.beginPhase(Phase.LOADING_FSIMAGE);\n    File phaseFile \u003d imageFiles.get(0).getFile();\n    prog.setFile(Phase.LOADING_FSIMAGE, phaseFile.getAbsolutePath());\n    prog.setSize(Phase.LOADING_FSIMAGE, phaseFile.length());\n    boolean needToSave \u003d inspector.needToSave();\n\n    Iterable\u003cEditLogInputStream\u003e editStreams \u003d null;\n\n    initEditLog(startOpt);\n\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.TXID_BASED_LAYOUT, getLayoutVersion())) {\n      // If we\u0027re open for write, we\u0027re either non-HA or we\u0027re the active NN, so\n      // we better be able to load all the edits. If we\u0027re the standby NN, it\u0027s\n      // OK to not be able to read all of edits right now.\n      // In the meanwhile, for HA upgrade, we will still write editlog thus need\n      // this toAtLeastTxId to be set to the max-seen txid\n      // For rollback in rolling upgrade, we need to set the toAtLeastTxId to\n      // the txid right before the upgrade marker.  \n      long toAtLeastTxId \u003d editLog.isOpenForWrite() ? inspector\n          .getMaxSeenTxId() : 0;\n      if (rollingRollback) {\n        // note that the first image in imageFiles is the special checkpoint\n        // for the rolling upgrade\n        toAtLeastTxId \u003d imageFiles.get(0).getCheckpointTxId() + 2;\n      }\n      editStreams \u003d editLog.selectInputStreams(\n          imageFiles.get(0).getCheckpointTxId() + 1,\n          toAtLeastTxId, recovery, false);\n    } else {\n      editStreams \u003d FSImagePreTransactionalStorageInspector\n        .getEditLogStreams(storage);\n    }\n    int maxOpSize \u003d conf.getInt(DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_KEY,\n        DFSConfigKeys.DFS_NAMENODE_MAX_OP_SIZE_DEFAULT);\n    for (EditLogInputStream elis : editStreams) {\n      elis.setMaxOpSize(maxOpSize);\n    }\n \n    for (EditLogInputStream l : editStreams) {\n      LOG.debug(\"Planning to load edit log stream: \" + l);\n    }\n    if (!editStreams.iterator().hasNext()) {\n      LOG.info(\"No edit log streams selected.\");\n    }\n    \n    FSImageFile imageFile \u003d null;\n    for (int i \u003d 0; i \u003c imageFiles.size(); i++) {\n      try {\n        imageFile \u003d imageFiles.get(i);\n        loadFSImageFile(target, recovery, imageFile);\n        break;\n      } catch (IOException ioe) {\n        LOG.error(\"Failed to load image from \" + imageFile, ioe);\n        target.clear();\n        imageFile \u003d null;\n      }\n    }\n    // Failed to load any images, error out\n    if (imageFile \u003d\u003d null) {\n      FSEditLog.closeAllStreams(editStreams);\n      throw new IOException(\"Failed to load an FSImage file!\");\n    }\n    prog.endPhase(Phase.LOADING_FSIMAGE);\n    long txnsAdvanced \u003d 0;\n    \n    if (!rollingRollback) {\n      loadEdits(editStreams, target, startOpt, recovery);\n      needToSave |\u003d needsResaveBasedOnStaleCheckpoint(imageFile.getFile(),\n          txnsAdvanced);\n    } else {\n      // Trigger the rollback for rolling upgrade. Here lastAppliedTxId equals\n      // to the last txid in rollback fsimage.\n      rollingRollback(lastAppliedTxId + 1, imageFiles.get(0).getCheckpointTxId());\n      needToSave \u003d false;\n    }\n    editLog.setNextTxId(lastAppliedTxId + 1);\n    return needToSave;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    }
  }
}