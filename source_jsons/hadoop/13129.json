{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CacheReplicationMonitor.java",
  "functionName": "findReasonForNotCaching",
  "functionId": "findReasonForNotCaching___cblock-CachedBlock__blockInfo-BlockInfo",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/CacheReplicationMonitor.java",
  "functionStartLine": 454,
  "functionEndLine": 485,
  "numCommitsSeen": 69,
  "timeTaken": 2451,
  "changeHistory": [
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
    "8deb7a60575ad33b78a5167673276275ba7bece5",
    "07e4fb1455abc33584fc666ef745abe256ebd7d1"
  ],
  "changeHistoryShort": {
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Yparameterchange",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": "Yparameterchange",
    "8deb7a60575ad33b78a5167673276275ba7bece5": "Ybodychange",
    "07e4fb1455abc33584fc666ef745abe256ebd7d1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Yparameterchange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "08/02/15 11:51 AM",
      "commitNameOld": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 108.12,
      "commitsBetweenForRepo": 1040,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n   private String findReasonForNotCaching(CachedBlock cblock, \n-          BlockInfoContiguous blockInfo) {\n+          BlockInfo blockInfo) {\n     if (blockInfo \u003d\u003d null) {\n       // Somehow, a cache report with the block arrived, but the block\n       // reports from the DataNode haven\u0027t (yet?) described such a block.\n       // Alternately, the NameNode might have invalidated the block, but the\n       // DataNode hasn\u0027t caught up.  In any case, we want to tell the DN\n       // to uncache this.\n       return \"not tracked by the BlockManager\";\n     } else if (!blockInfo.isComplete()) {\n       // When a cached block changes state from complete to some other state\n       // on the DataNode (perhaps because of append), it will begin the\n       // uncaching process.  However, the uncaching process is not\n       // instantaneous, especially if clients have pinned the block.  So\n       // there may be a period of time when incomplete blocks remain cached\n       // on the DataNodes.\n       return \"not complete\";\n     } else if (cblock.getReplication() \u003d\u003d 0) {\n       // Since 0 is not a valid value for a cache directive\u0027s replication\n       // field, seeing a replication of 0 on a CacheBlock means that it\n       // has never been reached by any sweep.\n       return \"not needed by any directives\";\n     } else if (cblock.getMark() !\u003d mark) { \n       // Although the block was needed in the past, we didn\u0027t reach it during\n       // the current sweep.  Therefore, it doesn\u0027t need to be cached any more.\n       // Need to set the replication to 0 so it doesn\u0027t flip back to cached\n       // when the mark flips on the next scan\n       cblock.setReplicationAndMark((short)0, mark);\n       return \"no longer needed by any directives\";\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private String findReasonForNotCaching(CachedBlock cblock, \n          BlockInfo blockInfo) {\n    if (blockInfo \u003d\u003d null) {\n      // Somehow, a cache report with the block arrived, but the block\n      // reports from the DataNode haven\u0027t (yet?) described such a block.\n      // Alternately, the NameNode might have invalidated the block, but the\n      // DataNode hasn\u0027t caught up.  In any case, we want to tell the DN\n      // to uncache this.\n      return \"not tracked by the BlockManager\";\n    } else if (!blockInfo.isComplete()) {\n      // When a cached block changes state from complete to some other state\n      // on the DataNode (perhaps because of append), it will begin the\n      // uncaching process.  However, the uncaching process is not\n      // instantaneous, especially if clients have pinned the block.  So\n      // there may be a period of time when incomplete blocks remain cached\n      // on the DataNodes.\n      return \"not complete\";\n    } else if (cblock.getReplication() \u003d\u003d 0) {\n      // Since 0 is not a valid value for a cache directive\u0027s replication\n      // field, seeing a replication of 0 on a CacheBlock means that it\n      // has never been reached by any sweep.\n      return \"not needed by any directives\";\n    } else if (cblock.getMark() !\u003d mark) { \n      // Although the block was needed in the past, we didn\u0027t reach it during\n      // the current sweep.  Therefore, it doesn\u0027t need to be cached any more.\n      // Need to set the replication to 0 so it doesn\u0027t flip back to cached\n      // when the mark flips on the next scan\n      cblock.setReplicationAndMark((short)0, mark);\n      return \"no longer needed by any directives\";\n    }\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/CacheReplicationMonitor.java",
      "extendedDetails": {
        "oldValue": "[cblock-CachedBlock, blockInfo-BlockInfoContiguous]",
        "newValue": "[cblock-CachedBlock, blockInfo-BlockInfo]"
      }
    },
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": {
      "type": "Yparameterchange",
      "commitMessage": "HDFS-7743. Code cleanup of BlockInfo and rename BlockInfo to BlockInfoContiguous. Contributed by Jing Zhao.\n",
      "commitDate": "08/02/15 11:51 AM",
      "commitName": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "23/10/14 11:58 PM",
      "commitNameOld": "0942c99eba12f6baf5609c9621cd07b09618a97e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 107.54,
      "commitsBetweenForRepo": 791,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n   private String findReasonForNotCaching(CachedBlock cblock, \n-          BlockInfo blockInfo) {\n+          BlockInfoContiguous blockInfo) {\n     if (blockInfo \u003d\u003d null) {\n       // Somehow, a cache report with the block arrived, but the block\n       // reports from the DataNode haven\u0027t (yet?) described such a block.\n       // Alternately, the NameNode might have invalidated the block, but the\n       // DataNode hasn\u0027t caught up.  In any case, we want to tell the DN\n       // to uncache this.\n       return \"not tracked by the BlockManager\";\n     } else if (!blockInfo.isComplete()) {\n       // When a cached block changes state from complete to some other state\n       // on the DataNode (perhaps because of append), it will begin the\n       // uncaching process.  However, the uncaching process is not\n       // instantaneous, especially if clients have pinned the block.  So\n       // there may be a period of time when incomplete blocks remain cached\n       // on the DataNodes.\n       return \"not complete\";\n     } else if (cblock.getReplication() \u003d\u003d 0) {\n       // Since 0 is not a valid value for a cache directive\u0027s replication\n       // field, seeing a replication of 0 on a CacheBlock means that it\n       // has never been reached by any sweep.\n       return \"not needed by any directives\";\n     } else if (cblock.getMark() !\u003d mark) { \n       // Although the block was needed in the past, we didn\u0027t reach it during\n       // the current sweep.  Therefore, it doesn\u0027t need to be cached any more.\n       // Need to set the replication to 0 so it doesn\u0027t flip back to cached\n       // when the mark flips on the next scan\n       cblock.setReplicationAndMark((short)0, mark);\n       return \"no longer needed by any directives\";\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private String findReasonForNotCaching(CachedBlock cblock, \n          BlockInfoContiguous blockInfo) {\n    if (blockInfo \u003d\u003d null) {\n      // Somehow, a cache report with the block arrived, but the block\n      // reports from the DataNode haven\u0027t (yet?) described such a block.\n      // Alternately, the NameNode might have invalidated the block, but the\n      // DataNode hasn\u0027t caught up.  In any case, we want to tell the DN\n      // to uncache this.\n      return \"not tracked by the BlockManager\";\n    } else if (!blockInfo.isComplete()) {\n      // When a cached block changes state from complete to some other state\n      // on the DataNode (perhaps because of append), it will begin the\n      // uncaching process.  However, the uncaching process is not\n      // instantaneous, especially if clients have pinned the block.  So\n      // there may be a period of time when incomplete blocks remain cached\n      // on the DataNodes.\n      return \"not complete\";\n    } else if (cblock.getReplication() \u003d\u003d 0) {\n      // Since 0 is not a valid value for a cache directive\u0027s replication\n      // field, seeing a replication of 0 on a CacheBlock means that it\n      // has never been reached by any sweep.\n      return \"not needed by any directives\";\n    } else if (cblock.getMark() !\u003d mark) { \n      // Although the block was needed in the past, we didn\u0027t reach it during\n      // the current sweep.  Therefore, it doesn\u0027t need to be cached any more.\n      // Need to set the replication to 0 so it doesn\u0027t flip back to cached\n      // when the mark flips on the next scan\n      cblock.setReplicationAndMark((short)0, mark);\n      return \"no longer needed by any directives\";\n    }\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/CacheReplicationMonitor.java",
      "extendedDetails": {
        "oldValue": "[cblock-CachedBlock, blockInfo-BlockInfo]",
        "newValue": "[cblock-CachedBlock, blockInfo-BlockInfoContiguous]"
      }
    },
    "8deb7a60575ad33b78a5167673276275ba7bece5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5589. Namenode loops caching and uncaching when data should be uncached. (awang via cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1555996 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/01/14 11:45 AM",
      "commitName": "8deb7a60575ad33b78a5167673276275ba7bece5",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "02/01/14 6:45 PM",
      "commitNameOld": "d85c017d0488930d806f267141057fc73e68c728",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 3.71,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,32 @@\n   private String findReasonForNotCaching(CachedBlock cblock, \n           BlockInfo blockInfo) {\n     if (blockInfo \u003d\u003d null) {\n       // Somehow, a cache report with the block arrived, but the block\n       // reports from the DataNode haven\u0027t (yet?) described such a block.\n       // Alternately, the NameNode might have invalidated the block, but the\n       // DataNode hasn\u0027t caught up.  In any case, we want to tell the DN\n       // to uncache this.\n       return \"not tracked by the BlockManager\";\n     } else if (!blockInfo.isComplete()) {\n       // When a cached block changes state from complete to some other state\n       // on the DataNode (perhaps because of append), it will begin the\n       // uncaching process.  However, the uncaching process is not\n       // instantaneous, especially if clients have pinned the block.  So\n       // there may be a period of time when incomplete blocks remain cached\n       // on the DataNodes.\n       return \"not complete\";\n-    }  else if (cblock.getReplication() \u003d\u003d 0) {\n+    } else if (cblock.getReplication() \u003d\u003d 0) {\n       // Since 0 is not a valid value for a cache directive\u0027s replication\n       // field, seeing a replication of 0 on a CacheBlock means that it\n       // has never been reached by any sweep.\n       return \"not needed by any directives\";\n     } else if (cblock.getMark() !\u003d mark) { \n       // Although the block was needed in the past, we didn\u0027t reach it during\n       // the current sweep.  Therefore, it doesn\u0027t need to be cached any more.\n+      // Need to set the replication to 0 so it doesn\u0027t flip back to cached\n+      // when the mark flips on the next scan\n+      cblock.setReplicationAndMark((short)0, mark);\n       return \"no longer needed by any directives\";\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private String findReasonForNotCaching(CachedBlock cblock, \n          BlockInfo blockInfo) {\n    if (blockInfo \u003d\u003d null) {\n      // Somehow, a cache report with the block arrived, but the block\n      // reports from the DataNode haven\u0027t (yet?) described such a block.\n      // Alternately, the NameNode might have invalidated the block, but the\n      // DataNode hasn\u0027t caught up.  In any case, we want to tell the DN\n      // to uncache this.\n      return \"not tracked by the BlockManager\";\n    } else if (!blockInfo.isComplete()) {\n      // When a cached block changes state from complete to some other state\n      // on the DataNode (perhaps because of append), it will begin the\n      // uncaching process.  However, the uncaching process is not\n      // instantaneous, especially if clients have pinned the block.  So\n      // there may be a period of time when incomplete blocks remain cached\n      // on the DataNodes.\n      return \"not complete\";\n    } else if (cblock.getReplication() \u003d\u003d 0) {\n      // Since 0 is not a valid value for a cache directive\u0027s replication\n      // field, seeing a replication of 0 on a CacheBlock means that it\n      // has never been reached by any sweep.\n      return \"not needed by any directives\";\n    } else if (cblock.getMark() !\u003d mark) { \n      // Although the block was needed in the past, we didn\u0027t reach it during\n      // the current sweep.  Therefore, it doesn\u0027t need to be cached any more.\n      // Need to set the replication to 0 so it doesn\u0027t flip back to cached\n      // when the mark flips on the next scan\n      cblock.setReplicationAndMark((short)0, mark);\n      return \"no longer needed by any directives\";\n    }\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/CacheReplicationMonitor.java",
      "extendedDetails": {}
    },
    "07e4fb1455abc33584fc666ef745abe256ebd7d1": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5708. The CacheManager throws a NPE in the DataNode logs when processing cache reports that refer to a block not known to the BlockManager. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554594 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/12/13 4:01 PM",
      "commitName": "07e4fb1455abc33584fc666ef745abe256ebd7d1",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,29 @@\n+  private String findReasonForNotCaching(CachedBlock cblock, \n+          BlockInfo blockInfo) {\n+    if (blockInfo \u003d\u003d null) {\n+      // Somehow, a cache report with the block arrived, but the block\n+      // reports from the DataNode haven\u0027t (yet?) described such a block.\n+      // Alternately, the NameNode might have invalidated the block, but the\n+      // DataNode hasn\u0027t caught up.  In any case, we want to tell the DN\n+      // to uncache this.\n+      return \"not tracked by the BlockManager\";\n+    } else if (!blockInfo.isComplete()) {\n+      // When a cached block changes state from complete to some other state\n+      // on the DataNode (perhaps because of append), it will begin the\n+      // uncaching process.  However, the uncaching process is not\n+      // instantaneous, especially if clients have pinned the block.  So\n+      // there may be a period of time when incomplete blocks remain cached\n+      // on the DataNodes.\n+      return \"not complete\";\n+    }  else if (cblock.getReplication() \u003d\u003d 0) {\n+      // Since 0 is not a valid value for a cache directive\u0027s replication\n+      // field, seeing a replication of 0 on a CacheBlock means that it\n+      // has never been reached by any sweep.\n+      return \"not needed by any directives\";\n+    } else if (cblock.getMark() !\u003d mark) { \n+      // Although the block was needed in the past, we didn\u0027t reach it during\n+      // the current sweep.  Therefore, it doesn\u0027t need to be cached any more.\n+      return \"no longer needed by any directives\";\n+    }\n+    return null;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private String findReasonForNotCaching(CachedBlock cblock, \n          BlockInfo blockInfo) {\n    if (blockInfo \u003d\u003d null) {\n      // Somehow, a cache report with the block arrived, but the block\n      // reports from the DataNode haven\u0027t (yet?) described such a block.\n      // Alternately, the NameNode might have invalidated the block, but the\n      // DataNode hasn\u0027t caught up.  In any case, we want to tell the DN\n      // to uncache this.\n      return \"not tracked by the BlockManager\";\n    } else if (!blockInfo.isComplete()) {\n      // When a cached block changes state from complete to some other state\n      // on the DataNode (perhaps because of append), it will begin the\n      // uncaching process.  However, the uncaching process is not\n      // instantaneous, especially if clients have pinned the block.  So\n      // there may be a period of time when incomplete blocks remain cached\n      // on the DataNodes.\n      return \"not complete\";\n    }  else if (cblock.getReplication() \u003d\u003d 0) {\n      // Since 0 is not a valid value for a cache directive\u0027s replication\n      // field, seeing a replication of 0 on a CacheBlock means that it\n      // has never been reached by any sweep.\n      return \"not needed by any directives\";\n    } else if (cblock.getMark() !\u003d mark) { \n      // Although the block was needed in the past, we didn\u0027t reach it during\n      // the current sweep.  Therefore, it doesn\u0027t need to be cached any more.\n      return \"no longer needed by any directives\";\n    }\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/CacheReplicationMonitor.java"
    }
  }
}